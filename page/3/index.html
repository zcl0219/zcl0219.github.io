<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar-16.png">
  <link rel="mask-icon" href="/images/emoji-smile.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zcl0219.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null,"show_result":true},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Doing the tough things sets winners apart from losers">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://zcl0219.github.io/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Doing the tough things sets winners apart from losers">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="GGBond">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://zcl0219.github.io/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  







<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap" rel="stylesheet">

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="GGBond"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">GGBond</p>
  <div class="site-description" itemprop="description">Doing the tough things sets winners apart from losers</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zcl0219.github.io/2023/08/23/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="GGBond">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="Doing the tough things sets winners apart from losers">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/08/23/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">中缀表达式转后缀表达式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-08-23 17:16:28" itemprop="dateCreated datePublished" datetime="2023-08-23T17:16:28+08:00">2023-08-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-07 18:31:14" itemprop="dateModified" datetime="2023-10-07T18:31:14+08:00">2023-10-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>面试时被问到了关于如何将中缀表达式转换为后缀表达式，这里总结一下转换的步骤</p>
<ol>
<li>遇到操作数，直接输出</li>
<li>栈为空时，遇到运算符，入栈</li>
<li>遇到左括号，将其入栈</li>
<li>遇到右括号，执行出栈操作，并将出栈的元素输出，直到弹出栈的是左括号，左括号不输出</li>
<li>遇到其他运算符“+”，“-”，“*”，“&#x2F;”时，弹出所有优先级大于或等于该运算符的栈顶元素，然后将该运算符入栈</li>
<li>最终将栈中的元素依次出栈，输出</li>
</ol>
<p><img src="1.png"></p>
<p>（啊！先写到这吧，为了弄个图片弄了好久）</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/y_16041527/article/details/79684188">https://blog.csdn.net/y_16041527/article/details/79684188</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zcl0219.github.io/2023/07/26/shared-ptr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="GGBond">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="Doing the tough things sets winners apart from losers">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/26/shared-ptr/" class="post-title-link" itemprop="url">智能指针shared_ptr的实现</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-07-26 09:12:27" itemprop="dateCreated datePublished" datetime="2023-07-26T09:12:27+08:00">2023-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-08-10 23:29:15" itemprop="dateModified" datetime="2023-08-10T23:29:15+08:00">2023-08-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们今天来实现一个简易版的智能指针吧！拖了好久啦，以后会把vector、string的简易版也给补上，<code>gigigi</code></p>
<p>我们可以先想想<code>shared_ptr</code>最大的特点，就是当他的引用计数为0时，便会自动释放所指对象和析构。所以一个关键点就是这个引用计数怎么设置？static？不可以！static变量同属于一个类的所有对象，这样就会导致不管指的是不是同一个对象，引用计数都相同。所以我们这里决定采用一个指针来进行引用计数。具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(T* sPtr = <span class="literal">nullptr</span>)</span>: sPtr_(sPtr)&#123;</span></span><br><span class="line">        <span class="keyword">if</span>(sPtr_)&#123;</span><br><span class="line">            useCount_ = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line">            sMutex_ = <span class="keyword">new</span> std::mutex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>()&#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)&#123;</span><br><span class="line">        useCount_ = sp.useCount_;</span><br><span class="line">        sPtr_ = sp.sPtr_;</span><br><span class="line">        sMutex_ = sp.sMutex_;</span><br><span class="line">        <span class="built_in">addUsecount</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sPtr_ != sp.sPtr_)&#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            sPtr_ = sp.sPtr_;</span><br><span class="line">            useCount_ = sp.useCount_;</span><br><span class="line">            sMutex_ = sp.sMutex_;</span><br><span class="line">            <span class="built_in">addUsecount</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()&#123;</span><br><span class="line">        <span class="keyword">return</span> *sPtr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">        <span class="keyword">return</span> sPtr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">useCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *useCount_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sPtr_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addUsecount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sMutex_-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        ++(*useCount_);</span><br><span class="line">        sMutex_-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">bool</span> deleteFlag = <span class="literal">false</span>;</span><br><span class="line">        sMutex_-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(--(*useCount_) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> useCount_;</span><br><span class="line">            <span class="keyword">delete</span> sPtr_;</span><br><span class="line">            deleteFlag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sMutex_-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span>(deleteFlag)&#123;</span><br><span class="line">            <span class="keyword">delete</span> sMutex_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* useCount_;</span><br><span class="line">    T* sPtr_;</span><br><span class="line">    std::mutex* sMutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;std::string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> std::string(<span class="string">&quot;hello&quot;</span>))</span></span>;</span><br><span class="line">    shared_ptr&lt;std::string&gt; p2 = p1;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; p2.useCount() &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="function">shared_ptr&lt;std::string&gt; <span class="title">p3</span><span class="params">(p2)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; p3.<span class="built_in">useCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p2.<span class="built_in">useCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    p2 = p3;</span><br><span class="line">    std::cout &lt;&lt; p3.<span class="built_in">useCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p2.<span class="built_in">useCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入结果图片有点问题，最近没时间弄，各位自己跑一下验证一下，有错误记得说！！！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zcl0219.github.io/2023/06/29/Cpp%E9%AB%98%E9%A2%91%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="GGBond">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="Doing the tough things sets winners apart from losers">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/29/Cpp%E9%AB%98%E9%A2%91%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">Cpp高频面经</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-06-29 03:50:53" itemprop="dateCreated datePublished" datetime="2023-06-29T03:50:53+08:00">2023-06-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-09 16:26:33" itemprop="dateModified" datetime="2023-10-09T16:26:33+08:00">2023-10-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h4><ul>
<li><p>属性的区别</p>
<p>new&#x2F;delete：这两个是C++中的关键字；</p>
<p>malloc&#x2F;free：这两个是库函数；</p>
</li>
<li><p>使用上的区别</p>
<p>malloc：申请空间需要显式填入申请内存的大小；</p>
<p>new：无需显式填入申请内存的大小，new会根据new的类型分配内存；</p>
</li>
<li><p>返回类型的区别</p>
<p>new操作符内存分配成功，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，故new是符合类型安全性的操作符。</p>
<p>malloc内存分配成功返回的是void*指针，需要通过强制类型转换，转换成我们需要的类型。</p>
<p>所以C++中new比malloc安全可靠。</p>
</li>
<li><p>分配失败的区别</p>
<p>malloc分配失败会返回NULL，我们可以通过判断返回值是否是NULL得知是否分配成功。</p>
<p>new分配失败会抛出bad_alloc异常。</p>
</li>
<li><p>扩张内存的区别</p>
<p>malloc有内存扩张机制（通过realloc实现）。</p>
<p>new没有扩张内存机制。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/338489910">https://zhuanlan.zhihu.com/p/338489910</a></p>
<h4 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h4><ul>
<li>明确动态内存使用范围：在程序中使用动态内存时，需要明确该内存的使用范围，确保在不需要使用该内存时能够及时释放内存。</li>
<li>使用RAII技术：RAII（Resource Acquisition Is Initialization）是C++中一种常用的资源管理技术，它利用了C++对象的构造函数和析构函数自动调用的特性，在对象的构造函数中申请资源，在对象的析构函数中释放资源，从而避免资源泄漏问题。</li>
<li>使用智能指针：智能指针可以自动管理动态内存的分配和释放。</li>
</ul>
<h4 id="线程池的数量一般怎么设置"><a href="#线程池的数量一般怎么设置" class="headerlink" title="线程池的数量一般怎么设置"></a>线程池的数量一般怎么设置</h4><p>线程池中线程数量的设置主要考虑两个方面：</p>
<ul>
<li><p>I&#x2F;O密集型</p>
</li>
<li><p>如果说任务是耗时I&#x2F;O型，比如涉及数据库、文件的读写，网络通信等任务，这种任务的特点是不会特别消耗CPU资源，但是我们需要考虑到I&#x2F;O操作耗时较长。这种情况一般会将线程数设置的比较大，达到了CPU核心数的很多倍。因为如果线程数设置的比较少，会造成CPU计算资源的浪费。</p>
</li>
<li><p>CPU密集型</p>
</li>
<li><p>对于CPU密集型任务，线程数不宜设置的过多，因为过多的线程都会去抢占CPU资源，就会产生不必要的上下文切换，反而会造成整体性能的下降</p>
</li>
</ul>
<p>线程数通用计算公示：线程数 &#x3D; CPU核心数 * (1 + I&#x2F;O耗时 &#x2F; CPU耗时)</p>
<h4 id="来了一个新任务，线程池是怎么工作的（本答案有待商榷）"><a href="#来了一个新任务，线程池是怎么工作的（本答案有待商榷）" class="headerlink" title="来了一个新任务，线程池是怎么工作的（本答案有待商榷）"></a>来了一个新任务，线程池是怎么工作的（本答案有待商榷）</h4><p>当有一个新任务到来时，线程池会先判断是否有空闲线程，如果有，则将任务分配给空闲线程；</p>
<p>如果此时线程池里没有空线程，则先将任务放任务任务队列，待有空闲线程之后，再从任务队列中取出任务。</p>
<h4 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h4><p>在我的理解里，完美转发 &#x3D; std::forward + 万能引用 + 引用折叠。首先引用折叠机制为T&amp;&amp;类型的万能引用中的模板参数T赋予了一个恰到好处的值，而我们用T去指明std::forward的模板参数，从而使得std::forward返回的是正确的类型（这里关于返回的是正确的类型，应该去看std::forward实现的源码，知乎链接如下：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/369203981%EF%BC%89">https://zhuanlan.zhihu.com/p/369203981）</a></p>
<h4 id="去掉std-forward会咋样"><a href="#去掉std-forward会咋样" class="headerlink" title="去掉std::forward会咋样"></a>去掉std::forward会咋样</h4><p>可能会导致在传递参数的时候丢失类型信息，从而导致编译器无法正确推断模板类型或者在模板类型推断中发生错误。</p>
<h4 id="讲一下C-中的虚继承"><a href="#讲一下C-中的虚继承" class="headerlink" title="讲一下C++中的虚继承"></a>讲一下C++中的虚继承</h4><h4 id="基类的析构函数为什么是虚函数？"><a href="#基类的析构函数为什么是虚函数？" class="headerlink" title="基类的析构函数为什么是虚函数？"></a>基类的析构函数为什么是虚函数？</h4><p>如果基类的虚构函数不是虚函数，当我们定义一个父类指针指向子类对象时，最后子类的析构函数不会调用，导致内存泄漏。</p>
<h4 id="struct和union的区别（默写）"><a href="#struct和union的区别（默写）" class="headerlink" title="struct和union的区别（默写）"></a>struct和union的区别（默写）</h4><h4 id="C-内存布局-x2F-程序分段（默写）"><a href="#C-内存布局-x2F-程序分段（默写）" class="headerlink" title="C++内存布局&#x2F;程序分段（默写）"></a>C++内存布局&#x2F;程序分段（默写）</h4><h4 id="了解shared-ptr吗？如果让你手写一个shared-ptr，你会怎么设计"><a href="#了解shared-ptr吗？如果让你手写一个shared-ptr，你会怎么设计" class="headerlink" title="了解shared_ptr吗？如果让你手写一个shared_ptr，你会怎么设计"></a>了解shared_ptr吗？如果让你手写一个shared_ptr，你会怎么设计</h4><p>shared_ptr是智能指针里面的共享指针，即多个指针指向同一个内存。每多一个指针指向这片内存，引用计数加1。当对象的引用计数减少为0时，对象会自动析构，对应内存被自动释放。智能指针是模板类，而不是指针。</p>
<p>设计：将shared_ptr定义为一个模板类，包括两个成员：模板类指针和一个指向引用计数的指针。指向引用计数类型的指针应该包括这些成员函数：增加计数、减少计数、返回现有计数。一个私有成员就是用于计数的变量。共享指针模板类的构造函数接受一个模板类型指针，并且需要声明为explicit，表示必须直接初始化。另外就是拷贝构造函数和移动构造函数。拷贝构造需要注意拷贝的对象的指针是否为nullptr，如果不是nullptr，则需要增加引用计数。移动构造函数需要注意将传入的右值引用对象的指针置空，引用计数清零。析构函数有两个判断条件，第一个最后一个指向对象的指针需要为非nullptr并且此时引用计数减一后为0。然后就是重载*、-&gt;、bool，还有一个函数用于获得指针get()。动态转换（可考虑）。</p>
<h4 id="介绍一下TCP，TCP粘包如何解决"><a href="#介绍一下TCP，TCP粘包如何解决" class="headerlink" title="介绍一下TCP，TCP粘包如何解决"></a>介绍一下TCP，TCP粘包如何解决</h4><p>解决办法：</p>
<ul>
<li>发送端：使用TCP_NODELAY关闭Nagle算法，但是如果不是时延敏感的应用尽量不要关闭</li>
<li>接收端：没法解决，只能交给应用端解决</li>
<li>应用层：有三种解决办法<ul>
<li>只发送固定包长的数据包，但是这个方法基本不用，灵活性太差</li>
<li>指定标识结尾，比如\r\n之类的</li>
<li>包头加包体，包头一般是固定长度，并且里面有一个字段可以告知我们接下来的包体有多大</li>
</ul>
</li>
</ul>
<h4 id="回调函数是什么，回调函数的本质"><a href="#回调函数是什么，回调函数的本质" class="headerlink" title="回调函数是什么，回调函数的本质"></a>回调函数是什么，回调函数的本质</h4><p>回调函数允许我们将一个函数（或函数对象）作为参数传递给另一个函数，并在需要的时候由后者调用执行。回调函数定义了在特定事件或条件满足时应该执行的操作。主调函数是接受回调函数作为参数的函数。</p>
<h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><ol>
<li>进程<ul>
<li>进程拥有独立内存空间和系统资源</li>
<li>进程之间相互独立，一个进程的崩溃通常不会影响其他进程</li>
<li>创建、销毁和切换进程开销比较大</li>
</ul>
</li>
<li>线程<ul>
<li>一个进程可以包含多个线程，所有线程共享相同的地址空间和系统资源</li>
<li>线程之间可以直接读写进程内的共享数据，执行起来更高效</li>
<li>线程的创建、销毁和切换开销比较小</li>
</ul>
</li>
</ol>
<h4 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h4><p>GET用于获取资源，参数通过URL传递，不适合传输敏感信息，幂等，有缓存，传输数据的大小受限于URL的长度。POST用于提交数据，参数通过请求体传递，适合传输敏感信息，不幂等，无缓存，没有数据大小限制。</p>
<h4 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h4><ol>
<li>HTTP<ul>
<li>HTTP是一种应用层协议，用于在Web浏览器和Web服务器之间传输超文本和其他资源</li>
<li>HTTP是明文传输的协议，意味着数据在传输过程中是未加密的，容易被窃听和篡改</li>
<li>HTTP默认使用80端口号</li>
</ul>
</li>
<li>HTTPS<ul>
<li>HTTPS是HTTP协议的安全版本，加强了数据传输的安全性和保密性</li>
<li>HTTPS使用了SSL&#x2F;TLS协议进行数据加密和身份认证</li>
<li>HTTPS默认使用443端口通信</li>
</ul>
</li>
</ol>
<h4 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++ 11新特性"></a>C++ 11新特性</h4><ul>
<li><p>auto关键字</p>
</li>
<li><p>智能指针</p>
</li>
<li><p>lambda表达式	参考链接（<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15323899/5785594%EF%BC%89">https://blog.51cto.com/u_15323899/5785594）</a></p>
<p>Lambda表达式是C++11引入的一种新特性，它允许在代码中定义匿名函数。虽然在使用上非常简洁和方便，但lambda表达式背后的实现相对复杂。以下是lambda表达式在底层的工作原理：</p>
<ol>
<li><p><strong>转换为类</strong>:</p>
<ul>
<li>当你定义一个lambda表达式，编译器会为你生成一个匿名类（也称为闭包类型）。这个类将会覆盖函数调用操作符，使得该对象可以像函数一样被调用。</li>
<li>如果lambda表达式捕获了外部的局部变量（例如通过值或引用），这些变量将会被添加为该匿名类的成员。</li>
</ul>
</li>
<li><p><strong>成员变量</strong>:</p>
<ul>
<li>为了支持捕获，生成的闭包类型可能会包含成员变量。如果使用值捕获，那么这些成员变量将存储捕获的变量的副本；如果使用引用捕获，那么成员变量将存储相应变量的引用。</li>
</ul>
</li>
<li><p><strong>函数调用操作符重载</strong>:</p>
<ul>
<li>生成的类会覆盖函数调用操作符<code>operator()</code>. 这个操作符的实现就是lambda表达式的主体。</li>
</ul>
</li>
<li><p><strong>构造函数</strong>:</p>
<ul>
<li>该匿名类的构造函数会初始化所有捕获的变量。根据捕获方式（值或引用）来复制或绑定这些变量。</li>
</ul>
</li>
<li><p><strong>生成的类是只移动构造的</strong>:</p>
<ul>
<li>这意味着你不能按常规方式复制lambda表达式，但可以移动它。</li>
</ul>
</li>
</ol>
<p>下面是一个简单的lambda表达式的例子以及一个可能的简化版本的匿名类表示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lambda</span></span><br><span class="line"><span class="keyword">auto</span> lambda = [x](<span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Possible representation by the compiler</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__anonymous</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    __anonymous(<span class="type">int</span> _x) : <span class="built_in">x</span>(_x) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要注意的是，这只是一个简化的表示。实际编译器生成的代码会比这更复杂，尤其是当涉及到更高级的特性（如泛型、<code>mutable</code>关键字或捕获列表）时。</p>
<p>最后，虽然从概念上讲，lambda表达式是转换为类的，但这并不意味着性能会受到影响。优化后的编译器通常会内联这些生成的类和函数调用操作符，从而消除由于间接调用导致的任何额外开销。</p>
</li>
<li><p>右值引用和移动语义</p>
</li>
</ul>
<h4 id="lambda表达式的使用场景"><a href="#lambda表达式的使用场景" class="headerlink" title="lambda表达式的使用场景"></a>lambda表达式的使用场景</h4><p>lambda表达式提供了一种简洁、方便的方式来创建匿名对象。在一些需要传递简单函数对象的场景下，使用lambda表达式可以避免额外的函数对象类。</p>
<h4 id="vector迭代器失效的原因"><a href="#vector迭代器失效的原因" class="headerlink" title="vector迭代器失效的原因"></a>vector迭代器失效的原因</h4><p>vector底层的实现是一个动态数组，vector里面存储的元素都是连续的，一旦比如删除一个元素，后面的所有元素都需要移动。我们可以考虑一种极端情况，删除最后一个元素，此时指向原vector数组的最后一个元素的迭代器就没指向任何元素了，如何此时我们访问这个迭代器所指向的元素，就会导致未定义行为，所以就会判定迭代器失效。其实所有改变vector大小的操作，都会导致vector迭代器失效。</p>
<h4 id="map的底层数据结构"><a href="#map的底层数据结构" class="headerlink" title="map的底层数据结构"></a>map的底层数据结构</h4><p>红黑树参考链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e136ec79235c">https://www.jianshu.com/p/e136ec79235c</a></p>
<p>map是有序容器，底层数据结构是红黑树，时间复杂度为log(n)。红黑树的前身可以说是二叉搜索树。但是二叉搜索树最坏的情况下树的高度为n，那么就导致时间复杂度为o(n), 所以便衍生出来了平衡二叉树。其实红黑树的五大特性就是为了保持二叉搜索树的平衡。保证时间复杂度稳定在o(logn)。</p>
<h4 id="unordered-map底层数据结构"><a href="#unordered-map底层数据结构" class="headerlink" title="unordered_map底层数据结构"></a>unordered_map底层数据结构</h4><p>unordered_map是无序容器，底层使用哈希表实现的。</p>
<h4 id="TCP握手为什么是三次握手，两次握手为什么不行呢"><a href="#TCP握手为什么是三次握手，两次握手为什么不行呢" class="headerlink" title="TCP握手为什么是三次握手，两次握手为什么不行呢"></a>TCP握手为什么是三次握手，两次握手为什么不行呢</h4><p>这里有两个大点，第一个字面意思很好理解，第二点举个例子就通透了，面试时最好全部答上来</p>
<ul>
<li><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤</p>
</li>
<li><p>防止已失效的连接请求又传送到服务器端，因而产生错误</p>
<p>只有采用三次握手可以减少服务端的资源浪费。解释如下：<br>例如，客户端向服务端发送请求同步报文A，因为网络阻塞等原因，服务端没有收到同步报文A，所以没有发送同步确认报文。过了一段时间，客户端没有收到服务端的确认报文，重新向服务端发送请求同步报文B，服务端接收到报文B后，向客户端发送同步确认报文，客户端接收到确认报文后，向服务端发送确认报文，建立连接。数据传输完毕后，连接断开。客户端进入close状态，此时服务端收到之前的报文A，向客户端返回同步确认报文。如果使用两次握手，服务端回应后不确认客户端的状态，连接建立成功。服务端会长时间等待客户端发送数据，连接长期保持，会造成资源浪费。当多个客户端产生这种情况，服务器就会等待多个客户端的响应，连接数量过多，之后的客户端请求，服务器无法响应。造成服务器处于瘫痪状态。<br>只有使用三次握手，当服务端收到确认报文后，保证当前时刻，客户端可以发送数据时，才能建立有意义的连接。当客户端一段时间不发送数据时，服务器应自动断开连接，来节省自身连接的客户端数量，减少资源的浪费。</p>
</li>
</ul>
<h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p>HTTP状态码是在HTTP协议中用于表示服务器对请求的处理结果的三位数字代码。HTTP状态码的分类如下：</p>
<ol>
<li><p>1xx（信息性状态码）：表示服务器已接收请求，需要客户端继续操作。</p>
</li>
<li><p>2xx（成功状态码）：表示服务器成功处理了请求。</p>
</li>
<li><p>3xx（重定向状态码）：表示请求需要进一步的操作，通常用于重定向。</p>
</li>
<li><p>4xx（客户端错误状态码）：表示客户端发出的请求有误。</p>
</li>
<li><p>5xx（服务器错误状态码）：表示服务器在处理请求时发生了错误。</p>
</li>
</ol>
<p>以下是一些常见的HTTP状态码示例：</p>
<ol>
<li><p>200 OK：请求成功，服务器成功处理了请求。</p>
</li>
<li><p>201 Created：请求成功，服务器已成功创建了资源。</p>
</li>
<li><p>204 No Content：请求成功，但服务器没有新的信息返回。</p>
</li>
<li><p>400 Bad Request：请求错误，服务器不理解或无法处理请求。</p>
</li>
<li><p>401 Unauthorized：请求需要用户认证，未提供有效的认证信息。</p>
</li>
<li><p>403 Forbidden：请求被服务器拒绝，没有访问权限。</p>
</li>
<li><p>404 Not Found：请求的资源不存在。</p>
</li>
<li><p>500 Internal Server Error：服务器内部错误，无法完成请求。</p>
</li>
<li><p>502 Bad Gateway：服务器作为网关或代理，从上游服务器收到无效的响应。</p>
</li>
<li><p>503 Service Unavailable：服务器暂时不可用，通常是由于过载或维护。</p>
</li>
</ol>
<p>这只是HTTP状态码中的一部分，实际中可能还会遇到其他状态码。状态码的具体含义可参考HTTP协议的官方文档或RFC文档。不同的状态码代表了服务器对请求的不同响应结果，客户端根据状态码可以做出相应的处理。</p>
<h4 id="使用智能指针了，普通指针还能用吗？"><a href="#使用智能指针了，普通指针还能用吗？" class="headerlink" title="使用智能指针了，普通指针还能用吗？"></a>使用智能指针了，普通指针还能用吗？</h4><p>个人觉得使用了智能指针后不推荐使用普通指针。因为使用了智能指针后，再使用普通指针指向相同对象，并不会增加引用计数，等智能指针引用计数变为0的时候，对象被销毁，此时普通指针就变为了野指针。</p>
<h4 id="什么时候使用智能指针，什么时候使用普通指针-（CHATGPT）"><a href="#什么时候使用智能指针，什么时候使用普通指针-（CHATGPT）" class="headerlink" title="什么时候使用智能指针，什么时候使用普通指针 （CHATGPT）"></a>什么时候使用智能指针，什么时候使用普通指针 （CHATGPT）</h4><p>使用智能指针还是普通指针取决于你的代码需求和内存管理需求。以下是一些指导原则：</p>
<p>使用智能指针的情况：</p>
<ol>
<li><p>动态分配内存：如果你需要动态分配内存，尤其是在使用<code>new</code>关键字时，最好使用智能指针来管理这些资源。智能指针会自动在不再需要时释放内存，避免了内存泄漏的问题。</p>
</li>
<li><p>所有权传递：当多个地方共享一个资源并且需要明确的所有权传递时，智能指针特别有用。例如，使用<code>std::shared_ptr</code>来共享资源，并在最后一个引用释放时自动删除资源。</p>
</li>
<li><p>异常安全：在使用普通指针的代码中，如果在动态分配资源后发生异常，可能会导致资源泄漏。使用智能指针可以更好地处理异常情况，确保资源在退出作用域时得到正确释放。</p>
</li>
<li><p>容器存储：如果要在STL容器中存储指针类型，建议使用智能指针。STL容器在元素添加或删除时可能会复制或移动元素，使用智能指针可以正确管理资源的所有权。</p>
</li>
</ol>
<p>使用普通指针的情况：</p>
<ol>
<li><p>接口和传统API：某些接口和传统的C API可能要求使用原始指针，此时你无法使用智能指针。在这种情况下，你应该小心管理内存，确保手动释放资源。</p>
</li>
<li><p>与C代码交互：当与C语言库或代码进行交互时，普通指针是常用的方式，因为C语言不支持智能指针。</p>
</li>
<li><p>临时指针：对于一些临时指针，其生命周期很短且不需要动态内存管理时，可以使用普通指针。</p>
</li>
<li><p>最低开销：在某些性能关键的场景，智能指针可能带来额外的开销，此时使用普通指针可能更合适。但请注意，在性能优化前确保使用智能指针没有影响到代码的正确性和可维护性。</p>
</li>
</ol>
<p>综上所述，智能指针在大多数情况下是推荐的内存管理方式，特别是在现代C++代码中。然而，有些特定的场景可能需要使用普通指针，但在这种情况下你需要格外小心以避免内存泄漏和悬挂指针问题。</p>
<h4 id="Hash-map原理"><a href="#Hash-map原理" class="headerlink" title="Hash_map原理"></a>Hash_map原理</h4><p>Hash_map基于Hash_map（哈希表）。</p>
<p>哈希表基本原理：使用一个下标范围较大的数组来储存元素。那我们怎么根据关键字知道它应该放在数组的哪个位置呢？这就通过哈希函数（散列函数）来解决。哈希函数使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应。但是，不能保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这就产生了哈希冲突。因此“直接定址”和“解决冲突”是哈希表的两大特点。</p>
<p>哈希冲突的解决主要有以下四种方法：开放地址法，再哈希法，链地址法和建立公共溢出区。关于这四种方法的解释见知乎链接 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29520044">https://zhuanlan.zhihu.com/p/29520044</a></p>
<h4 id="C-多态介绍一下"><a href="#C-多态介绍一下" class="headerlink" title="C++多态介绍一下"></a>C++多态介绍一下</h4><p>C++多态主要包括重载、虚函数、模板。重载包括函数重载和运算符重载，编译期，即编译器在编译阶段就会根据函数调用的上下文来决定使用哪一个重载版本。虚函数是在运行期。重载和模板属于静态多态，虚函数属于动态多态。静态多态与动态多态靠编译期与运行期区分。</p>
<h4 id="虚函数、纯虚函数原理，虚表什么时候建立的https-zhuanlan-zhihu-com-p-37331092"><a href="#虚函数、纯虚函数原理，虚表什么时候建立的https-zhuanlan-zhihu-com-p-37331092" class="headerlink" title="虚函数、纯虚函数原理，虚表什么时候建立的	https://zhuanlan.zhihu.com/p/37331092"></a>虚函数、纯虚函数原理，虚表什么时候建立的	<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37331092">https://zhuanlan.zhihu.com/p/37331092</a></h4><ul>
<li>虚函数，在类成员方法的声明（不是定义）语句前加“virtual”，如virtual void func</li>
<li>纯虚函数，在虚函数后加“&#x3D;0”，如virtual void func &#x3D; 0</li>
<li>对于虚函数，子类可以（也可以不）重写基类的虚函数，该行为称之为override</li>
<li>对于纯虚函数，子类必须提供纯虚函数的个性化实现</li>
</ul>
<p>在派生子类中对虚函数和纯虚函数的个性化实现，都体现了多态特性，但区别在于：</p>
<ul>
<li>子类如果不提供虚函数的实现，将会自动调用基类的缺省虚函数实现</li>
<li>子类如果不提供纯虚函数的实现，将会编译失败</li>
</ul>
<p><strong>当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数则由指针指向的实际类型决定</strong></p>
<p>实现虚函数表的关键就是虚函数表指针，这个指针指向一张名为虚函数表的表，为表中的数据则为函数指针，存储了虚函数具体实现所对应的位置。另外，当一个类有多个虚函数时，仍然只有一个虚函数指针，而此时的虚函数表里会有多个<strong>函数指针</strong>，因此，虚函数实现的过程是：<strong>通过对象内存中的虚函数指针vptr找到虚函数表vtbl，再通过vtbl中的函数指针找到对应虚函数的实现区域并进行调用。</strong>所以虚函数的调用时由指针所指向内存块的具体类型决定的。</p>
<h4 id="构造函数和析构函数可以是虚函数吗？"><a href="#构造函数和析构函数可以是虚函数吗？" class="headerlink" title="构造函数和析构函数可以是虚函数吗？"></a>构造函数和析构函数可以是虚函数吗？</h4><p>答案是：构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。</p>
<p>首先，我们已经知道虚函数的实现则是通过对象内存中的vptr来实现的。而构造函数是用来实例化一个对象的，通俗来讲就是为对象内存中的值做初始化操作。那么在构造函数完成之前，也即还没有进行初始化，此时vptr是没有值的，也就无法通过vptr找到作为构造函数和虚函数所在的代码区，所以构造函数只能以普通函数的形式存放在类所指定的代码区中。</p>
<p>而对于析构函数，当我们delete(a)的时候，如果析构函数不是虚函数，那么调用的将会是基类base的析构函数。而当继承的时候，通常派生类会在基类的基础上定义自己的成员，此时我们当然希望可以调用派生类的析构函数对新定义的成员也进行析构。</p>
<h4 id="map为啥用红黑树不用avl树？"><a href="#map为啥用红黑树不用avl树？" class="headerlink" title="map为啥用红黑树不用avl树？"></a>map为啥用红黑树不用avl树？</h4><ul>
<li>平衡调整次数更少</li>
<li>内存使用更少：AVL树需要存储额外的平衡因子信息</li>
<li>更适合于频繁的插入和删除操作</li>
</ul>
<h4 id="怎么判断map里key值存不存在"><a href="#怎么判断map里key值存不存在" class="headerlink" title="怎么判断map里key值存不存在"></a>怎么判断map里key值存不存在</h4><p>c.at(k)	访问关键字为k的元素，如果k不在c中，返回一个out_of_range异常</p>
<p>c.find(k)	如果存在，返回一个迭代器，指向关键字为k的元素；如果不存在，返回尾后迭代器</p>
<p>c.count(k)	不存在返回0，存在返回k关键字的数量</p>
<h4 id="多进程通信方式"><a href="#多进程通信方式" class="headerlink" title="多进程通信方式"></a>多进程通信方式</h4><p>管道、命名管道、消息队列、信号量、共享内存、套接字、RPC</p>
<p>管道：一种最简单的进程间通信方式，通常用于父子进程间通信。管道中数据只能朝一个方向流动，即一方读另一方写。管道通过系统调用pipe()创建。</p>
<p>命名管道：一种更通用的进程间通信方式，它可以在无关的进程之间进行通信。不同于管道，命名管道通过文件系统中的路径名来标识。命名管道可以通过系统调用 <code>mkfifo()</code> 创建。</p>
<p>信号量：讲好sem_init(), sem_wait(), sem_post()系统整体运作过程就好了</p>
<p>套接字：服务器监听一个ip+端口，客户端访问连接</p>
<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><table>
<thead>
<tr>
<th align="left"></th>
<th align="center">TCP</th>
<th align="center">UDP</th>
</tr>
</thead>
<tbody><tr>
<td align="left">可靠性</td>
<td align="center">可靠</td>
<td align="center">不可靠</td>
</tr>
<tr>
<td align="left">连接</td>
<td align="center">面向连接</td>
<td align="center">无连接</td>
</tr>
<tr>
<td align="left">数据传输方式</td>
<td align="center">字节流</td>
<td align="center">数据报</td>
</tr>
<tr>
<td align="left">双工性</td>
<td align="center">全双工</td>
<td align="center">一对一、一对多、多对一、多对多</td>
</tr>
<tr>
<td align="left">流量控制</td>
<td align="center">滑动窗口</td>
<td align="center">无</td>
</tr>
<tr>
<td align="left">拥塞控制</td>
<td align="center">慢启动、拥塞避免、快速重传、快速回复</td>
<td align="center">无</td>
</tr>
<tr>
<td align="left">效率</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
<tr>
<td align="left">传输速度</td>
<td align="center">慢</td>
<td align="center">快</td>
</tr>
</tbody></table>
<h4 id="TCP-x2F-IP协议组"><a href="#TCP-x2F-IP协议组" class="headerlink" title="TCP&#x2F;IP协议组"></a>TCP&#x2F;IP协议组</h4><p>IP协议、TCP协议、UDP协议、ICMP协议、ARP协议、RARP协议</p>
<h4 id="OSI七层"><a href="#OSI七层" class="headerlink" title="OSI七层"></a>OSI七层</h4><p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<h4 id="socket编程recv函数"><a href="#socket编程recv函数" class="headerlink" title="socket编程recv函数"></a>socket编程recv函数</h4><p>返回0：对方关闭连接</p>
<p>返回相应的接收数据大小</p>
<p>返回错误码：传输出现错误</p>
<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>快排思想：选定基准元素，小的放一边，大的放一边，最后分治</p>
<h4 id="HTTP状态码-1"><a href="#HTTP状态码-1" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><ol>
<li>1XX - 信息状态码：<ul>
<li>100 Continue：服务端已经收到了客户端请求，继续发送剩余部分</li>
</ul>
</li>
<li>2XX - 成功状态码：<ul>
<li>200 OK：请求成功，服务器成功处理了请求</li>
<li>201 Created：请求成功，并创建了资源</li>
<li>204 No Content：请求成功，但没有返回内容</li>
</ul>
</li>
<li>3XX - 重定向状态码：<ul>
<li>301 Moved Permanently：永久重定向，请求的资源被永久移到了新位置</li>
<li>302 Found：临时重定向，请求的资源被临时移到了新位置</li>
<li>304 Not Modified：客户端缓存资源仍然有效，未修改</li>
</ul>
</li>
<li>4XX - 客户端错误状态码：<ul>
<li>400 Bad Request：客户端请求错误，服务器无法理解</li>
<li>401 Unauthorized：请求要求身份验证，客户端未提供有效的身份信息</li>
<li>403 Forbidden：服务器拒绝请求，没有访问权限</li>
<li>404 Not Found：请求的资源不存在</li>
</ul>
</li>
<li>5XX - 服务器错误状态码：<ul>
<li>500 Internet Server Error：服务器内部错误，无法完成请求</li>
<li>502 Bad Gateway：作为网关或代理的服务器从上游服务器收到无效响应</li>
<li>503 Service Unavailable：服务器暂时过载或维护中，无法处理请求</li>
<li>504 Gateway Timeout：作为网关或代理服务器未及时从上游服务器接收响应</li>
</ul>
</li>
</ol>
<h4 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h4><p>DNS就是域名解析服务，查询过程依次递增。本地域名解析（操作系统首先会查询本地DNS缓存） —–》本地域名服务器查询 —–》根域名服务器查询 —–》顶级域名服务器查询 —–》权威域名服务器查询 —–》返回结果。DNS查询和应答报文具有相同格式，主要区别在于某些字段的标识。下面讲几个重要的字段。</p>
<ul>
<li>16位标识：用于标记一对DNS查询和应答，以此区分一个DNS应答是哪一个DNS查询的回应</li>
<li>16位标志<ul>
<li>QR：查询报文（0）&#x2F;	应答报文（1）</li>
<li>opcode：标准查询（0）&#x2F;    反向查询（1）就是是通过域名获取ip地址还是通过ip地址获取域名</li>
</ul>
</li>
</ul>
<h4 id="TCP为什么需要四次挥手，三次挥手有什么问题"><a href="#TCP为什么需要四次挥手，三次挥手有什么问题" class="headerlink" title="TCP为什么需要四次挥手，三次挥手有什么问题"></a>TCP为什么需要四次挥手，三次挥手有什么问题</h4><ol>
<li>客户端最后一个ACK可能会丢失，这样服务端就无法正常进入CLOSED状态。于是B会重传请求释放的报文，而此时如果A已经关闭了，那就收不到B的重传请求，就会导致B无法正常释放。而如果A还在等待时间内，就会收到B的重传，然后进行应答，这样B就可以进入CLOSED状态</li>
<li>如果三次挥手的话，服务端收到来自客户端的FIN请求后，需要同时回复ACK和发送FIN断开连接请求。但是在TCP连接中是有一个半关闭状态的，也就是服务端其实还是可以继续发送数据的，如果三次挥手，就无法做到服务器再发送数据了。</li>
</ol>
<h4 id="TCP传输为什么是可靠的"><a href="#TCP传输为什么是可靠的" class="headerlink" title="TCP传输为什么是可靠的"></a>TCP传输为什么是可靠的</h4><ul>
<li>确认与重传：如果一定时间内未收到ACK，则会重传</li>
<li>序列号与顺序性：TCP为每一个数据包分配一个序列号，接收端会进行数据包重组</li>
<li>流量控制</li>
<li>拥塞控制</li>
<li>连接管理：三次握手与四次挥手</li>
<li>超时与重试</li>
</ul>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p>新建、就绪、运行、阻塞、等待、终止</p>
<h4 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h4><p>死锁发生的必要条件，通常被称为死锁的四个条件，分别是：</p>
<ol>
<li><strong>互斥条件（Mutual Exclusion）：</strong> 指某个资源在一段时间内只能被一个线程或进程占用，其他线程或进程需要等待资源释放才能继续执行。</li>
<li><strong>请求与保持条件（Hold and Wait）：</strong> 指线程在保持至少一个资源的同时，还请求其他资源，而这些资源可能被其他线程占用，导致请求阻塞。</li>
<li><strong>不剥夺条件（No Preemption）：</strong> 指资源只能由占有它的线程显式释放，其他线程不能强行抢占资源。</li>
<li><strong>循环等待条件（Circular Wait）：</strong> 指多个线程形成一个循环，每个线程都在等待下一个线程所持有的资源，导致一个闭环的等待状态。</li>
</ol>
<h4 id="死锁解决方案"><a href="#死锁解决方案" class="headerlink" title="死锁解决方案"></a>死锁解决方案</h4><ul>
<li>系统重新启动</li>
<li>撤销进程、剥夺资源</li>
<li>进程回退策略，即让参与死锁的进程回退到没有发生死锁前某一点处。</li>
</ul>
<h4 id="树的知识"><a href="#树的知识" class="headerlink" title="树的知识"></a>树的知识</h4><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/bplus-tree/">https://oi-wiki.org/ds/bplus-tree/</a></p>
<h4 id="Linux-API调用返回值汇总"><a href="#Linux-API调用返回值汇总" class="headerlink" title="Linux API调用返回值汇总"></a>Linux API调用返回值汇总</h4><p>int pthread_create：成功时返回0，失败时返回错误码</p>
<p>void pthread_exit：不会失败</p>
<p>int pthread_join ( pthread_t thread, void** retval)：成功时返回0，失败时返回错误码。错误码：EDEADLK：可能引起死锁，比如两个线程互相针对对方调用pthread_join，或者线程对自身调用pthread_join；EINVAL：目标线程是不可回收的，或者已经有其他线程在回收该目标线程；ESRCH：目标线程不存在。</p>
<p>int sem_init( sem_t* sem, int pshared, unsigned int value )</p>
<p>int sem_destroy( sem_t* sem )</p>
<p>int sem_wait( sem_t* sem)</p>
<p>int sem_trywait( sem_t* sem )</p>
<p>int sem_post( sem_t* sem )：以上五个成功时返回0， 失败时返回-1并设置errno</p>
<h4 id="DNS的解析过程"><a href="#DNS的解析过程" class="headerlink" title="DNS的解析过程"></a>DNS的解析过程</h4><p>DNS是实现域名和IP地址相互映射的一个分布式数据库。DNS解析过程主要包括以下步骤</p>
<ol>
<li>本地缓存查询：当用户通过浏览器访问某域名时，浏览器会首先在自己的缓存里查询是否有该域名对应的IP地址。</li>
<li>本地系统查询：查看本计算机系统Host文件DNS缓存是否有对应DNS缓存</li>
<li>查看路由器缓存</li>
<li>查询ISP DNS缓存：也称本地域名服务器查询，计算机会向你的ISP（互联网服务提供商）分配的本地域名服务器发出查询请求</li>
<li>根域名服务器</li>
<li>顶级域名服务器：根域名服务器并不会直接返回用户IP地址，而是会指向查询请求对应的顶级域名服务器</li>
<li>权威域名服务器：顶级域名服务器会指向域名的权威域名服务器，这些服务器管理特定的域名的DNS服务。</li>
</ol>
<h4 id="TCP传输为什么是可靠的-1"><a href="#TCP传输为什么是可靠的-1" class="headerlink" title="TCP传输为什么是可靠的"></a>TCP传输为什么是可靠的</h4><p>总结下来主要包括三个方面：</p>
<ul>
<li>检验和</li>
<li>确认应答（ACK和序列号一应一答）</li>
<li>超时重传</li>
</ul>
<h4 id="NAT协议和跨域（不了解）"><a href="#NAT协议和跨域（不了解）" class="headerlink" title="NAT协议和跨域（不了解）"></a>NAT协议和跨域（不了解）</h4><h4 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h4><p>最明显的一个区别就是GET请求会把参数放在URL（统一资源定位符）中，POST会把参数放在请求体中。</p>
<p>数据大小限制：GET请求把参数放在URL中，GET请求数据大小收到URL长度限制。POST请求则不会</p>
<p>幂等性：GET请求每次相同请求返回的结果都一样，多次重复请求不会对资源产生影响。POST请求则相反</p>
<p>安全性：POST更安全，参数没有暴露在URL上</p>
<p>缓存：GET请求可以被浏览器缓存，POST请求不会被浏览器缓存</p>
<h4 id="写一段死锁的代码"><a href="#写一段死锁的代码" class="headerlink" title="写一段死锁的代码"></a>写一段死锁的代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_a;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">another</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in child thread, get mutex a\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_b);</span><br><span class="line">    b += a;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_b);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_a, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_b, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;id, <span class="literal">NULL</span>, another, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in parent thread, get mutex b\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    ++b;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_a);</span><br><span class="line">    a += b;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pro is end\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="删除字符串头尾空格代码"><a href="#删除字符串头尾空格代码" class="headerlink" title="删除字符串头尾空格代码"></a>删除字符串头尾空格代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::string tmp;</span><br><span class="line">    <span class="built_in">getline</span>(std::cin, s);   <span class="comment">//这里很重要哦，如果用cin，“hello world”会被截断成hello</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = s.<span class="built_in">substr</span>(i, s.<span class="built_in">size</span>() - i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = s.<span class="built_in">substr</span>(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="shared-ptr是线程安全的吗？https-cloud-tencent-com-developer-article-1654442"><a href="#shared-ptr是线程安全的吗？https-cloud-tencent-com-developer-article-1654442" class="headerlink" title="shared_ptr是线程安全的吗？https://cloud.tencent.com/developer/article/1654442"></a>shared_ptr是线程安全的吗？<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1654442">https://cloud.tencent.com/developer/article/1654442</a></h4><ul>
<li>多线程同时读一个shared_ptr对象是安全的</li>
<li>多线程同时对一个shared_ptr对象进行读和写是不安全的，需要加锁</li>
</ul>
<p>这里给出一个伪代码的简单例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Foo&gt; g(new Foo1);   // 线程之间共享的shared_ptr</span><br><span class="line">shared_ptr&lt;Foo&gt; x;   		  // 线程A的局部变量</span><br><span class="line">shared_ptr&lt;Foo&gt; n(new Foo2);   // 线程B的局部变量</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">线程A</span><br><span class="line">x = g;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">线程B</span><br><span class="line">g = n;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">测试场景：</span><br><span class="line"></span><br><span class="line">线程A </span><br><span class="line">  智能指针x 读取Foo1,然后还重置Foo1计数。</span><br><span class="line"></span><br><span class="line">线程 B:</span><br><span class="line"> 销毁了Foo1</span><br><span class="line">线程A</span><br><span class="line">重置计数时，foo1已经被销毁。</span><br></pre></td></tr></table></figure>



<h4 id="mysql读写锁怎么实现-mysql-读写锁和互斥锁的区别https-blog-51cto-com-u-16099299-7031260"><a href="#mysql读写锁怎么实现-mysql-读写锁和互斥锁的区别https-blog-51cto-com-u-16099299-7031260" class="headerlink" title="mysql读写锁怎么实现 mysql 读写锁和互斥锁的区别	https://blog.51cto.com/u_16099299/7031260"></a>mysql读写锁怎么实现 mysql 读写锁和互斥锁的区别	<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_16099299/7031260">https://blog.51cto.com/u_16099299/7031260</a></h4><ul>
<li>请你讲述一下互斥锁机制，以及互斥锁和读写锁的区别<ul>
<li>互斥锁（mutex），用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</li>
<li>读写锁（rwlock），分为读锁和写锁。处于读操作的时候，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其他获得写锁失败的线程将会进入睡眠状态，直到写锁释放时被唤醒。注意;写锁会阻塞其他读写锁。当有一个线程获得写锁在写时，读锁也不能被其他线程获取；写者优于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。<br>读写锁：区分读者和写者，而互斥锁不区分，互斥锁只允许同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。</li>
</ul>
</li>
<li>Linux中的四种锁机制<ul>
<li>互斥锁：在同一时间内只允许一个线程访问对象</li>
<li>读写锁：同一时间内允许多个读者同时读对象，同一时间内只允许一个写者访问对象，且当有一个线程获得写操作的时候，读锁也不能被其他的线程获取，写者优于读者，唤醒时先唤醒写者。</li>
<li>自旋锁：在任何时刻内自能有一个线程访问资源，但是当获取锁操作失败时，不会进入睡眠状态而是会原地自旋，直到锁被释放，这样减少了线程从睡眠状态到被唤醒状态的资源消耗，在加锁时间短暂的情况下使用会提高效率。但是加锁时间过长会非常浪费CPU</li>
<li>RCU（read-copy-update）：在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改，然后在将老数据update成新数据。在RCU的时候读者几乎不需要同步开销，即不需要获取锁，也不适用原子指令，不会导致竞争因此不用考虑死锁问题了。但是对于写者的同步开销比较大，他需要复制被修改的数据，还必须使用锁机制同步并行其他写者的改操作，在有大量读操作，少量写操作的时候使用。</li>
</ul>
</li>
</ul>
<h4 id="delete关键字的作用"><a href="#delete关键字的作用" class="headerlink" title="delete关键字的作用"></a>delete关键字的作用</h4><ol>
<li><p>删除特殊的成员函数：在C++11中可以使用delete来显示的阻止编译器自动生成某些特殊的成员函数。通过在类的声明中将这些特殊函数标记为delete，可以防止这些函数隐式的生成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() = <span class="keyword">delete</span>; <span class="comment">// 阻止生成默认构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp;) = <span class="keyword">delete</span>; <span class="comment">// 阻止生成拷贝构造函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除特定的函数重载：在函数重载时，可以使用delete关键字来标记某个特定的函数重载，防止特定的重载函数被调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">(<span class="type">double</span> x)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// 阻止调用带有 double 参数的函数</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="define和const的区别"><a href="#define和const的区别" class="headerlink" title="define和const的区别"></a>define和const的区别</h4><ul>
<li>就起作用的阶段而言：#define是在编译的预处理阶段起作用，而const是在编译、运行时起作用；</li>
<li>就起作用的方式而言：#define只是简单的字符串替换，没有类型检查，而const有类型检查，避免相应的错误；</li>
<li>就存储方式而言：#define只是进行展开，有多少地方使用，就有多少替换。const定义的只读变量在程序运行过程中只有一份备份；</li>
</ul>
<h4 id="写时拷贝（COW）https-www-cnblogs-com-biyeymyhjob-archive-2012-07-20-2601655-html"><a href="#写时拷贝（COW）https-www-cnblogs-com-biyeymyhjob-archive-2012-07-20-2601655-html" class="headerlink" title="写时拷贝（COW）	https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html"></a>写时拷贝（COW）	<a target="_blank" rel="noopener" href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html">https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html</a></h4><p>在linux里，fork（）会产生一个子进程，子进程与父进程用的是相同的物理空间，也就是说两者的虚拟空间不同，但对应的物理空间是一个。当父&#x2F;子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。这里的相应段你能理解不？其实就是一个程序一般分为哪些段，主要可以分为四大段：栈、堆、数据段、代码段；再细分的话可以加一个bss段，也就是用于存放程序中未初始化的全局变量的一块内存区域。</p>
<p>还有一个细节问题就是，fork之后内核会将子进程放在队列的前面，以让子进程先执行，以免父进程执行导致写时复制，造成不必要的复制，导致效率的下降。可以这么理解，可能子进程执行的代码并不需要写，完全可以使用原共享段，而父进程反而会改变（fork之后），如果父进程先执行，则子进程就要COW。</p>
<h4 id="coredump，gdb怎么定位"><a href="#coredump，gdb怎么定位" class="headerlink" title="coredump，gdb怎么定位"></a>coredump，gdb怎么定位</h4><p>整体流程如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g source.cpp -o <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./source</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./source ./core</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where(在gdb下输入)</span><br></pre></td></tr></table></figure>



<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><code>epoll</code></h4><p>关于<code>epoll</code>问题在这暂且不多写，只需记住内核事件表，<code>select</code>和<code>poll</code>都是轮询，事件复杂度：<code>epoll（o1）</code>，其他<code>（on）</code>。</p>
<p><code>select</code>和<code>poll</code>必须遍历内核事件表上所有已注册的文件描述符以找到其中的就绪者；<code>epoll</code>仅遍历就绪的文件描述符。</p>
<h4 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用"></a>static的作用</h4><ol>
<li><p>在函数体内，被声明为静态的变量在这一函数被调用过程中维持其值不变。</p>
<p>这句话其实是想说如果在函数内部声明了一个静态变量，那么这个变量在函数调用期间不会被重新初始化。它的生命周期是从程序开始到程序结束，但其作用域仍然限制在该函数内。这里给一段示例代码最好理解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    num++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num is: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">count</span>();	<span class="comment">// num = 1</span></span><br><span class="line">    <span class="built_in">count</span>();	<span class="comment">// num = 2 正常情况下，如果是非static，num会被重新置0，但这里并没有体现出来。</span></span><br><span class="line">    <span class="built_in">count</span>();	<span class="comment">// num = 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其他函数访问。它是一个本地的全局变量。</p>
<p>这句话就是表面意思，很好理解，这里给一个代码帮助理解</p>
<p><strong>moduleA.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> secretValue = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSecretValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; secretValue &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifySecretValue</span><span class="params">(<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">    secretValue = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>moudleB.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">printSecretValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">modifySecretValue</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printSecretValue</span>();</span><br><span class="line">    <span class="built_in">modifySecretValue</span>(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; secretValue &lt;&lt; std::endl; </span></span><br><span class="line">    <span class="comment">// 记住，这句话是会导致编译错误的，模块B不能直接访问模块A的变量。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在模块内，一个被声明为静态的函数只可被本模块内的其他函数调用。也就是，这个函数被限制在声明它的模块的本地范围内使用。</p>
<p>这里的意思其实就和第二点差不多了，也给一个简单示例代码吧</p>
<p><strong>moduleA.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个静态函数，只在moduleA.cpp中可见</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">secretFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside secret function of moduleA!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公开的函数，可以被其他模块调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">publicFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside public function of moduleA.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">secretFunction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>moduleB.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">publicFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">publicFunction</span>();  <span class="comment">// 可以调用这个函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能调用 secretFunction，因为它在moduleA.cpp中是静态的</span></span><br><span class="line">    <span class="comment">// secretFunction();  // 这一行会导致编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>moduleA.cpp</code>定义了一个静态函数<code>secretFunction</code>。在<code>moduleB.cpp</code>中，我们可以调用<code>publicFunction</code>，但当我们尝试调用<code>secretFunction</code>时，会导致编译错误，因为<code>secretFunction</code>只在<code>moduleA.cpp</code>中可见。</p>
</li>
</ol>
<h4 id="有关static的必要补充"><a href="#有关static的必要补充" class="headerlink" title="有关static的必要补充"></a>有关static的必要补充</h4><ul>
<li><p>修饰成员变量</p>
<p>用static修饰类的数据成员，使其成为类的全局变量，会被类的所有对象共享，包括派生类对象。<strong>所有对象只维持同一个实例。</strong>因此类的static成员必须进行类外初始化，而不能在构造函数内进行初始化，不过也可以用const修饰static数据成员在类内初始化。因为const修饰的变量无法修改。</p>
</li>
<li><p>修饰成员函数</p>
<p>用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针，因而只能访问static成员变量。<strong>注意</strong>：正是因为static修饰的成员函数不含this指针，而const修饰的成员函数会添加一个隐藏的参数const this*，所以这两种语义是矛盾的，所以在成员函数上不能同时用他们。</p>
</li>
<li><p>this指针理解</p>
<p>对象就是大房子，成员就是房子里的物件，this是一个指着房子的指针，如果要获取对象的成员也就是大房子内的物件，需要使用this指针加-&gt;这个符号。</p>
</li>
</ul>
<h4 id="三种智能指针"><a href="#三种智能指针" class="headerlink" title="三种智能指针"></a>三种智能指针</h4><p>智能指针是在栈中的一个类，用于管理堆上分配的内存。传统的C&#x2F;C++对于堆上内存的开辟释放，需要程序手动管理，而智能指针是一个类，有构造函数和析构函数，在超出作用范围后，程序会自动调用析构函数释放其管理的指针指向的内存，不需要手动释放。</p>
<ul>
<li>shared_ptr	共享智能指针，多个智能指针可以指向同一个对象，对象的资源在最后一个指针销毁时释放，通过引用计数来判断是否是最后一个智能指针。</li>
<li>unique_ptr	独占智能指针，同一时刻只有一个智能指针可以指向该对象，如果要安全重用该指针，标准库函数std::move()可以将unique_ptr赋值给另一个unique_ptr。</li>
<li>weak_ptr      弱智能指针，不会增加shared_ptr的引用计数，可以避免两个shared_ptr相互引用的死锁问题。weak_ptr只能用shared_ptr或者另一个weak_ptr构造，通过lock()方法weak_ptr可以转化为shared_ptr。</li>
</ul>
<p>下面给出代码示例</p>
<p><strong>unique_ptr</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string str;</span><br><span class="line">    ~<span class="built_in">test</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;test::~test()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> test())</span></span>;</span><br><span class="line">    p1-&gt;str = <span class="string">&quot;test string&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1-&gt;str: &quot;</span> &lt;&lt; p1-&gt;str &lt;&lt; std::endl;</span><br><span class="line">    std::unique_ptr&lt;test&gt; p2;</span><br><span class="line">    p2 = std::<span class="built_in">move</span>(p1);</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; p1-&gt;str &lt;&lt; std::endl; p1此时已经访问不到资源了</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p2-&gt;str: &quot;</span> &lt;&lt; p2-&gt;str &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// p1-&gt;str: test string</span></span><br><span class="line"><span class="comment">// p2-&gt;str: test string</span></span><br><span class="line"><span class="comment">// test::~test() 析构函数发生了调用，自动释放资源</span></span><br></pre></td></tr></table></figure>

<p><strong>shared_ptr</strong>造成的死锁问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; a;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;A&gt; b;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::~B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*******前边两个类中相互引用，此时引入weak_ptr解决死锁问题*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    p1-&gt;a = p2;</span><br><span class="line">    p2-&gt;b = p1;<span class="comment">//这种情况发生死锁,两个shared_ptr计数都不会为0，资源不会被释放</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count():&quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count():&quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体解释一下死锁的产生主要原因是引用计数无法降为0。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">首先，来理解下为什么这种情况会导致资源不能被释放：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 当你创建`p1`和`p2`时，它们都有一个引用计数为1。</span></span><br><span class="line"><span class="comment">2. 当执行`p1-&gt;a = p2;`，`p2`的引用计数增加到2，因为现在有两个`shared_ptr`对象（`p1-&gt;a`和`p2`）指向同一个`B`对象。</span></span><br><span class="line"><span class="comment">3. 当执行`p2-&gt;b = p1;`，`p1`的引用计数增加到2，因为现在有两个`shared_ptr`对象（`p2-&gt;b`和`p1`）指向同一个`A`对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">到此，我们得到了一个环状结构：`p1`指向`A`对象，`A`对象内部的`shared_ptr`指向`B`对象，`B`对象内部的`shared_ptr`又指向`A`对象。这就形成了循环引用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当`main`函数返回时，`p1`和`p2`的析构函数将被调用，但是它们的引用计数都不会降为0，因为循环引用。所以，`A`和`B`对象的析构函数永远不会被调用，这就导致了资源泄漏。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">要解决这个问题，可以使用`weak_ptr`来打破循环引用。你可以将其中一个类的`shared_ptr`成员变量替换为`weak_ptr`。这样，`weak_ptr`不会增加引用计数，从而避免了循环引用的问题。当你需要从`weak_ptr`获取一个`shared_ptr`时，可以使用`lock`方法。</span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></figure>

<p><strong>weak_prt</strong>解决循环引用问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; a;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    weak_ptr&lt;A&gt; b;  <span class="comment">// 将 shared_ptr 替换为 weak_ptr</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::~B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line">    p1-&gt;a = p2;</span><br><span class="line">    p2-&gt;b = p1;  <span class="comment">// 这里不会增加 p1 的引用计数</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 use_count(): &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 输出 1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2 use_count(): &quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 当 main 返回时，p1 和 p2 都会被析构，它们所指向的对象也会被正确地销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="STL内存池机制"><a href="#STL内存池机制" class="headerlink" title="STL内存池机制"></a>STL内存池机制</h4><ul>
<li><p>第一级配置器</p>
<p>第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。</p>
</li>
<li><p>第二级配置器</p>
<p>在STL的第二级配置器中多了一些机制，避免太多小区造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。</p>
<p>如果要分配的区块大于128bytes，则移交给第一级配置器处理。<br>如果要分配的区块小于128bytes，则以 内存池管理（memory pool），又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。</p>
<p>参考连接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/a987073381/article/details/52245795">https://blog.csdn.net/a987073381/article/details/52245795</a></p>
</li>
</ul>
<h4 id="索引选B-树的原因"><a href="#索引选B-树的原因" class="headerlink" title="索引选B+树的原因"></a>索引选B+树的原因</h4><p>个人感觉主要就是探讨B+树和B树之间的区别。<br>参考链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/JCpeng/p/15231338.html">https://www.cnblogs.com/JCpeng/p/15231338.html</a></p>
<h4 id="服务端TIME-WAIT过多的危害及解决办法"><a href="#服务端TIME-WAIT过多的危害及解决办法" class="headerlink" title="服务端TIME_WAIT过多的危害及解决办法"></a>服务端TIME_WAIT过多的危害及解决办法</h4><p>危害</p>
<ul>
<li>导致大量socket连接端口被占用无法释放，导致系统停转</li>
<li>处理大量的TIME_WAIT状态的连接会占用更多的CPU时间，导致服务器响应时间增加</li>
</ul>
<p>解决办法</p>
<ul>
<li>调整系统内核参数</li>
<li>调整短连接为长连接</li>
</ul>
<h4 id="set底层数据结构"><a href="#set底层数据结构" class="headerlink" title="set底层数据结构"></a>set底层数据结构</h4><p>set底层数据结构是红黑树。关于map和set的一些问题列举如下：</p>
<p><strong>为何map和set的插入删除效率比用其他序列容器高？</strong><br>因为对于关联容器来说，不需要做内存拷贝和内存移动。因为map和set容器内部所有元素都是以节点的方式来存储，父节点和子节点。因此插入和删除的时候都是指针的指向换来换去，并没有内存移动。</p>
<p><strong>为何每次插入&#x2F;删除后以前保存的迭代器不会失效</strong><br>在这里，迭代器就相当于指向节点的指针，内存没有变，指向内存的指针当然不会失效。不同于map&#x2F;set，vector就会失效，比如需要扩容的时候，需要一块更大的内存，就必须把之前的内存释放，申请更大的内存，复制已有的数据元素到新的内存。</p>
<p><strong>为何map和set不能像vector一样有个reserve函数来预分配数据</strong><br>不懂！预留本问题</p>
<p><strong>当数据元素增多时（10000到20000个比较），map和set的插入和搜索速度变化如何？</strong><br>map和set使用的是二分查找，举例来说就是，16个元素查四次，32个元素查5次，10000个也就是14次，20000也就15次。</p>
<h4 id="mapreduce原理（不懂，预留）"><a href="#mapreduce原理（不懂，预留）" class="headerlink" title="mapreduce原理（不懂，预留）"></a>mapreduce原理（不懂，预留）</h4><h4 id="socket哪些操作会产生阻塞"><a href="#socket哪些操作会产生阻塞" class="headerlink" title="socket哪些操作会产生阻塞"></a>socket哪些操作会产生阻塞</h4><p>accept()：在等待客户端的连接请求时会阻塞。如果没有客户端尝试连接，调用这个函数的进程或者线程会被挂起。</p>
<p>connect()：当客户端尝试与远程主机建立连接时，此操作会阻塞，知道连接成功或失败</p>
<p>recv()：当数据从网络到达时，如果没有数据可读，函数调用就会被挂起，阻塞</p>
<p>send()：当发送缓冲区已满，并且无法接受更多数据发送到网络时，操作阻塞。</p>
<h4 id="申请一块大内存和一块小内存的效率是一样的吗？"><a href="#申请一块大内存和一块小内存的效率是一样的吗？" class="headerlink" title="申请一块大内存和一块小内存的效率是一样的吗？"></a>申请一块大内存和一块小内存的效率是一样的吗？</h4><p>不一样，申请一块小内存通常是不需要一级配置器，小块内存通常由内存分配器从预先分配的内存池中分配，这些池被称为<code>bins</code>，这种分配通常非常快，因为它只是涉及到从已存在的内存池中返回一个指针。大的内存通常要调用<code>mmap()</code>。</p>
<h4 id="TCP慢启动和拥塞控制"><a href="#TCP慢启动和拥塞控制" class="headerlink" title="TCP慢启动和拥塞控制"></a>TCP慢启动和拥塞控制</h4><p>TCP连接建立好之后，CWND（congestion window，拥塞窗口）被设置为初始值IW（initial window），其大小为2~4个SMSS（TCP报文段的最大长度，仅指数据部分），新的linux内核加大了这个值。此时发送端最多能发送IW字节的数据，此后发送端每收到一个确认，CWND就按照如下公式增长：<br>$$<br>CWND +&#x3D; min(N, SMSS)<br>$$<br>其中N是此次确认中包含的之前未被确认的字节数。<br>如果不施加其他手段，慢启动必然使得CWND增长的很快，所以TCP拥塞控制中有另外一个非常重要的变量：慢启动门限。当CWND超过慢启动门限值时，TCP将进入拥塞避免阶段。</p>
<h4 id="发送端判断发生拥塞的依据"><a href="#发送端判断发生拥塞的依据" class="headerlink" title="发送端判断发生拥塞的依据"></a>发送端判断发生拥塞的依据</h4><ul>
<li>传输超时</li>
<li>接收到重复的确认报文段</li>
</ul>
<h4 id="Linux下的POSIX互斥锁和条件变量"><a href="#Linux下的POSIX互斥锁和条件变量" class="headerlink" title="Linux下的POSIX互斥锁和条件变量"></a>Linux下的POSIX互斥锁和条件变量</h4><p>牢记这几个函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">pthread_mutex_destory(&amp;mutex);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">pthread_mutex_trylock(&amp;mutex);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_init(&amp;cond, NULL);</span><br><span class="line">pthread_cond_destory(&amp;cond);</span><br><span class="line">pthread_cond_broadcast(&amp;cond);</span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);</span><br></pre></td></tr></table></figure>

<p>条件变量要配合互斥锁使用。这里挂一个讲的比较清晰明了的博客链接（<a target="_blank" rel="noopener" href="https://punmy.cn/2018/06/07/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condition%20Variables%EF%BC%89.html%EF%BC%89%EF%BC%8C%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E5%8A%A0%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B">https://punmy.cn/2018/06/07/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condition%20Variables%EF%BC%89.html），下面是使用互斥锁加条件变量实现的生产者-消费者模型</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mutex_;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span> condition_;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_t</span> notifying_thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;condition_, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;condition_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span> *args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">    <span class="keyword">while</span>(value != <span class="number">10</span>)&#123;</span><br><span class="line">        value++;</span><br><span class="line">    &#125;</span><br><span class="line">    notifying_thread = <span class="built_in">pthread_self</span>();</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;condition_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">    <span class="keyword">while</span>(value != <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;condition_, &amp;mutex_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value is 10, the pthread is: %lu\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)notifying_thread);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">consumer</span><span class="params">(<span class="type">void</span> *args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">waitCondition</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> a1;</span><br><span class="line">    <span class="type">pthread_t</span> a2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;a1, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;a2, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(a1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(a2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">destory</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="写一个生产者-x2F-消费者模型（采用信号量）"><a href="#写一个生产者-x2F-消费者模型（采用信号量）" class="headerlink" title="写一个生产者&#x2F;消费者模型（采用信号量）"></a>写一个生产者&#x2F;消费者模型（采用信号量）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_BUFFERS = <span class="number">10</span>;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> empty;</span><br><span class="line"><span class="type">sem_t</span> full;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        num = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;empty);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">        buffer.<span class="built_in">push</span>(num);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">comsumer</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;full);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">        num = buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Comsumed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> proThread, comPthread;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;empty, <span class="number">0</span>, MAX_BUFFERS);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;full, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;proThread, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;comPthread, <span class="literal">NULL</span>, comsumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(proThread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(comPthread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;empty);</span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;full);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="基类的析构函数为什么是虚函数"><a href="#基类的析构函数为什么是虚函数" class="headerlink" title="基类的析构函数为什么是虚函数"></a>基类的析构函数为什么是虚函数</h4><p>当基类的析构函数不是虚函数可能会导致派生类对象的析构函数不被调用。从而引发资源泄露或者其他未定义行为。下面给出示例代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base obj is constructed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="comment">// ~Base() &#123; std::cout &lt;&lt; &quot;Base obj is deconstructed&quot; &lt;&lt; std::endl; &#125;</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base obj is deconstructed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()&#123;</span><br><span class="line">        num_ = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived is constructed&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Derived</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived is deconstructed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *num_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base *base = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）"><a href="#为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）" class="headerlink" title="为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）"></a>为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）</h4><p>当一个基类没有虚析构函数，并且通过基类指针删除一个派生类对象时，只有基类的析构函数会被调用。这是因为编译器在编译时期决定了调用哪个析构函数，而不是在运行时期，这种机制被称为“静态绑定”。</p>
<p>如果基类的析构函数是虚函数，那么编译器会在运行时决定要调用哪个析构函数，这种机制称为“动态绑定”或“多态”。</p>
<h4 id="拷贝构造函数为什么要用引用"><a href="#拷贝构造函数为什么要用引用" class="headerlink" title="拷贝构造函数为什么要用引用"></a>拷贝构造函数为什么要用引用</h4><p>避免拷贝构造函数无限递归下去！那传引用为什么行呢？回忆一下引用定义，传引用人家根本就不会涉及到构造函数这玩意，形参相当于实参的一个别名。</p>
<h4 id="左右值的差别"><a href="#左右值的差别" class="headerlink" title="左右值的差别"></a>左右值的差别</h4><h4 id="C-中的虚继承"><a href="#C-中的虚继承" class="headerlink" title="C++中的虚继承"></a>C++中的虚继承</h4><p>c++中的虚继承主要是为了解决多继承情况中存在的二义性问题。比如，现在类A为基类，类B和类C继承自类A，类D继承自类B和类C，假设此时A中有一个名为x的变量且B和C都定义了x，如果此时D直接访问x会产生二义性问题。因为不清楚是A-&gt;B-&gt;D还是A-&gt;C-&gt;D。此时如果让类B和类C虚继承自A，就使得在派生类中只保留有一份成员变量x，解决了二义性问题。<br>参考链接：<br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/2280.html">http://c.biancheng.net/view/2280.html</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/41309205%EF%BC%88%E8%99%9A%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E9%83%BD%E8%AE%B2%E4%BA%86%EF%BC%8C%E5%8D%81%E5%88%86%E8%AF%A6%E7%BB%86%EF%BC%89">https://zhuanlan.zhihu.com/p/41309205（虚继承、虚函数都讲了，十分详细）</a></p>
<h4 id="C-中的forward函数"><a href="#C-中的forward函数" class="headerlink" title="C++中的forward函数"></a>C++中的forward函数</h4><p>左值引用和右值引用的结果都是左值，无法通过引用区分原本变量的左右值，forward可以保持变量的原本的左右值属性，帮助我们区分。</p>
<h4 id="如何判断TCP断开"><a href="#如何判断TCP断开" class="headerlink" title="如何判断TCP断开"></a>如何判断TCP断开</h4><ol>
<li>发送心跳消息</li>
<li>利用recv&#x2F;send函数的返回值<ul>
<li>recv返回0代表对方关闭了连接</li>
<li>recv返回-1并且errno&#x3D;&#x3D;EAGAIN或者EWOULDBLOCK时，表示没有数据可读，可以稍后再试。</li>
<li><strong>send返回非负值</strong>:<ul>
<li><code>send</code>返回的是实际发送的字节数，这可能会少于你请求发送的字节数（缓冲区已满）。</li>
<li>如果没有可用的缓冲区空间，那么在非阻塞模式下，<code>send</code>可能会返回<code>EAGAIN</code>或<code>EWOULDBLOCK</code>。</li>
</ul>
</li>
<li><strong>send返回-1</strong>:<ul>
<li>与<code>recv</code>类似，这表示出现了错误。</li>
<li>可以使用<code>perror</code>、<code>strerror</code>或检查<code>errno</code>来确定具体的错误原因。</li>
<li>常见的错误原因包括<code>EPIPE</code>（对端已关闭，本端仍尝试发送数据导致的”Broken pipe”错误）和<code>ECONNRESET</code>（连接被对端重置）。</li>
</ul>
</li>
</ul>
</li>
<li>利用tcp自带的keepalive机制</li>
</ol>
<h4 id="如何查看系统的最大进程数和线程数"><a href="#如何查看系统的最大进程数和线程数" class="headerlink" title="如何查看系统的最大进程数和线程数"></a>如何查看系统的最大进程数和线程数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/pid_max    # 最大进程数</span><br><span class="line">cat /proc/sys/kernel/threads-max	# 最大线程数</span><br></pre></td></tr></table></figure>



<h4 id="git-rebase和git-merge的区别（https-joyohub-com-2020-04-06-git-rebase-）"><a href="#git-rebase和git-merge的区别（https-joyohub-com-2020-04-06-git-rebase-）" class="headerlink" title="git rebase和git merge的区别（https://joyohub.com/2020/04/06/git-rebase/）"></a>git rebase和git merge的区别（<a target="_blank" rel="noopener" href="https://joyohub.com/2020/04/06/git-rebase/%EF%BC%89">https://joyohub.com/2020/04/06/git-rebase/）</a></h4><h4 id="C-calss-和-struct的区别"><a href="#C-calss-和-struct的区别" class="headerlink" title="C++ calss 和 struct的区别"></a>C++ calss 和 struct的区别</h4><p>class默认访问类型是private，struct默认访问类型是public</p>
<h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><ol>
<li>指针是一个变量，它保存了另一个变量的内存地址；引用是另一个变量的别名，与原变量共享内存地址。</li>
<li>指针可以被重新赋值，指向新的对象；引用绑定对象后不能更改。</li>
<li>指针可以为nullptr；引用必须初始化。</li>
</ol>
<h4 id="为什么模板类的声明和实现不能分别写在-h文件和-cpp文件中"><a href="#为什么模板类的声明和实现不能分别写在-h文件和-cpp文件中" class="headerlink" title="为什么模板类的声明和实现不能分别写在.h文件和.cpp文件中"></a>为什么模板类的声明和实现不能分别写在.h文件和.cpp文件中</h4><p>首先，模板不是传统意义上的代码。它更像是编译器的“代码生成工具”。当你使用一个特定的模板类型（例如<code>std::vector&lt;int&gt;</code>)，<strong>编译器会为你生成这种类型的实例代码</strong>。为了做到这一点，编译器需要能够看到模板的完整定义。注意：这就是模板和普通类的最大区别。普通类在编译阶段并没有（并不依赖于）编译时的类型特化，只需要在链接阶段将所有.cpp文件链接在一起就好了。而如果模板分开写，其他使用模板的.cpp文件在编译时找不到定义，导致链接错误。</p>
<h4 id="动态链接与静态链接"><a href="#动态链接与静态链接" class="headerlink" title="动态链接与静态链接"></a>动态链接与静态链接</h4><p>静态链接（.a&#x2F;.lib）：把要调用的函数或者过程链接到可执行文件中，成为可执行文件的一部分。如果多个程序使用相同的库，那么该库的代码在每个程序中都会被复制，这浪费了磁盘和内存空间。但是所有代码都在可执行文件中，没有运行时链接开销。</p>
<p>动态链接（.so&#x2F;.ddl）：动态链接所调用的函数代码并没有被拷贝到应用程序的可执行文件中去，而是仅仅在其中加入了所调用函数的描述信息（往往是一些重定位信息）。仅当应用程序被装入内存开始运行时，在Windows的管理下，才在应用程序与相应的DLL之间建立链接关系。当要执行所调用DLL中的函数时，根据链接产生的重定位信息，Windows才转去执行DLL中相应的函数代码。多份代码可以共享同一份库代码。</p>
<h4 id="pragma-pack编译宏"><a href="#pragma-pack编译宏" class="headerlink" title="pragma pack编译宏"></a>pragma pack编译宏</h4><p>pragma pack用于指定内存对齐值。</p>
<h4 id="vector底层实现原理"><a href="#vector底层实现原理" class="headerlink" title="vector底层实现原理"></a>vector底层实现原理</h4><p>理解vector的实现主要考虑四个东西就好了：三个指针加动态内存申请。</p>
<p>三个指针：</p>
<ul>
<li>first_：指向vector容器对象起始地址的位置</li>
<li>last_：指向vector容器对象中当前最后一个元素的末尾字节</li>
<li>end_：指向vector容器所占内存空间的最后一个字节</li>
</ul>
<p><img src="png1.gif"></p>
<p>动态内存申请：</p>
<p>当 vector 的大小和容量相等（size&#x3D;&#x3D;capacity）也就是满载时，如果再向其添加元素，那么 vector 就需要扩容。vector 容器扩容的过程需要经历以下 3 步：</p>
<ol>
<li>完全弃用现有的内存空间，重新申请更大的内存空间；</li>
<li>将旧内存空间中的数据，按原有顺序移动到新的内存空间中；</li>
<li>最后将旧的内存空间释放。</li>
</ol>
<h4 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h4><p>常量指针：记忆方法（常量的指针），指针指向的对象是一个常量，只能读取指针指向的内容，不能修改指针指向的内容。</p>
<p>指针常量：指针本身是一个常量，不能修改指针指向的地址，可以修改指针指向地址的内容。</p>
<h4 id="C-中一些特别的关键字（default，override、final、volatile）"><a href="#C-中一些特别的关键字（default，override、final、volatile）" class="headerlink" title="C++中一些特别的关键字（default，override、final、volatile）"></a>C++中一些特别的关键字（default，override、final、volatile）</h4><p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011947630/article/details/103062773">https://blog.csdn.net/u011947630/article/details/103062773</a></p>
<h4 id="字节算法题：小于N的最大数"><a href="#字节算法题：小于N的最大数" class="headerlink" title="字节算法题：小于N的最大数"></a>字节算法题：小于N的最大数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> value = <span class="number">14132</span>;</span><br><span class="line">string valueStr = <span class="built_in">to_string</span>(value);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index, <span class="type">bool</span> judge, <span class="type">int</span> temp)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(index == valueStr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ans = temp;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(judge) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">true</span>, temp * <span class="number">10</span> + (nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>]));    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> val = valueStr[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val == nums[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">false</span>, temp * <span class="number">10</span> + nums[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; nums[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">true</span>, temp * <span class="number">10</span> + nums[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最终结果为空</span></span><br><span class="line">        <span class="keyword">if</span>(index != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//少了一位，显然小了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">true</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="如果同时有大量客户并发建立连接，服务器端有什么机制进行处理"><a href="#如果同时有大量客户并发建立连接，服务器端有什么机制进行处理" class="headerlink" title="如果同时有大量客户并发建立连接，服务器端有什么机制进行处理"></a>如果同时有大量客户并发建立连接，服务器端有什么机制进行处理</h4><ol>
<li>多进程和多线程</li>
<li>连接池</li>
<li>异步I&#x2F;O</li>
<li>负载均衡</li>
<li>限流</li>
<li>短连接与长连接</li>
</ol>
<h4 id="HTTP和TCP之间的关系"><a href="#HTTP和TCP之间的关系" class="headerlink" title="HTTP和TCP之间的关系"></a>HTTP和TCP之间的关系</h4><ol>
<li><p>HTTP是一个应用层协议，TCP是一个传输层协议</p>
</li>
<li><p>HTTP依赖于TCP来进行数据的传输。比如，当你使用浏览器访问一个网页时，背后发生的是HTTP请求和响应的交换，而这些HTTP数据包是通过TCP连接发送的。</p>
</li>
<li><p>HTTP&#x2F;1.0对于每一个请求-响应都会新建一个TCP连接，使用完之后就关闭</p>
<p>HTPP&#x2F;1.1引入了keep-alive机制，允许在单个TCP连接上发送多个HTTP请求和响应</p>
<p>HTTP&#x2F;2进一步扩展了这种机制，允许在单个TCP连接上同时多路复用多个HTTP请求和响应</p>
</li>
</ol>
<h4 id="HTTP从请求到得到结果的过程"><a href="#HTTP从请求到得到结果的过程" class="headerlink" title="HTTP从请求到得到结果的过程"></a>HTTP从请求到得到结果的过程</h4><ol>
<li><p><strong>域名解析</strong>：</p>
<ul>
<li>客户端（通常是浏览器）首先检查URL是否包含域名（例如 <code>www.example.com</code>）。</li>
<li>如果包含，客户端首先会查找其DNS缓存是否已经有该域名的IP地址。</li>
<li>如果没有，客户端会发起一个DNS查询到配置的DNS服务器，以获取对应的IP地址。</li>
</ul>
</li>
<li><p><strong>建立TCP连接</strong>：</p>
<ul>
<li>使用从DNS查询得到的IP地址，客户端尝试与服务器的80端口（HTTP）或443端口（HTTPS）建立一个TCP连接。</li>
<li>这涉及到TCP三次握手过程。</li>
</ul>
</li>
<li><p><strong>（HTTPS的情况）SSL&#x2F;TLS握手</strong>：</p>
<ul>
<li>如果是HTTPS请求，一旦TCP连接建立，客户端和服务器会进行SSL&#x2F;TLS握手来建立加密的通信通道。</li>
</ul>
</li>
<li><p><strong>发送HTTP请求</strong>：</p>
<ul>
<li>连接建立后，客户端会发送HTTP请求报文。这包括请求行（例如 <code>GET /path HTTP/1.1</code>）、请求头和（对于某些请求如POST）请求体。</li>
</ul>
</li>
<li><p><strong>服务器处理请求</strong>：</p>
<ul>
<li>服务器接收到请求后，由其HTTP服务软件（如Apache、Nginx等）处理。</li>
<li>服务器可能会根据请求路径查询文件、与数据库交互或调用其他服务，以生成响应。</li>
</ul>
</li>
<li><p><strong>服务器发送响应</strong>：</p>
<ul>
<li>服务器生成响应后，它将响应报文发送回客户端。响应通常包括状态行（例如 <code>HTTP/1.1 200 OK</code>）、响应头和响应体。</li>
<li>对于动态内容，如由PHP、Python或Node.js等后端语言生成的页面，服务器可能会进行一些额外的处理来生成响应内容。</li>
</ul>
</li>
<li><p><strong>客户端处理响应</strong>：</p>
<ul>
<li>客户端（如浏览器）接收响应，并基于响应内容采取相应的行动。</li>
<li>如果响应是一个HTML页面，浏览器会开始解析HTML，并可能发起其他请求来获取页面上的资源，如图片、CSS、JavaScript文件等。</li>
</ul>
</li>
<li><p><strong>关闭连接</strong>：</p>
<ul>
<li>一旦数据交换完成，通常会关闭TCP连接。然而，在HTTP&#x2F;1.1中，默认使用<code>keep-alive</code>，意味着连接可以被复用，从而减少后续请求的延迟。</li>
</ul>
</li>
</ol>
<h4 id="https和http的区别是什么，https具体是怎么做的"><a href="#https和http的区别是什么，https具体是怎么做的" class="headerlink" title="https和http的区别是什么，https具体是怎么做的"></a>https和http的区别是什么，https具体是怎么做的</h4><p>HTTPS和HTTP唯一的区别就是HTTPS使用TLS&#x2F;SSL来加密普通的HTTP请求和响应。</p>
<p>关于https具体是如何做的，这里有一个参考博文链接，写的超好（参考链接：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/http-vs-https.html%EF%BC%89">https://www.runoob.com/w3cnote/http-vs-https.html）</a></p>
<h4 id="gdb中，如何查看每个线程相关的信息"><a href="#gdb中，如何查看每个线程相关的信息" class="headerlink" title="gdb中，如何查看每个线程相关的信息"></a>gdb中，如何查看每个线程相关的信息</h4><p>在 gdb 中，可以使用 <code>info threads</code> 命令查看当前进程中的所有线程信息。这个命令会列出每个线程的编号、状态（如运行、挂起等）以及当前所在的函数名称。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info threads</span><br><span class="line">  Id   Target Id         Frame </span><br><span class="line">  2    Thread 0x7ffff7fc8700 (LWP 13627) <span class="string">&quot;main&quot;</span> __libc_start_main (argc=1, argv=0x7fffffffe4c8, <span class="built_in">env</span>=0x7fffffffe4d8,</span><br><span class="line">      auxvec=0x7fffffffe4d8, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffe4c8) at ../csu/libc-start.c:310</span><br><span class="line">  3    Thread 0x7ffff77c7700 (LWP 13628) <span class="string">&quot;main&quot;</span> foo () at test.c:6</span><br><span class="line">  4    Thread 0x7ffff6fc6700 (LWP 13629) <span class="string">&quot;main&quot;</span> bar () at test.c:11</span><br></pre></td></tr></table></figure>

<p>你还可以使用 <code>thread &lt;thread-id&gt;</code> 命令来切换到指定的线程，然后使用其他 gdb 命令来查看线程的信息或调试线程。</p>
<p>例如，你可以输入 <code>thread 3</code> 命令切换到编号为 3 的线程，然后输入 <code>bt</code> 命令来查看线程的调用堆栈：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) thread 3</span><br><span class="line">[Switching to thread 3 (Thread 0x7ffff77c7700 (LWP 13628))]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  foo () at test.c:6</span></span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  foo () at test.c:6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00007ffff7bbb830 <span class="keyword">in</span> start_thread (arg=&lt;optimized out&gt;) at pthread_create.c:486</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007ffff78f95fd <span class="keyword">in</span> <span class="built_in">clone</span> () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span></span><br></pre></td></tr></table></figure>



<h4 id="构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因"><a href="#构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因" class="headerlink" title="构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因"></a>构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因</h4><p>构造函数从语法上调用虚函数没有任何问题，但这样做可能并不会达到预期的结果。因为在构造函数执行期间，对象的虚表仍在被设置，因此调用的虚函数版本可能并不是我们想要的版本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base construct\n&quot;</span>;</span><br><span class="line">        <span class="built_in">call</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base call\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived construct\n&quot;</span>;</span><br><span class="line">        <span class="built_in">call</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived call\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这段程序，可能我们期望得到的结果是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Derived call</span><br><span class="line">Derived constructor</span><br><span class="line">Derived call</span><br></pre></td></tr></table></figure>

<p>但我们实际得到的结果是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Base call</span><br><span class="line">Derived constructor</span><br><span class="line">Derived call</span><br></pre></td></tr></table></figure>

<p>原因是在Base构造函数执行时，Derived部分的对象还没有完全构造出来，因此，此时vtable仍然指向Base类的vtable。因此，当在Base构造函数中调用call虚函数时，他会调用Base版本，而不是Derived版本。</p>
<p><strong>这里延伸一下不要在析构函数中调用虚函数的原因</strong>：析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经“销毁”，这个时再调用子类的虚函数已经没有意义了。</p>
<h4 id="迭代器的实现"><a href="#迭代器的实现" class="headerlink" title="迭代器的实现"></a>迭代器的实现</h4><p>参考链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wengle520/p/12492708.html">https://www.cnblogs.com/wengle520/p/12492708.html</a></p>
<h4 id="epoll红黑树的作用"><a href="#epoll红黑树的作用" class="headerlink" title="epoll红黑树的作用"></a>epoll红黑树的作用</h4><p>简单点讲就是在内核事件表上快速注册&#x2F;删除所需连接文件描述符。下面两篇文章基本阐述了这个问题，好好看！</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1862671">https://cloud.tencent.com/developer/article/1862671</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/366955699">https://zhuanlan.zhihu.com/p/366955699</a></p>
<h4 id="用户态和内核态分别会做什么，怎么切换的"><a href="#用户态和内核态分别会做什么，怎么切换的" class="headerlink" title="用户态和内核态分别会做什么，怎么切换的"></a>用户态和内核态分别会做什么，怎么切换的</h4><p>内核空间主要负责操作系统内核线程以及用户程序系统调用。</p>
<p>用户空间主要负责用户程序的非系统调用。</p>
<p>从用户态切换到内核态主要有三种方式：</p>
<ol>
<li>系统调用：系统调用本身就是中断，但是<strong>软件中断</strong>，跟硬中断不同。系统调用机制是使用了操作系统为用户特别开放的一个中断来实现，如 Linux 的 int 80h 中断。</li>
<li>异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，会触发由当前运行进程切换到处理此异常的内核相关进程中</li>
<li>外围设备中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序。</li>
</ol>
<p>有一个面试问题：I&#x2F;O频繁发生内核态和用户态切换，怎么解决？</p>
<p>答案：使用用户进程缓冲区。</p>
<p>用户进程缓冲区</p>
<p>你看一些程序在读取文件时，会先申请一块内存数组，称为buffer，然后每次调用read，读取设定字节长度的数据，写入buffer。之后的程序都是从buffer中获取数据，当buffer使用完后，在进行下一次调用，填充buffer。所以说：用户缓冲区的目的就是是为了减少系统调用次数，从而降低操作系统在用户态与核心态切换所耗费的时间。除了在进程中设计缓冲区，内核也有自己的缓冲区。</p>
<p>内核缓存区</p>
<p>当一个用户进程要从磁盘读取数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程缓冲区中。但若是内核缓冲区中没有数据，内核会把对数据块的请求，加入到请求队列，然后把进程挂起，为其它进程提供服务。等到数据已经读取到内核缓冲区时，把内核缓冲区中的数据读取到用户进程中，才会通知进程，当然不同的IO模型，在调度和使用内核缓冲区的方式上有所不同。</p>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42052956/article/details/111562280">https://blog.csdn.net/qq_42052956/article/details/111562280</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2131401">https://cloud.tencent.com/developer/article/2131401</a></p>
<h4 id="进程的创建需要系统分配什么资源"><a href="#进程的创建需要系统分配什么资源" class="headerlink" title="进程的创建需要系统分配什么资源"></a>进程的创建需要系统分配什么资源</h4><p>根据其他博客里写的底层源码来看，分配给一个进程的东西太多啦，我们挑几个记一下：内存、CPU处理时间、输入输出设备、存储空间。</p>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lvyibin890/article/details/82193900">https://blog.csdn.net/lvyibin890/article/details/82193900</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/s/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%99%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E4%BB%80%E4%B9%88%E8%B5%84%E6%BA%90">https://juejin.cn/s/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%99%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E4%BB%80%E4%B9%88%E8%B5%84%E6%BA%90</a></p>
<h4 id="HTTPS加密方式：对称加密、非对称加密"><a href="#HTTPS加密方式：对称加密、非对称加密" class="headerlink" title="HTTPS加密方式：对称加密、非对称加密"></a>HTTPS加密方式：对称加密、非对称加密</h4><p>对称加密：密钥只有一个，加密解密为同一个密码。利用这种加密方式时必须把密钥也发送给对方，密钥在传输过程中被窃取，也就失去了加密的意义。</p>
<p>非对称加密：密钥成对出现，公钥加密需要私钥解密，私钥加密需要公钥解密。</p>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/http-vs-https.html">https://www.runoob.com/w3cnote/http-vs-https.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.itwork.club/2022/05/27/why-did-https-use-mixed-encryption-algorithm/">https://www.itwork.club/2022/05/27/why-did-https-use-mixed-encryption-algorithm/</a></p>
<h4 id="线程的三种状态"><a href="#线程的三种状态" class="headerlink" title="线程的三种状态"></a>线程的三种状态</h4><p>就绪态、运行态、阻塞态</p>
<h4 id="析构函数里能不能抛异常-为什么？"><a href="#析构函数里能不能抛异常-为什么？" class="headerlink" title="析构函数里能不能抛异常?为什么？"></a>析构函数里能不能抛异常?为什么？</h4><p>析构函数从语法上是可以抛出异常的，但是这样做很危险，请尽量不要这要做。原因在《More Effective C++》中提到两个： </p>
<p>（1）如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。 </p>
<p>（2）通常异常发生时，c++的异常处理机制在异常的传播过程中会进行栈展开（stack-unwinding），因发生异常而逐步退出复合语句和函数定义的过程，被称为栈展开。在栈展开的过程中就会调用已经在栈构造好的对象的析构函数来释放资源，此时若其他析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃。</p>
<h4 id="两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？"><a href="#两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？" class="headerlink" title="两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？"></a>两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？</h4><p>有虚函数的大，因为有虚函数的类的会包含一个虚函数指针。注意不同操作系统指针大小不一样。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/luolaihua2018/article/details/110736211">https://blog.csdn.net/luolaihua2018/article/details/110736211</a></p>
<h4 id="数据报和数据流的区别？"><a href="#数据报和数据流的区别？" class="headerlink" title="数据报和数据流的区别？"></a>数据报和数据流的区别？</h4><p>可以这么简单理解：</p>
<p>假设现在有100字节数据，面向数据流和面向数据报的连接可以分别怎么样处理呢？</p>
<ul>
<li>数据流是发送端可以调用10次write，每次10字节。接收端调用一次read。也可以是发送端调用一次write，接收端调用10次read。数据流是没有边界的</li>
<li>数据报则是一次write就需要一次read，是有边界的。</li>
</ul>
<h4 id="在分布式系统中，如果某个节点宕机了咋办？"><a href="#在分布式系统中，如果某个节点宕机了咋办？" class="headerlink" title="在分布式系统中，如果某个节点宕机了咋办？"></a>在分布式系统中，如果某个节点宕机了咋办？</h4><p>做一个数据副本策略，把每一台机器上的数据做几个副本的冗余，放在别的机器上。万一说某一台机器宕机，没事啊，因为其他机器上还有他的副本。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>所谓自旋锁就是通过while循环实现的，让拿到锁的线程进入临界区执行代码，让没有拿到锁的线程一直进行while死循环，这其实就是线程自己“旋”在while循环了，因而这种锁就叫做自旋锁。</p>
<p>自旋锁实现参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jeffasd/article/details/80661804">https://blog.csdn.net/jeffasd/article/details/80661804</a></p>
<h4 id="线程同步的方式有哪些"><a href="#线程同步的方式有哪些" class="headerlink" title="线程同步的方式有哪些"></a>线程同步的方式有哪些</h4><p>互斥锁、信号量、条件变量、自旋锁、读写锁、屏障</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zcl0219.github.io/2023/06/28/RPC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="GGBond">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="Doing the tough things sets winners apart from losers">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/28/RPC/" class="post-title-link" itemprop="url">RPC</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-06-28 22:08:50" itemprop="dateCreated datePublished" datetime="2023-06-28T22:08:50+08:00">2023-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-09-18 14:18:48" itemprop="dateModified" datetime="2023-09-18T14:18:48+08:00">2023-09-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="开始补上MPRPC项目的代码实现，从头开始———-day1"><a href="#开始补上MPRPC项目的代码实现，从头开始———-day1" class="headerlink" title="开始补上MPRPC项目的代码实现，从头开始———-day1"></a><strong>开始补上<code>MPRPC</code>项目的代码实现，从头开始———-<code>day1</code></strong></h3><p>简介：项目基于muduo高性能网络库 + protobuf开发，所以命名为mprpc。</p>
<p>技术栈</p>
<ul>
<li>集群和分布式概念及原理</li>
<li>RPC远程过程调用原理及实现</li>
<li>Protobuf数据序列化和反序列化协议</li>
<li>Zookeeper分布式一致性协调服务应用及编程（服务注册中心，方便寻找哪个服务在哪台服务器上）</li>
<li>muduo网络库编程</li>
<li>conf配置文件读取</li>
<li>CMake构建项目集成编译环境</li>
</ul>
<h4 id="集群和分布式（搞懂为什么要分布式）"><a href="#集群和分布式（搞懂为什么要分布式）" class="headerlink" title="集群和分布式（搞懂为什么要分布式）"></a><strong>集群和分布式（搞懂为什么要分布式）</strong></h4><p><strong>集群</strong>：每一台服务器独立运行一个工程的所有模块</p>
<p><strong>分布式</strong>：一个工程拆分了很多模块，每一个模块独立部署运行在一个服务器主机上，所有服务器协同工作共同提供服务，每一台服务器称作分布式的一个节点，根据节点的并发要求，对一个节点可以再做节点模块集群部署。</p>
<p><img src="png1.PNG"></p>
<p>如图中<code>server</code>所示，一个聊天系统包括不同模块：用户管理、好友管理、群组管理、消息管理以及后台管理五个模块。每个模块有自己的特定业务，举个例子，用户管理模块包括用户注册、用户登录、用户注销等。</p>
<p>现在让你提出一些单机聊天服务器的缺陷，你能想到哪些？</p>
<ol>
<li>受限于硬件资源，聊天服务器所能承受的用户的并发量，比如端口用光了。</li>
<li>假设这个单机聊天服务器体系很庞大，项目编译需要两个小时！如果现在消息管理模块有一个小<code>bug</code>，需要改动几行，然后导致需要重新编译、部署整个项代码。</li>
<li>系统中，有些模块是属于<code>CPU</code>密集型，有些模块是<code>I/O</code>密集型的，造成各模块对于硬件资源的需求是不一样的。既然受限于硬件资源，我们就多部署几台服务器，横向增加服务器数量。但并未解决问题2和3。</li>
</ol>
<p>集群的优缺点如下，优点：用户的并发量提升了。缺点：项目代码还是需要整体重新编译，而且需要进行多次部署。</p>
<p><img src="png2.png"></p>
<p>现在我们看红色圈，我们把不同模块分类部署在不同服务器上。所有服务器共同构成一个聊天系统，这就是分布式。现在我们将不同服务器分别视为不同分布式节点。比如用户管理模块和消息管理模块对并发要求高，我们可以进行扩容，再部署几台服务器用于用户管理和消息管理（根据节点的并发要求，对一个节点可以再做节点模块集群部署）。分布式系统针对问题2，每个模块独立部署独立运行，哪个模块有<code>bug</code>，我只需要重新编译部署那个模块，其他模块还能正常运行。问题3就很明显了，视不同要求配置不同服务器。</p>
<p>那分布式就全是优点吗？下面我们说说关于分布式设计的难点。</p>
<ol>
<li>大系统的软件模块该怎么划分。</li>
<li>各模块之间怎么访问？集群服务器所有模块运行在一个进程里，不同模块之间访问简便。而分布式各模块都运行在不同的进程里，那服务器1的模块怎么调用服务器2上的模块的一个业务方法呢？我们这个项目所做的就是封装这种远程调用过程，方便用户调用，也就是程序员方便使用我们写的项目（<code>MPRPC</code>）。</li>
</ol>
<h3 id="RPC通信原理———-day2"><a href="#RPC通信原理———-day2" class="headerlink" title="RPC通信原理———-day2"></a><strong><code>RPC</code>通信原理———-<code>day2</code></strong></h3><p><img src="png3.png"></p>
<p>通过上图我们可以看到，我们设计的框架主要由以下部分和流程组成：</p>
<ul>
<li>发起调用端（caller）：调用方需要将调用的函数名、参数打包（序列化），并通过网络发送出去。这里打算采用muduo网络库。</li>
<li>接收端（callee）：接收方接收到包后，将包里的内容反序列化，就能知道调用哪一个函数、传入的参数是啥，然后返回值依旧是序列化之后通过网络发送回去，发送端接收到后反序列化，得到具体的返回值。</li>
<li>我们的框架主要是实现图中的黄绿部分。<ol>
<li>黄色部分是rpc方法参数的打包和解析，也就是数据的序列化与反序列化，通过protobuf完成。</li>
<li>在图中，有一些东西没画进去，比如我们将黄色块分别取名为client-stub和server-stub。这两个stub都是执行数据的序列化与反序列化。</li>
<li>如果远程调用过程中函数执行出错，我们可以返回一些错误码，防止接收端读取错误的返回值。</li>
<li>绿色部分：网络部分，包括寻找rpc服务主机，发起rpc调用请求和响应rpc调用结果，使用muduo网络库和Zookeeper服务配置中心（专门做服务发现）。</li>
</ol>
</li>
</ul>
<p>protobuf相对于json的好处：</p>
<p>1、protobuf是二进制存储；xml和json都是文本存储</p>
<p>2、protobuf不需要存储额外的信息；json通过key-value存储数据</p>
<ul>
<li><p>json：name: “zhang san”, pwd: “123456”</p>
</li>
<li><p>protobuf: “zhangsan” “123456”</p>
</li>
</ul>
<h3 id="项目环境搭建"><a href="#项目环境搭建" class="headerlink" title="项目环境搭建"></a><strong>项目环境搭建</strong></h3><h4 id="文件组成"><a href="#文件组成" class="headerlink" title="文件组成"></a>文件组成</h4><ul>
<li>bin：可执行文件</li>
<li>build：项目编译文件</li>
<li>lib：项目库文件</li>
<li>src：源文件</li>
<li>test：测试代码</li>
<li>example：框架代码使用范例</li>
<li>CMakeLists.txt：顶层的</li>
<li>cmake文件</li>
<li>README.md：项目自述文件</li>
<li>autonbuild.sh：一键编译脚本</li>
</ul>
<h4 id="Ubuntu-protobuf环境搭建"><a href="#Ubuntu-protobuf环境搭建" class="headerlink" title="Ubuntu protobuf环境搭建"></a>Ubuntu protobuf环境搭建</h4><p>首先在GitHub下载源代码，源码包中src&#x2F;README.md有详细的安装说明，也可以按照如下步骤安装：</p>
<ol>
<li>解压压缩包：unzip protobuf-master.zip</li>
<li>进入解压后的文件夹：cd protobuf-master</li>
<li>安装所需工具：sudo apt-get install autoconf automake libtool curl make g++ unzip</li>
<li>自动生成configure配置文件：.&#x2F;autogen.sh</li>
<li>配置环境：.&#x2F;configure</li>
<li>编译源代码（时间比较长）：make</li>
<li>安装：sudo make install</li>
<li>刷新动态库：sudo ldconfig</li>
<li>测试：看能否正常执行protoc命令（直接去终端执行）</li>
</ol>
<p>源码下载地址：<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf">https://github.com/protocolbuffers/protobuf</a></p>
<h4 id="muduo库安装"><a href="#muduo库安装" class="headerlink" title="muduo库安装"></a>muduo库安装</h4><p>关于muduo库安装，强烈推荐按照施老师的步骤来（参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/QIANGWEIYUAN/article/details/89023980%EF%BC%89%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%B8%8D%E7%94%A8%E7%9C%8B%E6%88%91%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4%EF%BC%8C%E4%B8%8D%E5%AE%8C%E6%95%B4%EF%BC%81%EF%BC%81%EF%BC%81">https://blog.csdn.net/QIANGWEIYUAN/article/details/89023980），可以不用看我下面的安装步骤，不完整！！！</a></p>
<ol>
<li>安装依赖：sudo apt-get install libbost-dev libbost-test-dev sudo apt-get install libcurl4-openssl-dev libc-ares-dev</li>
<li>拉文件：git clone <a target="_blank" rel="noopener" href="https://github.com/chenshuo/muduo.git">https://github.com/chenshuo/muduo.git</a></li>
<li>.&#x2F;build.sh</li>
</ol>
<p>muduo库是否安装成功的测试：muduo_test.cpp实现了一个简单的echo server</p>
<p>编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++11 muduo_test.cpp -lmuduo_net -lmuduo_base -lpthread -o muduo_test</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<p>一个shell终端执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./muduo_test </span><br></pre></td></tr></table></figure>

<p>另一个shell终端执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 8032</span><br></pre></td></tr></table></figure>

<p>如下图所示则安装成功</p>
<p><img src="png4.png"></p>
<h4 id="创建文件（循序渐进，现在需要哪些文件夹就创建哪些）"><a href="#创建文件（循序渐进，现在需要哪些文件夹就创建哪些）" class="headerlink" title="创建文件（循序渐进，现在需要哪些文件夹就创建哪些）"></a>创建文件（循序渐进，现在需要哪些文件夹就创建哪些）</h4><p>首先，我们可以以自己的名字缩写作为后缀创建一个mprpc文件夹，比如我创建的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir mprpc_zcl</span><br></pre></td></tr></table></figure>

<p>接下来我们需要在mprpc_zcl文件夹里创建以下这些文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd mprpc_zcl</span><br><span class="line">mkdir bin</span><br><span class="line">mkdir build</span><br><span class="line">mkdir example</span><br><span class="line">mkdir lib</span><br><span class="line">mkdir src</span><br><span class="line">mkdir test</span><br><span class="line">touch autobuild.sh</span><br><span class="line">touch CMakeLists.txt</span><br></pre></td></tr></table></figure>

<p>好啦，第一件该做的事我们已经完成啦！</p>
<h4 id="protobuf实践讲解（一）"><a href="#protobuf实践讲解（一）" class="headerlink" title="protobuf实践讲解（一）"></a>protobuf实践讲解（一）</h4><p>首先我们写一个protobuf测试文件来了解一下protobuf的基本使用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在<span class="built_in">test</span>文件夹下创建protobuf文件夹，在protobuf文件夹里创建test.proto文件和main.cpp文件</span></span><br><span class="line">cd test/</span><br><span class="line">mkdir protobuf</span><br><span class="line">cd protobuf/</span><br><span class="line">touch main.cpp test.proto</span><br></pre></td></tr></table></figure>

<p>首先编写test.proto文件，必要的注释我会放在代码块里。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 声明protobuf版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug; <span class="comment">// 声明了代码所在的包（对于C++来说就是namespace）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">message就是消息类型，protobuf就是将我们封装好的数据类型进行序列化与反序列化。</span></span><br><span class="line"><span class="comment">定义登录消息类型：名字 + 密码</span></span><br><span class="line"><span class="comment">string name = 1; 1 代表第一个字段</span></span><br><span class="line"><span class="comment">注意，你的name等变量需要使用什么类型，string要指明。</span></span><br><span class="line"><span class="comment">这里的string是protobuf里的string类型，不是c++里的string类型</span></span><br><span class="line"><span class="comment">我们编译protobuf文件的时候需要使用这样的命令编译：protoc test.proto --cpp_out=./ （=后面是编译生成文件的输出路径）</span></span><br><span class="line"><span class="comment">编译后会生成一个LoginRequest类（这里仅拿LoginRequest举例），类有两个成员：string name 和 string pwd。</span></span><br><span class="line"><span class="comment">如果序列化成功，就把序列化的结果放在了send_str里面了，serializeToString是protobuf编译后人家已经帮我们写好的方法，我们直接用就好了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义登录请求消息类型 name pwd</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定于登录响应消息类型 错误码：errcode，错误消息：errmsg， 成功与否：success</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> errmsg = <span class="number">2</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，编写main.cpp进行测试</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// using namespace fixbug</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">protobuf是一个动态库，需要链接，所以整个编译命令为：g++ main.cpp test.pb.cc -lprotobuf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装了login请求对象的数据</span></span><br><span class="line">    fixbug::LoginRequest req;</span><br><span class="line">    req.<span class="built_in">set_name</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    req.<span class="built_in">set_pwd</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象数据序列化</span></span><br><span class="line">    std::string send_str;</span><br><span class="line">    <span class="keyword">if</span>(req.<span class="built_in">SerializeToString</span>(&amp;send_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; send_str.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从send_str反序列化一个login请求对象</span></span><br><span class="line">    fixbug::LoginRequest reqB;</span><br><span class="line">    <span class="keyword">if</span>(reqB.<span class="built_in">ParseFromString</span>(send_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; reqB.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; reqB.<span class="built_in">pwd</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="protobuf实践讲解（二）"><a href="#protobuf实践讲解（二）" class="headerlink" title="protobuf实践讲解（二）"></a>protobuf实践讲解（二）</h4><p>这一小节我们主要引入了两个新知识：</p>
<ul>
<li>在一个消息类型中定义另外一个消息类型</li>
<li>列表</li>
</ul>
<p>必要的注释我已经放在代码块里了，大家可以看看，有不对的地方请谅解并麻烦指出来。</p>
<p>首先是test.proto文件的更新版</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 声明protobuf版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug; <span class="comment">// 声明了代码所在的包（对于C++来说就是namespace）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">message就是消息类型，protobuf就是将我们封装好的数据类型进行序列化与反序列化。</span></span><br><span class="line"><span class="comment">定义登录消息类型：名字 + 密码</span></span><br><span class="line"><span class="comment">string name = 1; 1 代表第一个字段</span></span><br><span class="line"><span class="comment">注意，你的name等变量需要使用什么类型，string要指明。</span></span><br><span class="line"><span class="comment">这里的string是protobuf里的string类型，不是c++里的string类型</span></span><br><span class="line"><span class="comment">我们编译protobuf文件的时候需要使用这样的命令编译：protoc test.proto --cpp_out=./ （=后面是编译生成文件的输出路径）</span></span><br><span class="line"><span class="comment">编译后会生成一个LoginRequest类（这里仅拿LoginRequest举例），类有两个成员：string name 和 string pwd。</span></span><br><span class="line"><span class="comment">如果序列化成功，就把序列化的结果放在了send_str里面了，serializeToString是protobuf编译后人家已经帮我们写好的方法，我们直接用就好了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> errmsg = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义登录请求消息类型 name pwd</span></span><br><span class="line"><span class="comment">// 这里有一个点可以注意一下，一般把string定义成bytes，string也没错，但bytes效率更高</span></span><br><span class="line"><span class="comment">// 因为你定义成string，protobuf还是要转换成bytes</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定于登录响应消息类型 错误码：errcode，错误消息：errmsg， 成功与否：success</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：对于protobuf的消息类型里面定义的成员变量本身又是另外一个消息类型的话，</span></span><br><span class="line"><span class="comment">他都会提供一个mutable用于改变其成员</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在protobuf里还有一个常用的叫列表</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetFriendListsRequest</span>&#123;</span><br><span class="line">    <span class="type">uint32</span> userid = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32</span> age = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">enum </span><span class="title class_">Sex</span>&#123;</span><br><span class="line">        MAN = <span class="number">0</span>;</span><br><span class="line">        WOMAN = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Sex sex = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetFriendListsReponse</span>&#123;</span><br><span class="line">    <span class="comment">// 这里我们注意到，我们每次定义响应的时候好像都会定义errcode和errmsg字段</span></span><br><span class="line">    <span class="comment">// 所以我们决定将其封装起来（ResultCode），便于使用</span></span><br><span class="line">    <span class="comment">// int32 errcode = 1;</span></span><br><span class="line">    <span class="comment">// bytes errmsg = 2;</span></span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的肯定是一个列表，如何表示呢？</span></span><br><span class="line">    <span class="keyword">repeated</span> User friend_list = <span class="number">2</span>; <span class="comment">// 定义了一个列表类型</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>main.cpp更新版</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// using namespace fixbug</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">protobuf是一个动态库，需要链接，所以整个编译命令为：g++ main.cpp test.pb.cc -lprotobuf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装了login请求对象的数据</span></span><br><span class="line">    fixbug::LoginRequest req;</span><br><span class="line">    req.<span class="built_in">set_name</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    req.<span class="built_in">set_pwd</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象数据序列化</span></span><br><span class="line">    std::string send_str;</span><br><span class="line">    <span class="keyword">if</span>(req.<span class="built_in">SerializeToString</span>(&amp;send_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; send_str.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从send_str反序列化一个login请求对象</span></span><br><span class="line">    fixbug::LoginRequest reqB;</span><br><span class="line">    <span class="keyword">if</span>(reqB.<span class="built_in">ParseFromString</span>(send_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; reqB.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; reqB.<span class="built_in">pwd</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixbug::LoginResponse rsp;</span><br><span class="line">    fixbug::ResultCode *rc = rsp.<span class="built_in">mutable_result</span>();</span><br><span class="line">    rc-&gt;<span class="built_in">set_errcode</span>(<span class="number">1</span>);</span><br><span class="line">    rc-&gt;<span class="built_in">set_errmsg</span>(<span class="string">&quot;登陆处理失败了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::string recv_str;</span><br><span class="line">    <span class="keyword">if</span>(rsp.<span class="built_in">SerializeToString</span>(&amp;recv_str))&#123;</span><br><span class="line">        <span class="comment">// 好像设置的errcode并没有输出，暂时不知道为啥</span></span><br><span class="line">        std::cout &lt;&lt; recv_str.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixbug::GetFriendListsReponse rsp2;</span><br><span class="line">    fixbug::ResultCode *rc2 = rsp2.<span class="built_in">mutable_result</span>();</span><br><span class="line">    rc2-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fixbug::User *user1 = rsp2.<span class="built_in">add_friend_list</span>();</span><br><span class="line">    user1-&gt;<span class="built_in">set_name</span>(<span class="string">&quot;zhang san&quot;</span>);</span><br><span class="line">    user1-&gt;<span class="built_in">set_age</span>(<span class="number">20</span>);</span><br><span class="line">    user1-&gt;<span class="built_in">set_sex</span>(fixbug::User::MAN);</span><br><span class="line"></span><br><span class="line">    fixbug::User *user2 = rsp2.<span class="built_in">add_friend_list</span>();</span><br><span class="line">    user2-&gt;<span class="built_in">set_name</span>(<span class="string">&quot;li si&quot;</span>);</span><br><span class="line">    user2-&gt;<span class="built_in">set_age</span>(<span class="number">18</span>);</span><br><span class="line">    user2-&gt;<span class="built_in">set_sex</span>(fixbug::User::MAN);</span><br><span class="line"></span><br><span class="line">    std::string recv_str2;</span><br><span class="line">    <span class="keyword">if</span>(rsp2.<span class="built_in">SerializeToString</span>(&amp;recv_str2))&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; recv_str2.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string user_str;</span><br><span class="line">    <span class="keyword">if</span>(user1-&gt;<span class="built_in">SerializeToString</span>(&amp;user_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; user_str.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; rsp2.<span class="built_in">friend_list_size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="protobuf实践讲解（三）"><a href="#protobuf实践讲解（三）" class="headerlink" title="protobuf实践讲解（三）"></a>protobuf实践讲解（三）</h4><p>这一节我们主要讲了如何引入函数名。因为我们只传输参数给远程rpc服务器是肯定不够的，远程rpc服务器还需要知道我们需要调用哪种方法，因此我们需要使用service在远程rpc服务器上注册函数？（不知道这个理解对不对）同时，方便之后函数调用方传输函数名，里面有一个ServiceDescriptor类型的指针，用于访问方法的各个属性。代码更新如下，主要更新了test.proto文件，main文件没有更新。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 声明protobuf版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug; <span class="comment">// 声明了代码所在的包（对于C++来说就是namespace）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">message就是消息类型，protobuf就是将我们封装好的数据类型进行序列化与反序列化。</span></span><br><span class="line"><span class="comment">定义登录消息类型：名字 + 密码</span></span><br><span class="line"><span class="comment">string name = 1; 1 代表第一个字段</span></span><br><span class="line"><span class="comment">注意，你的name等变量需要使用什么类型，string要指明。</span></span><br><span class="line"><span class="comment">这里的string是protobuf里的string类型，不是c++里的string类型</span></span><br><span class="line"><span class="comment">我们编译protobuf文件的时候需要使用这样的命令编译：protoc test.proto --cpp_out=./ （=后面是编译生成文件的输出路径）</span></span><br><span class="line"><span class="comment">编译后会生成一个LoginRequest类（这里仅拿LoginRequest举例），类有两个成员：string name 和 string pwd。</span></span><br><span class="line"><span class="comment">如果序列化成功，就把序列化的结果放在了send_str里面了，serializeToString是protobuf编译后人家已经帮我们写好的方法，我们直接用就好了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> errmsg = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义登录请求消息类型 name pwd</span></span><br><span class="line"><span class="comment">// 这里有一个点可以注意一下，一般把string定义成bytes，string也没错，但bytes效率更高</span></span><br><span class="line"><span class="comment">// 因为你定义成string，protobuf还是要转换成bytes</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定于登录响应消息类型 错误码：errcode，错误消息：errmsg， 成功与否：success</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：对于protobuf的消息类型里面定义的成员变量本身又是另外一个消息类型的话，</span></span><br><span class="line"><span class="comment">他都会提供一个mutable用于改变其成员</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在protobuf里还有一个常用的叫列表</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetFriendListsRequest</span>&#123;</span><br><span class="line">    <span class="type">uint32</span> userid = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32</span> age = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">enum </span><span class="title class_">Sex</span>&#123;</span><br><span class="line">        MAN = <span class="number">0</span>;</span><br><span class="line">        WOMAN = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Sex sex = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetFriendListsReponse</span>&#123;</span><br><span class="line">    <span class="comment">// 这里我们注意到，我们每次定义响应的时候好像都会定义errcode和errmsg字段</span></span><br><span class="line">    <span class="comment">// 所以我们决定将其封装起来（ResultCode），便于使用</span></span><br><span class="line">    <span class="comment">// int32 errcode = 1;</span></span><br><span class="line">    <span class="comment">// bytes errmsg = 2;</span></span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的肯定是一个列表，如何表示呢？</span></span><br><span class="line">    <span class="keyword">repeated</span> User friend_list = <span class="number">2</span>; <span class="comment">// 定义了一个列表类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">我们在上面已经完成了参数和反回值传输，但我们仅将函数参数传过去，远程服务器并不知道我们要调用哪种方法啊！</span></span><br><span class="line"><span class="comment">protobuf没有rpc通信功能，只进行序列化与反序列化。但我们依旧要在protobuf里完成rpc方法类型的定义描述。</span></span><br><span class="line"><span class="comment">这就需要使用protobuf的service功能，注意此时需要加入option选项， option cc_generic_services = true; 表示生成service服务类和rpc方法描述</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 不管是message还是service，最后都会生成class类。注意message只生成一个，service会生成两个，一个class UserServiceRpc，一个class UserServiceRpc_stub</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserServiceRpc</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Login(LoginRequest) <span class="keyword">returns</span>(LoginResponse)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> GetFriendLists(GetFriendListsRequest) <span class="keyword">returns</span>(GetFriendListsReponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="本地服务如何发布成RPC服务（一）"><a href="#本地服务如何发布成RPC服务（一）" class="headerlink" title="本地服务如何发布成RPC服务（一）"></a>本地服务如何发布成RPC服务（一）</h4><p>这一块算是正式跨入项目第一步，我们通过业务出发，如果要实现我们所需要的具体需求应该怎么办，直接给出更新后的代码，必要的注释都在代码里</p>
<p>这里先给大家看一个本节之后的文件组成情况</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── autobuild.sh</span><br><span class="line">├── bin</span><br><span class="line">├── build</span><br><span class="line">├── example</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── callee</span><br><span class="line">│   │   ├── CMakeLists.txt</span><br><span class="line">│   │   └── userservice.cpp</span><br><span class="line">│   ├── caller</span><br><span class="line">│   ├── user.pb.cc</span><br><span class="line">│   ├── user.pb.h</span><br><span class="line">│   └── user.proto</span><br><span class="line">├── lib</span><br><span class="line">├── src</span><br><span class="line">└── test</span><br><span class="line">    └── protobuf</span><br><span class="line">        ├── a.out</span><br><span class="line">        ├── main.cpp</span><br><span class="line">        ├── test.pb.cc</span><br><span class="line">        ├── test.pb.h</span><br><span class="line">        └── test.proto</span><br><span class="line"></span><br><span class="line">9 directories, 13 files</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最上面的小点代表根目录：mprpc_zcl</span></span><br></pre></td></tr></table></figure>

<p>更新后的mprpc_zcl&#x2F;CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置cmake的最低版本和项目名称</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(mprpc_zcl)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目可执行文件输出的路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目库文件输出路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目编译头文件搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/example)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目库文件搜索路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># src里面放的是框架代码</span></span><br><span class="line"><span class="comment"># add_subdirectory(src)  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># example里面放的是rpc服务的使用者和消费者，业务代码</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(example)</span><br></pre></td></tr></table></figure>

<p>更新后的mprpc_zcl&#x2F;example&#x2F;user.proto</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> errmsg = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserServiceRpc</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Login_rpc(LoginRequest) <span class="keyword">returns</span>(LoginResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，编写完之后直接使用protoc user.proto --cpp_out=./编译</span></span><br></pre></td></tr></table></figure>

<p>更新后的mprpc_zcl&#x2F;example&#x2F;CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(callee)</span><br></pre></td></tr></table></figure>

<p>更新后的mprpc_zcl&#x2F;example&#x2F;callee&#x2F;userservice.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我个人觉得这个项目应该从这里开始讲解，我们现在本地有一个用户登录Login_Local方法（隶属于UserService类）。</span></span><br><span class="line"><span class="comment">我们自己在本地调用那肯定很方便，创建一个UserService类对象，直接调用Login_Local方法即可</span></span><br><span class="line"><span class="comment">可是，如果现在有另外一个进程或者另外一台机器想调用我们这个方法怎么办呢？所以我们就要结合谷歌protobuf提供给我们的工具了</span></span><br><span class="line"><span class="comment">这个文件写的就是rpc服务提供者文件，我们在别人想要调用这个本地方法之前需要做哪些基础工作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1、proto文件经过protobuf编译后生成了UserServiceRpc类</span></span><br><span class="line"><span class="comment">2、我们需要在userservice.cpp文件里对这个类里的方法进行重写</span></span><br><span class="line"><span class="comment">3、注意：message会变为类的成员，service会生成一个类，service里的内容会生成方法</span></span><br><span class="line"><span class="comment">4、现在的问题就是：我们重写过后，远方是怎么调用的呢？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Userservice</span> : <span class="keyword">public</span> fixbug::UserServiceRpc   <span class="comment">// 使用在rpc服务发布端（rpc服务提供者）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Login_local</span><span class="params">(std::string name, std::string pwd)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doing local service: Login&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; pwd:&quot;</span> &lt;&lt; pwd;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，作用过程是这样的，当远端将请求发送过来，先会被我们的rpc框架接受，我们rpc框架根据接收到的参数，函数名等数据</span></span><br><span class="line">    <span class="comment">// 匹配到了我们重写的这个函数，然后调用了这个函数。</span></span><br><span class="line">    <span class="comment">// 所以这一块不属于框架的代码，是我们要使用这个框架必须自己写的代码，实现自己需要的功能。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Login_rpc</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> ::fixbug::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::fixbug::LoginResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::google::protobuf::Closure* done)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 暂时还没写完</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新后的mprpc_zcl&#x2F;example&#x2F;callee&#x2F;CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(SRC_LIST userservice.cpp ../user.pb.cc)</span><br><span class="line"><span class="keyword">add_executable</span>(provider <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="本地服务如何发布成RPC服务（二）"><a href="#本地服务如何发布成RPC服务（二）" class="headerlink" title="本地服务如何发布成RPC服务（二）"></a>本地服务如何发布成RPC服务（二）</h4><p>这一节必要的注释我都放在了代码里，以及思考的过程，这一节只对userservice.cpp进行了更新</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我个人觉得这个项目应该从这里开始讲解，我们现在本地有一个用户登录Login_Local方法（隶属于UserService类）。</span></span><br><span class="line"><span class="comment">我们自己在本地调用那肯定很方便，创建一个UserService类对象，直接调用Login_Local方法即可</span></span><br><span class="line"><span class="comment">可是，如果现在有另外一个进程或者另外一台机器想调用我们这个方法怎么办呢？所以我们就要结合谷歌protobuf提供给我们的工具了</span></span><br><span class="line"><span class="comment">这个文件写的就是rpc服务提供者文件，我们在别人想要调用这个本地方法之前需要做哪些基础工作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1、proto文件经过protobuf编译后生成了UserServiceRpc类</span></span><br><span class="line"><span class="comment">2、我们需要在userservice.cpp文件里对这个类里的方法进行重写</span></span><br><span class="line"><span class="comment">3、注意：message会变为类的成员，service会生成一个类，service里的内容会生成方法</span></span><br><span class="line"><span class="comment">4、现在的问题就是：我们重写过后，远方是怎么调用的呢？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Userservice</span> : <span class="keyword">public</span> fixbug::UserServiceRpc   <span class="comment">// 使用在rpc服务发布端（rpc服务提供者）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Login_local</span><span class="params">(std::string name, std::string pwd)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doing local service: Login&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; pwd:&quot;</span> &lt;&lt; pwd;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，作用过程是这样的，当远端将请求发送过来，先会被我们的rpc框架接受，我们rpc框架根据接收到的参数，函数名等数据</span></span><br><span class="line">    <span class="comment">// 匹配到了我们重写的这个函数，然后调用了这个函数。</span></span><br><span class="line">    <span class="comment">// 所以这一块不属于框架的代码，是我们要使用这个框架必须自己写的代码，实现自己需要的功能。</span></span><br><span class="line">    <span class="comment">// 现在的问题是，我callee端收到了参数和函数名，怎么匹配的呢？</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Login_rpc</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> ::fixbug::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::fixbug::LoginResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::google::protobuf::Closure* done)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 框架给业务上报了请求参数LoginRequest，应用获取相应数据做本地业务</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string pwd = request-&gt;<span class="built_in">pwd</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做本地业务</span></span><br><span class="line">        <span class="type">bool</span> login_result = <span class="built_in">Login_local</span>(name, pwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把响应写入，包括错误码、错误消息、返回值。我们不需要管序列化与反序列化，这个是框架来做的</span></span><br><span class="line">        fixbug::ResultCode *code = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        code-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        code-&gt;<span class="built_in">set_errmsg</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(login_result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，我们可以跳进::google::protobuf::Closure类去看看，里面的run是纯虚函数，需要我们进行重新写，那么run应该实现什么功能呢？</span></span><br><span class="line">        <span class="comment">// 其实就是执行响应对象数据的序列化与网络发送</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    总结一下，初始准备步骤：</span></span><br><span class="line"><span class="comment">    写proto文件 ------》继承生成的类，重写类里的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Mprpc框架基础类设计"><a href="#Mprpc框架基础类设计" class="headerlink" title="Mprpc框架基础类设计"></a>Mprpc框架基础类设计</h4><p>这一节我们从服务发布方的需求出发，比如我需要发布一个rpc服务，我需要做什么？我们考虑思路是这样的：假设现在框架写好了，当远端将请求发送过来，先会被我们的rpc框架接受，我们rpc框架根据接收到的参数，函数名等数据。匹配到了我们重写的这个函数，然后调用了这个函数。所以这一块不属于框架的代码，是我们要使用这个框架必须自己写的代码，实现自己需要的功能。<strong>现在的问题是，我callee端收到了参数和函数名，怎么匹配的呢？</strong></p>
<p>我们现在做好了服务发布方的基础工作，我们现在需要思考一个问题：我怎么能让别人想用我们写的rpc框架呢？答案只有一个，就是越简单越好。</p>
<ol>
<li>先进行框架初始化操作</li>
<li>框架里提供了用于发布服务的类</li>
</ol>
<p>这一节更新的文件如下</p>
<p>新加入src&#x2F;include&#x2F;mprpcapplication.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责框架的初始化操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MprpcApplication</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> MprpcApplication &amp;<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">MprpcApplication</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>(<span class="type">const</span> MprpcApplication&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>(MprpcApplication&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新加入src&#x2F;include&#x2F;mprpcprovider.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架提供的专门服务发布rpc服务的网络对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个是框架提供给外部使用的，可以发布rpc方法的函数接口 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新加入src&#x2F;mprpcapplication.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcApplication::Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MprpcApplication &amp;<span class="title">MprpcApplication::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> MprpcApplication app;</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新加入src&#x2F;mprpcprovider.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新了example&#x2F;callee&#x2F;userservice.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我个人觉得这个项目应该从这里开始讲解，我们现在本地有一个用户登录Login_Local方法（隶属于UserService类）。</span></span><br><span class="line"><span class="comment">我们自己在本地调用那肯定很方便，创建一个UserService类对象，直接调用Login_Local方法即可</span></span><br><span class="line"><span class="comment">可是，如果现在有另外一个进程或者另外一台机器想调用我们这个方法怎么办呢？所以我们就要结合谷歌protobuf提供给我们的工具了</span></span><br><span class="line"><span class="comment">这个文件写的就是rpc服务提供者文件，我们在别人想要调用这个本地方法之前需要做哪些基础工作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1、proto文件经过protobuf编译后生成了UserServiceRpc类</span></span><br><span class="line"><span class="comment">2、我们需要在userservice.cpp文件里对这个类里的方法进行重写</span></span><br><span class="line"><span class="comment">3、注意：message会变为类的成员，service会生成一个类，service里的内容会生成方法</span></span><br><span class="line"><span class="comment">4、现在的问题就是：我们重写过后，远方是怎么调用的呢？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;/home/zcl/mprpc_zcl/src/include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;/home/zcl/mprpc_zcl/src/include/mprpcprovider.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> : <span class="keyword">public</span> fixbug::UserServiceRpc   <span class="comment">// 使用在rpc服务发布端（rpc服务提供者）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Login_local</span><span class="params">(std::string name, std::string pwd)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doing local service: Login&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; pwd:&quot;</span> &lt;&lt; pwd;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，作用过程是这样的，当远端将请求发送过来，先会被我们的rpc框架接受，我们rpc框架根据接收到的参数，函数名等数据</span></span><br><span class="line">    <span class="comment">// 匹配到了我们重写的这个函数，然后调用了这个函数。</span></span><br><span class="line">    <span class="comment">// 所以这一块不属于框架的代码，是我们要使用这个框架必须自己写的代码，实现自己需要的功能。</span></span><br><span class="line">    <span class="comment">// 现在的问题是，我callee端收到了参数和函数名，怎么匹配的呢？</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Login_rpc</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> ::fixbug::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::fixbug::LoginResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::google::protobuf::Closure* done)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 框架给业务上报了请求参数LoginRequest，应用获取相应数据做本地业务</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string pwd = request-&gt;<span class="built_in">pwd</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做本地业务</span></span><br><span class="line">        <span class="type">bool</span> login_result = <span class="built_in">Login_local</span>(name, pwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把响应写入，包括错误码、错误消息、返回值。我们不需要管序列化与反序列化，这个是框架来做的</span></span><br><span class="line">        fixbug::ResultCode *code = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        code-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        code-&gt;<span class="built_in">set_errmsg</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(login_result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，我们可以跳进::google::protobuf::Closure类去看看，里面的run是纯虚函数，需要我们进行重新写，那么run应该实现什么功能呢？</span></span><br><span class="line">        <span class="comment">// 其实就是执行响应对象数据的序列化与网络发送</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    总结一下，初始准备步骤：</span></span><br><span class="line"><span class="comment">    写proto文件 ------》继承生成的类，重写类里的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们现在做好了服务发布方的基础工作，我们现在需要思考一个问题：我怎么能让别人想用我们写的rpc框架呢？答案只有一个，就是越简单越好。</span></span><br><span class="line"><span class="comment">1、先进行框架初始化操作</span></span><br><span class="line"><span class="comment">2、框架里提供了用于发布服务的类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="comment">// argc和argv是写ip地址和端口号配置文件这些的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用框架的初始化操作</span></span><br><span class="line">    MprpcApplication::<span class="built_in">Init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// provider是一个rpc网络服务对象。把UserService对象发布到rpc节点上</span></span><br><span class="line">    <span class="comment">// 可能会有很多用户同时使用Rpcprovider，所以这一块必须做到高并发，使用muduo网络库</span></span><br><span class="line">    RpcProvider provider;</span><br><span class="line">    provider.<span class="built_in">NotifyService</span>(<span class="keyword">new</span> <span class="built_in">UserService</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个rpc服务发布节点, Run以后，进程进入阻塞状态，等待远程的rpc调用请求</span></span><br><span class="line">    provider.<span class="built_in">Run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Mprpc框架项目动态库编译"><a href="#Mprpc框架项目动态库编译" class="headerlink" title="Mprpc框架项目动态库编译"></a>Mprpc框架项目动态库编译</h4><p>在init的时候，我们希望用户的输入是这样的：.&#x2F;provider -i config.conf（config.conf是配置文件，自动读取网络服务器和配置中心的ip地址和端口号）。</p>
<p>这节涉及到一个函数：int getopt(int argc, char * const argv[], const char *optstring); 我先给出这个函数的详细解释，方便解读下面的代码</p>
<p>首先，让我们看看<code>getopt</code>函数：</p>
<p><code>getopt</code>函数用于解析命令行参数。其原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getopt</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[], <span class="type">const</span> <span class="type">char</span> *optstring)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>argc</code>和<code>argv</code>是从<code>main</code>函数传递过来的命令行参数数量和参数值。</li>
<li><code>optstring</code>是一个字符串，表示我们期望的选项。例如，如果我们期望一个<code>-i</code>选项，那么<code>optstring</code>就会是<code>&quot;i:&quot;</code>。冒号表示<code>-i</code>后面必须跟一个参数值。</li>
</ul>
<p>函数每次调用都会返回一个字符，这个字符表示被解析到的选项。如果选项后面跟有参数值（如<code>-i value</code>），那么这个值可以通过<code>optarg</code>全局变量获得。当所有选项都被解析完毕后，<code>getopt</code>返回-1。</p>
<p>现在，让我们回到你的代码片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;i:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>while</code>循环的目的是持续解析命令行参数，直到所有选项都被解析完毕。</p>
<ul>
<li><p><code>c = getopt(argc, argv, &quot;i:&quot;)</code>：这里，<code>getopt</code>被调用，并返回值赋给<code>c</code>。如果有<code>-i</code>选项，<code>c</code>会等于字符<code>&#39;i&#39;</code>。</p>
</li>
<li><p><code>c != -1</code>：这个条件检查<code>c</code>是否不等于-1。如果<code>c</code>等于-1，那么说明所有选项都已经被解析完毕，<code>while</code>循环结束。</p>
</li>
</ul>
<p>在<code>while</code>循环的内部，你可能会基于<code>c</code>的值做一些操作，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">        <span class="comment">// do something with optarg, which contains the value after -i</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// possibly handle other options</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">        <span class="comment">// handle unknown option</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简而言之，这个代码片段用<code>getopt</code>函数在命令行参数中寻找<code>-i</code>选项，并将找到的值存储在<code>optarg</code>中。</p>
<p>在使用 <code>getopt</code> 函数来解析命令行参数时，你可能会遇到几种特定的返回值。当你在 <code>optstring</code> 中指定了一个选项后跟冒号（如 “i:”），这意味着该选项需要一个参数。</p>
<p>对于 <code>getopt</code> 的返回值：</p>
<ul>
<li>如果一个选项被发现，并且它有一个关联的参数（例如 <code>-i &lt;value&gt;</code>），那么 <code>getopt</code> 返回该选项字符。</li>
<li>如果一个选项被发现，但它缺少一个关联的参数（例如仅仅 <code>-i</code> 而没有后续值），并且在 <code>optstring</code> 中该选项后面有一个冒号，那么 <code>getopt</code> 返回 <code>&#39;:&#39;</code>。</li>
<li>如果找到一个不在 <code>optstring</code> 中的选项，或者找到一个不应有参数但却有参数的选项，那么 <code>getopt</code> 返回 <code>&#39;?&#39;</code>。</li>
</ul>
<p>所以，<code>case &#39;:&#39;</code> 在 <code>switch</code> 语句中处理的是缺少参数的选项情况。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;i:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">            <span class="comment">// handle the -i option with its argument in optarg</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:  <span class="comment">// Missing option argument</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Option -%c requires an argument.\n&quot;</span>, optopt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:  <span class="comment">// Unknown option</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unknown option: -%c\n&quot;</span>, optopt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，如果用户只输入 <code>-i</code> 而没有提供参数，程序将输出 “Option -i requires an argument.”。</p>
<p>新加入src&#x2F;CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="keyword">add_library</span>(mprpc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)  <span class="comment"># 创建一个动态库，方便用户调用</span></span><br></pre></td></tr></table></figure>

<p>更新example&#x2F;callee&#x2F;CMakeLists</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(SRC_LIST userservice.cpp ../user.pb.cc)</span><br><span class="line"><span class="keyword">add_executable</span>(provider <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(provider mprpc protobuf)	<span class="comment"># 链接我们上面创建的mprpc动态库和protobuf库</span></span><br></pre></td></tr></table></figure>

<p>更新mprpcapplication.cpp文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showArgHelp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;format: command -i &lt;configfile&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcApplication::Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">showArgHelp</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    std::string config_file;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;i:&quot;</span>)) != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">                config_file = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;invalid args!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">showArgHelp</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);	<span class="comment">// 配置文件都没加载进来就不要break啦，直接退出运行吧</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;need config_file&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">showArgHelp</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始加载配置文件了 rpcserver_ip=  rpcserver_port=    zookeeper_ip=   zookeeper_port=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MprpcApplication &amp;<span class="title">MprpcApplication::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> MprpcApplication app;</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Mprpc配置文件的加载（一）"><a href="#Mprpc配置文件的加载（一）" class="headerlink" title="Mprpc配置文件的加载（一）"></a>Mprpc配置文件的加载（一）</h4><p>这一节我们主要讲的是如何加载配置文件，换句话说就是解析配置文件。首先我们规定了配置文件的标准格式，如下所示：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpc节点的ip地址</span></span><br><span class="line">rpcserverip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># rpc节点的port端口号</span></span><br><span class="line">rpcserverport = <span class="number">8000</span></span><br><span class="line"><span class="comment"># zk的IP地址</span></span><br><span class="line">zookeeperip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># zk的port端口号</span></span><br><span class="line">zookeeperport = <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p>这一节引入了MprpcConfig类，我们考虑两部分：解析配置文件 + 查询配置信息。一个自然而然要思考的问题就是如何查询配置信息呢？我们这里考虑的是通过一个map映射即通过键找值。具体如何操作看代码就能了解了。</p>
<p>新加入配置文件&#x2F;bin&#x2F;test.conf</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpc节点的ip地址</span></span><br><span class="line">rpcserverip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># rpc节点的port端口号</span></span><br><span class="line">rpcserverport = <span class="number">8000</span></span><br><span class="line"><span class="comment"># zk的IP地址</span></span><br><span class="line">zookeeperip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># zk的port端口号</span></span><br><span class="line">zookeeperport = <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p>新加入&#x2F;src&#x2F;include&#x2F;mprpcconfig.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MprpcConfig</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 负责解析加载配置文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *config_file)</span></span>;</span><br><span class="line">    <span class="comment">// 查询配置项信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 每解析到一组ip---port，就insert进m_configMap</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; m_configMap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新加入&#x2F;src&#x2F;mprpcconfig.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcconfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责解析加载配置文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcConfig::loadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *config_file)</span></span>&#123;</span><br><span class="line">    FILE *pf = <span class="built_in">fopen</span>(config_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(pf == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; config_file &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、注释 2、正确的配置项通过=判断 3、去掉开头多余的空格</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">feof</span>(pf))&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">fgets</span>(buf, <span class="number">512</span>, pf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串前面的空格</span></span><br><span class="line">        <span class="comment">// 转换成字符串便于后续操作，因为字符串里有很多函数</span></span><br><span class="line">        <span class="function">std::string <span class="title">src_buf</span><span class="params">(buf)</span></span>;</span><br><span class="line">        <span class="type">int</span> idx = src_buf.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// 说明字符串前面有空格</span></span><br><span class="line">            src_buf = src_buf.<span class="built_in">substr</span>(idx, src_buf.<span class="built_in">size</span>() - idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉字符串后面多余的空格</span></span><br><span class="line">        idx = src_buf.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx != <span class="number">-1</span>)&#123;</span><br><span class="line">            src_buf = src_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断#的注释</span></span><br><span class="line">        <span class="keyword">if</span>(src_buf[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || src_buf.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析配置项</span></span><br><span class="line">        idx = src_buf.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// 配置项不合法</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::string key;</span><br><span class="line">        std::string value;</span><br><span class="line">        key = src_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        value = src_buf.<span class="built_in">substr</span>(idx + <span class="number">1</span>, src_buf.<span class="built_in">size</span>() - idx);</span><br><span class="line">        m_configMap.<span class="built_in">insert</span>(&#123;key, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询配置项信息</span></span><br><span class="line"><span class="function">std::string <span class="title">MprpcConfig::load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_configMap.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(it == m_configMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新&#x2F;src&#x2F;include&#x2F;mprpcapplication.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责框架的初始化操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcconfig.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MprpcApplication</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> MprpcApplication &amp;<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> MprpcConfig m_config;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>(<span class="type">const</span> MprpcApplication&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>(MprpcApplication&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更新&#x2F;src&#x2F;mprpcapplication.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MprpcConfig MprpcApplication::m_config;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showArgHelp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;format: command -i &lt;configfile&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcApplication::Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">showArgHelp</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    std::string config_file;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;i:&quot;</span>)) != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">                config_file = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                <span class="built_in">showArgHelp</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">                <span class="built_in">showArgHelp</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始加载配置文件了 rpcserver_ip=  rpcserver_port=    zookeeper_ip=   zookeeper_port=</span></span><br><span class="line">    <span class="comment">// 这是我们规定的配置文件的标准格式，因为我们后面解析的配置文件也是这个格式</span></span><br><span class="line">    m_config.<span class="built_in">loadConfigFile</span>(config_file.<span class="built_in">c_str</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rpcserverip:&quot;</span> &lt;&lt; m_config.<span class="built_in">load</span>(<span class="string">&quot;reserverip&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rpcserverport:&quot;</span> &lt;&lt; m_config.<span class="built_in">load</span>(<span class="string">&quot;reserverport&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;zookeeperip:&quot;</span> &lt;&lt; m_config.<span class="built_in">load</span>(<span class="string">&quot;zookeeperip&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;zookeeperport:&quot;</span> &lt;&lt; m_config.<span class="built_in">load</span>(<span class="string">&quot;zookeeperport&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MprpcApplication &amp;<span class="title">MprpcApplication::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> MprpcApplication app;</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Mprpc配置文件的加载（二）"><a href="#Mprpc配置文件的加载（二）" class="headerlink" title="Mprpc配置文件的加载（二）"></a>Mprpc配置文件的加载（二）</h4><p>在上一节中好像忘记告诉大家如何编译测试代码了。不知道大家还记不记得我们的可执行文件都是放在bin目录里的，所以我们需要先进入bin目录，即cd bin&#x2F;。</p>
<p>然后为了我们就可以在终端执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./provider -i test.conf</span><br></pre></td></tr></table></figure>

<p>从这个编译命令就可以看出来我们为什么要把test.conf文件和provider都放在bin目录下，这样方便我们编译。然后你们可以测试一下上一节的代码，是有bug的！然后我们需要进行gdb调试，进行gdb调试的话，我们需要在最外层的CMakeLists.txt文件加一行这个代码</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE <span class="string">&quot;Debug&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>bug出现在了mprpcconfig.cpp文件里，你们自己调试一下哈，我下面给出更新后的本节所有代码</p>
<p>更新后的CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置cmake的最低版本和项目名称</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(mprpc_zcl)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb调试选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE <span class="string">&quot;Debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目可执行文件输出的路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目库文件输出路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目编译头文件搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/example)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目库文件搜索路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># src里面放的是框架代码</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># example里面放的是rpc服务的使用者和消费者，业务代码</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(example)</span><br></pre></td></tr></table></figure>

<p>更新后的&#x2F;src&#x2F;include&#x2F;mprpcconfig.h文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MprpcConfig</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 负责解析加载配置文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *config_file)</span></span>;</span><br><span class="line">    <span class="comment">// 查询配置项信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; m_configMap;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 去掉字符串前后的空格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Trim</span><span class="params">(std::string &amp;src_buf)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更新后的mprpcconfig.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcconfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责解析加载配置文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcConfig::loadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *config_file)</span></span>&#123;</span><br><span class="line">    FILE *pf = <span class="built_in">fopen</span>(config_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(pf == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; config_file &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、注释 2、正确的配置项通过=判断 3、去掉开头多余的空格</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">feof</span>(pf))&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">fgets</span>(buf, <span class="number">512</span>, pf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串前面的空格</span></span><br><span class="line">        <span class="comment">// 转换成字符串便于后续操作，因为字符串里有很多函数</span></span><br><span class="line">        <span class="function">std::string <span class="title">read_buf</span><span class="params">(buf)</span></span>;</span><br><span class="line">        <span class="built_in">Trim</span>(read_buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断#的注释</span></span><br><span class="line">        <span class="keyword">if</span>(read_buf[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || read_buf.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析配置项</span></span><br><span class="line">        <span class="type">int</span> idx = read_buf.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// 配置项不合法</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::string key;</span><br><span class="line">        std::string value;</span><br><span class="line">        key = read_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        <span class="built_in">Trim</span>(key);</span><br><span class="line">        <span class="type">int</span> endidx = read_buf.<span class="built_in">find</span>(<span class="string">&#x27;\n&#x27;</span>, idx);</span><br><span class="line">        value = read_buf.<span class="built_in">substr</span>(idx + <span class="number">1</span>, endidx - idx - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Trim</span>(value);</span><br><span class="line">        m_configMap.<span class="built_in">insert</span>(&#123;key, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询配置项信息</span></span><br><span class="line"><span class="function">std::string <span class="title">MprpcConfig::load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_configMap.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(it == m_configMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉字符串前后的空格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcConfig::Trim</span><span class="params">(std::string &amp;src_buf)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = src_buf.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(idx != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 说明字符串前面有空格</span></span><br><span class="line">        src_buf = src_buf.<span class="built_in">substr</span>(idx, src_buf.<span class="built_in">size</span>() - idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去掉字符串后面多余的空格</span></span><br><span class="line">    idx = src_buf.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(idx != <span class="number">-1</span>)&#123;</span><br><span class="line">        src_buf = src_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="开发RpcProvider的网络服务"><a href="#开发RpcProvider的网络服务" class="headerlink" title="开发RpcProvider的网络服务"></a>开发RpcProvider的网络服务</h4><p>是这样的，我们现在已经能够读取到配置文件里的信息了，包括哪些信息呢？还记得吗？来一起回顾一下：rpc服务的ip地址和port端口号，zookeeper的ip地址和port端口号。我们现在回到这个配置文件这里，我们从这个角度出发，我们读取配置文件就是为了获取rpc服务发布节点的ip地址和port端口号，我们是为了什么读取呢？是为了让客户端能够接入，能够调用我们发布的这个rpc服务方法。我们之前在mprpcapplication里说过，为了简便用户的操作，我们提供了一个RpcProvoder类来发布服务节点。所以，这节我们要做的就是通过muduo网络库让配置文件里的rpc服务节点运行起来，可以接收客户端的连接请求。Let‘s go！</p>
<p>新加入mprpcprovider.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架提供的专门服务发布rpc服务的网络对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个是框架提供给外部使用的，可以发布rpc方法的函数接口 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 组合了EventLoop</span></span><br><span class="line">    muduo::net::EventLoop m_eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的socket连接回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已建立连接用户的读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新加入mprpcprovider.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 你启动一个rpc网络服务节点，总要获取ip地址和port端口号吧</span></span><br><span class="line">    <span class="comment">// 所以这里是获取ip地址和port端口号</span></span><br><span class="line">    std::string ip = MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;m_eventLoop, address, <span class="string">&quot;RpcProvider&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 绑定连接回调和消息读写回调方法 分离了网络代码和业务代码</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">// 设置muduo库线程数量，自动分配I/O线程和工作线程</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    m_eventLoop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="RpcProvider发布服务方法（一）"><a href="#RpcProvider发布服务方法（一）" class="headerlink" title="RpcProvider发布服务方法（一）"></a>RpcProvider发布服务方法（一）</h4><p>我们想一下，我们发布的rpc服务节点运行起来阻塞着等待客户的请求连接。假设现在有一个客户端将函数及其参数全部传递过来了，框架应该怎么做匹配呢？框架怎么就能做到这个函数名就匹配这个函数呢？对，有人应该想到了，使用map。我现在的想法也是map。我们将服务与函数对应起来（回忆一下：proto文件里服务生成类，函数就是类成员函数），所以要先限定服务，在限定函数。所以我们使用map将服务函数对应起来就好了。</p>
<p>更新mprpcprovider.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架提供的专门服务发布rpc服务的网络对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个是框架提供给外部使用的，可以发布rpc方法的函数接口 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 组合了EventLoop</span></span><br><span class="line">    muduo::net::EventLoop m_eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// service服务类型信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ServiceInfo</span>&#123;</span><br><span class="line">        google::protobuf::Service *m_service; <span class="comment">// 保存服务对象</span></span><br><span class="line">        std::unordered_map&lt;std::string, <span class="type">const</span> google::protobuf::MethodDescriptor*&gt; m_methodMap; <span class="comment">// 保存服务方法</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::unordered_map&lt;std::string, ServiceInfo&gt; m_serviceMap;  <span class="comment">// 可不止一个服务类型哦，所以也要建立一个映射到不同服务的表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的socket连接回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已建立连接用户的读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更新mprpcprovider.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是框架提供给外部使用的，可以发布rpc方法的函数接口</span></span><br><span class="line"><span class="comment">这里有一个很重要的指针（protobuf提供给我们获取服务及函数的）：google::protobuf::ServiceDescriptor *pserviceDesc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line">    ServiceInfo service_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务对象的描述信息</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::ServiceDescriptor *pserviceDesc = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line">    <span class="comment">// 获取服务的名字</span></span><br><span class="line">    std::string service_name = pserviceDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">    <span class="comment">// 获取服务对象service的方法的数量</span></span><br><span class="line">    <span class="type">int</span> methodCnt = pserviceDesc-&gt;<span class="built_in">method_count</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;service_name: &quot;</span> &lt;&lt; service_name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; methodCnt; ++i)&#123;</span><br><span class="line">        <span class="comment">// 获取了服务对象指定下标的服务方法的描述（抽象描述）</span></span><br><span class="line">        <span class="type">const</span> google::protobuf::MethodDescriptor *pmethodDesc = pserviceDesc-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        std::string method_name = pmethodDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">        service_info.m_methodMap.<span class="built_in">insert</span>(&#123;method_name, pmethodDesc&#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    service_info.m_service = service;</span><br><span class="line">    m_serviceMap.<span class="built_in">insert</span>(&#123;service_name, service_info&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 你启动一个rpc网络服务节点，总要获取ip地址和port端口号吧</span></span><br><span class="line">    <span class="comment">// 所以这里是获取ip地址和port端口号</span></span><br><span class="line">    std::string ip = MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;m_eventLoop, address, <span class="string">&quot;RpcProvider&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 绑定连接回调和消息读写回调方法 分离了网络代码和业务代码</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">// 设置muduo库线程数量，自动分配I/O线程和工作线程</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    m_eventLoop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是要处理当rpc服务节点接收到来自客户端的已经序列化的请求该如何处理。首先，我们框架内部RpcProvider和RpcConsumer协商好之间通信用的protobuf数据类型，这样才方便序列化与反序列化。我们考虑将服务名+方法名作为头部字段，同时，为了防止后面的参数与下一次请求产生粘包问题，我们需要在头部字段里声明参数的大小。另外还有一个问题就是，我们如何分离出头部字段和参数字段呢？一个方法就是指明头部字段有多长。所以，我们的代码更新如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcheader.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是框架提供给外部使用的，可以发布rpc方法的函数接口</span></span><br><span class="line"><span class="comment">这里有一个很重要的指针（protobuf提供给我们获取服务及函数的）：google::protobuf::ServiceDescriptor *pserviceDesc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line">    ServiceInfo service_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务对象的描述信息</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::ServiceDescriptor *pserviceDesc = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line">    <span class="comment">// 获取服务的名字</span></span><br><span class="line">    std::string service_name = pserviceDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">    <span class="comment">// 获取服务对象service的方法的数量</span></span><br><span class="line">    <span class="type">int</span> methodCnt = pserviceDesc-&gt;<span class="built_in">method_count</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;service_name: &quot;</span> &lt;&lt; service_name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; methodCnt; ++i)&#123;</span><br><span class="line">        <span class="comment">// 获取了服务对象指定下标的服务方法的描述（抽象描述）</span></span><br><span class="line">        <span class="comment">// 注意，这里建立map表都是依据proto文件建立的！！！思考一下哦！</span></span><br><span class="line">        <span class="type">const</span> google::protobuf::MethodDescriptor *pmethodDesc = pserviceDesc-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        std::string method_name = pmethodDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">        service_info.m_methodMap.<span class="built_in">insert</span>(&#123;method_name, pmethodDesc&#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    service_info.m_service = service;</span><br><span class="line">    m_serviceMap.<span class="built_in">insert</span>(&#123;service_name, service_info&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 你启动一个rpc网络服务节点，总要获取ip地址和port端口号吧</span></span><br><span class="line">    <span class="comment">// 所以这里是获取ip地址和port端口号</span></span><br><span class="line">    std::string ip = MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;m_eventLoop, address, <span class="string">&quot;RpcProvider&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 绑定连接回调和消息读写回调方法 分离了网络代码和业务代码</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">// 设置muduo库线程数量，自动分配I/O线程和工作线程</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    m_eventLoop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!conn-&gt;<span class="built_in">connected</span>())&#123;</span><br><span class="line">        <span class="comment">// 和rpc client的连接断开了</span></span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在框架内部，RpcProvider和RpcConsumer协商好之间通信用的protobuf数据类型</span></span><br><span class="line"><span class="comment">service_name method_name args   定义proto的message类型，进行数据头的序列化与反序列化</span></span><br><span class="line"><span class="comment">                                service_name method_name args_size（args_size是为了防止粘包问题，指定参数长度）</span></span><br><span class="line"><span class="comment">16UserServiceLogin_rpc16zhang san123456</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">header_size + header_str + args_size + args_str</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr &amp;conn, muduo::net::Buffer *buffer, muduo::Timestamp)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 接收到来自客户端的请求</span></span><br><span class="line">    std::string recv_buf = buffer-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字符流中读取前四个字节的内容</span></span><br><span class="line">    <span class="type">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    recv_buf.<span class="built_in">copy</span>((<span class="type">char</span>*)&amp;header_size, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据header_size读取数据头的原始字符流，反序列化数据，得到rpc请求的详细信息</span></span><br><span class="line">    std::string rpc_header_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span>, header_size);</span><br><span class="line">    mprpc::RpcHeader rpcHeader;</span><br><span class="line">    std::string servcie_name;</span><br><span class="line">    std::string method_name;</span><br><span class="line">    <span class="type">uint32_t</span> args_size;</span><br><span class="line">    <span class="keyword">if</span>(rpcHeader.<span class="built_in">ParseFromString</span>(rpc_header_str))&#123;</span><br><span class="line">        servcie_name = rpcHeader.<span class="built_in">service_name</span>();</span><br><span class="line">        method_name = rpcHeader.<span class="built_in">method_name</span>();</span><br><span class="line">        args_size = rpcHeader.<span class="built_in">args_size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;rpc_header_str:&quot;</span> &lt;&lt; rpc_header_str &lt;&lt; <span class="string">&quot; parse error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取rpc方法参数的字符流数据</span></span><br><span class="line">    std::string args_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span> + header_size, args_size);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;header_size: &quot;</span> &lt;&lt; header_size &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rpc_header_str: &quot;</span> &lt;&lt; rpc_header_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;servcie_name: &quot;</span> &lt;&lt; servcie_name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;args_str: &quot;</span> &lt;&lt; args_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="RpcProvider响应回调实现"><a href="#RpcProvider响应回调实现" class="headerlink" title="RpcProvider响应回调实现"></a>RpcProvider响应回调实现</h4><p>回忆一下provider应该做的事，调用方法并返回response。所以这一节做的就是这个事情。注意request和response都是继承自google::protobuf::Message。</p>
<p>更新mprpcprovider.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架提供的专门服务发布rpc服务的网络对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个是框架提供给外部使用的，可以发布rpc方法的函数接口 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 组合了EventLoop</span></span><br><span class="line">    muduo::net::EventLoop m_eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// service服务类型信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ServiceInfo</span>&#123;</span><br><span class="line">        google::protobuf::Service *m_service; <span class="comment">// 保存服务对象</span></span><br><span class="line">        std::unordered_map&lt;std::string, <span class="type">const</span> google::protobuf::MethodDescriptor*&gt; m_methodMap; <span class="comment">// 保存服务方法</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::unordered_map&lt;std::string, ServiceInfo&gt; m_serviceMap;  <span class="comment">// 可不止一个服务类型哦，所以也要建立一个映射到不同服务的表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的socket连接回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已建立连接用户的读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Closure的回调操作，用于序列化rpc的响应和网络发送</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendRpcResponse</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, google::protobuf::Message*)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更新mprpcprovider.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcheader.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是框架提供给外部使用的，可以发布rpc方法的函数接口</span></span><br><span class="line"><span class="comment">这里有一个很重要的指针（protobuf提供给我们获取服务及函数的）：google::protobuf::ServiceDescriptor *pserviceDesc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line">    ServiceInfo service_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务对象的描述信息</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::ServiceDescriptor *pserviceDesc = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line">    <span class="comment">// 获取服务的名字</span></span><br><span class="line">    std::string service_name = pserviceDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">    <span class="comment">// 获取服务对象service的方法的数量</span></span><br><span class="line">    <span class="type">int</span> methodCnt = pserviceDesc-&gt;<span class="built_in">method_count</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;service_name: &quot;</span> &lt;&lt; service_name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; methodCnt; ++i)&#123;</span><br><span class="line">        <span class="comment">// 获取了服务对象指定下标的服务方法的描述（抽象描述）</span></span><br><span class="line">        <span class="comment">// 注意，这里建立map表都是依据proto文件建立的！！！思考一下哦！</span></span><br><span class="line">        <span class="type">const</span> google::protobuf::MethodDescriptor *pmethodDesc = pserviceDesc-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        std::string method_name = pmethodDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">        service_info.m_methodMap.<span class="built_in">insert</span>(&#123;method_name, pmethodDesc&#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    service_info.m_service = service;</span><br><span class="line">    m_serviceMap.<span class="built_in">insert</span>(&#123;service_name, service_info&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 你启动一个rpc网络服务节点，总要获取ip地址和port端口号吧</span></span><br><span class="line">    <span class="comment">// 所以这里是获取ip地址和port端口号</span></span><br><span class="line">    std::string ip = MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;m_eventLoop, address, <span class="string">&quot;RpcProvider&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 绑定连接回调和消息读写回调方法 分离了网络代码和业务代码</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">// 设置muduo库线程数量，自动分配I/O线程和工作线程</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    m_eventLoop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!conn-&gt;<span class="built_in">connected</span>())&#123;</span><br><span class="line">        <span class="comment">// 和rpc client的连接断开了</span></span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在框架内部，RpcProvider和RpcConsumer协商好之间通信用的protobuf数据类型</span></span><br><span class="line"><span class="comment">service_name method_name args   定义proto的message类型，进行数据头的序列化与反序列化</span></span><br><span class="line"><span class="comment">                                service_name method_name args_size（args_size是为了防止粘包问题，指定参数长度）</span></span><br><span class="line"><span class="comment">16UserServiceLogin_rpc16zhang san123456</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">header_size + header_str + args_size + args_str</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr &amp;conn, muduo::net::Buffer *buffer, muduo::Timestamp)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 接收到来自客户端的请求</span></span><br><span class="line">    std::string recv_buf = buffer-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字符流中读取前四个字节的内容</span></span><br><span class="line">    <span class="type">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    recv_buf.<span class="built_in">copy</span>((<span class="type">char</span>*)&amp;header_size, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据header_size读取数据头的原始字符流，反序列化数据，得到rpc请求的详细信息</span></span><br><span class="line">    std::string rpc_header_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span>, header_size);</span><br><span class="line">    mprpc::RpcHeader rpcHeader;</span><br><span class="line">    std::string servcie_name;</span><br><span class="line">    std::string method_name;</span><br><span class="line">    <span class="type">uint32_t</span> args_size;</span><br><span class="line">    <span class="keyword">if</span>(rpcHeader.<span class="built_in">ParseFromString</span>(rpc_header_str))&#123;</span><br><span class="line">        servcie_name = rpcHeader.<span class="built_in">service_name</span>();</span><br><span class="line">        method_name = rpcHeader.<span class="built_in">method_name</span>();</span><br><span class="line">        args_size = rpcHeader.<span class="built_in">args_size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;rpc_header_str:&quot;</span> &lt;&lt; rpc_header_str &lt;&lt; <span class="string">&quot; parse error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取rpc方法参数的字符流数据</span></span><br><span class="line">    std::string args_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span> + header_size, args_size);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;header_size: &quot;</span> &lt;&lt; header_size &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rpc_header_str: &quot;</span> &lt;&lt; rpc_header_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;servcie_name: &quot;</span> &lt;&lt; servcie_name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;args_str: &quot;</span> &lt;&lt; args_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取servcie对象和method对象</span></span><br><span class="line">    <span class="keyword">auto</span> it = m_serviceMap.<span class="built_in">find</span>(servcie_name);</span><br><span class="line">    <span class="keyword">if</span>(it == m_serviceMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; servcie_name &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> mit = it-&gt;second.m_methodMap.<span class="built_in">find</span>(method_name);</span><br><span class="line">    <span class="keyword">if</span>(mit == it-&gt;second.m_methodMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; servcie_name &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; method_name &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    google::protobuf::Service *service = it-&gt;second.m_service;  <span class="comment">// 获取seivice对象</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::MethodDescriptor *method = mit-&gt;second; <span class="comment">// 获取method对像</span></span><br><span class="line"></span><br><span class="line">    google::protobuf::Message *request = service-&gt;<span class="built_in">GetRequestPrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line">    <span class="keyword">if</span>(!request-&gt;<span class="built_in">ParseFromString</span>(args_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;request parse error, content:&quot;</span> &lt;&lt; args_str &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    google::protobuf::Message *response = service-&gt;<span class="built_in">GetResponsePrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给下面的method方法的调用，绑定一个Closure的回调函数</span></span><br><span class="line">    google::protobuf::Closure *done = google::protobuf::<span class="built_in">NewCallback</span>&lt;RpcProvider, <span class="type">const</span> muduo::net::TcpConnectionPtr &amp;, google::protobuf::Message *&gt;(<span class="keyword">this</span>, &amp;RpcProvider::SendRpcResponse, conn, response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在框架上根据远端rpc请求，调用当前rpc节点上发布的方法</span></span><br><span class="line">    service-&gt;<span class="built_in">CallMethod</span>(method, <span class="literal">nullptr</span>, request, response, done);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Closure的回调操作，用于序列化rpc的响应和网络发送</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::SendRpcResponse</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr &amp;conn, google::protobuf::Message *response)</span></span>&#123;</span><br><span class="line">    std::string response_str;</span><br><span class="line">    <span class="keyword">if</span>(response-&gt;<span class="built_in">SerializeToString</span>(&amp;response_str))&#123; <span class="comment">// response进行序列化</span></span><br><span class="line">        <span class="comment">// 序列化成功后，通过网络把rpc方法执行的结果发送回rpc的调用方</span></span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response_str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;serialize response_str error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    conn-&gt;<span class="built_in">shutdown</span>(); <span class="comment">// 模拟http的短连接服务，由provider主动断开连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="RpcController"><a href="#RpcController" class="headerlink" title="RpcController"></a>RpcController</h4><p>为什么需要这个呢？这里我们需要注意到一个问题，举个例子，在我们的callfriendservice.cpp文件中，当我们使用完stub调用函数GetFriendlist之后，就直接开始读取response了。但你有没有想过，如果在序列化、网络发送、反序列化、函数执行等过程中产生错误了呢？那我们根本就拿不到response或者说拿到的response是错误的。RpcController可以帮助我们记录一些rpc调用过程中的状态信息。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zcl0219.github.io/2023/06/08/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="GGBond">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="Doing the tough things sets winners apart from losers">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/06/08/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/" class="post-title-link" itemprop="url">UNIX环境高级编程第一章</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-06-08 03:01:19" itemprop="dateCreated datePublished" datetime="2023-06-08T03:01:19+08:00">2023-06-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zcl0219.github.io/2023/05/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="GGBond">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="Doing the tough things sets winners apart from losers">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">排序算法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-21 14:12:58" itemprop="dateCreated datePublished" datetime="2023-05-21T14:12:58+08:00">2023-05-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-16 01:42:21" itemprop="dateModified" datetime="2023-10-16T01:42:21+08:00">2023-10-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="tips：为什么快速排序算法把基准元素名称定义为pivot"><a href="#tips：为什么快速排序算法把基准元素名称定义为pivot" class="headerlink" title="tips：为什么快速排序算法把基准元素名称定义为pivot"></a>tips：为什么快速排序算法把基准元素名称定义为pivot</h5><p>在快速排序算法中，”<code>pivot</code>“（基准元素）是一个用来将数据集分割成两部分的元素。所有比基准元素小的元素都被放到它的左边，而所有比它大的元素都被放到它的右边。这就是为什么它被称为 “<code>pivot</code>“（枢轴），因为它在排序过程中起到了中心轴的作用，就像一个旋转门或者天平的支点那样。</p>
<p>在一次快速排序的分割操作中，我们从数组的一端开始，将所有比<code>pivot</code>小的元素放到左边，比<code>pivot</code>大的元素放到右边。这个过程称为分区操作（<code>partitioning</code>）。经过分区操作后，<code>pivot</code>元素会位于数组的某个位置，它左边的所有元素都不大于它，它右边的所有元素都不小于它，所以它就到了排序后应该在的位置。</p>
<p>然后我们可以递归地对<code>pivot</code>左边的元素和右边的元素分别进行快速排序，这样整个数组就会变得有序。</p>
<p>所以，<code>pivot</code>元素在快速排序中起到了关键的作用，它是算法的核心部分。</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>以下是一个C++的快速排序实现示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序的一次划分操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];   <span class="comment">// 选择最右边的元素作为基准元素</span></span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = low; j &lt;= high<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i+<span class="number">1</span>], arr[high]);</span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high);   <span class="comment">// 执行一次划分操作</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>);   <span class="comment">// 对左侧子数组递归执行快速排序</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high);  <span class="comment">// 对右侧子数组递归执行快速排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: \n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个程序中，<code>partition</code>函数是快速排序的核心，它实现了一次划分操作。我们首先选择一个基准元素（这里选择的是数组最右侧的元素），然后将所有比基准元素小的元素移动到数组的左侧，比基准元素大的元素移动到数组的右侧。</p>
<p><code>quickSort</code>函数是一个递归函数，它首先调用<code>partition</code>函数进行一次划分操作，然后对基准元素左侧和右侧的子数组分别递归调用<code>quickSort</code>函数进行排序。这个过程会一直递归下去，直到子数组的大小为1或0，此时子数组已经是有序的，递归结束。</p>
<h5 id="在实现代码时犯了一个小错误"><a href="#在实现代码时犯了一个小错误" class="headerlink" title="在实现代码时犯了一个小错误"></a>在实现代码时犯了一个小错误</h5><p>在<code>partition</code>函数实现时，最后一步的交换过程中，应该是<code>swap(arr[i+1], arr[high])</code>，而我第一次实现时写成了<code>swap(arr[i+1], pivot)</code>。为什么这样不行呢？貌似看起来是合理的，因为我们在一开始就有语句：<code>int pivot = arr[high];</code>但是恰巧问题就是出现在了这里，因为我们要交换的是<code>vector</code>容器里的元素，我们在实现<code>int pivot = arr[high];</code>这个语句时<code>pivot</code>只是拿到了<code>arr[high]</code>的值，因此我们并没有实际交换<code>arr[i+1]</code>和<code>arr[high]</code>，所以排序后的结果肯定是错的。（因此，定义成这样<code>int&amp; pivot = arr[high]</code>，就可以这样写：<code>swap(arr[i+1], pivot)</code>）</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序是一种基于堆的排序算法。它使用了一种叫做堆的数据结构。堆有两种类型：最大堆和最小堆。最大堆的特性是父节点的值大于或等于其所有子节点的值，最小堆的特性是父节点的值小于或等于其所有子节点的值。</p>
<p>堆排序的基本步骤如下：</p>
<ol>
<li>建立最大堆：将待排序序列构造成一个最大堆，这样就能保证整个序列的最大值就是堆顶的根节点。</li>
<li>交换数据：将根节点与最后一个元素交换位置，然后断开（排除）最后一个元素。</li>
<li>重建最大堆：通过调整使剩余元素重新构成最大堆。</li>
<li>重复步骤2~3，直到整个序列有序。</li>
</ol>
<p>这里挂一个讲堆排序很好的博客，一定要耐心阅读！<a href="%5B(92%E6%9D%A1%E6%B6%88%E6%81%AF">引用链接</a> 堆排序详细图解（通俗易懂）_右大臣的博客-CSDN博客](<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_51609435/article/details/122982075">https://blog.csdn.net/weixin_51609435/article/details/122982075</a>))</p>
<h5 id="堆排序c-实现"><a href="#堆排序c-实现" class="headerlink" title="堆排序c++实现"></a>堆排序c++实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> largest = i;   <span class="comment">//从largest往下开始建立大根堆，暂不考虑largset往上的数据</span></span><br><span class="line">	<span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">		largest = left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">		largest = right;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line">		<span class="built_in">heapify</span>(arr, n, largest);    </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">		<span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; arr = &#123; <span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	<span class="built_in">heapSort</span>(arr);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> a : arr) &#123;</span><br><span class="line">		cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="自己初步实现时没有彻底弄明白堆排序，所以有如下这个问题"><a href="#自己初步实现时没有彻底弄明白堆排序，所以有如下这个问题" class="headerlink" title="自己初步实现时没有彻底弄明白堆排序，所以有如下这个问题"></a>自己初步实现时没有彻底弄明白堆排序，所以有如下这个问题</h5><p>为什么第一次需要</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>而从<code>i=n-1</code>开始，就直接 <code>heapify(arr, i, 0); </code>就没有<code>i=n/2-1</code>的这个过程</p>
<p>这是因为我们在开始的时候是在创建最大堆。在创建最大堆的过程中，我们需要从最后一个非叶子节点（即 <code>n / 2 - 1</code>）开始，然后向前遍历到根节点（即 <code>0</code>），对每个节点进行下沉操作，确保其满足最大堆的性质。这是创建最大堆的过程。</p>
<p>然后，我们进入排序的步骤，每次将当前最大的元素（即堆顶元素）与当前堆的最后一个元素交换，然后断开最后一个元素（即排除最后一个元素，使堆的大小减小1），然后再将新的堆顶元素进行下沉操作，确保剩余元素还是一个最大堆。这个过程一直持续到整个堆的元素都被排除，即整个数组都被排序。</p>
<p>因此，在排序的过程中，我们不需要再从 <code>n / 2 - 1</code> 开始了，因为除了堆顶元素以外，其他元素都满足最大堆的性质，所以我们只需要将新的堆顶元素进行下沉操作即可，也就是 <code>heapify(arr, i, 0);</code>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zcl0219.github.io/2023/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="GGBond">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="Doing the tough things sets winners apart from losers">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1%E6%96%87/" class="post-title-link" itemprop="url">计算机网络八股文</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-19 14:52:49" itemprop="dateCreated datePublished" datetime="2023-05-19T14:52:49+08:00">2023-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-06-15 04:17:45" itemprop="dateModified" datetime="2023-06-15T04:17:45+08:00">2023-06-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1、HTTP常见的状态码</p>
<ul>
<li>1XX	提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</li>
<li>2XX    成功，报文已经成功收到并被正确处理；</li>
<li>3XX    重定向，资源位置发生变动，需要客户端重新发送请求；</li>
<li>4XX    客户端错误，请求报文有误，服务器无法处理；</li>
<li>5XX    服务器错误。服务器在处理请求时内部发生了错误；</li>
</ul>
<p>2、HTTP请求和响应的各自组成部分</p>
<p>HTTP通信协议由请求（Request）和响应（Response）两部分构成。每个请求和响应都由头部和主体组成，其中头部包含了各种元数据，而主体则包含了实际的内容（如果有的话）。</p>
<h5 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h5><p>HTTP请求包括以下字段：</p>
<ol>
<li><p><strong>请求行（Request Line）</strong>：请求行包括HTTP方法（比如GET、POST、PUT、DELETE等）、请求的URI、以及HTTP版本。</p>
</li>
<li><p><strong>请求头（Request Headers）</strong>：请求头包含了一系列的字段，每个字段都提供了一些关于请求的元数据。常见的请求头包括：</p>
<ul>
<li>Host: 请求的目标主机名和端口号。</li>
<li>User-Agent: 发起请求的用户代理的信息，通常包括浏览器类型、版本、操作系统等信息。</li>
<li>Accept: 客户端可以处理的MIME类型。</li>
<li>Accept-Language: 客户端接受的语言。</li>
<li>Accept-Encoding: 客户端接受的内容编码，比如gzip。</li>
<li>Cookie: 客户端存储的用于服务器识别的cookie。</li>
<li>Content-Type: 如果请求包含了主体，这个字段描述了主体的MIME类型。</li>
<li>Content-Length: 如果请求包含了主体，这个字段描述了主体的长度。</li>
</ul>
</li>
<li><p><strong>请求主体（Request Body）</strong>：不是所有的请求都包含主体。比如GET和HEAD请求就没有主体。但是POST和PUT请求通常会有主体，包含了要发送给服务器的数据。</p>
</li>
</ol>
<h5 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h5><p>HTTP响应包括以下字段：</p>
<ol>
<li><strong>状态行（Status Line）</strong>：状态行包括HTTP版本、状态码（比如200表示成功，404表示未找到等），以及状态描述。</li>
<li><strong>响应头（Response Headers）</strong>：响应头包含了一系列的字段，每个字段都提供了一些关于响应的元数据。常见的响应头包括：<ul>
<li>Server: 发送响应的服务器的信息。</li>
<li>Content-Type: 响应主体的MIME类型。</li>
<li>Content-Length: 响应主体的长度。</li>
<li>Content-Encoding: 响应主体的内容编码，比如gzip。</li>
<li>Set-Cookie: 服务器想要设置在客户端的cookie。</li>
<li>Last-Modified: 资源的最后修改日期。</li>
<li>ETag: 资源的版本标识。</li>
</ul>
</li>
<li><strong>响应主体（Response Body）</strong>：响应的主体包含了服务器返回的数据，比如HTML页面、图片、JSON数据等。</li>
</ol>
<p>3、完整的HTTP请求和响应展示</p>
<p>让我们来看一下一对典型的HTTP请求和响应。</p>
<h5 id="HTTP请求示例"><a href="#HTTP请求示例" class="headerlink" title="HTTP请求示例"></a>HTTP请求示例</h5><p>假设你在浏览器中访问 <code>http://www.example.com</code>，你的浏览器可能会发送如下的GET请求：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Language: en-US,en;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<h5 id="HTTP响应示例"><a href="#HTTP响应示例" class="headerlink" title="HTTP响应示例"></a>HTTP响应示例</h5><p>对于上述的请求，服务器可能会返回如下的响应：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">HTTP/1.1</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">Date:</span> <span class="string">Mon,</span> <span class="number">23</span> <span class="string">May</span> <span class="number">2023 22:38:34 </span><span class="string">GMT</span></span><br><span class="line"><span class="attr">Server:</span> <span class="string">Apache/2.4.1</span> <span class="string">(Unix)</span></span><br><span class="line"><span class="attr">Last-Modified:</span> <span class="string">Sat,</span> <span class="number">20</span> <span class="string">May</span> <span class="number">2023 18:56:51 </span><span class="string">GMT</span></span><br><span class="line"><span class="attr">ETag:</span> <span class="string">&quot;2dcd3-2c-54b5a5e68b177&quot;</span></span><br><span class="line"><span class="attr">Accept-Ranges:</span> <span class="string">bytes</span></span><br><span class="line"><span class="attr">Content-Length:</span> <span class="number">44</span></span><br><span class="line"><span class="attr">Vary:</span> <span class="string">Accept-Encoding</span></span><br><span class="line"><span class="attr">Content-Type:</span> <span class="string">text/html</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It</span> <span class="string">works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个响应表示请求成功（状态码是200），服务器返回了一个简单的HTML页面作为响应主体。响应头还包含了一些其他的信息，比如服务器类型（Apache），最后修改日期，内容长度，内容类型等。</p>
<p>希望这些示例可以帮助你更好地理解HTTP请求和响应！</p>
<p>4、TCP的KeepAlive和HTTP的Keep-Alive</p>
<p>TCP的KeepAlive和HTTP的Keep-Alive虽然名字类似，但实际上是两个不同级别的概念，分别在TCP和HTTP协议层级中起作用。</p>
<p><strong>TCP的KeepAlive</strong>：</p>
<p>TCP的KeepAlive是一个底层的、可选的机制，其目的是为了检测和维护处于空闲状态的TCP连接。一旦启用，如果在特定的时间间隔内（通常在数小时）没有任何数据在TCP连接上进行交换，那么发送方就会发送一个KeepAlive数据包到接收方，而无需传输任何应用级别的数据。接收方需要对这个数据包做出响应。如果发送方在一定时间内没有收到响应，它将重发KeepAlive数据包，一般会尝试多次。如果仍然没有收到响应，发送方将假设连接已经断开，并将其关闭。</p>
<p><strong>HTTP的Keep-Alive</strong>：</p>
<p>HTTP的Keep-Alive是在HTTP 1.1引入的，用来允许单一的TCP连接被多个HTTP请求&#x2F;响应共享，而不是每个请求&#x2F;响应都重新建立一个新的连接。这显著提高了网络通信的效率，因为建立和关闭TCP连接需要时间和资源。</p>
<p>在HTTP 1.0中，每个HTTP请求&#x2F;响应都需要一个新的TCP连接，这被称为非持久连接。而在HTTP 1.1中，默认启用了Keep-Alive，也就是说默认使用持久连接，除非明确指定”Connection: close”。</p>
<p>当使用HTTP Keep-Alive时，HTTP请求的头部会包含一个”Connection: keep-alive”字段，这告诉服务器客户端希望保持连接以便发送更多的请求。服务器的响应也会包含一个”Connection: keep-alive”字段，这表示服务器同意保持连接。</p>
<p>总的来说，这两个概念都关于连接的维护，但是工作在不同的层级。TCP的KeepAlive主要是为了检测和处理僵死连接，而HTTP的Keep-Alive则是为了提高效率，通过复用已存在的TCP连接来发送多个HTTP请求&#x2F;响应。</p>
<p><strong>队头阻塞</strong></p>
<p>这里涉及到一个小概念需要说一下：可以想象，当我们开启Keep-Alive时，我们无需像以前那样，先发送A请求，等待服务器回应，再发送B请求…..一直如此运作下去。我们可以发送A请求后，无需等待服务器响应，紧接着发送B请求。但是服务器还是按照顺序响应，先响应A请求，完成后再响应B请求。其实这里很明显感觉到会有问题，如果迟迟收不到A响应，后面的响应就更收不到了，就会造成所谓的<strong>队头阻塞</strong>问题。</p>
<p><strong>在使用HTTP长连接时，如果一个客户端完成了一个HTTP请求后不在发起请求，此时这个TCP连接一直占用不就会导致浪费资源吗？</strong></p>
<p>对没错，所以为了避免资源浪费的情况，web 服务软件一般都会提供 <code>keepalive_timeout</code> 参数，用来指定 HTTP 长连接的超时时间。</p>
<p>比如设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会<strong>启动一个定时器</strong>，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接。</strong></p>
<p><strong>传输层协议有哪些</strong></p>
<p><code>UDP</code>和<code>TCP</code>协议；</p>
<p><strong><code>TCP</code>协议的特点</strong></p>
<p>面向连接的：采用<code>TCP</code>协议通信的双方必须通过三次握手建立连接才能开始数据的读写。完成数据交换以后，通信双方都必须断开连接，以释放内核的资源。</p>
<p>面向字节流的：当用户消息通过<code>TCP</code>协议传输时，<code>TCP</code>模块先将这些消息放入<code>TCP</code>发送缓冲区，发送的时候消息可能会被操作系统分组成多个<code>TCP</code>报文。注意，当我们调用<code>send</code>函数的时候，消息并没有真正被发送出去，只是被拷贝到了操作系统内核协议栈中。何时被真正发送，取决于<strong>发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件</strong>。</p>
<p>可靠的：1、<code>TCP</code>采用发送应答机制，即<code>TCP</code>发送端发送每一个<code>TCP</code>报文段都要接收到对方的应答，才认为这个<code>TCP</code>报文段传输成功；2、<code>TCP</code>协议采用超时重传机制，发送端发送一个<code>TCP</code>报文段之后，开启定时器，如果在规定时间内没有接收到应答，则重传此<code>TCP</code>报文段；3、因为<code>TCP</code>报文段最终是以<code>IP</code>数据报发送的，<code>IP</code>数据报到达接受方的时候可能乱序、重复，TCP协议还会对接收到的TCP报文段重排、整理，再交付给应用层。</p>
<p><strong>描述TCP头部结构的大致组成部分</strong></p>
<p>16位源端口号、16位目标端口号、32位序号、32位确认号、4位头部长度、6位保留、6位标志位、16位窗口大小、16位校验和、16位紧急指针</p>
<p><strong>简述各部分作用</strong></p>
<p>源端口号代表的是是从发送端的哪一个端口发送出来的，目的端口号代表的是发送给接收端上层应用程序的哪一个端口。</p>
<p><code>TCP</code>报文段的序号值等于系统初始化的某个随机值<code>ISN</code>加上该报文段在字节流中的偏移（偏移值）。</p>
<p>确认号就是接收到的<code>TCP</code>报文段的序号值加1。</p>
<p>4位头部长度代表<code>TCP</code>报文段整个头部长度有多少个<code>32bit</code>字（四字节）。</p>
<p>6位标志位分别为：<code>URG</code>（紧急指针是否有效）、<code>ACK</code>（确认号）、<code>PSH</code>（接收端应立即从<code>TCP</code>接收缓冲区中读走数据）、<code>RST</code>（表示要求对方重新建立连接）、<code>SYN</code>（请求建立一个连接）、<code>FIN</code>（通知对方本端要关闭连接）。</p>
<p>16位窗口大小是流量控制的一个手段，他告诉对方本端的<code>TCP</code>接收缓冲区还能容纳多少字节的数据。</p>
<p>16位校验和由发送端填充，接收端采取<code>CRC</code>算法对接收到的<code>TCP</code>报文段验证。</p>
<p><strong>TCP连接的建立和关闭</strong></p>
<p>首先，通过数据展示一下三次握手：</p>
<p>发送端：<code>seq 12345 (SYN)</code>     ————-      接收端：<code>seq 56789 (SYN)</code>  <code>ack 12346</code>    ————-   发送端：<code>ack 56790</code></p>
<p>接下来是四次握手，假设发送端首先发出了断开连接请求</p>
<p>发：<code>seq 12346</code>, <code>ack 56790</code> <code>(FIN)</code> —— 收：<code>ack 12347</code> —— 收：<code>seq 56790</code>, <code>ack 12347</code> <code>(FIN)</code> ——- 发：<code>ack 56791</code>  </p>
<p>实际上，四次握手中的收的第一次确认报文段可以省略，因为下一次收的TCP报文段里包含了<code>ack</code>。其实第一个<code>ack</code>是否应该出现取决于<code>TCP</code>的延迟确认特性。</p>
<p><strong>TCP状态转移</strong></p>
<p>服务器处于被动等待客户连接，可以简单描述一下当有客户端请求连接时，该连接服务器端的状态变化为：</p>
<p><code>LISTEN</code> ————- <code>SYN RCVD</code> —————– <code>ESTABLISHED</code>.</p>
<p>当客户端主动关闭连接时，服务器端状态变化为：</p>
<p><code>CLOSE_WAIT</code> ————– <code>LAST_ACK</code>.</p>
<p>请求连接时，客户端状态变化为，考虑<code>connect</code>系统调用成功</p>
<p><code>SYN_SENT</code> ————- <code>ESTABLISHED</code></p>
<p>注意，<code>connect</code>系统调用失败有三个原因：</p>
<p>1、<code>connect</code>连接的目标端口不存在（未被任何线程监听）</p>
<p>2、<code>connect</code>试图连接的端口处在<code>TIME_WAIT</code>状态</p>
<p>3、没有收到服务器端的应答报文</p>
<p><code>connect</code>调用失败则返回<code>CLOSE</code>状态。</p>
<p>客户端请求关闭时，客户端状态变化为</p>
<p><code>FIN_WAIT_1</code> ———- <code>(FIN_WAIT_2)</code> ————– <code>TIME_WAIT</code></p>
<p><strong>TIME_WAIT状态好好看看书的3.4.2节，讲的很好</strong></p>
<p><strong>复位报文段</strong></p>
<p><strong>什么情况下接收端会回复复位报文段？</strong></p>
<p>1、发送端访问一个不存在的窗口。</p>
<p>2、发送端访问的服务器端的窗口仍处于<code>TIME_WAIT</code>状态。</p>
<p>3、半打开状态向连接发送数据，会收到复位报文段。</p>
<p><strong>收到复位报文段应该如何处理呢</strong></p>
<p>收到复位报文段的机器应该断开连接或者重新发起连接。</p>
<p><strong>半打开状态</strong></p>
<p>假设现在服务器端（或者客户端）关闭或者异常终止了连接，客户端（或者服务器端）并没有接收到结束报文段，依旧保持连接状态，就称为半打开连接状态。如果此时客户端（或者服务器端）向此连接发送数据，会收到一个复位报文段的回应报文。</p>
<p><strong>关于<code>MSS</code>的计算</strong></p>
<p>首先需要了解两个名词，一个是<code>MTU</code>（<code>MaxMaximum Transmission Unit</code>）是指网络传输中最大的数据包大小，<code>MSS</code>（<code>Maximum Segment Size</code>）是指<code>TCP</code>协议中数据段的最大大小。在<code>TCP</code>协议中，<code>MSS</code>是由<code>MTU</code>减去<code>IP</code>和<code>TCP</code>头部的长度得出的。</p>
<p><code>IP</code>头部的长度通常为20个字节，<code>TCP</code>头部的长度通常为20个字节，所以<code>MSS</code>的计算方法为：</p>
<p><code>MSS</code>&#x3D; <code>MTU</code> - <code>IP</code>头部长度 - <code>TCP</code>头部长度</p>
<p>因此，在<code>MTU</code>为16436字节的情况下，<code>MSS</code>的计算公式为：</p>
<p><code>MSS</code> &#x3D; 16436 - 20 - 20 &#x3D; 16396</p>
<p>其中，20是<code>IP</code>头部和<code>TCP</code>头部的长度之和，这是因为<code>IP</code>和<code>TCP</code>协议都需要使用头部来传递各种控制信息，如源地址、目标地址、端口号、序列号、确认号等。因此，在<code>TCP</code>协议中，<code>MSS</code>是<code>MTU</code>减去<code>IP</code>和<code>TCP</code>头部长度的结果。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zcl0219.github.io/2023/05/12/%E5%85%AB%E8%82%A1%E6%96%87C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="GGBond">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="Doing the tough things sets winners apart from losers">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/12/%E5%85%AB%E8%82%A1%E6%96%87C/" class="post-title-link" itemprop="url">八股文C++</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-12 03:03:13" itemprop="dateCreated datePublished" datetime="2023-05-12T03:03:13+08:00">2023-05-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-06-06 18:36:57" itemprop="dateModified" datetime="2023-06-06T18:36:57+08:00">2023-06-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="你知道c-三大特性吗？那你又是否清楚他们的特点呢？"><a href="#你知道c-三大特性吗？那你又是否清楚他们的特点呢？" class="headerlink" title="你知道c++三大特性吗？那你又是否清楚他们的特点呢？"></a>你知道c++三大特性吗？那你又是否清楚他们的特点呢？</h5><p>c++三大特性分别为：封装、继承和多态</p>
<p>封装：<br>1、三个特点</p>
<p>结合性，即将属性（数据成员）和行为（成员函数）相结合</p>
<p>信息隐蔽性，利用接口机制隐蔽内部实现细节，只留下接口给外界调用</p>
<p>实现代码重用，在此举个例子解释所谓的实现代码重用：</p>
<p>例如，如果你需要在程序的多个地方进行文件读写操作，你可以创建一个名为<code>FileHandler</code>的类，将文件的打开、关闭、读取和写入等操作封装在该类中的成员函数中。然后，你可以在程序的各个地方实例化<code>FileHandler</code>对象，并调用其成员函数来执行文件操作，而不需要每次都编写打开、关闭、读取和写入的代码。</p>
<p>这种方式可以大大简化程序的编写和维护，并且当你需要对文件操作的逻辑进行修改时，只需要修改<code>FileHandler</code>类中的代码，而不需要修改所有调用该类的地方。</p>
<p>继承：</p>
<p>类的派生就是指从已有类产生新类的过程，原有类称为基类或父类，产生的新类称为子类或派生类，子类继承基类后，可以创建子类对象调用基类的函数和变量等。</p>
<p>多态：</p>
<p>多态（Polymorphism）是面向对象编程中的一个重要概念，它允许使用基类类型的指针或引用来调用派生类对象的特定方法。C++中的多态性是通过虚函数（virtual function）和动态绑定（dynamic binding）实现的。</p>
<p>在C++中，要实现多态，需要满足以下条件：</p>
<ol>
<li>基类（父类）中声明一个虚函数。</li>
<li>派生类（子类）中重写（覆盖）这个虚函数，并使用关键字<code>override</code>进行标记。</li>
</ol>
<p>例如，考虑一个基类<code>Shape</code>和两个派生类<code>Circle</code>和<code>Rectangle</code>的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a shape.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shape1 = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    Shape* shape2 = <span class="keyword">new</span> <span class="built_in">Rectangle</span>();</span><br><span class="line"></span><br><span class="line">    shape1-&gt;<span class="built_in">draw</span>();  <span class="comment">// 调用派生类的方法：Drawing a circle.</span></span><br><span class="line">    shape2-&gt;<span class="built_in">draw</span>();  <span class="comment">// 调用派生类的方法：Drawing a rectangle.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，基类<code>Shape</code>声明了一个虚函数<code>draw()</code>，并且两个派生类<code>Circle</code>和<code>Rectangle</code>分别重写了这个函数。在<code>main()</code>函数中，我们创建了两个指向基类的指针<code>shape1</code>和<code>shape2</code>，分别指向派生类<code>Circle</code>和<code>Rectangle</code>的对象。然后，通过基类指针调用<code>draw()</code>函数，由于这个函数是虚函数，实际调用的是派生类的版本，即产生了多态行为。</p>
<p>通过多态，我们可以使用统一的接口来处理不同的对象，提高了代码的灵活性和可维护性。此外，通过将基类指针或引用传递给函数或方法，我们可以在运行时确定要调用的具体实现，而不是在编译时静态地确定。</p>
<p>需要注意的是，在基类中使用关键字<code>virtual</code>来声明虚函数是很重要的，而派生类中的重写函数则使用关键字<code>override</code>进行标记，以确保正确的绑定和多态行为。</p>
<h5 id="函数体内部声明一个string变量，未进行初始化，会进行默认初始化吗？"><a href="#函数体内部声明一个string变量，未进行初始化，会进行默认初始化吗？" class="headerlink" title="函数体内部声明一个string变量，未进行初始化，会进行默认初始化吗？"></a>函数体内部声明一个string变量，未进行初始化，会进行默认初始化吗？</h5><p>在c++中，如果你在函数体内部声明一个<code>std::string</code>变量而不进行初始化，该变量会被默认初始化。对于<code>std::string</code>，默认初始化意味着会创建一个空字符串。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    <span class="comment">// ..... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>s</code> 被默认初始化为一个空字符串。当你尝试打印 <code>s</code> 或者获取 <code>s.length()</code> 时，你会发现<code>s</code>是一个空字符串。</p>
<p>注意这与内置类型如<code>int</code>、<code>float</code>等不同，这些类型如果没有明确初始化，它们的值是未定义的。</p>
<h6 id="string属于内置类型吗？"><a href="#string属于内置类型吗？" class="headerlink" title="string属于内置类型吗？"></a><span style="color:black">string属于内置类型吗？</span></h6><p>是的，<code>string</code> 类型不属于内置类型。<code>std::string</code> 是 C++ 标准库中的一个类，它是对字符数组（C 风格字符串）的封装，提供了更加方便、安全的字符串操作功能。</p>
<p>内置类型（也称为基本类型或原始类型）是编程语言中预定义的、最基本的数据类型，例如 <code>int</code>、<code>float</code>、<code>double</code>、<code>char</code> 等。这些类型通常直接映射到计算机硬件上的表示，所以操作起来非常高效。</p>
<p>相比之下，<code>std::string</code> 是一个类，其对象由多个数据成员和成员函数组成，提供了对字符串的各种操作。虽然 <code>std::string</code> 不是内置类型，但它在 C++ 中被广泛使用，因为它提供了比 C 风格字符串更方便和安全的方式来处理字符串。</p>
<h5 id="pragma-once的作用和-ifndef一样么"><a href="#pragma-once的作用和-ifndef一样么" class="headerlink" title="#pragma once的作用和#ifndef一样么"></a><code>#pragma once</code>的作用和<code>#ifndef</code>一样么</h5><p>是的，<code>#pragma once</code> 和 <code>#ifndef</code>（加上对应的 <code>#define</code> 和 <code>#endif</code>）都用于防止头文件的重复包含。它们的作用相似，但实现方式有所不同。</p>
<ol>
<li><p><code>#pragma once</code>：<br><code>#pragma once</code> 是一种编译器指令，用于确保头文件只被包含一次。当编译器遇到 <code>#pragma once</code> 时，它会记录已经包含了该头文件，从而避免重复包含。这种方法简洁易懂，只需在头文件的开头添加一行代码。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// header.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 声明和定义</span></span><br></pre></td></tr></table></figure>

<p>请注意，<code>#pragma once</code> 不是 C++ 标准的一部分，但大多数现代编译器都支持它。</p>
</li>
<li><p><code>#ifndef</code>，<code>#define</code> 和 <code>#endif</code>：<br>这是一种被称为“包含保护”的技术，通过预处理器指令来防止头文件的重复包含。首先使用 <code>#ifndef</code> 检查一个特定的宏是否已定义，如果未定义，则使用 <code>#define</code> 定义宏，并将头文件的内容包含在 <code>#ifndef</code> 和 <code>#endif</code> 之间。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// header.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 声明和定义</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HEADER_H</span></span></span><br></pre></td></tr></table></figure>

<p>这种方法是 C++ 标准的一部分，因此具有更好的可移植性。</p>
</li>
</ol>
<p>总的来说，<code>#pragma once</code> 和 <code>#ifndef</code> 都可以防止头文件的重复包含，但实现方式不同。在实际项目中，你可以根据编译器支持和代码可移植性的需求来选择其中一种方法。</p>
<p>总结一下上面的：作用是一样的，关于<code>ifndef</code>的具体细节可以去看<code>C++ primer</code>第68页的有关介绍。</p>
<h5 id="C-分离式编译"><a href="#C-分离式编译" class="headerlink" title="C++分离式编译"></a>C++分离式编译</h5><p>举例一个简单情况：</p>
<p>我在<code>Chapter6.h</code>头文件中声明了<code>fact</code>函数，在<code>fact.cpp</code>文件中定义了<code>fact</code>函数，并在<code>factMain.cpp</code>文件中使用了<code>fact</code>函数，为什么在<code>factMain.cpp</code>文件中，只需要引入<code>Chapter6.h</code>头文件就可以调用到<code>fact</code>函数，<code>Chapter6.h</code>头文件里不是只有一个声明吗？</p>
<p>解答：</p>
<p><code>Chapter6.h</code> 头文件中只有 <code>fact</code> 函数的声明。然而，这就是在 C++ 中分离声明和定义的好处。你在头文件中声明函数（告诉编译器有一个名为 <code>fact</code> 的函数存在），然后在一个源文件（例如 <code>fact.cpp</code>）中定义该函数（提供函数的具体实现）。这样，其他源文件（例如 <code>factMain.cpp</code>）可以通过包含相应的头文件来获取函数的声明，从而能够调用该函数。</p>
<p>在编译阶段，编译器会分别编译 <code>fact.cpp</code> 和 <code>factMain.cpp</code>，并生成相应的对象文件（例如 <code>fact.o</code> 和 <code>factMain.o</code>）。在 <code>fact.cpp</code> 中定义的 <code>fact</code> 函数的具体实现会在 <code>fact.o</code> 中。</p>
<p>然后在链接阶段，链接器会把所有的对象文件连接在一起，形成一个可执行文件。链接器会解决所有未解决的符号引用，例如在 <code>factMain.o</code> 中对 <code>fact</code> 函数的调用。因为 <code>fact</code> 函数在 <code>fact.o</code> 中定义了，所以链接器能够找到它，并正确地设置引用。</p>
<p>因此，尽管 <code>Chapter6.h</code> 头文件中只有 <code>fact</code> 函数的声明，但只要 <code>fact</code> 函数在其他地方被定义，那么在 <code>factMain.cpp</code> 中就可以通过包含 <code>Chapter6.h</code> 来调用 <code>fact</code> 函数。</p>
<h5 id="为什么不可以同时用const和static修饰成员函数。详细解释一下"><a href="#为什么不可以同时用const和static修饰成员函数。详细解释一下" class="headerlink" title="为什么不可以同时用const和static修饰成员函数。详细解释一下"></a>为什么不可以同时用<code>const</code>和<code>static</code>修饰成员函数。详细解释一下</h5><p>在<code>C++</code>中，<code>const</code>和<code>static</code>都可以用于修饰成员函数，但它们有不同的含义，并且不能同时应用于同一个成员函数。下面我们来详细了解一下：</p>
<ol>
<li><p><code>const</code>成员函数：如果一个成员函数被声明为<code>const</code>，那么它就不能修改对象的任何非静态数据成员或者调用任何非<code>const</code>成员函数。在<code>const</code>成员函数中，关键字<code>const</code>是在参数列表之后声明的。<code>const</code>成员函数可以被任何类型的对象调用，无论是<code>const</code>还是非<code>const</code>对象。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nonConstMethod</span><span class="params">()</span> </span>&#123; <span class="comment">/* 可以修改对象的状态 */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">constMethod</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">/* 不能修改对象的状态 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>static</code> 成员函数：<code>static</code> 成员函数与类的对象无关，不需要对象就可以调用。它不能访问类的非静态成员（包括数据成员和成员函数），因为非静态成员都是与特定对象关联的，而 <code>static</code> 成员函数与任何对象都无关。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123; <span class="comment">/* 不能访问非静态成员 */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123; <span class="comment">/* 可以访问非静态成员 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这就是为什么不能同时用 <code>const</code> 和 <code>static</code> 修饰成员函数的原因：<code>const</code> 成员函数是基于对象的，它不能改变对象的状态，但可以访问对象的状态。而 <code>static</code> 成员函数是不基于对象的，它不能访问对象的状态。因此，<code>const</code> 和 <code>static</code> 在这里是冲突的，不能同时用于同一个成员函数。</p>
<h6 id="如果一个成员函数被声明为-const，那么它就不能修改对象的任何非静态数据成员或者调用任何非-const-成员函数。能举个例子吗？解释的更通俗一点"><a href="#如果一个成员函数被声明为-const，那么它就不能修改对象的任何非静态数据成员或者调用任何非-const-成员函数。能举个例子吗？解释的更通俗一点" class="headerlink" title="如果一个成员函数被声明为 const，那么它就不能修改对象的任何非静态数据成员或者调用任何非 const 成员函数。能举个例子吗？解释的更通俗一点"></a><span style="color:black">如果一个成员函数被声明为 const，那么它就不能修改对象的任何非静态数据成员或者调用任何非 const 成员函数。能举个例子吗？解释的更通俗一点</span></h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">data</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123; ++data; &#125;  <span class="comment">// 非const成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data; &#125;  <span class="comment">// const成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tryToModify</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        <span class="comment">// ++data;  // 这里将导致编译错误，因为不能在const成员函数中修改非静态数据成员</span></span><br><span class="line">        <span class="comment">// increment();  // 这里也将导致编译错误，因为不能在const成员函数中调用非const成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个类中，<code>increment()</code> 是一个非 <code>const</code> 成员函数，它可以修改对象的状态。<code>getValue()</code> 是一个 <code>const</code> 成员函数，它不能修改对象的状态，只能返回对象的状态。</p>
<p><code>tryToModify()</code> 也是一个 <code>const</code> 成员函数，试图在其中修改 <code>data</code> 或者调用 <code>increment()</code> 都会导致编译错误，因为这些操作都会改变对象的状态，而 <code>const</code> 成员函数不允许这样做。</p>
<p>通俗来说，<code>const</code> 成员函数就像一个诺言，它承诺我不会改变对象的状态。这样，你就可以放心地把对象传给这个函数，知道这个函数不会做任何坏事。这在编程中是非常有用的，因为它可以帮助你避免一些常见的错误，并使你的代码更容易理解和维护。</p>
<h6 id="static-成员函数与类的对象无关，不需要对象就可以调用。这句话怎么理解呢？不需要对象如何调用呢？直接传参吗？能举个例子吗"><a href="#static-成员函数与类的对象无关，不需要对象就可以调用。这句话怎么理解呢？不需要对象如何调用呢？直接传参吗？能举个例子吗" class="headerlink" title="static 成员函数与类的对象无关，不需要对象就可以调用。这句话怎么理解呢？不需要对象如何调用呢？直接传参吗？能举个例子吗"></a><span style="color:black">static 成员函数与类的对象无关，不需要对象就可以调用。这句话怎么理解呢？不需要对象如何调用呢？直接传参吗？能举个例子吗</span></h6><p><code>static</code> 成员函数是与类本身相关联的，而不是与类的特定实例（即对象）相关联。因此，你不需要创建一个类的实例就可以调用 <code>static</code> 成员函数。你可以直接使用类名和作用域解析运算符 <code>::</code> 来调用 <code>static</code> 成员函数。</p>
<p>下面是一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling static method&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass::<span class="built_in">staticMethod</span>();  <span class="comment">// 不需要创建MyClass的实例就可以调用staticMethod</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们没有创建 <code>MyClass</code> 的实例就直接调用了 <code>staticMethod</code>。这是因为 <code>staticMethod</code> 是一个 <code>static</code> 成员函数，它与类本身相关联，而不是与类的特定实例相关联。</p>
<p>注意，<code>static</code> 成员函数不能访问类的非 <code>static</code> 成员（包括数据成员和成员函数），因为非 <code>static</code> 成员都是与特定对象关联的，而 <code>static</code> 成员函数与任何对象都无关。这也是为什么 <code>static</code> 成员函数不能有 <code>this</code> 指针的原因。</p>
<h5 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h5><p>在用户未自定义拷贝构造函数的情况下，系统会调用默认的拷贝构造函数，系统默认的拷贝构造函数执行浅拷贝。当数据成员中没有指针时，浅拷贝是可行的。</p>
<p>但当数据成员中出现指针时，如果依旧使用默认的拷贝构造函数，就会出现调用两次析构函数，造成悬空指针问题。</p>
<p>深拷贝与浅拷贝的区别就在于深拷贝会在<strong>堆内存中另外申请空间来储存数据</strong>，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。</p>
<h5 id="问了一个很愚蠢的问题：我发现在定义一个类的时候，构造函数会对private里的类似于int，string和指针等类型显式或隐式的初始化，而一些函数只给出了声明，函数为什么不用给出定义？"><a href="#问了一个很愚蠢的问题：我发现在定义一个类的时候，构造函数会对private里的类似于int，string和指针等类型显式或隐式的初始化，而一些函数只给出了声明，函数为什么不用给出定义？" class="headerlink" title="问了一个很愚蠢的问题：我发现在定义一个类的时候，构造函数会对private里的类似于int，string和指针等类型显式或隐式的初始化，而一些函数只给出了声明，函数为什么不用给出定义？"></a>问了一个很愚蠢的问题：我发现在定义一个类的时候，构造函数会对private里的类似于int，string和指针等类型显式或隐式的初始化，而一些函数只给出了声明，函数为什么不用给出定义？</h5><p>在<code>C++</code>中，类的定义通常分为两部分：声明和定义。声明是告诉编译器某个东西（例如变量、函数、类等）的存在，而定义则提供了这个东西的实际实现或分配了它的内存。</p>
<p>在类的定义中，构造函数对数据成员进行初始化，这是构造函数的主要目的。对于简单类型如<code>int</code>、<code>string</code>或者指针，可以在构造函数中显式初始化，也可以使用默认的初始化（对于类类型，调用其默认构造函数；对于内置类型，如果它们是静态存储期的对象，则进行值初始化，即初始化为0，否则不进行初始化）。</p>
<p>对于成员函数，只需要在类定义中给出声明，这是因为我们通常希望将函数的定义（实现）放在类定义之外，例如在一个<code>.cpp</code>文件中。这样可以将接口（即类的声明）与实现（即函数的定义）分离，使代码更清晰，易于理解和维护。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a);  <span class="comment">// 构造函数声明</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;  <span class="comment">// 成员函数声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyClass.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> a) : <span class="built_in">data</span>(a) &#123;&#125;  <span class="comment">// 构造函数定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::foo</span><span class="params">()</span> </span>&#123;  <span class="comment">// 成员函数定义</span></span><br><span class="line">    std::cout &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，也可以直接在类定义中提供成员函数的定义。这通常在函数体很短，或者希望函数被内联（<code>inline</code>）时这样做：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a) : <span class="built_in">data</span>(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; data &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>foo</code>函数会自动被编译器视为内联函数，可以减少函数调用开销，但可能增加代码大小。</p>
<h4 id="数组不允许拷贝和赋值"><a href="#数组不允许拷贝和赋值" class="headerlink" title="数组不允许拷贝和赋值"></a>数组不允许拷贝和赋值</h4><p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> a2[] = a;	<span class="comment">//错误，不允许使用一个数组初始化另一个数组</span></span><br><span class="line">a2 = a;			<span class="comment">//错误，不能把一个数组直接赋值给另外一个数组</span></span><br></pre></td></tr></table></figure>



<h4 id="标准库函数begin-和end"><a href="#标准库函数begin-和end" class="headerlink" title="标准库函数begin()和end()"></a>标准库函数begin()和end()</h4><p>数组毕竟不是类类型，因此这两个函数不是成员函数，正确的使用形式是把数组作为他们的参数传入：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"><span class="type">int</span>* beg = <span class="built_in">begin</span>(ia);	<span class="comment">//指向ia首元素的指针</span></span><br><span class="line"><span class="type">int</span>* last = <span class="built_in">end</span>(ia);	<span class="comment">//指向ia尾元素的下一位置的指针</span></span><br></pre></td></tr></table></figure>





<h5 id="创建一个vector容器存放string类型的对象"><a href="#创建一个vector容器存放string类型的对象" class="headerlink" title="创建一个vector容器存放string类型的对象"></a>创建一个<code>vector</code>容器存放<code>string</code>类型的对象</h5><p>1、首先我们确定一下这个类要实现哪些功能，初步设计包括三个：</p>
<ul>
<li>实现<code>push_back</code>向容器尾后迭代器指定位置添加元素；</li>
<li>实现<code>size</code>获取容器中存放元素个数的功能；</li>
<li>实现<code>capacity</code>获取容器当前最大容量的功能；</li>
</ul>
<p>同时，可以想到以上三个要在<code>public</code>里实现，作为对外的接口。</p>
<p>2、要实现以上这些功能（拷贝控制函数那些后面再实现）需要哪些变量呢？</p>
<ul>
<li><p>在一开始，我们需要获得一个原始内存，在这里我们采用一个<code>allocator</code>来获得原始内存；</p>
</li>
<li><p>三个指针，分别指向<code>vector</code>容器的首元素、最后一个实际元素之后的位置、分配的内存末尾之后的位置；</p>
</li>
</ul>
<p>3、拷贝控制函数的实现需要哪些工具函数</p>
<p>为了方便各种拷贝控制函数的实现，我们需要实现一些工具函数。拿拷贝构造函数举例来说，我们需要对一个<code>vector</code>容器对象进行拷贝，在拷贝构造函数里直接调用工具函数肯定会使得整个代码结构更加清晰明朗。</p>
<ul>
<li><code>alloc_n_copy</code>：分配内存，并拷贝一个给定范围中的元素；</li>
<li><code>free</code>：销毁构造的元素并释放内存；</li>
<li><code>chk_n_alloc</code>：保证<code>StrVec</code>至少有容纳一个新元素的空间。如果没有空间添加新元素，<code>chk_n_alloc</code>会调用<code>reallocate</code>来分配更多内存；</li>
<li><code>reallocate</code>在内存用完时为<code>StrVec</code>分配新内存；</li>
</ul>
<h5 id="我决定先实现StrVec类的拷贝构造函数"><a href="#我决定先实现StrVec类的拷贝构造函数" class="headerlink" title="我决定先实现StrVec类的拷贝构造函数"></a>我决定先实现StrVec类的拷贝构造函数</h5><p>我们可以将拷贝构造函数设想为将一个vector容器里的所有string拷贝到另一个vector里面。可以简单思考一下，在实现拷贝构造函数时最先遇到的两个问题：</p>
<ul>
<li>既然我要拷贝到另外一个vector里面，那我要如何分配这个新vector的空间？</li>
<li>分配的新空间应该多大呢？</li>
</ul>
<p>在分配空间时我们需要使用到c++里的模板类allocator（后面我会给出有关介绍），</p>
<h4 id="返回类型-函数名-形参列表-const-函数体，请问这个const作用是什么"><a href="#返回类型-函数名-形参列表-const-函数体，请问这个const作用是什么" class="headerlink" title="返回类型+函数名+形参列表+const+函数体，请问这个const作用是什么"></a>返回类型+函数名+形参列表+<code>const</code>+函数体，请问这个<code>const</code>作用是什么</h4><p>在 <code>C++</code>中，函数后面的 <code>const</code> 关键字用于说明函数是一个常量成员函数。这意味着该函数不能修改它所在类的任何非静态成员变量的值。换句话说，常量成员函数不能修改对象的状态。</p>
<p>例如，考虑以下类定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        x = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>getValue()</code> 是一个常量成员函数，因为它后面有 <code>const</code> 关键字。这意味着 <code>getValue()</code> 函数不能修改 <code>MyClass</code> 对象的任何成员变量的值（在这个例子中是 <code>x</code>）。如果你尝试在 <code>getValue()</code> 函数中修改 <code>x</code> 的值，编译器会报错。</p>
<p>常量成员函数通常用于定义不应改变对象状态的操作。这有助于提高代码的安全性和易读性，因为读者可以明确知道哪些函数不会修改对象的状态。</p>
<p>另外，常量成员函数可以在常量对象上调用，非常量成员函数则不能。这使得你可以在需要保证对象不被修改的情况下，仍然可以调用其上的一些成员函数。</p>
<h5 id="常量成员函数可以在常量对象上调用，非常量成员函数则不能。这句话的意思是常量对象不能调用非常量成员函数？"><a href="#常量成员函数可以在常量对象上调用，非常量成员函数则不能。这句话的意思是常量对象不能调用非常量成员函数？" class="headerlink" title="常量成员函数可以在常量对象上调用，非常量成员函数则不能。这句话的意思是常量对象不能调用非常量成员函数？"></a>常量成员函数可以在常量对象上调用，非常量成员函数则不能。这句话的意思是常量对象不能调用非常量成员函数？</h5><p>常量对象（即被 <code>const</code> 修饰的对象）只能调用常量成员函数。这是因为常量对象一旦初始化，其值就不能再被改变。因此，为了保证常量对象的状态不被改变，编译器禁止在常量对象上调用可能会改变对象状态的非常量成员函数。</p>
<p>举一个例子，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;    <span class="comment">// 常量成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; x = val; &#125;   <span class="comment">// 非常量成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;   <span class="comment">// 声明一个常量对象</span></span><br><span class="line">    std::cout &lt;&lt; obj.<span class="built_in">getValue</span>() &lt;&lt; std::endl;  <span class="comment">// 合法，因为getValue是常量成员函数</span></span><br><span class="line">    obj.<span class="built_in">setValue</span>(<span class="number">20</span>);  <span class="comment">// 非法，编译错误。因为setValue是非常量成员函数，不能在常量对象上调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>obj</code> 是一个常量对象。尽管 <code>setValue()</code> 是 <code>MyClass</code> 的一个成员函数，但你不能在 <code>obj</code> 上调用它，因为 <code>setValue()</code> 可能会改变对象的状态，这违反了 <code>obj</code> 是常量的事实。但你可以在 <code>obj</code> 上调用 <code>getValue()</code>，因为它是一个常量成员函数，不会改变对象的状态。</p>
<p>总结：常量对象不能调用非常量成员函数，非常量对象可以调用常量成员函数。（<code>c++ primer p231</code>：引入<code>const</code>成员函数）</p>
<h4 id="封装定义"><a href="#封装定义" class="headerlink" title="封装定义"></a>封装定义</h4><p>封装是指保护类的成员不被随意访问的能力，通过把类的实现细节设置为<code>private</code>，我们就能完成类的封装，实现类的接口与实现分离。</p>
<p>封装的两个重要优点：</p>
<p>1、用户代码不会无意间破坏封装对象的状态；</p>
<p>2、被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码；</p>
<h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>类允许其他类或者函数访问它的非公有成员（私有成员），方法是将其他类或者函数定义成友元，使用关键字<code>friend</code></p>
<p>注意：</p>
<p>友元只能出现在类定义的内部，在类内出现的具体位置不受约束。友元不是类的成员，不受它所在区域访问控制级别的约束。</p>
<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>右值引用主要用来解决两个问题：</p>
<p>1、临时对象非必要的昂贵的拷贝操作</p>
<p>2、在模板函数中如何按照参数的实际类型进行转发</p>
<p>在<code>c++11</code>中所有的值必属于左值、将亡值和纯右值之一。</p>
<p>右值引用绑定了右值，让临时右值的生命周期延长了，可以利用这个特点做一些性能优化，即避免临时对象的拷贝构造和析构</p>
<p>右值引用类型既可能是左值也可能是右值，如<code>T&amp;&amp; t</code>，这里的t既可能是左值也可能是右值。如下所示</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; t)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>); <span class="comment">//t是右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>(x); <span class="comment">//t是左值</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qicosmos/p/4283455.html">贴一个超级详细的连接</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zcl0219.github.io/2023/05/11/echo%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="GGBond">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="Doing the tough things sets winners apart from losers">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/11/echo%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">echo服务器问题</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-05-11 02:49:20 / Modified: 03:24:54" itemprop="dateCreated datePublished" datetime="2023-05-11T02:49:20+08:00">2023-05-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 5000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_IP <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_nonblocking</span><span class="params">(<span class="type">int</span> sockfd)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(sockfd, F_GETFL);</span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(sockfd, F_SETFL, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> listen_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(listen_fd &gt;= <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;address, <span class="number">0</span>, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, SERVER_IP, &amp;address.sin_addr);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(listen_fd, (<span class="keyword">struct</span> sockaddr*)(&amp;address), <span class="built_in">sizeof</span>(address));</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> ret1 = <span class="built_in">listen</span>(listen_fd, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ret1 != <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">set_nonblocking</span>(listen_fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> epoll_fd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(epoll_fd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">    ev.data.fd = listen_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, listen_fd, &amp;ev) == <span class="number">-1</span>)&#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to add file descriptor to epoll&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(epoll_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[MAX_EVENTS];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> nfds = <span class="built_in">epoll_wait</span>(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(events[i].data.fd == listen_fd)&#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">                <span class="type">socklen_t</span> client_len = <span class="built_in">sizeof</span>(client);</span><br><span class="line">                <span class="type">int</span> sock_fd = <span class="built_in">accept</span>(listen_fd, (<span class="keyword">struct</span> sockaddr*)(&amp;client), &amp;client_len);</span><br><span class="line">                <span class="built_in">set_nonblocking</span>(sock_fd);</span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                ev.data.fd = sock_fd;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, sock_fd, &amp;ev) == <span class="number">-1</span>)&#123;</span><br><span class="line">                    std::cerr &lt;&lt; <span class="string">&quot;Failed to add client socket file descriptor to epoll&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> client_fd = events[i].data.fd;</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> recv_size;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>((recv_size = <span class="built_in">recv</span>(client_fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;服务端接收到的消息为：&quot;</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">                    <span class="built_in">send</span>(client_fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(recv_size == <span class="number">0</span> || (recv_size == <span class="number">-1</span> &amp;&amp; errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_DEL, client_fd, &amp;ev) == <span class="number">-1</span>)&#123;</span><br><span class="line">                        std::cerr &lt;&lt; <span class="string">&quot;Failed delete the client_fd&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">close</span>(client_fd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(listen_fd);</span><br><span class="line">    <span class="built_in">close</span>(epoll_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 5000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_IP <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 5</span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client_thread_function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> client_sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, SERVER_IP, &amp;serv_addr.sin_addr);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(client_sockfd, (<span class="keyword">struct</span> sockaddr*)(&amp;serv_addr), <span class="built_in">sizeof</span>(serv_addr)))&#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Connection failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(client_sockfd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="type">int</span> send_size = <span class="built_in">send</span>(client_sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(send_size &lt; <span class="number">0</span>) std::cerr &lt;&lt; <span class="string">&quot;Error sending data: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> recv_size = <span class="built_in">recv</span>(client_sockfd, buf, send_size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(recv_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error recving data: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(mtx);</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;客户端&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;接收信息为：&quot;</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(client_sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> thread_num = <span class="number">5</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; client_threads;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_num; ++i)&#123;</span><br><span class="line">        client_threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(client_thread_function));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t : client_threads)&#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="运行时问题及结果截图"><a href="#运行时问题及结果截图" class="headerlink" title="运行时问题及结果截图"></a>运行时问题及结果截图</h2><p>在服务端与客户端均运行起来时，会发现程序并不能完整运行完，可能运行三条&#x2F;一条&#x2F;直接卡住，一条没有等情况，截图如下：</p>
<p><img src="%E4%B8%80%E6%9D%A1echo.png" alt="0条echo，直接卡住不动"></p>
<p>如上图所示，就显示一条echo回声消息，服务端跟客户端就都卡在这不动了。</p>
<p><img src="%E4%B8%A4%E6%9D%A1echo.png" alt="0条echo，直接卡住不动"></p>
<h2 id="解决方案（我并不清楚怎么就解决了！）"><a href="#解决方案（我并不清楚怎么就解决了！）" class="headerlink" title="解决方案（我并不清楚怎么就解决了！）"></a>解决方案（我并不清楚怎么就解决了！）</h2><p>将ET边缘触发模式改为LT水平触发模式就OK了，但从ET结果来看，程序貌似阻塞住了，但哪里会产生阻塞呢？十分不理解？还是其他问题呢（并非阻塞）？</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://zcl0219.github.io/2023/04/27/%E7%AC%AC%E4%B8%89%E7%AF%87%E5%8D%9A%E5%AE%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="GGBond">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="Doing the tough things sets winners apart from losers">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/04/27/%E7%AC%AC%E4%B8%89%E7%AF%87%E5%8D%9A%E5%AE%A2/" class="post-title-link" itemprop="url">第三篇博客</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-04-27 23:38:05 / Modified: 23:43:40" itemprop="dateCreated datePublished" datetime="2023-04-27T23:38:05+08:00">2023-04-27</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="赋值运算符为什么必须定义为成员函数"><a href="#赋值运算符为什么必须定义为成员函数" class="headerlink" title="赋值运算符为什么必须定义为成员函数"></a>赋值运算符为什么必须定义为成员函数</h2><p>在C++中，赋值运算符（&#x3D;）通常需要被定义为类的成员函数，而不能是友元函数或非成员函数。这是因为以下几个原因：</p>
<ol>
<li><p>语法限制：在C++中，某些运算符（如赋值运算符、下标运算符、函数调用运算符等）只能作为成员函数来重载，而不能作为非成员函数。这是C++语言本身的规定，设计者这样规定是为了让这些运算符的行为更接近其内建类型的原生行为。</p>
</li>
<li><p>保持语义一致性：赋值运算符用于将一个对象的值赋给另一个对象。将赋值运算符定义为成员函数，有助于保持与内建类型的赋值操作一致的语义。此外，成员函数可以访问类的私有成员，这使得赋值操作可以在内部完成，而无需暴露类的实现细节。</p>
</li>
<li><p>自动处理自赋值情况：当赋值运算符被定义为成员函数时，如果发生自赋值（如a &#x3D; a），编译器可以更容易地识别这种情况并进行优化。如果将赋值运算符定义为非成员函数，处理自赋值情况可能会更加困难。</p>
</li>
<li><p>提供默认赋值运算符：如果在类中没有显式地定义赋值运算符，编译器会自动生成一个默认的赋值运算符。这个默认的赋值运算符会执行逐成员（逐个数据成员）的赋值操作。默认的赋值运算符是一个成员函数，可以满足大多数场景的需求。如果你需要自定义赋值运算符，定义成员函数是最直接的方式。</p>
</li>
</ol>
<p>总之，将赋值运算符定义为成员函数，有助于保持与内建类型的赋值操作一致的语义，简化自赋值情况的处理，并允许访问类的私有成员。这些原因使得赋值运算符作为成员函数更加合适。</p>
<h2 id="给出定义成成员函数和非成员函数的例子，以及如果是编译器自动生成的，默认赋值是怎么赋值的，都给出例子"><a href="#给出定义成成员函数和非成员函数的例子，以及如果是编译器自动生成的，默认赋值是怎么赋值的，都给出例子" class="headerlink" title="给出定义成成员函数和非成员函数的例子，以及如果是编译器自动生成的，默认赋值是怎么赋值的，都给出例子"></a>给出定义成成员函数和非成员函数的例子，以及如果是编译器自动生成的，默认赋值是怎么赋值的，都给出例子</h2><p>首先，我们给出一个成员函数和非成员函数的简单示例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">memberFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nonMemberFunction</span><span class="params">(MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    obj.x = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成员函数</span></span><br><span class="line">    obj.<span class="built_in">memberFunction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用非成员函数</span></span><br><span class="line">    <span class="built_in">nonMemberFunction</span>(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了如何使用成员函数和非成员函数来操作类的公共数据成员。请注意，这个示例没有涉及运算符重载，只是展示了成员函数和非成员函数的基本概念。</p>
<p>接下来，我们讨论编译器自动生成的默认赋值运算符。当你没有为类显式定义赋值运算符时，编译器会生成一个默认的赋值运算符。默认赋值运算符会执行逐成员赋值，即逐个拷贝源对象的数据成员到目标对象。这里有一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point p1;</span><br><span class="line">    p1.x = <span class="number">3</span>;</span><br><span class="line">    p1.y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    Point p2;</span><br><span class="line">    p2.x = <span class="number">0</span>;</span><br><span class="line">    p2.y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用编译器生成的默认赋值运算符</span></span><br><span class="line">    p2 = p1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果：3, 4</span></span><br><span class="line">    std::cout &lt;&lt; p2.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p2.y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们没有为<code>Point</code>类显式定义赋值运算符。然而，当我们执行<code>p2 = p1</code>时，编译器生成的默认赋值运算符会被调用。默认赋值运算符会将<code>p1</code>的数据成员逐个拷贝到<code>p2</code>，所以在赋值操作之后，<code>p2.x</code>和<code>p2.y</code>分别是3和4。</p>
<h2 id="如果把MyClass类里的x定义成private，那么非成员函数传入的obj的x还能被赋值吗，你能详细展开讲讲这些问题吗"><a href="#如果把MyClass类里的x定义成private，那么非成员函数传入的obj的x还能被赋值吗，你能详细展开讲讲这些问题吗" class="headerlink" title="如果把MyClass类里的x定义成private，那么非成员函数传入的obj的x还能被赋值吗，你能详细展开讲讲这些问题吗"></a>如果把MyClass类里的x定义成private，那么非成员函数传入的obj的x还能被赋值吗，你能详细展开讲讲这些问题吗</h2><p>如果将<code>MyClass</code>类中的数据成员<code>x</code>定义为<code>private</code>，则非成员函数将无法直接访问和修改它。以下是修改后的类定义和示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">memberFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个访问x的接口</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个修改x的接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> newX)</span> </span>&#123;</span><br><span class="line">        x = newX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nonMemberFunction</span><span class="params">(MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// obj.x = 42; // 错误！无法访问私有成员</span></span><br><span class="line">    obj.<span class="built_in">setX</span>(<span class="number">42</span>); <span class="comment">// 使用公共接口修改x</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成员函数</span></span><br><span class="line">    obj.<span class="built_in">memberFunction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用非成员函数</span></span><br><span class="line">    <span class="built_in">nonMemberFunction</span>(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>x</code>现在是私有成员，我们不能在类外部直接访问它。这种情况下，我们需要为<code>MyClass</code>提供公共接口（如<code>getX()</code>和<code>setX()</code>），以便在类外部获取和修改<code>x</code>的值。在这个示例中，我们在<code>nonMemberFunction()</code>中使用了<code>setX()</code>方法来修改<code>x</code>的值，而不是直接访问私有成员。</p>
<p>私有成员的主要目的是封装和隐藏类的实现细节。这样，你可以更自由地修改类的内部实现，而不影响使用该类的代码。通过将数据成员设置为私有并提供公共接口，你可以控制类外部对数据成员的访问和修改，从而确保类的正确使用和数据的完整性。</p>
<h3 id="x2F-obj-x-x3D-42-x2F-x2F-错误！无法访问私有成员-obj-setX-42-x2F-x2F-使用公共接口修改x-这个意思是：虽然不能直接对x进行修改，但obj仍然有x这个属性，那么obj的x属性值是多少呢？obj不是拥有它吗？我的理解有误吗"><a href="#x2F-obj-x-x3D-42-x2F-x2F-错误！无法访问私有成员-obj-setX-42-x2F-x2F-使用公共接口修改x-这个意思是：虽然不能直接对x进行修改，但obj仍然有x这个属性，那么obj的x属性值是多少呢？obj不是拥有它吗？我的理解有误吗" class="headerlink" title="&#x2F; obj.x &#x3D; 42; &#x2F;&#x2F; 错误！无法访问私有成员    obj.setX(42); &#x2F;&#x2F; 使用公共接口修改x 这个意思是：虽然不能直接对x进行修改，但obj仍然有x这个属性，那么obj的x属性值是多少呢？obj不是拥有它吗？我的理解有误吗"></a>&#x2F; obj.x &#x3D; 42; &#x2F;&#x2F; 错误！无法访问私有成员    obj.setX(42); &#x2F;&#x2F; 使用公共接口修改x 这个意思是：虽然不能直接对x进行修改，但obj仍然有x这个属性，那么obj的x属性值是多少呢？obj不是拥有它吗？我的理解有误吗</h3><p>是的，你的理解是正确的。<code>MyClass</code>对象<code>obj</code>仍然具有数据成员<code>x</code>，但是由于<code>x</code>是私有的，所以在类的外部不能直接访问或修改它。这就是封装的概念。尽管<code>x</code>是私有的，但它仍然是<code>MyClass</code>对象的一部分。这意味着当你创建一个<code>MyClass</code>对象时，<code>x</code>也会作为对象的一部分被创建。</p>
<p>在上述示例中，当我们创建<code>MyClass</code>对象<code>obj</code>时，<code>x</code>的初始值是未定义的（因为我们没有为<code>x</code>提供初始值）。在调用<code>obj.memberFunction()</code>后，<code>x</code>的值被设置为42。然后，当我们调用<code>nonMemberFunction(obj)</code>时，我们不能直接访问<code>x</code>，但可以通过公共接口<code>setX()</code>来修改<code>x</code>的值。这里，我们再次将<code>x</code>的值设置为42。</p>
<p>所以，在<code>nonMemberFunction()</code>执行之后，<code>obj</code>的<code>x</code>属性值仍然是42。虽然我们不能直接访问<code>x</code>，但通过公共接口<code>getX()</code>，我们可以获取<code>x</code>的值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;obj.x = &quot;</span> &lt;&lt; obj.<span class="built_in">getX</span>() &lt;&lt; std::endl; <span class="comment">// 输出：obj.x = 42</span></span><br></pre></td></tr></table></figure>

<p>总之，<code>obj</code>确实拥有私有成员<code>x</code>，但在类的外部不能直接访问或修改它。为了在类外部操作<code>x</code>，我们需要使用类提供的公共接口。</p>
<h2 id="此外，成员函数可以访问类的私有成员，这使得赋值操作可以在内部完成，而无需暴露类的实现细节。如果不是成员函数就会暴露细节吗？给个例子"><a href="#此外，成员函数可以访问类的私有成员，这使得赋值操作可以在内部完成，而无需暴露类的实现细节。如果不是成员函数就会暴露细节吗？给个例子" class="headerlink" title="此外，成员函数可以访问类的私有成员，这使得赋值操作可以在内部完成，而无需暴露类的实现细节。如果不是成员函数就会暴露细节吗？给个例子"></a>此外，成员函数可以访问类的私有成员，这使得赋值操作可以在内部完成，而无需暴露类的实现细节。如果不是成员函数就会暴露细节吗？给个例子</h2><p>当赋值操作涉及类的私有成员时，使用成员函数可以确保不会暴露类的实现细节。如果尝试使用非成员函数来实现赋值操作，我们需要提供访问私有成员的接口，这可能会破坏封装。让我们用一个例子来说明这个问题。</p>
<p>首先，考虑以下<code>MyClass</code>定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> initialX) : <span class="built_in">x</span>(initialX) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员赋值运算符</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x = other.x; <span class="comment">// 可以直接访问私有成员</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了一个成员赋值运算符。因为这是一个成员函数，所以它可以直接访问<code>other</code>对象的私有成员<code>x</code>。这样，我们不需要提供额外的接口来访问<code>x</code>，可以保持封装。</p>
<p>现在，假设我们尝试使用非成员函数来实现赋值操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> initialX) : <span class="built_in">x</span>(initialX) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供访问x的接口</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供修改x的接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> newX)</span> </span>&#123;</span><br><span class="line">        x = newX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非成员赋值运算符</span></span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp; lhs, <span class="type">const</span> MyClass&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (&amp;lhs == &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无法直接访问私有成员，需要使用公共接口</span></span><br><span class="line">    lhs.<span class="built_in">setX</span>(rhs.<span class="built_in">getX</span>());</span><br><span class="line">    <span class="keyword">return</span> lhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们试图使用非成员函数实现赋值运算符。然而，由于非成员函数无法直接访问私有成员，我们必须提供公共接口<code>getX()</code>和<code>setX()</code>来访问和修改<code>x</code>。这暴露了类的实现细节，并可能破坏封装。</p>
<p>需要注意的是，这个例子中的非成员赋值运算符尝试重载等号运算符（&#x3D;），然而，实际上在C++中赋值运算符（&#x3D;）必须被定义为类的成员函数，不能作为非成员函数。这个例子只是用来说明如果使用非成员函数来实现类似赋值操作的情况，可能会导致封装的破坏。</p>
<h2 id="类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值，这句话如何理解"><a href="#类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值，这句话如何理解" class="headerlink" title="类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值，这句话如何理解"></a>类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值，这句话如何理解</h2><p>这句话的意思是，对于某些类，编译器生成的合成拷贝赋值运算符可能不适用，或者类的设计者希望禁止对象之间的赋值操作。在这种情况下，合成拷贝赋值运算符会被显式地删除或声明为私有，从而阻止用户对该类的对象执行赋值操作。</p>
<p>当类中包含不可复制的资源（如文件句柄、互斥锁等）或类的实例应该保持唯一时（如单例模式），通常需要禁止类的对象之间的赋值操作。让我们通过一个例子来说明这个概念。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyableResource</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有拷贝构造函数</span></span><br><span class="line">    <span class="built_in">NonCopyableResource</span>(<span class="type">const</span> NonCopyableResource&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有拷贝赋值运算符</span></span><br><span class="line">    NonCopyableResource&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyableResource&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NonCopyableResource</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了一个<code>NonCopyableResource</code>类，它具有私有的拷贝构造函数和拷贝赋值运算符。因为这两个函数是私有的，所以在类的外部不能使用它们。这样，我们就阻止了该类对象之间的拷贝和赋值操作。</p>
<p>从C++11开始，我们可以更明确地禁止拷贝构造函数和拷贝赋值运算符，方法是将它们声明为<code>= delete</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyableResource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NonCopyableResource</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line">    <span class="built_in">NonCopyableResource</span>(<span class="type">const</span> NonCopyableResource&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝赋值运算符</span></span><br><span class="line">    NonCopyableResource&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyableResource&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方法更清晰地表明了拷贝构造函数和拷贝赋值运算符是被禁止的。当试图对这个类的对象执行拷贝或赋值操作时，编译器会报错。</p>
<p>总之，当类的对象不应该被复制或赋值时，可以通过将拷贝构造函数和拷贝赋值运算符声明为私有或删除它们来禁止这些操作。这样可以确保类的对象在程序中具有正确的行为。</p>
<h2 id="如果拷贝赋值运算符不是出于禁止拷贝的目的，他会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，为啥static不能赋值过去，是因为他的存储位置吗"><a href="#如果拷贝赋值运算符不是出于禁止拷贝的目的，他会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，为啥static不能赋值过去，是因为他的存储位置吗" class="headerlink" title="如果拷贝赋值运算符不是出于禁止拷贝的目的，他会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，为啥static不能赋值过去，是因为他的存储位置吗"></a>如果拷贝赋值运算符不是出于禁止拷贝的目的，他会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，为啥static不能赋值过去，是因为他的存储位置吗</h2><p>是的，你的理解是正确的。当拷贝赋值运算符执行时，它会将右侧运算对象的每个非static成员逐一赋值给左侧运算对象的对应成员。static成员变量的赋值不涉及到拷贝赋值运算符，因为它们不属于类的单个实例。</p>
<p>static成员变量属于类本身，而不是类的对象。它们在内存中的存储位置与类的实例对象不同。实际上，所有类的实例共享同一个static成员变量。因此，当你修改一个类实例的static成员变量时，这个修改会影响所有类实例。这就是为什么在拷贝赋值操作中，不需要拷贝static成员变量的原因。</p>
<p>以下是一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> nonStaticMember;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticMember;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> nonStaticValue) : <span class="built_in">nonStaticMember</span>(nonStaticValue) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化static成员变量</span></span><br><span class="line"><span class="type">int</span> MyClass::staticMember = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改static成员变量</span></span><br><span class="line">    MyClass::staticMember = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值操作</span></span><br><span class="line">    obj1 = obj2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果：20, 42</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj1: &quot;</span> &lt;&lt; obj1.nonStaticMember &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; MyClass::staticMember &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 输出结果：20, 42</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj2: &quot;</span> &lt;&lt; obj2.nonStaticMember &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; MyClass::staticMember &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>MyClass</code>具有一个非static成员变量<code>nonStaticMember</code>和一个static成员变量<code>staticMember</code>。当我们执行拷贝赋值操作<code>obj1 = obj2</code>时，只有<code>nonStaticMember</code>被拷贝，而<code>staticMember</code>保持不变。这是因为<code>staticMember</code>属于类本身，而不是类的实例。</p>
<h2 id="哪些情况下指针所指的对象会随着指针的销毁而销毁，哪些情况下不会？指针指向的对象没了，指针就没了吗？"><a href="#哪些情况下指针所指的对象会随着指针的销毁而销毁，哪些情况下不会？指针指向的对象没了，指针就没了吗？" class="headerlink" title="哪些情况下指针所指的对象会随着指针的销毁而销毁，哪些情况下不会？指针指向的对象没了，指针就没了吗？"></a>哪些情况下指针所指的对象会随着指针的销毁而销毁，哪些情况下不会？指针指向的对象没了，指针就没了吗？</h2><p>指针和指针所指向的对象是两个不同的概念。指针是一种变量，它存储了对象在内存中的地址。当指针被销毁时，它所指向的对象不会自动销毁。同样，当指针所指向的对象被销毁时，指针本身也不会自动销毁。它们的生命周期是独立的。</p>
<ol>
<li><p>指针所指向的对象会随着指针的销毁而销毁的情况：<br>实际上，没有这样的情况。当指针被销毁时，它所指向的对象不会自动销毁。只有当你显式地销毁指针所指向的对象时，对象才会被销毁。</p>
</li>
<li><p>指针指向的对象没了，指针就没了吗？<br>不是这样的。当指针所指向的对象被销毁时，指针本身不会自动销毁。指针仍然存在，但它现在指向的是一个已经销毁的对象，也就是所谓的悬空指针（dangling pointer）。在这种情况下，访问该悬空指针可能导致未定义行为，因为它可能指向无效的内存区域。</p>
</li>
</ol>
<p>以下是一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>); <span class="comment">// 动态分配内存，p指向该内存区域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 销毁p所指向的对象，释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// p没有被销毁，但现在是一个悬空指针，因为它指向的对象已经被销毁</span></span><br><span class="line">    <span class="comment">// 访问p可能导致未定义行为</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; *p &lt;&lt; std::endl; // 不安全！不要这样做</span></span><br><span class="line"></span><br><span class="line">    p = <span class="literal">nullptr</span>; <span class="comment">// 将悬空指针设置为nullptr，避免未定义行为</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免未定义行为，当销毁指针所指向的对象后，通常将指针设置为<code>nullptr</code>。这样，即使指针没有被销毁，也不会指向一个无效的内存区域。</p>
<h2 id="HasPtr-const-HasPtr-amp-rhs-this-gt-i-x3D-rhs-i-this-gt-ps-x3D-amp-rhs-ps-和下面这个-HasPtr-const-HasPtr-amp-rhs-this-gt-i-x3D-rhs-i-ps-x3D-new-string-rhs-ps-从拷贝构造函数的实现意义层面来说，有区别吗？是不是都是拷贝了ps指向的对象，而不是拷贝ps本身"><a href="#HasPtr-const-HasPtr-amp-rhs-this-gt-i-x3D-rhs-i-this-gt-ps-x3D-amp-rhs-ps-和下面这个-HasPtr-const-HasPtr-amp-rhs-this-gt-i-x3D-rhs-i-ps-x3D-new-string-rhs-ps-从拷贝构造函数的实现意义层面来说，有区别吗？是不是都是拷贝了ps指向的对象，而不是拷贝ps本身" class="headerlink" title="HasPtr(const HasPtr&amp; rhs) { 	this-&gt;i &#x3D; rhs.i; 	this-&gt;ps &#x3D; &amp;(*rhs.ps); } 和下面这个 HasPtr(const HasPtr&amp; rhs) { 	this-&gt;i &#x3D; rhs.i; 	ps &#x3D; new string(*rhs.ps); } 从拷贝构造函数的实现意义层面来说，有区别吗？是不是都是拷贝了ps指向的对象，而不是拷贝ps本身"></a>HasPtr(const HasPtr&amp; rhs) { 	this-&gt;i &#x3D; rhs.i; 	this-&gt;ps &#x3D; &amp;(*rhs.ps); } 和下面这个 HasPtr(const HasPtr&amp; rhs) { 	this-&gt;i &#x3D; rhs.i; 	ps &#x3D; new string(*rhs.ps); } 从拷贝构造函数的实现意义层面来说，有区别吗？是不是都是拷贝了ps指向的对象，而不是拷贝ps本身</h2><p>这两个拷贝构造函数的实现在语义层面上有很大的区别。</p>
<p>第一个拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;i = rhs.i;</span><br><span class="line">    <span class="keyword">this</span>-&gt;ps = &amp;(*rhs.ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个拷贝构造函数的实现仅仅是将<code>rhs</code>对象的<code>ps</code>成员的地址赋值给当前对象的<code>ps</code>成员。这意味着，两个<code>HasPtr</code>对象的<code>ps</code>成员指向同一个<code>string</code>对象。在这种情况下，我们说这是一种浅拷贝（shallow copy）。浅拷贝可能导致资源管理问题，如在析构函数中释放同一个对象两次。</p>
<p>第二个拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;i = rhs.i;</span><br><span class="line">    ps = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个拷贝构造函数的实现不仅将<code>rhs</code>对象的<code>ps</code>成员的值复制给当前对象的<code>ps</code>成员，还为当前对象的<code>ps</code>成员创建了一个新的<code>string</code>对象。这样，两个<code>HasPtr</code>对象的<code>ps</code>成员指向两个不同的、相互独立的<code>string</code>对象。在这种情况下，我们说这是一种深拷贝（deep copy）。深拷贝通常可以避免资源管理问题，因为每个对象都有自己独立的资源副本。</p>
<p>所以，从拷贝构造函数的实现意义层面来说，这两个实现有很大的区别。第一个实现是浅拷贝，可能导致资源管理问题；而第二个实现是深拷贝，可以避免这些问题。在实际编程中，根据具体需求选择合适的拷贝策略是很重要的。</p>
<h2 id="include-class-HasPtr-public-HasPtr-const-std-string-amp-s-x3D-std-string-ps-new-std-string-s-i-0-x2F-HasPtr-const-HasPtr-amp-rhs-this-gt-i-x3D-rhs-i-this-gt-ps-x3D-amp-rhs-ps-x2F-HasPtr-delete-ps-private-std-string-ps-int-i-HasPtr-f-HasPtr-hp-HasPtr-ret-x3D-hp-return-ret-int-main-HasPtr-p-“hello-world”-f-p-HasPtr-q-p-return-0-这里我有一个疑问，f函数的返回值是HasPtr类型，为什么我在main函数里调用f不需要使用HasPtr类型的对象来接受它的返回值呢"><a href="#include-class-HasPtr-public-HasPtr-const-std-string-amp-s-x3D-std-string-ps-new-std-string-s-i-0-x2F-HasPtr-const-HasPtr-amp-rhs-this-gt-i-x3D-rhs-i-this-gt-ps-x3D-amp-rhs-ps-x2F-HasPtr-delete-ps-private-std-string-ps-int-i-HasPtr-f-HasPtr-hp-HasPtr-ret-x3D-hp-return-ret-int-main-HasPtr-p-“hello-world”-f-p-HasPtr-q-p-return-0-这里我有一个疑问，f函数的返回值是HasPtr类型，为什么我在main函数里调用f不需要使用HasPtr类型的对象来接受它的返回值呢" class="headerlink" title="#include  class HasPtr { public: HasPtr(const std::string &amp;s &#x3D; std::string()): ps(new std::string(s)), i(0) {} 	&#x2F;HasPtr(const HasPtr&amp; rhs) { 	this-&gt;i &#x3D; rhs.i; 	this-&gt;ps &#x3D; &amp;(rhs.ps); }&#x2F; 	~HasPtr() { delete ps; } private: std::string ps; int i; }; HasPtr f(HasPtr hp) { HasPtr ret &#x3D; hp; return ret; } int main() { HasPtr p(“hello world”); f(p); HasPtr q(p); 	return 0; } 这里我有一个疑问，f函数的返回值是HasPtr类型，为什么我在main函数里调用f不需要使用HasPtr类型的对象来接受它的返回值呢"></a>#include <iostream> class HasPtr { public: HasPtr(const std::string &amp;s &#x3D; std::string()): ps(new std::string(s)), i(0) {} 	&#x2F;<em>HasPtr(const HasPtr&amp; rhs) { 	this-&gt;i &#x3D; rhs.i; 	this-&gt;ps &#x3D; &amp;(<em>rhs.ps); }</em>&#x2F; 	~HasPtr() { delete ps; } private: std::string</em> ps; int i; }; HasPtr f(HasPtr hp) { HasPtr ret &#x3D; hp; return ret; } int main() { HasPtr p(“hello world”); f(p); HasPtr q(p); 	return 0; } 这里我有一个疑问，f函数的返回值是HasPtr类型，为什么我在main函数里调用f不需要使用HasPtr类型的对象来接受它的返回值呢</iostream></h2><p>在这个例子中，当你调用<code>f(p)</code>时，即使没有为<code>f</code>函数的返回值指定一个<code>HasPtr</code>类型的对象来接收它，C++编译器仍然会处理这种情况。在没有指定接收返回值的情况下，编译器会创建一个临时<code>HasPtr</code>对象，用于接收<code>f</code>函数的返回值。这个临时对象会在表达式结束后立即销毁。</p>
<p>这就是为什么你不需要显式地使用一个<code>HasPtr</code>对象来接收<code>f</code>函数的返回值。然而，为了避免潜在的性能损失和资源浪费，通常建议你在调用返回对象的函数时指定一个接收返回值的变量。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">HasPtr <span class="title">p</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line">    HasPtr r = <span class="built_in">f</span>(p);  <span class="comment">// 使用HasPtr对象r来接收f函数的返回值</span></span><br><span class="line">    <span class="function">HasPtr <span class="title">q</span><span class="params">(p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，你可以避免创建和销毁临时对象，从而提高程序的性能。</p>
<h2 id="为什么需要拷贝操作的类也需要赋值操作，反之亦然，这句话是什么意思"><a href="#为什么需要拷贝操作的类也需要赋值操作，反之亦然，这句话是什么意思" class="headerlink" title="为什么需要拷贝操作的类也需要赋值操作，反之亦然，这句话是什么意思"></a>为什么需要拷贝操作的类也需要赋值操作，反之亦然，这句话是什么意思</h2><p>这句话的意思是，当你为一个类实现拷贝操作（拷贝构造函数）时，通常也需要实现赋值操作（拷贝赋值运算符），反之亦然。这是因为拷贝操作和赋值操作通常在语义上是相似的，而且在实际使用中经常会一起出现。实现一个而不实现另一个可能导致类的行为不一致或不完整。</p>
<p>拷贝构造函数和拷贝赋值运算符的主要区别在于它们的用途：</p>
<ol>
<li>拷贝构造函数（Copy Constructor）：当创建一个新对象并用另一个已存在的对象初始化它时，会调用拷贝构造函数。典型的情况包括：将一个对象作为参数传递给函数、从函数返回一个对象、初始化列表等。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj1;</span><br><span class="line"><span class="function">MyClass <span class="title">obj2</span><span class="params">(obj1)</span></span>;  <span class="comment">// 调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拷贝赋值运算符（Copy Assignment Operator）：当两个已经存在的对象之间进行赋值操作时，会调用拷贝赋值运算符。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass obj1;</span><br><span class="line">MyClass obj2;</span><br><span class="line">obj2 = obj1;  <span class="comment">// 调用拷贝赋值运算符</span></span><br></pre></td></tr></table></figure>

<p>在许多情况下，拷贝构造函数和拷贝赋值运算符需要执行相似的操作（如深拷贝）。实现两者可以确保类在各种情况下都能正确地处理拷贝和赋值操作。这就是为什么“需要拷贝操作的类也需要赋值操作，反之亦然”的原因。如果仅实现其中之一，可能会导致类在某些情况下无法正确地执行拷贝或赋值操作，从而引发问题。</p>
<p>当然可以。让我们通过一个简单的示例来说明仅实现拷贝构造函数而不实现拷贝赋值运算符可能导致的问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> std::string&amp; s) : <span class="built_in">data</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(s)) &#123;&#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) : <span class="built_in">data</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(*other.data)) &#123;&#125; <span class="comment">// 拷贝构造函数实现了深拷贝</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; <span class="keyword">delete</span> data; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="string">&quot;world&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MyClass <span class="title">obj3</span><span class="params">(obj1)</span></span>; <span class="comment">// 使用拷贝构造函数，执行正确</span></span><br><span class="line"></span><br><span class="line">    obj2 = obj1; <span class="comment">// 这里使用默认的拷贝赋值运算符，执行浅拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们实现了<code>MyClass</code>的拷贝构造函数，它执行深拷贝。但是，我们没有实现拷贝赋值运算符。因此，在赋值操作（如<code>obj2 = obj1;</code>）时，编译器会生成一个默认的拷贝赋值运算符，该运算符执行浅拷贝。</p>
<p>问题出现在这个默认的拷贝赋值运算符上。因为它执行浅拷贝，<code>obj2</code>和<code>obj1</code>的<code>data</code>成员将指向同一个<code>std::string</code>对象。当<code>main</code>函数结束时，<code>obj1</code>和<code>obj2</code>的析构函数都将被调用，它们都会尝试删除同一个<code>std::string</code>对象。这将导致未定义行为，可能会导致程序崩溃。</p>
<p>如果我们为<code>MyClass</code>同时实现拷贝构造函数和拷贝赋值运算符，并确保它们都执行深拷贝，就可以避免这个问题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 其他成员函数 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符实现了深拷贝</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::string* newData = <span class="keyword">new</span> std::<span class="built_in">string</span>(*other.data);</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">        data = newData;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string* data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，无论是使用拷贝构造函数还是拷贝赋值运算符，<code>MyClass</code>对象都将正确地执行深拷贝，从而避免了资源管理问题。</p>
<h2 id="你这个例子并没有解释为什么二者需要同时定义啊，比如第一个程序，我不执行赋值对拷贝构造也没影响啊"><a href="#你这个例子并没有解释为什么二者需要同时定义啊，比如第一个程序，我不执行赋值对拷贝构造也没影响啊" class="headerlink" title="你这个例子并没有解释为什么二者需要同时定义啊，比如第一个程序，我不执行赋值对拷贝构造也没影响啊"></a>你这个例子并没有解释为什么二者需要同时定义啊，比如第一个程序，我不执行赋值对拷贝构造也没影响啊</h2><p>抱歉，我的示例可能没有充分解释为什么两者需要同时定义。请允许我通过另一个例子来解释这个问题。</p>
<p>假设你有一个类，它表示一个动态分配的二维数组，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> rows, <span class="type">int</span> cols)</span><br><span class="line">        : <span class="built_in">rows</span>(rows), <span class="built_in">cols</span>(cols), <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[rows * cols]) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">const</span> Matrix&amp; other)</span><br><span class="line">        : <span class="built_in">rows</span>(other.rows), <span class="built_in">cols</span>(other.cols), <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[rows * cols]) &#123;</span><br><span class="line">        std::<span class="built_in">copy</span>(other.data, other.data + rows * cols, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Matrix</span>() &#123; <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他成员函数 ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> rows, cols;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们实现了<code>Matrix</code>的拷贝构造函数，它执行深拷贝。然而，我们没有实现拷贝赋值运算符。因此，编译器会生成一个默认的拷贝赋值运算符，执行浅拷贝。</p>
<p>现在，假设你需要执行以下操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matrix <span class="title">m1</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Matrix <span class="title">m2</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设有一个函数，它需要一个Matrix对象作为参数，并返回一个Matrix对象</span></span><br><span class="line">Matrix result = <span class="built_in">some_function</span>(m1);</span><br><span class="line"></span><br><span class="line">m2 = result; <span class="comment">// 使用默认的拷贝赋值运算符</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了两个<code>Matrix</code>对象，它们具有不同的尺寸。然后我们调用一个函数<code>some_function</code>，它返回一个<code>Matrix</code>对象。接下来，我们将<code>result</code>对象赋值给<code>m2</code>。这里，编译器会使用默认的拷贝赋值运算符，它执行浅拷贝。</p>
<p>问题在于，默认的拷贝赋值运算符无法处理不同尺寸的矩阵。由于它执行浅拷贝，<code>m2</code>的<code>data</code>指针将简单地指向<code>result</code>的<code>data</code>，而不会调整其大小。这将导致错误的行为，因为<code>m2</code>现在引用了一个与其原始大小不匹配的数组。此外，原始<code>m2</code>的<code>data</code>指针已经丢失，导致内存泄漏。</p>
<p>为了解决这个问题，我们需要同时实现拷贝构造函数和拷贝赋值运算符，以确保它们都执行深拷贝，并正确处理不同尺寸的矩阵。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 其他成员函数 ...</span></span><br><span class="line"></span><br><span class="line">    Matrix&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Matrix&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>* newData = <span class="keyword">new</span> <span class="type">int</span>[other.rows * other.cols];</span><br><span class="line">        std::<span class="built_in">copy</span>(other.data, other.data + other.rows * other.cols, newData);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        data = newData;</span><br><span class="line">        rows = other.rows;</span><br><span class="line">        cols = other.cols;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">GGBond</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"cdn":"https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML","tags":"none","src":"custom_mathjax_source","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>

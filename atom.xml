<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://zcl0219.github.io/atom.xml" rel="self"/>
  
  <link href="http://zcl0219.github.io/"/>
  <updated>2024-10-22T15:39:03.072Z</updated>
  <id>http://zcl0219.github.io/</id>
  
  <author>
    <name>GGBond</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DiaDSP</title>
    <link href="http://zcl0219.github.io/2024/10/22/DiaDSP/"/>
    <id>http://zcl0219.github.io/2024/10/22/DiaDSP/</id>
    <published>2024-10-22T13:38:57.000Z</published>
    <updated>2024-10-22T15:39:03.072Z</updated>
    
    <content type="html"><![CDATA[<p>Differentially Private Distributed Optimization via State and Direction Perturbation in Multiagent Systems</p><span id="more"></span><p>Introduction</p><p>Problem Formulation</p><p>DiaDSP Algorithm</p><p>B. Development of DiaDSP</p><p>We employ the combine-then-adapt strategy for each agent $i$, which is expressed as</p><p>Convergence Analysis of DiaDSP</p><p>Differential Privacy</p><p>Simulations</p><p>Conclusion</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Differentially Private Distributed Optimization via State and Direction Perturbation in Multiagent Systems&lt;/p&gt;</summary>
    
    
    
    <category term="Scholarly Reads" scheme="http://zcl0219.github.io/categories/Scholarly-Reads/"/>
    
    
    <category term="Distributed Optimization Algorithm" scheme="http://zcl0219.github.io/tags/Distributed-Optimization-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://zcl0219.github.io/2023/11/10/%E7%AE%97%E6%B3%95/"/>
    <id>http://zcl0219.github.io/2023/11/10/%E7%AE%97%E6%B3%95/</id>
    <published>2023-11-10T10:44:01.000Z</published>
    <updated>2024-10-20T12:40:55.432Z</updated>
    
    <content type="html"><![CDATA[<p>2023-11-10</p><p>并查集：<a href="https://blog.csdn.net/YSJ367635984/article/details/113504723">https://blog.csdn.net/YSJ367635984/article/details/113504723</a></p><span id="more"></span><p>C++代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisjointSets</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DisjointSets</span>();</span><br><span class="line">    ~<span class="built_in">DisjointSets</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findParentNode</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionSetNode</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DisjointSets::<span class="built_in">DisjointSets</span>(): <span class="built_in">count</span>(<span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)&#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DisjointSets::~<span class="built_in">DisjointSets</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int DisjointSets::findParentNode(int x)&#123;</span></span><br><span class="line"><span class="comment">    if(x != parent[x])&#123;</span></span><br><span class="line"><span class="comment">        findParentNode(parent[x]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return x;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化版本的并查集，减小以后查找时间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DisjointSets::findParentNode</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x != parent[x])&#123;</span><br><span class="line">        <span class="comment">// 找一次x只是压缩一次，多找几次就会导致父节点为根节点</span></span><br><span class="line">        parent[x] = parent[parent[x]];</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisjointSets::unionSetNode</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> parent_x = <span class="built_in">findParentNode</span>(x);</span><br><span class="line">    <span class="type">int</span> parent_y = <span class="built_in">findParentNode</span>(y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(parent_x == parent_y) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    parent[parent_y] = parent_x;</span><br><span class="line">    </span><br><span class="line">    --count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;2023-11-10&lt;/p&gt;
&lt;p&gt;并查集：&lt;a href=&quot;https://blog.csdn.net/YSJ367635984/article/details/113504723&quot;&gt;https://blog.csdn.net/YSJ367635984/article/details/113504723&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Zookeeper</title>
    <link href="http://zcl0219.github.io/2023/10/22/Zookeeper/"/>
    <id>http://zcl0219.github.io/2023/10/22/Zookeeper/</id>
    <published>2023-10-22T10:27:16.000Z</published>
    <updated>2023-10-22T12:52:38.677Z</updated>
    
    <content type="html"><![CDATA[<p>一、Zookeeper特点</p><ol><li>Zookeeper:一个领导者(Leader)，多个跟随者(Follower)组成的集群。<br>2)集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器。<br>3)全局数据一致:每个Server保存一份相同的数据副本， Client无论连接到哪个Server，数据都是一致的。<br>4)更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行。<br>5)数据更新原子性，一次数据更新要么成功，要么失败。<br>6)实时性，在一定时间范围内，Client能读到最新数据。</li></ol><p>二、数据结构<br>ZooKeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一棵树，每个节点称做一个ZNode。每一个ZNode默认能够存储1MB 的数据，每个ZNode都可以通过其路径唯一标识。</p><p>三、应用场景</p><p>提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。</p><p>四、配置参数</p><p>tickTime &#x3D; 2000：通信心跳时间，Zookeeper服务器与客户端心跳时间，单位毫秒</p><p>initLimit &#x3D; 10：LF初始通信时限，10次心跳，也就是20s，Leader和Follower初始链接时限</p><p>syncLimit &#x3D; 5：LF同步通信时限，两者之间的通信时间（5s）</p><p>dataDir：保存Zookeeper中的数据，可以修改</p><p>clientPort &#x3D; 2181：客户端连接端口，通常不做修改</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、Zookeeper特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Zookeeper:一个领导者(Leader)，多个跟随者(Follower)组成的集群。&lt;br&gt;2)集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器。&lt;br&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>对象的优化</title>
    <link href="http://zcl0219.github.io/2023/10/22/%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://zcl0219.github.io/2023/10/22/%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BC%98%E5%8C%96/</id>
    <published>2023-10-22T08:31:53.000Z</published>
    <updated>2023-10-22T10:26:35.842Z</updated>
    
    <content type="html"><![CDATA[<p>一、拷贝构造、赋值运算符重载的相关知识</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> a = <span class="number">10</span>): <span class="built_in">ma</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test &amp;t): <span class="built_in">ma</span>(t.ma) &#123; cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    Test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Test &amp;t)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">        ma = t.ma;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test t1;</span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;</span><br><span class="line">    Test t3 = t1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Test(20)显式生成临时对象 生存周期：所在的语句</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    c++编译器对于对象构造的优化：</span></span><br><span class="line"><span class="comment">    用临时对象生成新对象的时候，临时对象就不产生了，直接构造新对象就可以了。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Test t4 = <span class="built_in">Test</span>(<span class="number">20</span>); <span class="comment">// Test t4(20)没有区别的!</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t4 = t2; <span class="comment">// t4已经存在，这是赋值</span></span><br><span class="line">    t4 = <span class="built_in">Test</span>(<span class="number">30</span>); <span class="comment">// t4.operator=(const Test &amp;t)</span></span><br><span class="line">    t4 = (Test)<span class="number">30</span>; <span class="comment">// int -&gt; Test,强制转换编译器会看有没有合适的构造函数</span></span><br><span class="line">    t4 = <span class="number">30</span>; <span class="comment">// 隐式生成临时对象 隐式类型转换，注意如果30换成一个char类型变量，那就不行了，因为没有对应的构造  函数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Test *p = &amp;<span class="built_in">Test</span>(<span class="number">40</span>); <span class="comment">// p指向的是一个已经析构的临时对象</span></span><br><span class="line">    <span class="type">const</span> Test &amp;ref = <span class="built_in">Test</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="comment">// 使用引用引用一个临时变量，临时变量的周期就变为了变量的生命周期</span></span><br><span class="line">    <span class="comment">// 自己思考为引用给变量起了一个别名，在引用的生命周期内，就可以继续访问这个临时变量了</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> a = <span class="number">5</span>, <span class="type">int</span> b = <span class="number">5</span>): <span class="built_in">ma</span>(a), <span class="built_in">mb</span>(b)&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test(int, int)&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test &amp;src): <span class="built_in">ma</span>(src.ma), <span class="built_in">mb</span>(src.mb)&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Test &amp;src)&#123;</span><br><span class="line">        ma = src.ma;</span><br><span class="line">        mb = src.mb;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">    <span class="type">int</span> mb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;  <span class="comment">//1. Test(int , int)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;  <span class="comment">//3. Test(int , int)</span></span><br><span class="line">    Test t3 = t2; <span class="comment">// 4.Test(const Test&amp;)</span></span><br><span class="line">    <span class="type">static</span> Test t4 = <span class="built_in">Test</span>(<span class="number">30</span>, <span class="number">30</span>); <span class="comment">//5. Test(int, int)</span></span><br><span class="line">    t2 = <span class="built_in">Test</span>(<span class="number">40</span>, <span class="number">40</span>); <span class="comment">//6.Test(int, int), operetor=, ~Test()</span></span><br><span class="line">    t2 = (Test)(<span class="number">50</span>, <span class="number">50</span>); <span class="comment">//7.Test(int, int), operetor=, ~Test()</span></span><br><span class="line">    t2 = <span class="number">60</span>; <span class="comment">//8.Test(int, int), operetor=, ~Test()</span></span><br><span class="line">    Test *p1 = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">70</span>, <span class="number">70</span>); <span class="comment">// 9.Test(int, int),堆上需要显式释放</span></span><br><span class="line">    Test *p2 = <span class="keyword">new</span> Test[<span class="number">2</span>]; <span class="comment">// 10.Test(int, int), Test(int, int)</span></span><br><span class="line">    Test *p3 = &amp;<span class="built_in">Test</span>(<span class="number">80</span>, <span class="number">80</span>); <span class="comment">//11.Test(int, int), ~Test()</span></span><br><span class="line">    <span class="type">const</span> Test &amp;p4 = <span class="built_in">Test</span>(<span class="number">90</span>, <span class="number">90</span>); <span class="comment">//12.Test(int, int)</span></span><br><span class="line">    <span class="keyword">delete</span> p1; <span class="comment">// 13.~Test()</span></span><br><span class="line">    <span class="keyword">delete</span> []p2; <span class="comment">// 14. ~Test(), ~Test()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Test <span class="title">t5</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;  <span class="comment">//2. Test(int , int)</span></span><br><span class="line"><span class="comment">// 注意，t4的析构最晚，它在数据段，需要等程序结束。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、拷贝构造、赋值运算符重载的相关知识&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>OS_ucore</title>
    <link href="http://zcl0219.github.io/2023/10/18/OS-ucore/"/>
    <id>http://zcl0219.github.io/2023/10/18/OS-ucore/</id>
    <published>2023-10-18T02:11:15.000Z</published>
    <updated>2023-12-25T18:08:19.076Z</updated>
    
    <content type="html"><![CDATA[<p>1、操作系统要干啥？哪些操作&#x2F;任务不属于操作系统的管理范畴？</p><p>2、工具使用</p><p>阅读源码工具：<code>understannd</code></p><p>源码文档自动生成工具：<code>doxygen</code></p><p>虚拟运行环境：<code>qemu</code></p><p><code>Lab0</code></p><p>1、了解汇编</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;cld \n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;rep \n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;stosl&quot;</span></span><br><span class="line">        :</span><br><span class="line">        : <span class="string">&quot;c&quot;</span> (count), <span class="string">&quot;a&quot;</span>(value), <span class="string">&quot;D&quot;</span> (buf[<span class="number">0</span>])</span><br><span class="line">        :</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这段 C 代码给出了一个简单的函数，其中包括了一段内联汇编。</span></span><br><span class="line"><span class="comment">该代码试图展示如何使用 `rep stos` 指令来填充一个缓冲区，但存在一些问题和错误。</span></span><br><span class="line"><span class="comment">我会逐步解释代码，然后提出建议的更正。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 变量定义:</span></span><br><span class="line"><span class="comment">    ```c</span></span><br><span class="line"><span class="comment">    int count = 1;</span></span><br><span class="line"><span class="comment">    int value = 1;</span></span><br><span class="line"><span class="comment">    int buf[10];</span></span><br><span class="line"><span class="comment">    ```</span></span><br><span class="line"><span class="comment">    你定义了三个变量：一个 `count` 用于记录要重复的次数，</span></span><br><span class="line"><span class="comment">                    一个 `value` 用于指定要存储的值，</span></span><br><span class="line"><span class="comment">                    以及一个 `buf` 数组用于存储数据。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 主函数和内联汇编:</span></span><br><span class="line"><span class="comment">    ```c</span></span><br><span class="line"><span class="comment">    void main()&#123;</span></span><br><span class="line"><span class="comment">        asm(</span></span><br><span class="line"><span class="comment">            &quot;cld \n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;rep \n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;stsol&quot;</span></span><br><span class="line"><span class="comment">            :</span></span><br><span class="line"><span class="comment">            : &quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf[0])</span></span><br><span class="line"><span class="comment">        );</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    ```</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    - `cld`: 清除方向标志（Direction Flag）。这确保了字符串操作（如 `stos`）从低地址向高地址操作。</span></span><br><span class="line"><span class="comment">    - `rep stos`: 这应该是一个组合的指令，意思是&quot;重复存储&quot;。</span></span><br><span class="line"><span class="comment">      你试图使用这个指令将 `value` 的内容存储到 `buf` 指定的内存位置，</span></span><br><span class="line"><span class="comment">      并根据 `count` 的值重复该操作。但这里有个小错误: 你写的是 `&quot;stsol&quot;`，它是不正确的。应该是 `&quot;stosl&quot;`。</span></span><br><span class="line"><span class="comment">    - 输出约束（Output operands）: 这里没有列出输出操作数，所以你只有一个冒号。</span></span><br><span class="line"><span class="comment">    - 输入约束（Input operands）: `&quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf[0])`，这里:</span></span><br><span class="line"><span class="comment">        * `&quot;c&quot; (count)`：把 `count` 放入 `ECX` 寄存器（这是 `rep` 指令使用的计数寄存器）。</span></span><br><span class="line"><span class="comment">        * `&quot;a&quot;(value)`：把 `value` 放入 `EAX` 寄存器（这是 `stosl` 指令使用的源数据寄存器）。</span></span><br><span class="line"><span class="comment">        * `&quot;D&quot; (buf[0])`：把 `buf` 的首地址放入 `EDI` 寄存器（这是 `stosl` 指令使用的目标地址寄存器）。</span></span><br><span class="line"><span class="comment">          但这样写是不准确的，应该是 `&quot;D&quot; (buf)`。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">修正后的代码如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">```c</span></span><br><span class="line"><span class="comment">int count = 1;</span></span><br><span class="line"><span class="comment">int value = 1;</span></span><br><span class="line"><span class="comment">int buf[10];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void main()&#123;</span></span><br><span class="line"><span class="comment">    asm(</span></span><br><span class="line"><span class="comment">        &quot;cld \n\t&quot;</span></span><br><span class="line"><span class="comment">        &quot;rep \n\t&quot;</span></span><br><span class="line"><span class="comment">        &quot;stosl&quot;</span></span><br><span class="line"><span class="comment">        :</span></span><br><span class="line"><span class="comment">        : &quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf)</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">```</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：使用内联汇编通常是平台和编译器特定的。</span></span><br><span class="line"><span class="comment">上述代码假定你正在使用 GCC 或其它支持 GNU 汇编语法的编译器，并且在一个 x86 架构的机器上运行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在 GCC 的内联汇编中，第三个冒号后面的部分是用于指定被汇编代码修改的寄存器列表的，也叫做“Clobber List”。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以下是 `asm` 的基本格式：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">asm ( assembly code </span></span><br><span class="line"><span class="comment">     : output operands                  // optional</span></span><br><span class="line"><span class="comment">     : input operands                   // optional</span></span><br><span class="line"><span class="comment">     : list of clobbered registers      // optional</span></span><br><span class="line"><span class="comment">     );</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. Assembly Code: 包含汇编指令的字符串。</span></span><br><span class="line"><span class="comment">2. Output Operands: 输出操作数列表。</span></span><br><span class="line"><span class="comment">3. Input Operands: 输入操作数列表。</span></span><br><span class="line"><span class="comment">4. Clobber List: 表示汇编指令可能会更改的寄存器列表，</span></span><br><span class="line"><span class="comment">   这告诉编译器这些寄存器的值可能会被修改，所以不要依赖它们的原始值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在你的例子中，你使用了 `&quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf[0])` 为汇编指令提供输入操作数，</span></span><br><span class="line"><span class="comment">但你并没有指定输出操作数，也没有列出任何可能被修改的寄存器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">虽然在此例中，你知道 `ECX`, `EAX`, 和 `EDI` 寄存器会被修改，</span></span><br><span class="line"><span class="comment">但在许多情况下，列出clobbered registers是很有必要的，因为它可以帮助编译器更好地优化生成的代码。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以，理论上，你的代码应该像这样：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int count = 1;</span></span><br><span class="line"><span class="comment">int value = 1;</span></span><br><span class="line"><span class="comment">int buf[10];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void main()&#123;</span></span><br><span class="line"><span class="comment">    asm(</span></span><br><span class="line"><span class="comment">        &quot;cld \n\t&quot;</span></span><br><span class="line"><span class="comment">        &quot;rep \n\t&quot;</span></span><br><span class="line"><span class="comment">        &quot;stosl&quot;</span></span><br><span class="line"><span class="comment">        :</span></span><br><span class="line"><span class="comment">        : &quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf)</span></span><br><span class="line"><span class="comment">        : &quot;ecx&quot;, &quot;eax&quot;, &quot;edi&quot;</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这里，`&quot;ecx&quot;, &quot;eax&quot;, &quot;edi&quot;` 是clobber list，告诉编译器这些寄存器的值已经被汇编代码修改了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>3、掌握指针和类型转换相关的Ｃ编程</p><p>实验源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_IG32 0xE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_TG32 0xF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">uint32_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)&#123;\</span></span><br><span class="line"><span class="meta">    (gate).gd_off_15_0 = (uint32_t)(off) &amp; 0xffff;\</span></span><br><span class="line"><span class="meta">    (gate).gd_ss = (sel);\</span></span><br><span class="line"><span class="meta">    (gate).gd_args = 0;\</span></span><br><span class="line"><span class="meta">    (gate).gd_rsv1 = 0;\</span></span><br><span class="line"><span class="meta">    (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;\</span></span><br><span class="line"><span class="meta">    (gate).gd_s = 0;\</span></span><br><span class="line"><span class="meta">    (gate).gd_dpl = (dpl);\</span></span><br><span class="line"><span class="meta">    (gate).gd_p = 1;\</span></span><br><span class="line"><span class="meta">    (gate).gd_off_31_16 = (uint32_t)(off) &gt;&gt; 16;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> gd_off_15_0: <span class="number">16</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_ss: <span class="number">16</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_args: <span class="number">5</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_rsv1: <span class="number">3</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_type: <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_s: <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_dpl: <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_p: <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_off_31_16: <span class="number">16</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> before;</span><br><span class="line">    <span class="type">unsigned</span> intr;</span><br><span class="line">    <span class="type">unsigned</span> after;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> <span class="title">gintr</span>;</span></span><br><span class="line"></span><br><span class="line">    intr = <span class="number">8</span>;</span><br><span class="line">    before = after = <span class="number">0</span>;</span><br><span class="line">    gintr = *((<span class="keyword">struct</span> gatedesc*)&amp;intr);</span><br><span class="line">    SETGATE(gintr, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    intr = *((<span class="type">unsigned</span>*)&amp;(gintr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;intr is 0x%x\n&quot;</span>, intr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gintr is 0x%llx\n&quot;</span>, gintr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己根据输出即可推出来是怎么做的。注意，<code>gintr</code>等于<code>0xee0000010002</code>中，最高16位全部等于0没有展示出来。而%x只能展示32位，所以<code>intr</code>的输出结果为：<code>0x10002</code>。</p><h4 id="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"><a href="#一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？" class="headerlink" title="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"></a>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</h4><p>硬盘主引导扇区（Master Boot Record，MBR）是位于硬盘第一个扇区（通常是逻辑地址0号扇区）的512字节的数据结构，用于引导计算机操作系统。一个符合规范的硬盘主引导扇区应该包含以下几个特征：</p><ol><li><p><strong>引导代码（Boot Code）：</strong> 前446个字节用于存储引导代码，这是引导加载程序（Boot Loader）的代码，负责加载操作系统。这段代码必须是有效的汇编代码，能够启动计算机。</p></li><li><p><strong>分区表（Partition Table）：</strong> 接下来的64字节用于存储分区表，每个分区表项占16字节。一个硬盘可以分为最多4个主分区，每个分区表项描述一个分区的起始位置、大小和分区类型等信息。</p></li><li><p><strong>签名字节（Signature）：</strong> 最后的两个字节（0x55AA）是MBR的签名，标志这个扇区是有效的MBR扇区。这个签名是个小端字节序的16位值，它告诉操作系统这个扇区包含了引导信息，是一个有效的MBR。</p></li></ol><p>总结起来，一个被系统认为是符合规范的硬盘主引导扇区应该包含引导代码、分区表和签名字节。这些特征是为了确保引导加载程序可以正确地读取分区信息，从而启动操作系统。如果这些特征中的任何一个缺失或损坏，可能导致系统无法正确引导。</p><p>引导扇区代码（<code>tools/sign.c</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span> </span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: &lt;input filename&gt; &lt;output filename&gt;\n&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stat(argv[<span class="number">1</span>], &amp;st) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error opening file &#x27;%s&#x27;: %s\n&quot;</span>, argv[<span class="number">1</span>], strerror(errno)); </span><br><span class="line">        <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&#x27;%s&#x27; size: %lld bytes\n&quot;</span>, argv[<span class="number">1</span>], (<span class="type">long</span> <span class="type">long</span>)st.st_size); </span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; <span class="number">510</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%lld &gt;&gt; 510!!\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)st.st_size); </span><br><span class="line">        <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf)); </span><br><span class="line">    FILE*ifp=fopen(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="type">int</span> size = fread(buf, <span class="number">1</span>,st.st_size, ifp); </span><br><span class="line">    <span class="keyword">if</span> (size != st.st_size) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;read &#x27;%s&#x27; error, size is %d.\n&quot;</span>, argv[<span class="number">1</span>], size); </span><br><span class="line">        <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ifp);</span><br><span class="line">    buf[<span class="number">510</span>]= <span class="number">0x55</span>; </span><br><span class="line">    buf[<span class="number">511</span>] =<span class="number">0xAA</span>;</span><br><span class="line">    FILE*ofp = fopen(argv[<span class="number">2</span>], <span class="string">&quot;wb+&quot;</span>);</span><br><span class="line">    size = fwrite(buf, <span class="number">1</span>, <span class="number">512</span>, ofp); </span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">512</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;write &#x27;%s&#x27; error, size is %d.\n&quot;</span>, argv[<span class="number">2</span>], size); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ofp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;build 512 bytes boot sector: &#x27;%s&#x27; success!\n&quot;</span>, argv[<span class="number">2</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">这是一个简单的C程序，用于生成一个包含引导代码的512字节的引导扇区（Boot Sector）。这样的引导扇区通常用于创建可引导的存储介质，例如硬盘、U盘等。以下是程序的主要功能和流程：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 使用 `stat` 函数获取指定输入文件（`argv[1]`）的信息，主要是文件大小。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 打印输入文件的大小。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 检查文件大小是否超过了510字节。如果超过，打印错误信息并退出程序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 读取输入文件的内容（最多510字节），将内容存储在一个大小为512字节的缓冲区中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5. 在缓冲区的倒数第二个字节（第510字节）写入0x55，倒数第一个字节（第511字节）写入0xAA。这是引导扇区的标志，用于告诉计算机系统这是一个有效的引导扇区。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6. 打开输出文件（`argv[2]`），将修改后的缓冲区写入文件。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">7. 打印成功信息并返回0。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这个程序的目的是创建一个符合标准的引导扇区，其中包含引导代码和标志字节。请注意，生成的引导扇区在实际使用时需要按照引导扇区的规范进行进一步配置，以确保它能够正确地引导计算机系统。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以下是程序的一些可能的改进和注意事项：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 添加更多的错误检查，例如检查文件是否成功打开。</span></span><br><span class="line"><span class="comment">- 考虑处理更多的边界情况，例如文件是否为空。</span></span><br><span class="line"><span class="comment">- 考虑使用二进制文件读写模式（&quot;rb&quot; 和 &quot;wb+&quot;）而不是文本模式。</span></span><br><span class="line"><span class="comment">- 考虑使用 `perror` 函数来打印与 `fopen`、`fread`、`fwrite` 相关的错误信息。</span></span><br><span class="line"><span class="comment">- 考虑处理大端和小端字节序的问题，特别是当涉及到二进制文件时。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、操作系统要干啥？哪些操作&amp;#x2F;任务不属于操作系统的管理范畴？&lt;/p&gt;
&lt;p&gt;2、工具使用&lt;/p&gt;
&lt;p&gt;阅读源码工具：&lt;code&gt;understannd&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;源码文档自动生成工具：&lt;code&gt;doxygen&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;虚拟</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://zcl0219.github.io/2023/10/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zcl0219.github.io/2023/10/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-10-06T18:57:06.000Z</published>
    <updated>2023-10-06T18:57:06.148Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器-第八章</title>
    <link href="http://zcl0219.github.io/2023/09/07/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
    <id>http://zcl0219.github.io/2023/09/07/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%AC%AC%E5%85%AB%E7%AB%A0/</id>
    <published>2023-09-07T01:30:19.000Z</published>
    <updated>2023-09-07T01:44:27.621Z</updated>
    
    <content type="html"><![CDATA[<p>这里因为做项目的需要，我先写下8.6节有关有限状态机的内容</p><p>这一节我们介绍逻辑单元内部的一种高效编程方法：有限状态机。有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里因为做项目的需要，我先写下8.6节有关有限状态机的内容&lt;/p&gt;
&lt;p&gt;这一节我们介绍逻辑单元内部的一种高效编程方法：有限状态机。有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CMake</title>
    <link href="http://zcl0219.github.io/2023/08/29/CMake/"/>
    <id>http://zcl0219.github.io/2023/08/29/CMake/</id>
    <published>2023-08-29T14:34:47.000Z</published>
    <updated>2023-09-06T02:00:51.820Z</updated>
    
    <content type="html"><![CDATA[<p>这里画一个图直接直接展示一下CMake和Makefile的使用过程</p><p><img src="png1.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ *.cpp -o app  <span class="comment">//直接编译    </span></span><br></pre></td></tr></table></figure><p>使用#注释</p><p>块注释#[[ ]]</p><p>camke_minimum_required：指定使用的cmake的最低版本</p><p>project：定义工程名称</p><p>add_executable：定义工程会生成一个可执行程序 add_executable(可执行程序名称 源文件名称（空格或者分号隔离源文件)）</p><p>cmake CMakeLists.txt：文件所在路径</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(app, add.cpp div.cpp mult.cpp main.cpp sub.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果CMakeLists.txt文件就在当前目录下，直接执行以下命令</span></span><br><span class="line">cmake .</span><br><span class="line">make</span><br><span class="line"><span class="comment">#就会出现app可执行文件</span></span><br></pre></td></tr></table></figure><p>生成了很多其他文件，我们可以把这些临时文件放在一个文件夹里，一般为build文件夹。创建build文件后，cd进build文件，执行camke ..，则cmake执行后生成的文件都放在了build文件夹里。</p><h3 id="set的使用"><a href="#set的使用" class="headerlink" title="set的使用"></a><code>set</code>的使用</h3><p>set是为了简化add_executable(app, add.cpp div.cpp mult.cpp main.cpp sub.cpp)的编写，要不然这样和直接编译感觉没啥区别。set给一个变量赋值都是字符串类型，这些文件的名字会作为一个字符串存在变量里。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set指令的语法是：</span></span><br><span class="line"><span class="comment"># [] 中的参数为可选项，如不需要可以不写</span></span><br><span class="line"><span class="keyword">set</span>(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># VAR：变量名</span></span><br><span class="line"><span class="comment"># VALUE：变量值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一：各个源文件之间使用空格间隔</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST add.c div.c main.c mult.c sub.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二：各个源文件之间使用;间隔</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST add.c;div.c;main.c;mult.c;sub.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><p>取变量值必须以这种方式。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &quot;$ + &#123;变量名&#125;&quot;</span></span><br><span class="line"><span class="variable">$&#123;SRC_LIST&#125;</span></span><br></pre></td></tr></table></figure><p>还可以通过set设置使用C++的标准（C++11，C++17）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正常编译选定c++标准</span></span><br><span class="line">g++ *.cpp -std=c++11 -o app</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用camke指定c++标准，对应有一个宏叫做DCMAKE_Cxx_STANDARD</span></span><br><span class="line"><span class="comment"># 由两种方式指定C++标准</span></span><br><span class="line"><span class="comment"># 第一种：在CMakeLists.txt中通过set命令指定</span></span><br><span class="line"><span class="keyword">set</span>(CAMKE_CXX_STANDARD <span class="number">11</span>)  <span class="comment"># 等价于增加 -std=c++11</span></span><br><span class="line"><span class="keyword">set</span>(CAMKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="keyword">set</span>(CAMKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种：在执行camke命令的时候制定出这个宏的值</span></span><br><span class="line">camke CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=<span class="number">11</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=<span class="number">14</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=<span class="number">17</span></span><br></pre></td></tr></table></figure><p>set还可以指定输出路径，建议使用绝对路径，如果这个路径中的子目录不存在，会自动生成，无需自己手动创建。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在CMake中指定可执行程序输出的路径，也对应一个宏，叫做EXECUTABLE_OUTPUT_PATH，它的值还是通过set命令设置</span></span><br><span class="line"><span class="keyword">set</span>(HOME /home/zcl/linux/soft)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_UOTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>/bin)</span><br><span class="line"><span class="comment"># 第一行：定义一个变量用于存储一个绝对路径</span></span><br><span class="line"><span class="comment"># 第二行：将拼接好的路径值设置给EXECUTABLE_OUTPUT_PATH宏</span></span><br></pre></td></tr></table></figure><h3 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h3><p>我们可以看到我们上面所讲的使用set并没有解决要将所有源文件名字写出来的本质问题。为了解决这个问题，这里我们讲一下通过搜索某个目录下的文件来引入源文件的方法。CMake给我们提供了两种方法来搜索文件，aux_source_directory命令或者file命令。</p><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>在CMake中使用aux_source_directory命令可以查找某个路径下的所有源文件。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(&lt;dir&gt; &lt;variable&gt;)</span><br><span class="line"><span class="comment"># dir：要搜索的目录</span></span><br><span class="line"><span class="comment"># variable：将从dir目录下搜索到的源文件列表存储到该变量中</span></span><br><span class="line"><span class="comment"># 这里介绍一个宏，PROJECT_SOURCE_DIR宏代表的就是我们在camke命令后携带的那个路径。比如camke ..，PROJECT_SORCE_DIR宏代表的就是`..`</span></span><br><span class="line"><span class="comment"># 再介绍另外一个宏，CMAKE_CURRENT_SOURCE_DIR宏代表的就是当前CMakelists.txt文件所在的路径</span></span><br><span class="line"><span class="comment"># 下面进入实操，比如搜索当前CMakelists.txt文件所在目录下的src目录</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src SRC_LIST)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>通过file命令来搜索出所有需要的源文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line"><span class="keyword">file</span>(GLOB 变量名 要搜索的文件路径和文件类型)</span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</span><br><span class="line"><span class="comment"># GLOB：将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中</span></span><br><span class="line"><span class="comment"># GLOB_RECURSE：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中</span></span><br><span class="line"><span class="comment"># 比如：搜索当前目录的src目录下所有的源文件，并将其存储到变量中</span></span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="variable">$&#123;CAMKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/*.h)</span><br><span class="line"><span class="comment"># 注：关于要搜索的文件路径和类型可以加双引号，也可不加</span></span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="搜索头文件路径"><a href="#搜索头文件路径" class="headerlink" title="搜索头文件路径"></a>搜索头文件路径</h3><p>在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能找到这些头文件。在CMake里搜索头文件的命令也很简单</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(headpath)</span><br><span class="line"><span class="comment"># headpath就是头文件路径，这里建议写绝对路径</span></span><br><span class="line"><span class="comment"># 实操</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><h3 id="通过CMake制作库文件"><a href="#通过CMake制作库文件" class="headerlink" title="通过CMake制作库文件"></a>通过CMake制作库文件</h3><p>有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来讲解在cmake中生成这两类库文件的方法。</p><h4 id="制作静态库"><a href="#制作静态库" class="headerlink" title="制作静态库"></a>制作静态库</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在cmake中，如果要制作静态库，需要使用的命令如下：</span></span><br><span class="line"><span class="keyword">add_library</span>(库名称 STATIC 源文件<span class="number">1</span> [源文件<span class="number">2</span>] ...) </span><br><span class="line"><span class="comment"># 注：在Linux中，静态库名字分为三部分：lib+库名字+.a，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。</span></span><br><span class="line"><span class="comment"># 如果是动态库，最终生成的库的名字就是：libXXX.so(Linux)，libXXX.dll(Windows)；</span></span><br><span class="line"><span class="comment"># 如果是静态库，最终生成的库的名字就是：libXXX.a(Linux)，libXXX.lib(Windows)；</span></span><br><span class="line"><span class="comment"># 下面有一个目录，需要将src目录中的源文件编译成静态库，然后再使用：</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── <span class="keyword">include</span>           <span class="comment"># 头文件目录</span></span><br><span class="line">│   └── head.h</span><br><span class="line">├── main.cpp          <span class="comment"># 用于测试的源文件</span></span><br><span class="line">└── src               <span class="comment"># 源文件目录</span></span><br><span class="line">    ├── add.cpp</span><br><span class="line">    ├── div.cpp</span><br><span class="line">    ├── mult.cpp</span><br><span class="line">    └── sub.cpp</span><br><span class="line"><span class="comment"># 根据上面的目录结构，可以这样编写CMakeLists.txt文件:</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 注：STATIC对应的是静态库，SHARED对应的是动态库</span></span><br></pre></td></tr></table></figure><h4 id="制作动态库"><a href="#制作动态库" class="headerlink" title="制作动态库"></a>制作动态库</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(calc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><h4 id="指定输出路径"><a href="#指定输出路径" class="headerlink" title="指定输出路径"></a>指定输出路径</h4><p>对于生成的库文件来说和可执行程序一样都可以指定输出路径。这里使用LIBRARY_OUTPUT_PATH宏，这个宏对应静态库文件和动态库文件都适用。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="comment"># 设置动态库/静态库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="comment">#add_library(calc SHARED $&#123;SRC_LIST&#125;)</span></span><br><span class="line"><span class="comment"># 生成静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="包含库文件"><a href="#包含库文件" class="headerlink" title="包含库文件"></a>包含库文件</h3><p>在编写程序的过程中，可能会用到一些系统提供的动态库或者自己制作出的动态库或者静态库文件，cmake中也为我们提供了相关的加载动态库的命令。</p><h4 id="链接静态库"><a href="#链接静态库" class="headerlink" title="链接静态库"></a>链接静态库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── add.cpp</span><br><span class="line">├── div.cpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── mult.cpp</span><br><span class="line">└── sub.cpp</span><br></pre></td></tr></table></figure><p>现在我们把上面src目录中的add.cpp、div.cpp、mult.cpp、sub.cpp编译成一个静态库文件libcalc.a。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试目录结构</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span> </span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.a     # 制作出的静态库的名字</span><br><span class="line">└── src</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br><span class="line">4 directories, 4 files</span><br></pre></td></tr></table></figure><p>在cmake中，链接静态库的命令如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_libraries</span>(&lt;static lib&gt; [&lt;static lib&gt;...])</span><br><span class="line"><span class="comment"># 参数1：指定出要链接的静态库的名字，可以是全名 libxxx.a，也可以是掐头（lib）去尾（.a）之后的名字 xxx</span></span><br><span class="line"><span class="comment"># 参数2-N：要链接的其它静态库的名字</span></span><br></pre></td></tr></table></figure><p>如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(&lt;lib path&gt;)</span><br></pre></td></tr></table></figure><p>这样，修改之后的CMakeLists.txt文件内容如下:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="comment"># 搜索指定目录下源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="comment"># 包含头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 包含静态库路径 添加了这行代码，就可以根据参数指定的路径找到这个静态库了。</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 链接静态库</span></span><br><span class="line"><span class="keyword">link_libraries</span>(calc)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><h4 id="链接动态库"><a href="#链接动态库" class="headerlink" title="链接动态库"></a>链接动态库</h4><p>target不知道这个符号是来自它链接的多个库中的哪一个库，它只知道有这么一个库。</p><p>FATAL_ERROR：CMake 错误, 终止所有处理过程（CMake在生成”message to display”这条消息之后就不在执行了，直接中断）</p><p>CMake在底层管理的时候会将子字符串通过分号隔开，但通过message打印变量值的时候，看不到这个分号。这个分号有助于cmake进行字符串删除操作。只能删除组成变量的子串。比如一开始SRC&#x3D;”A123”，后来apeend了“456”, “789”，如果没有分号，你可能可以删除”345”，但有了分号后，就删除不了了，你只能删除组成SRC的完整的子串，比如”A123”, “456”等。</p><p>注意，存储列表长度的output variable依旧是一个字符串类型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里画一个图直接直接展示一下CMake和Makefile的使用过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;png1.png&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://zcl0219.github.io/2023/08/29/MySQL/"/>
    <id>http://zcl0219.github.io/2023/08/29/MySQL/</id>
    <published>2023-08-29T13:56:11.000Z</published>
    <updated>2023-10-09T08:27:20.733Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DAY1"><a href="#DAY1" class="headerlink" title="DAY1"></a><code>DAY1</code></h3><p>使用指令创建数据库：CREATE DATABASE zcl_db01;</p><p>删除数据库指令：DROP DATABASE zcl_db01;</p><p>创建一个使用utf8字符集的zcl_db02数据库：CREATE DATABASE zcl_db02 CHARACTER SET utf8</p><p>创建一个使用utf8字符集，并带校对规则的zcl_db03数据库：CREATE DATABASE zcl_db03 CHARACTER SET utf8 COLLATE utf8_bin<br>utf8_bin区分大小写，utf8_general_ci不区分大小写</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查看当前数据库服务器中的所有数据库</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES</span><br><span class="line"></span><br><span class="line">#查看前面创建的zcl_db01数据库的定义信息</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE `zcl_db01`</span><br><span class="line"></span><br><span class="line">#在创建数据库、表的时候，为了规避关键字，可以使用``解决</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE `<span class="keyword">CREATE</span>`</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#备份数据库</span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p <span class="operator">-</span>B zcl_db03 <span class="operator">&gt;</span> e:\\tmp.sql (文件名)</span><br><span class="line"></span><br><span class="line">#恢复数据库</span><br><span class="line">source e:\\tmp.sql</span><br><span class="line"></span><br><span class="line">#备份数据库的表</span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p zcl_db03 t1 t2 (t1和t2是表名) <span class="operator">&gt;</span> e:\\tmp1.sql</span><br></pre></td></tr></table></figure><h3 id="DAY2"><a href="#DAY2" class="headerlink" title="DAY2"></a><code>DAY2</code></h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 创建表</span><br><span class="line"># create table table_name</span><br><span class="line"># (</span><br><span class="line"># filed1 datatype,</span><br><span class="line">#filed2 datatype,</span><br><span class="line">#filed3 datatype</span><br><span class="line"># )character set 字符集 collate 校对规则 engine 存储引擎</span><br><span class="line">#  filed：指定列名   datatype：指定列类型（字段类型）</span><br><span class="line">#  character set：如不指定则为所在数据库字符集</span><br><span class="line">#  collate：如不指定则为所在数据库校对规则</span><br><span class="line"></span><br><span class="line"># 实操</span><br><span class="line">create table `user`(</span><br><span class="line">id int,</span><br><span class="line">    `name` varchar(255),</span><br><span class="line">    `passward` varchar(255),</span><br><span class="line">    `birthday` date</span><br><span class="line">)character set utf8 collate utf8_general_ci engine innodb; </span><br></pre></td></tr></table></figure><h4 id="Mysql常用数据类型"><a href="#Mysql常用数据类型" class="headerlink" title="Mysql常用数据类型"></a>Mysql常用数据类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Mysql列类型就是Mysql的数据类型</span><br><span class="line"># 数值类型：</span><br><span class="line"># 整型：tinyint(1个字节)smallint(2个字节)mediumint(3个字节)int(4个字节)bigint(8个字节)</span><br><span class="line"># 小数类型：float(单精度 4个字节)double(双精度 8个字节)decimal[M,D](大小不确定，M代表长度，D代表小数位数)</span><br><span class="line"></span><br><span class="line"># 文本类型（字符串类型）</span><br><span class="line"># char(0-255)varchar(0~65535)text(0~2^16-1)longtext(0~2^32-1)</span><br><span class="line"></span><br><span class="line"># 二进制数据类型</span><br><span class="line"># blob[0~2^16-1]longblob[0~2^32-1]</span><br><span class="line"></span><br><span class="line"># 日期类型</span><br><span class="line"># date[日期 年月日] time[时间 时分秒]datetime[年月日 时分秒 YYYY-MM-DD HH:MM:SS]timestamp[时间戳]</span><br></pre></td></tr></table></figure><p>在满足需求的情况下，尽量选择占用空间小的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t3(</span><br><span class="line">id TINYINT</span><br><span class="line">);</span><br><span class="line"># INSERT INTO t3 VALUES(128); 错误：越界了，超过了tinyint范围。 </span><br><span class="line">INSERT INTO t3 VALUES(127);</span><br><span class="line"># 定义无符号的整数 指定unsigned</span><br><span class="line">CREATE TABLE t4(</span><br><span class="line">id TINYINT UNSIGNED</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># BIT(M), M在1-64。显示按照bit。</span><br><span class="line">CREATE TABLE t5(</span><br><span class="line">num BIT(8)</span><br><span class="line">);</span><br><span class="line">INSERT INTO t5 VALUES(255);</span><br><span class="line">SELECT * FROM t5;</span><br><span class="line"># 输出：11111111</span><br><span class="line">SELECT * FROM t5 WHERE num = 255;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># DECIMAL[M, D] </span><br><span class="line"># M是小数位数（精度）的总数，D是小数点（标度）后面的位数。</span><br><span class="line"># 如果D是0，则值没有小数点或分数部分，M最大是65，D最大是30。如果D被省略，则默认是0，如果M被省略，默认是10。</span><br><span class="line">CREATE TABLE t6(</span><br><span class="line">num1 FLOAT,</span><br><span class="line">    num2 DOUBLE,</span><br><span class="line">    num3 DECIMAL(30, 20)</span><br><span class="line">);</span><br><span class="line">INSERT INTO t6 VALUES(88.123456789123456, 88.123456789123456, 88.123456789123456)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># char(4) 这个4表示字符数（最大255），不是字节数，不管是中文还是英文都是放四个，按字符计算，定长，即使你插入&#x27;aa&#x27;，也会占用分配的4个字符的空间</span><br><span class="line"># varchar(4) 这个4表示字符数，是变长，如果你插入&#x27;aa&#x27;，实际占用空间并不是4个字符，而是实际占用的空间。</span><br><span class="line"># utf-8：一个字符占三个字节</span><br><span class="line">CREATE TABLE t11(</span><br><span class="line">&#x27;name&#x27; CHAR(4)</span><br><span class="line">);</span><br><span class="line"># INSERT INTO t11 VALUES(&#x27;ABCDE&#x27;) 报错，太长</span><br><span class="line">INSERT INTO t11 VALUES(&#x27;ABCD&#x27;)</span><br><span class="line">INSERT INTO t11 VALUES(&#x27;你好&#x27;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 日期类型 date datetime timestamp</span><br><span class="line">CREATE TABLE birthday11(</span><br><span class="line">birthday DATE,</span><br><span class="line">    worktime DATETIME,</span><br><span class="line">    login_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</span><br><span class="line">);</span><br><span class="line">INSERT INTO bithday11(birthday, worktime) VALUES(&#x27;2022-11-11&#x27;, &#x27;2022-11-11 10:10:10&#x27;);</span><br></pre></td></tr></table></figure><h4 id="创建表的课堂练习"><a href="#创建表的课堂练习" class="headerlink" title="创建表的课堂练习"></a>创建表的课堂练习</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#x27;emp&#x27;(</span><br><span class="line">id INT,</span><br><span class="line">    &#x27;name&#x27; VARCHAR(32),</span><br><span class="line">    sex CHAR(1),</span><br><span class="line">    birthday DATE,</span><br><span class="line">    entry_date DATETIME,</span><br><span class="line">    job VARCHAR(32),</span><br><span class="line">    saraly DOUBLE,</span><br><span class="line">    &#x27;resume&#x27; TEXT</span><br><span class="line">) CHARSET utf8 COLLATE utf8_bin ENGINE INNODB;</span><br><span class="line">INSERT INTO &#x27;emp&#x27; VALUES(</span><br><span class="line">100, &#x27;小妖怪&#x27;, &#x27;男&#x27;, &#x27;2000-11-11&#x27;, &#x27;巡山的&#x27;, 3000, &#x27;大王叫我来巡山&#x27;</span><br><span class="line">);</span><br><span class="line">SELECT * FROM &#x27;emp&#x27;;</span><br><span class="line"></span><br><span class="line"># 增加列</span><br><span class="line">ALTER TABLE emp ADD image VARCHAR(32) NOT NULL DEFAULT &#x27;&#x27; AFTER RESUME</span><br><span class="line"></span><br><span class="line"># 显示表结构</span><br><span class="line">DESC emp</span><br><span class="line"></span><br><span class="line"># 修改job长度</span><br><span class="line">ALTER TABLE emp MODIFY job VARCHAR(60) NOT NULL DEFAULT &#x27;&#x27;</span><br><span class="line"></span><br><span class="line"># 删除列</span><br><span class="line">ALTER TABLE emp DROP sex</span><br><span class="line"></span><br><span class="line"># 修改表名</span><br><span class="line">RENAME TABLE emp TO employee</span><br><span class="line"></span><br><span class="line"># 修改表的字符集</span><br><span class="line">ALTER TABLE employee CHARACTER SET utf8</span><br><span class="line"></span><br><span class="line"># 修改列名</span><br><span class="line">ALTER TABLE employee CHANGE &#x27;name&#x27; user_name VARCHAR(64) NOT NULL DEFAULT &#x27;&#x27;</span><br></pre></td></tr></table></figure><h4 id="数据库CRUD语句"><a href="#数据库CRUD语句" class="headerlink" title="数据库CRUD语句"></a>数据库CRUD语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 使用INSERT语句向表中插入数据</span><br><span class="line">CREATE TABLE &#x27;goods&#x27;(</span><br><span class="line">id INT,</span><br><span class="line">    goods_name VARCHAR(10),</span><br><span class="line">    price DOUBLE</span><br><span class="line">);</span><br><span class="line">INSERT INTO &#x27;goods&#x27; (id, goods_name, price) VALUES (10, &#x27;华为手机&#x27;, 2000);</span><br><span class="line">INSERT INTO &#x27;goods&#x27; (id, goods_name, price) VALUES (20, &#x27;苹果手机&#x27;, 20000);</span><br><span class="line"></span><br><span class="line"># INSERT语句的细节</span><br><span class="line">-- 插入的数据应与字段的数据类型相同，比如把&#x27;abc&#x27;添加到int类型会错误。</span><br><span class="line">-- 数据的长度应在列的规定范围内，不能将一个长度为80的字符串加入到长度为40的列中。</span><br><span class="line">-- 在VALUES中列出的数据位置必须与被加入的列的排列位置相对应。</span><br><span class="line">-- 字符和日期类型应包含在单引号中</span><br><span class="line">-- 列可以插入空值，前提是该字段允许为空（没有NOT NULL）</span><br><span class="line">-- INSERT INTO TABLE_NAME (列名) VALUES (),(),()，添加多条数据一次性</span><br><span class="line">-- 如果是给表中的所有字段添加数据，(id, goods_name, price)这个可以省略</span><br><span class="line">-- 默认值的使用，当不给某个字段赋值时，如果有默认值就会添加，否则报错。</span><br><span class="line">-- 如果我们希望指定某个列的默认值，可以在创建表时指定。</span><br><span class="line">CREATE TABLE &#x27;goods2&#x27;(</span><br><span class="line">id INT,</span><br><span class="line">    goods_name VARCHAR(10),</span><br><span class="line">    price DOUBLE NOT NULL DEFAULT 100</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 演示update语句</span><br><span class="line">-- employee是表名，salary是列名</span><br><span class="line">-- 将所有员工薪水修改为5000，如果没有带where条件，会修改所有的记录，因此要小心</span><br><span class="line">UPDATE employee SET salary = 5000 </span><br><span class="line">-- 将姓名为小妖怪的员工薪水修改为3000</span><br><span class="line">UPDATE employee SET salary = 3000 WHERE user_name = &#x27;小妖怪&#x27;</span><br><span class="line">-- 将老妖怪的薪水在原有基础上增加1000</span><br><span class="line">INSERT INTO employee VALUES(200, &#x27;老妖怪&#x27;, &#x27;1990-11-11&#x27;, &#x27;2000-11-11 10:10:10&#x27;, &#x27;捶背的&#x27;, 5000,  &#x27;给大王捶背的&#x27;);</span><br><span class="line">UPDATE employee SET salary = salary + 1000 WHERE user_name = &#x27;老妖怪&#x27;</span><br><span class="line">UPDATE employee SET salary = salary + 1000, job = &#x27;出主意的&#x27; WHERE user_name = &#x27;老妖怪&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 演示delete语句</span><br><span class="line">-- 删除表中名称为‘老妖怪’的记录</span><br><span class="line">DELETE FROM employee WHERE user_name = &#x27;老妖怪&#x27;;</span><br><span class="line">-- 删除表中所有记录</span><br><span class="line">DELETE FROM employee</span><br><span class="line">-- DELETE删除不了一列的值，但可以使用UPDATE语句置为null</span><br><span class="line">UPDATE employee SET job = NULL WHERE user_name = &#x27;老妖怪&#x27;;</span><br><span class="line">-- 要删除这个表</span><br><span class="line">DROP TABLE employee</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">-- select指定查询哪些列的数据</span><br><span class="line">-- *代表查询所有列</span><br><span class="line">-- from指定查询哪张表</span><br><span class="line">-- DISTINCT可选，指显示结果时，是否去掉重复数据</span><br><span class="line">CREATE TABLE student(</span><br><span class="line">id INT NOT NULL DEFAULT 1,</span><br><span class="line">    NAME VARCHAR(20) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">    chinese FLOAT NOT NULL DEFAULT 0.0,</span><br><span class="line">    english FLOAT NOT NULL DEFAULT 0.0,</span><br><span class="line">    math FLOAT NOT NULL DEFAULT 0.0</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(1, &#x27;韩顺平&#x27;, 89, 78, 90);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(2, &#x27;张飞&#x27;, 67, 98, 56);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(3, &#x27;宋江&#x27;, 87, 78, 77);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(4, &#x27;关羽&#x27;, 88, 98, 90);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(5, &#x27;赵云&#x27;, 82, 84, 67);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(6, &#x27;欧阳锋&#x27;, 55, 85, 45);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(7, &#x27;黄蓉&#x27;, 75, 65, 30);</span><br><span class="line"></span><br><span class="line">SELECT * FROM student;</span><br><span class="line"></span><br><span class="line">-- 查寻表中所有学生的信息</span><br><span class="line">SELECT * FROM student;</span><br><span class="line"></span><br><span class="line">-- 查询表中所有学生的姓名和对应的英语成绩</span><br><span class="line">SELECT &#x27;NAME&#x27;, english FROM student;</span><br><span class="line"></span><br><span class="line">-- 过滤表中重复数据distinct</span><br><span class="line">-- 要查询的记录每个字段都相同，才会去重</span><br><span class="line">SELECT DISTINCT english FROM student;</span><br><span class="line"></span><br><span class="line">-- 统计每个学生的总分</span><br><span class="line">SELECT &#x27;NAME&#x27;, (chinese + english + math) FROM student;</span><br><span class="line"></span><br><span class="line">-- 在所有学生总分加10分</span><br><span class="line">SELECT &#x27;NAME&#x27;, (chinese + english + math + 10) FROM student;</span><br><span class="line"></span><br><span class="line">-- 使用别名表示学生分数</span><br><span class="line">SELECT &#x27;NAME&#x27;, (chinese + english + math + 10) AS total_score FROM student;</span><br><span class="line">SELECT &#x27;NAME&#x27; AS &#x27;名字&#x27;, (chinese + english + math + 10) AS total_score FROM student;</span><br><span class="line"></span><br><span class="line">-- 查询姓名为赵云的学生成绩</span><br><span class="line">SELECT * FROM student WHERE &#x27;NAME&#x27; = &#x27;赵云&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询英语成绩大于90分的同学</span><br><span class="line">SELECT * FROM student WHERE english &gt; 90;</span><br><span class="line"></span><br><span class="line">-- 查询总分大于200分的所有同学</span><br><span class="line">SELECT * FROM student WHERE (chinese + english + math) &gt; 200;</span><br><span class="line"></span><br><span class="line">-- 查询math大于60并且id大于4的学生成绩</span><br><span class="line">SELECT * FROM student WHERE math &gt; 60 AND id &gt; 4;</span><br><span class="line"></span><br><span class="line">-- 查询英语成绩大于语文成绩的同学</span><br><span class="line">SELECT * FROM student WHERE english &gt; chinese;</span><br><span class="line"></span><br><span class="line">-- 查询总分大于200分并且数学成绩小于语文成绩的姓韩的学生</span><br><span class="line">-- 韩% 表示名字以韩开头的就可以</span><br><span class="line">SELECT * FROM student WHERE (chinese + english + math) &gt; 200 AND </span><br><span class="line">  math &lt; chinese AND &#x27;NAME&#x27; LIKE &#x27;韩%&#x27;;</span><br><span class="line">  </span><br><span class="line">-- 查询英语分数在80-90之间的同学</span><br><span class="line">SELECT * FROM student WHERE english &gt;= 80 AND english &lt;= 90;</span><br><span class="line">SELECT * FROM student WHERE english BETWWWN 80 AND 90; -- BETWEEN AND 是闭区间</span><br><span class="line"></span><br><span class="line">-- 查询数学分数为89，90，91的同学</span><br><span class="line">SELECT * FROM student WHERE math = 89 OR math = 90 OR math = 91;</span><br><span class="line">SELECT * FROM student WHERE math IN (89, 90, 91);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;DAY1&quot;&gt;&lt;a href=&quot;#DAY1&quot; class=&quot;headerlink&quot; title=&quot;DAY1&quot;&gt;&lt;/a&gt;&lt;code&gt;DAY1&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;使用指令创建数据库：CREATE DATABASE zcl_db01;&lt;/p&gt;
&lt;p&gt;删除数据库指</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux 高性能服务器--第五章</title>
    <link href="http://zcl0219.github.io/2023/08/27/Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <id>http://zcl0219.github.io/2023/08/27/Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%AC%AC%E4%BA%94%E7%AB%A0/</id>
    <published>2023-08-27T04:45:48.000Z</published>
    <updated>2023-11-08T18:52:29.127Z</updated>
    
    <content type="html"><![CDATA[<h4 id="5-1-1-判断主机是小端字节序还是大端字节序"><a href="#5-1-1-判断主机是小端字节序还是大端字节序" class="headerlink" title="5.1.1 判断主机是小端字节序还是大端字节序"></a>5.1.1 判断主机是小端字节序还是大端字节序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">byteOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">short</span> value;</span><br><span class="line">        <span class="type">char</span> union_bytes[<span class="built_in">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    &#125;test;</span><br><span class="line">    </span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span>(test.union_bytes[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; test.union_bytes[<span class="number">1</span>] == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端字节序\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(test.union_bytes[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; test.union_bytes[<span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端字节序\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不清楚\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">byteOrder</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-3专用socket地址"><a href="#5-1-3专用socket地址" class="headerlink" title="5.1.3专用socket地址"></a>5.1.3专用<code>socket</code>地址</h4><p><code>TCP/IP</code>协议族有<code>sockaddr_in</code>和<code>sockaddr_in6</code>两个专用<code>socket</code>地址结构体，他们分别用于<code>IPv4</code>和<code>IPv6</code>，这里我只介绍<code>sockaddr_in</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;  <span class="comment">// 地址族：AF_INET</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin_port;<span class="comment">// 端口号：要用网络字节序表示</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;<span class="comment">// IPv4地址结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span>&#123;</span><br><span class="line">    <span class="type">u_int32_t</span> s_addr;<span class="comment">// 要用网络字节序表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：所有专用<code>socket</code>地址类型的变量在实际使用时都需要转换为通用<code>socket</code>地址类型<code>sockaddr</code>（强制转换即可），因为所有<code>socket</code>编程接口使用的地址参数的类型都是<code>sockaddr</code>。</p><h4 id="5-1-4IP地址转换函数"><a href="#5-1-4IP地址转换函数" class="headerlink" title="5.1.4IP地址转换函数"></a>5.1.4<code>IP</code>地址转换函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span>;<span class="comment">// 用于将字符串表示的IP地址转换为用网络字节序整数表示的IP地址</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> cnt)</span></span>;<span class="comment">// 最后一个参数指定目标存储单元的大小，这两个宏可以帮我们指定</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">inet_pton成功时返回1，失败时返回0并设置errno</span></span><br><span class="line"><span class="comment">inet_ntop成功时返回目标存储单元的地址，失败返回NULL并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET6_ADDRSTRLEN 64</span></span><br></pre></td></tr></table></figure><h4 id="5-2创建socket"><a href="#5-2创建socket" class="headerlink" title="5.2创建socket"></a>5.2创建socket</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">domain一般为PF_INET(IPv4)，或者PF_INET6(IPv6)</span></span></span><br><span class="line"><span class="comment"><span class="function">type参数指定服务类型，主要有SOCK_STREAM和SOCK_UGRAM</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span> </span></span><br></pre></td></tr></table></figure><p>socket系统调用成功时返回一个socket文件描述符，失败返回-1并设置errno</p><h4 id="5-3命名socket"><a href="#5-3命名socket" class="headerlink" title="5.3命名socket"></a>5.3命名socket</h4><p>创建socket时，我们给它指定了地址族，但是并未指定使用该地址族中的哪个具体socket地址。将一个socket与socket地址绑定称为给socket命名。在服务器程序中，我们通常需要命名socket，<strong>因为只有命名后客户端才知道该如何连接它</strong>。客户端通常不需要命名socket，而是采用匿名方式，也就是使用操作系统自动分配的socket地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* my_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bind将my_addr所指的socket地址分配给未命名的socket文件描述符，addrlen参数指出该socket地址的长度</span></span><br><span class="line"><span class="comment">bind成功时返回0，失败时返回-1并设置errno，其中两种常见的errno是：EACCES和EADDRINUSE。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="5-4监听socket"><a href="#5-4监听socket" class="headerlink" title="5.4监听socket"></a>5.4监听socket</h4><p>socket被命名之后，还不能立即接收客户端连接，我们需要使用如下系统调用来创建一个监听队列以存放待处理的客户连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sockfd参数指定被监听的socket，backlog参数提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客户端连接，客户端也将收到ECONNREFUSED错误信息。（实际上最多可以接收backlog + 1个客户端连接）</span></span><br><span class="line"><span class="comment">listen成功时返回0，失败时返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>下面我们编写一个程序测试一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">basename使用示例：</span></span><br><span class="line"><span class="comment">`basename()` 是一个常用于处理文件路径和程序参数的库函数。</span></span><br><span class="line"><span class="comment">它的主要目的是从一个给定的路径中提取基础名（base name），也就是最后一部分的名称，不包含任何前导的目录。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">来自 `&lt;libgen.h&gt;`（或在某些系统中是 `&lt;string.h&gt;` 或 `&lt;strings.h&gt;`），`basename()` 函数的原型如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">char *basename(char *path);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">让我们看一些使用 `basename()` 的例子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 输入 `/home/user/documents/file.txt` 返回 `file.txt`</span></span><br><span class="line"><span class="comment">2. 输入 `/home/user/documents/folder/` 返回 `folder`</span></span><br><span class="line"><span class="comment">3. 输入 `/home/user/documents/` 返回 `documents`</span></span><br><span class="line"><span class="comment">4. 输入 `file.txt` 返回 `file.txt`</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在给出的代码示例中：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">printf(&quot;usage: %s ip_address port_num backlog\n&quot;, basename(argv[0]));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">`argv[0]` 通常是程序的名称，包括它被执行时的完整路径。</span></span><br><span class="line"><span class="comment">使用 `basename()` 函数，你可以仅提取程序的实际名称，而不包括其路径，这在显示帮助或错误消息时特别有用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">举个例子，假设程序的完整路径是 `/home/user/my_program`，那么 `basename(argv[0])` 就会返回 `my_program`。这样，上述的 `printf` 语句将输出：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">usage: my_program ip_address port_num backlog</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">需要注意的是，`basename()` 函数可能会修改其参数，也可能返回一个指向静态存储区的指针。</span></span><br><span class="line"><span class="comment">因此，如果原始路径字符串不应被修改，那么在调用 `basename()` 之前，最好先复制这个字符串。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">term_handler</span><span class="params">(<span class="type">int</span> sig)</span>&#123;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    signal(SIGTERM, term_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_num backlog\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sockfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sign = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    server_addr.sin_family = PF_INET;</span><br><span class="line">    server_addr.sin_port = htons(port);</span><br><span class="line">    inet_pton(PF_INET, ip, &amp;server_addr.sin_addr);</span><br><span class="line"></span><br><span class="line">    sign = bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    assert(sign != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    sign = listen(sockfd, <span class="number">5</span>);</span><br><span class="line">    assert(sign != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果忘记截图了，大家可以自己试一下，具体步骤</span></span><br><span class="line"><span class="comment">./test 172.30.78.145 8000 5</span></span><br><span class="line"><span class="comment">另开终端多次telnet 172.30.78.145 8000</span></span><br><span class="line"><span class="comment">netstat -nt | grep 8000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个命令组合使用了两个命令：<code>netstat</code> 和 <code>grep</code>，并通过管道（<code>|</code>）将第一个命令的输出作为第二个命令的输入。我会为你逐步解释它：</p><ol><li><p><strong><code>netstat -nt</code></strong>:</p><ul><li><code>netstat</code>: 这是一个命令行工具，用于显示网络状态，包括网络连接、路由表、接口统计等。</li><li><code>-n</code>: 表示以数字形式显示地址和端口号，而不是尝试解析它们的名称。</li></ul></li></ol><ul><li><code>-t</code>: 仅显示TCP连接。</li></ul><p>因此，<code>netstat -nt</code> 的输出会列出系统上所有活动的TCP连接，同时显示它们的源和目标IP地址以及端口号，并直接显示数字而不进行名称解析。</p><ol start="2"><li><strong><code>|</code></strong>:</li></ol><ul><li>这是一个管道操作符，用于将前一个命令的输出作为后一个命令的输入。</li></ul><ol start="3"><li><p><strong><code>grep 8000</code></strong>:</p><ul><li><code>grep</code>: 是一个强大的文本搜索工具，用于搜索匹配的字符串。</li><li><code>8000</code>: 是你想在 <code>netstat</code> 的输出中搜索的字符串。</li></ul><p>这个命令会从 <code>netstat</code> 的输出中筛选出所有包含 “8000” 的行，这通常意味着你正在查找与端口 <code>8000</code> 相关的所有活动连接。</p></li></ol><p>综上所述，<code>netstat -nt | grep 8000</code> 会显示所有在端口 <code>8000</code> 上的活动TCP连接。</p><h4 id="5-5接受连接"><a href="#5-5接受连接" class="headerlink" title="5.5接受连接"></a>5.5接受连接</h4><p>代码：接受一个异常的连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libgen.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;运行程序，需输入这三个参数：%s, ip_address, port_num\n&quot;</span>, <span class="built_in">basename</span>(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = <span class="built_in">ntohs</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(sock, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">    <span class="type">socklen_t</span> client_len = <span class="built_in">sizeof</span>(client);</span><br><span class="line">    <span class="type">int</span> connfd = <span class="built_in">accept</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;client_len);</span><br><span class="line">    <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">char</span> remote[INET_ADDRSTRLEN];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>, <span class="built_in">inet_ntop</span>(AF_INET, &amp;client.sin_addr, remote, client_len),</span><br><span class="line">                <span class="built_in">ntohs</span>(client.sin_port));</span><br><span class="line">        <span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、第一次运行报错，<code>undefined reference to main</code>，这种情况一般有三种可能：</p><ul><li>没有定义main函数</li><li>main函数的main拼写错误</li><li>刚写的代码忘记保存了</li></ul><p>2、<code>accept</code>函数是阻塞的，上述代码即服务器端运行的时候，会阻塞在<code>accept</code>处，一旦客户端请求建立连接，服务器立马终止程序。注意<code>accept</code>只是从<code>listen</code>监听队列中取出连接，它不会理会客户端处于什么状态。</p><p>3、一直在思考<code>select/poll/epoll</code>这些有什么用。首先因为listen是有监听队列的，劣势就在于只能一个个处理，并且同时接入的连接数有限。比如队列长度为5，处理完一个，再建立下一个连接，这样如果某一个连接处理很长时间一直阻塞在那里，就导致后面的新请求连接建立超时。很直观的想法是<code>fork</code>新进程或者创建新线程来处理新连接，每来一个连接我就创建一个来跟他对接。这样资源消耗太大。因此就有了<code>select/poll/epoll</code>，先把连接建立起来并放进文件描述符，最后从这里面寻找哪些发生了可读可写事件，也避免了因为读写事件造成的阻塞（没有数据到来就阻塞了）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;5-1-1-判断主机是小端字节序还是大端字节序&quot;&gt;&lt;a href=&quot;#5-1-1-判断主机是小端字节序还是大端字节序&quot; class=&quot;headerlink&quot; title=&quot;5.1.1 判断主机是小端字节序还是大端字节序&quot;&gt;&lt;/a&gt;5.1.1 判断主机是小端字节序还</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++内存管理</title>
    <link href="http://zcl0219.github.io/2023/08/27/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://zcl0219.github.io/2023/08/27/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2023-08-27T03:48:36.000Z</published>
    <updated>2023-08-28T01:05:57.661Z</updated>
    
    <content type="html"><![CDATA[<p>有关C++内存管理问题总结如下</p><h3 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h3><h4 id="C-中堆和栈的区别是什么"><a href="#C-中堆和栈的区别是什么" class="headerlink" title="C++中堆和栈的区别是什么"></a><code>C++</code>中堆和栈的区别是什么</h4><ol><li>栈由系统分配释放，栈上变量的生命周期是确定的，一般与作用域有关。栈的地址由高到低，栈上分配的空间大小在编译时通常已知。</li><li>堆由程序员手动开辟释放，堆上的变量除非被显示释放，否则会持续存在。堆的地址由低到高，堆上几乎可以分配任意大小的内存块，但可能会造成内存碎片。</li><li>这里说一下<code>C++</code>的内存分区：堆区、栈区、<code>data</code>区、<code>bss</code>段、代码段。数据<code>data</code>区存放的是静态变量和初始化的全局变量，<code>bss</code>段存放的是未初始化的全局变量。</li></ol><h4 id="什么是RAII？为什么它在C-中很重要"><a href="#什么是RAII？为什么它在C-中很重要" class="headerlink" title="什么是RAII？为什么它在C++中很重要"></a>什么是<code>RAII</code>？为什么它在<code>C++</code>中很重要</h4><p><code>RAII</code>是一种编程思想和设计模式，核心思想是：将资源的获取与对象的初始化捆绑在一起，将资源的释放与对象的销毁捆绑在一起。这样，资源管理就与对象的生命周期紧密关联。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::fstream fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">File</span>(<span class="type">const</span> std::string&amp; filename) &#123;</span><br><span class="line">        fs.<span class="built_in">open</span>(filename, std::ios::in | std::ios::out);</span><br><span class="line">        <span class="keyword">if</span> (!fs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to open the file&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他与文件相关的操作...</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">File</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (fs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            fs.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">File <span class="title">myFile</span><span class="params">(<span class="string">&quot;sample.txt&quot;</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 进行文件操作...</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当myFile对象离开其作用域时，它的析构函数会自动被调用，从而关闭文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释new和delete，与malloc和free的区别"><a href="#解释new和delete，与malloc和free的区别" class="headerlink" title="解释new和delete，与malloc和free的区别"></a>解释<code>new</code>和<code>delete</code>，与<code>malloc</code>和<code>free</code>的区别</h4><ul><li><p>属性的区别</p><p><code>new/delete</code>：这两个是<code>C++</code>中的关键字；</p><p><code>malloc/free</code>：这两个是库函数；</p></li><li><p>使用上的区别</p><p><code>malloc</code>：申请空间需要显式填入申请内存的大小；</p><p><code>new</code>：无需显式填入申请内存的大小，<code>new</code>会根据<code>new</code>的类型分配内存；</p></li><li><p>返回类型的区别</p><p><code>new</code>操作符内存分配成功，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，故<code>new</code>是符合类型安全性的操作符。</p><p><code>malloc</code>内存分配成功返回的是<code>void*</code>指针，需要通过强制类型转换，转换成我们需要的类型。</p><p>所以<code>C++</code>中<code>new</code>比<code>malloc</code>安全可靠。</p></li><li><p>分配失败的区别</p><p><code>malloc</code>分配失败会返回<code>NULL</code>，我们可以通过判断返回值是否是<code>NULL</code>得知是否分配成功。</p><p><code>new</code>分配失败会抛出<code>bad_alloc</code>异常。</p></li><li><p>扩张内存的区别</p><p><code>malloc</code>有内存扩张机制（通过<code>realloc</code>实现）。</p><p><code>new</code>没有扩张内存机制。</p></li></ul><h3 id="中级问题"><a href="#中级问题" class="headerlink" title="中级问题"></a>中级问题</h3><h4 id="为什么C-推荐使用智能指针，如shared-ptr和unique-ptr"><a href="#为什么C-推荐使用智能指针，如shared-ptr和unique-ptr" class="headerlink" title="为什么C++推荐使用智能指针，如shared_ptr和unique_ptr"></a>为什么<code>C++</code>推荐使用智能指针，如<code>shared_ptr</code>和<code>unique_ptr</code></h4><ul><li>自动管理内存：对于<code>unique_ptr</code>，当它超出作用域或者被重新分配时，它指向的对象会被删除。对于<code>shared_ptr</code>，当它的引用计数为0时，它指向的对象会被删除。</li><li>异常安全：当函数抛出异常，智能指针确保资源被正确清理，避免资源泄露。</li><li>防止悬挂指针：悬挂指针是指指向已经释放内存的指针。<code>unique_ptr</code>和<code>shared_ptr</code>可以减少悬挂指针的风险，因为他们确保在没有引用的时候释放资源。</li></ul><h4 id="你能解释shared-ptr中的引用计数机制是如何工作的吗"><a href="#你能解释shared-ptr中的引用计数机制是如何工作的吗" class="headerlink" title="你能解释shared_ptr中的引用计数机制是如何工作的吗"></a>你能解释<code>shared_ptr</code>中的引用计数机制是如何工作的吗</h4><ul><li>通过一个指针实现引用计数功能，加锁，保证线程安全</li></ul><h4 id="什么情况下会导致内存泄漏，你如何检测和预防"><a href="#什么情况下会导致内存泄漏，你如何检测和预防" class="headerlink" title="什么情况下会导致内存泄漏，你如何检测和预防"></a>什么情况下会导致内存泄漏，你如何检测和预防</h4><ul><li><p>指针重新赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line"><span class="type">int</span> *np = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line">p = np;</span><br><span class="line"><span class="comment">//p原来的指向的内存无法释放，因为现在没有指针指向这块内存</span></span><br></pre></td></tr></table></figure></li><li><p>错误的内存释放</p><p>假设有一个指针<code>p</code>指向10字节的内存，该内存的第三个字节<code>np</code>又指向某个动态分配的内存， 如果此时你直接<code>delete(p)</code>，则会导致<code>np</code>指向的内存无法释放。</p></li><li><p>返回值的不正确处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于没有对函数f()的返回值做正确接收，将会导致f函数分配的内存无法释放。</span></span><br></pre></td></tr></table></figure></li></ul><p>关于内存泄露可以使用工具：<code>Valgrind</code>。</p><h3 id="高级问题"><a href="#高级问题" class="headerlink" title="高级问题"></a>高级问题</h3><h4 id="描述C-的内存模型是什么？如何保证线程间的数据同步？"><a href="#描述C-的内存模型是什么？如何保证线程间的数据同步？" class="headerlink" title="描述C++的内存模型是什么？如何保证线程间的数据同步？"></a>描述C++的内存模型是什么？如何保证线程间的数据同步？</h4><h4 id="什么是内存屏障-memory-barrier-或内存栅栏？在哪些场景中需要使用它？"><a href="#什么是内存屏障-memory-barrier-或内存栅栏？在哪些场景中需要使用它？" class="headerlink" title="什么是内存屏障(memory barrier)或内存栅栏？在哪些场景中需要使用它？"></a>什么是内存屏障(memory barrier)或内存栅栏？在哪些场景中需要使用它？</h4><h4 id="你有没有用过定制的内存分配器，比如为某些高性能的应用场景？如果有，请描述其工作原理和使用场景。"><a href="#你有没有用过定制的内存分配器，比如为某些高性能的应用场景？如果有，请描述其工作原理和使用场景。" class="headerlink" title="你有没有用过定制的内存分配器，比如为某些高性能的应用场景？如果有，请描述其工作原理和使用场景。"></a>你有没有用过定制的内存分配器，比如为某些高性能的应用场景？如果有，请描述其工作原理和使用场景。</h4><h3 id="实践问题"><a href="#实践问题" class="headerlink" title="实践问题"></a>实践问题</h3><h4 id="描述一个你曾遇到的复杂的内存相关bug，你是如何诊断和解决的？"><a href="#描述一个你曾遇到的复杂的内存相关bug，你是如何诊断和解决的？" class="headerlink" title="描述一个你曾遇到的复杂的内存相关bug，你是如何诊断和解决的？"></a>描述一个你曾遇到的复杂的内存相关bug，你是如何诊断和解决的？</h4><h4 id="你如何评估一个C-程序的内存使用效率？你使用过哪些工具或技术"><a href="#你如何评估一个C-程序的内存使用效率？你使用过哪些工具或技术" class="headerlink" title="你如何评估一个C++程序的内存使用效率？你使用过哪些工具或技术"></a>你如何评估一个C++程序的内存使用效率？你使用过哪些工具或技术</h4><h4 id="请编写一个小程序，其中创建一个有资源泄漏的类，然后展示如何使用工具或方法找到并修复该泄漏。"><a href="#请编写一个小程序，其中创建一个有资源泄漏的类，然后展示如何使用工具或方法找到并修复该泄漏。" class="headerlink" title="请编写一个小程序，其中创建一个有资源泄漏的类，然后展示如何使用工具或方法找到并修复该泄漏。"></a>请编写一个小程序，其中创建一个有资源泄漏的类，然后展示如何使用工具或方法找到并修复该泄漏。</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有关C++内存管理问题总结如下&lt;/p&gt;
&lt;h3 id=&quot;基础问题&quot;&gt;&lt;a href=&quot;#基础问题&quot; class=&quot;headerlink&quot; title=&quot;基础问题&quot;&gt;&lt;/a&gt;基础问题&lt;/h3&gt;&lt;h4 id=&quot;C-中堆和栈的区别是什么&quot;&gt;&lt;a href=&quot;#C-中堆和栈的区别是</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>单例懒汉模式</title>
    <link href="http://zcl0219.github.io/2023/08/25/%E5%8D%95%E4%BE%8B%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zcl0219.github.io/2023/08/25/%E5%8D%95%E4%BE%8B%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-08-25T03:31:52.000Z</published>
    <updated>2023-08-25T03:35:53.069Z</updated>
    
    <content type="html"><![CDATA[<p>话不多说，直接上代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//双重检查锁定模式</span></span><br><span class="line">    <span class="comment">//这样做的目的是，如果实例已经被创建，可以避免每次加锁解锁的操作，提高性能</span></span><br><span class="line">    <span class="comment">//但看文字可能不好理解，这里给出不是双重检查锁定模式就好理解了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    static Singleton&amp; getInstance()&#123;</span></span><br><span class="line"><span class="comment">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</span></span><br><span class="line"><span class="comment">        if(instance_ == nullptr)&#123;</span></span><br><span class="line"><span class="comment">            instance_ = new Singleton();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return *instance_;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    这种写法性能非常低下，因为每次调用instance()都会加锁释放锁，而这个步骤只有在第一次new Singleton()才是有必要的。</span></span><br><span class="line"><span class="comment">    只要p被创建出来了，不管多少线程同时访问，使用if (p == nullptr) 进行判断都是足够的（只是读操作，不需要加锁），没有线程安全问题，</span></span><br><span class="line"><span class="comment">    加了锁之后反而存在性能问题。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance_ == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(instance_ == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                instance_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *instance_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::mutex mutex_;</span><br><span class="line">    <span class="type">static</span> Singleton *instance_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::mutex Singleton::mutex_;</span><br><span class="line">Singleton* Singleton::instance_ = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p><strong>问题</strong></p><p>构造析构为什么要私有</p><p>解答：</p><p>在单例模式中，构造函数和析构函数被设置为私有的原因是为了确保满足单例模式的核心要求：系统中某个类只能存在一个实例。</p><p>通过将构造函数和析构函数设为私有，我们可以确保以下几点：</p><ol><li><p><strong>外部无法实例化</strong>：由于构造函数是私有的，这意味着不能在类的外部直接创建该类的实例。这确保了实例的创建只能通过单例类提供的某些特定方法（如<code>getInstance</code>）来完成，从而控制实例的数量。</p></li><li><p><strong>禁止复制</strong>：单例模式要确保只有一个实例存在，所以我们不希望该类的对象被复制。将构造函数设为私有可以防止复制构造，但为了进一步确保不被复制，我们通常还需要禁止拷贝构造函数和拷贝赋值操作符（通过<code>= delete</code>）。</p></li><li><p><strong>外部无法销毁</strong>：将析构函数设为私有可以确保外部代码无法直接删除单例对象。通常，单例对象在程序结束时自动销毁，或者单例类提供了一个专门的方法来手动销毁它。</p></li><li><p><strong>继承控制</strong>：由于构造函数和析构函数是私有的，这也意味着这个类不能被继承（因为派生类的构造函数需要调用基类的构造函数）。</p></li></ol><p>综上所述，将构造函数和析构函数设为私有是为了确保满足单例模式的设计原则，即系统中该类只有一个实例，并提供对该实例的全局访问点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;话不多说，直接上代码&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>日志模块设计</title>
    <link href="http://zcl0219.github.io/2023/08/25/%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/"/>
    <id>http://zcl0219.github.io/2023/08/25/%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/</id>
    <published>2023-08-25T02:45:23.000Z</published>
    <updated>2023-08-25T02:57:50.778Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本篇文章主要参考如下文章，主要是对代码做一个较为详尽的解释</strong></p><p>参考链接：<a href="https://blog.csdn.net/qq_46495964/article/details/122952567">https://blog.csdn.net/qq_46495964/article/details/122952567</a></p><p><strong>前言：</strong><br>日志系统在程序运行中有着非常大的作用，用于记录程序的运行情况，在程序出错后查看日志，方便地定位出错的大概范围。在设计日志系统之前，先考虑一下日志需要输出什么信息呢？什么信息才是有用的信息，都知道写日志是一种对文件的<code>io</code>操作，所以尽可能避免输出没用的信息。<br><strong>有用的信息：关键变量的值、运行的位置（哪个文件、哪个函数、哪一行）、时间、线程号、进程号等等。</strong></p><h4 id="日志系统的设计"><a href="#日志系统的设计" class="headerlink" title="日志系统的设计"></a>日志系统的设计</h4><ol><li><p>日志的级别</p><p>在测试、调试、交付等场景需要输出不同的级别日志。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见的日志级别</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LOGLEVEL</span></span><br><span class="line">&#123;</span><br><span class="line">LOG_LEVEL_NONE,</span><br><span class="line">LOG_LEVEL_ERROR,     <span class="comment">// error</span></span><br><span class="line">LOG_LEVEL_WARNING,   <span class="comment">// warning</span></span><br><span class="line">LOG_LEVEL_DEBUG,     <span class="comment">// debug</span></span><br><span class="line">LOG_LEVEL_INFO,      <span class="comment">// info</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>日志的输出地</p><p>日志输出的地方可能不同，终端、控制台、UI界面、文件等等都有。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">LOGTARGET</span></span><br><span class="line">&#123;</span><br><span class="line">LOG_TERM      = <span class="number">0x00</span>,</span><br><span class="line">LOG_FILE      = <span class="number">0x01</span>,</span><br><span class="line">LOG_UI        = <span class="number">0x10</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>日志的作用域</p><p>日志做到什么时候都可以输出，可作用于全程序文件，考虑到多线程情况下，必须保证日志的输出需要得到线程安全的保障，所以需要一个<strong>全局且唯一的日志器</strong>。使用设计模式中的<strong>单例模式—–日志器</strong></p></li></ol><h4 id="C-版本的日志系统的实现"><a href="#C-版本的日志系统的实现" class="headerlink" title="C++版本的日志系统的实现"></a>C++版本的日志系统的实现</h4><p><strong>Logger.h</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">这是一个基本的线程安全日志系统的头文件，其目的是为应用程序提供日志功能。以下是对这个头文件的详细解释：</span><br><span class="line"></span><br><span class="line">1. **预处理指令和宏**:</span><br><span class="line">    - `<span class="comment">#ifndef`, `#define`, 和 `#endif` 用于保证头文件只被包含一次，避免重复定义。</span></span><br><span class="line">    - `<span class="comment">#define` 宏定义了三个日志级别：`LogInfo`, `LogWarning`, 和 `LogError`。这些宏都使用了变参（`...`），允许用户为日志提供自定义的格式和参数。这些宏捕获了日志消息的来源（文件、行号和函数）并将其添加到日志队列中。</span></span><br><span class="line"></span><br><span class="line">2. **类定义：Logger**</span><br><span class="line">    - 是一个单例类，这意味着整个程序中只能有一个实例。这通过私有的默认构造函数、删除的复制构造函数和赋值运算符来实现。</span><br><span class="line">    - `GetInstance()` 方法提供了对单例实例的访问。</span><br><span class="line">    - `SetFileName()` 允许设置日志文件的名称。</span><br><span class="line">    - `Start()` 和 `Stop()` 用于启动和停止日志线程。</span><br><span class="line">    - `AddToQueue()` 是用于将新的日志消息添加到日志队列的方法。</span><br><span class="line">    - `threadfunc()` 是日志线程的工作函数，它持续从日志队列中读取消息并写入文件。</span><br><span class="line"></span><br><span class="line">3. **类的私有成员**:</span><br><span class="line">    - `filename_`: 存储日志文件的名称。</span><br><span class="line">    - `fp_`: 用于文件操作的文件指针。请注意，在所给代码中，`FILE` 的声明被注释掉了，你需要包含 `&lt;cstdio&gt;` 或者直接使用 C++ 的文件流类（如 `std::ofstream`）。</span><br><span class="line">    - `spthread_`: 一个智能指针，指向日志线程。</span><br><span class="line">    - `mutex_`: 用于保护日志队列和其他共享资源，确保多线程访问时的线程安全。</span><br><span class="line">    - `cv_`: 条件变量，用于通知日志线程有新的消息到来。</span><br><span class="line">    - `exit_`: 一个标志，指示日志线程何时退出。</span><br><span class="line">    - `queue_`: 存储待处理日志消息的队列。</span><br><span class="line"></span><br><span class="line">4. **注释**: </span><br><span class="line">    - 提供了关于该文件的基本信息，如文件名称和日期。</span><br><span class="line"></span><br><span class="line">总之，这个日志系统设计的思路是：</span><br><span class="line">1. 用户调用预定义的宏添加日志消息。</span><br><span class="line">2. 日志消息被添加到一个线程安全的队列。</span><br><span class="line">3. 一个独立的日志线程从队列中取出消息并写入文件。</span><br><span class="line"></span><br><span class="line">这种设计允许应用程序非阻塞地添加日志消息，而将I/O操作留给专门的线程，从而提高应用程序的性能。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 日志类头文件, Logger.h</span></span><br><span class="line"><span class="comment"> *  2022.02.1</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LOGGER_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LOGGER_H__</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//struct FILE;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LogInfo(...)        Logger::GetInstance().AddToQueue(<span class="string">&quot;INFO&quot;</span>, __FILE__, __LINE__, __PRETTY_FUNCTION__, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LogWarning(...)     Logger::GetInstance().AddToQueue(<span class="string">&quot;WARNING&quot;</span>, __FILE__, __LINE__, __PRETTY_FUNCTION__, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LogError(...)       Logger::GetInstance().AddToQueue(<span class="string">&quot;ERROR&quot;</span>, __FILE__, __LINE__, __PRETTY_FUNCTION__, __VA_ARGS__)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetFileName</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddToQueue</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszLevel, <span class="type">const</span> <span class="type">char</span>* pszFile, <span class="type">int</span> lineNo, <span class="type">const</span> <span class="type">char</span>* pszFuncSig, <span class="type">char</span>* pszFmt, ...)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Logger</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> Logger&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    Logger&amp; <span class="keyword">operator</span> =(Logger&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadfunc</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string                     filename_;</span><br><span class="line">    FILE*                           fp_&#123;&#125;;</span><br><span class="line">    std::shared_ptr&lt;std::thread&gt;    spthread_;</span><br><span class="line">    std::mutex                      mutex_;</span><br><span class="line">    std::condition_variable         cv_;            <span class="comment">//有新的日志到来的标识</span></span><br><span class="line">    <span class="type">bool</span>                            exit_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    std::list&lt;std::string&gt;          queue_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//!__LOGGER_H__</span></span></span><br></pre></td></tr></table></figure><p>Logger.cpp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">这是日志类的实现文件`Logger.cpp`。它对`Logger.h`中定义的函数进行了具体的实现。我将分步解释这个文件的内容：</span><br><span class="line"></span><br><span class="line">1. **<span class="comment">#include语句**: 引入了所需的头文件，其中`Logger.h`是之前你展示的日志类的头文件，其他的是C和C++标准库中的头文件。</span></span><br><span class="line"></span><br><span class="line">2. **GetInstance方法**: 实现了单例模式的核心功能。通过使用局部静态对象`logger`，它确保只创建一次`Logger`类的实例。</span><br><span class="line"></span><br><span class="line">3. **SetFileName方法**: 允许用户设置日志文件的名称。</span><br><span class="line"></span><br><span class="line">4. **Start方法**: </span><br><span class="line">    - 如果用户没有提供日志文件名，它会生成一个默认的日志文件名，该文件名包含当前的日期和时间。</span><br><span class="line">    - 尝试打开日志文件以写入和读取。</span><br><span class="line">    - 创建一个新线程来处理日志消息。</span><br><span class="line"></span><br><span class="line">5. **Stop方法**: </span><br><span class="line">    - 设置`exit_`标志为`<span class="literal">true</span>`。</span><br><span class="line">    - 通过条件变量通知日志线程。</span><br><span class="line">    - 等待日志线程结束。</span><br><span class="line"></span><br><span class="line">6. **AddToQueue方法**: </span><br><span class="line">    - 使用变长参数列表格式化日志消息。</span><br><span class="line">    - 生成一个包含日期、时间、日志级别、线程ID、源文件名、行号、函数签名和日志消息的完整日志字符串。</span><br><span class="line">    - 使用互斥锁将完整的日志字符串添加到队列。</span><br><span class="line">    - 通过条件变量通知日志线程有新的消息到来。</span><br><span class="line"></span><br><span class="line">7. **threadfunc方法**:</span><br><span class="line">    - 日志线程的核心功能。</span><br><span class="line">    - 检查文件指针是否为空。</span><br><span class="line">    - 在`exit_`为`<span class="literal">false</span>`的情况下，循环处理日志消息。</span><br><span class="line">    - 使用互斥锁和条件变量等待新的消息到来。</span><br><span class="line">    - 当有新的消息时，从队列中取出并写入日志文件。</span><br><span class="line">    - 如果设置了退出标志并且队列为空，线程将退出。</span><br><span class="line"></span><br><span class="line">总体上，这是一个简单但功能完整的日志系统实现。它使用了多线程，互斥锁和条件变量来确保线程安全，并使日志操作与应用程序的其他部分异步进行，从而提高了性能。</span><br><span class="line"></span><br><span class="line">然而，也有一些可以进一步优化或改进的地方：</span><br><span class="line">1. 在`Start()`中，文件是以<span class="string">&quot;wt+&quot;</span>模式打开的，这意味着如果文件已经存在，它会被覆盖。如果希望在现有文件中追加日志，则应使用<span class="string">&quot;at+&quot;</span>。</span><br><span class="line">2. 代码中没有明确的错误处理或异常处理策略。例如，如果`fopen`失败或`std::thread`创建失败时。</span><br><span class="line">3. 在`threadfunc`中，当队列不为空时，每处理一个消息就会刷新文件，这可能影响性能。可以考虑在队列中有多个消息时，一次性写入多个消息，然后再刷新。</span><br><span class="line">4. 可能会考虑添加一个`Rotate`功能，当日志文件大小超过某个限制时，自动将当前日志文件重命名，并创建一个新的日志文件。</span><br><span class="line">5. 为了提高性能，可以考虑使用双缓冲技术，这样可以减少互斥锁的争用。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 日志类实现文件, Logger.cpp</span></span><br><span class="line"><span class="comment"> *  2022.02.1</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">Logger&amp; <span class="title">Logger::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Logger logger;</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::SetFileName</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    filename_ = filename;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Logger::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (filename_.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">tm</span>* t = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line">        <span class="type">char</span> timestr[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(timestr, <span class="string">&quot;%04d%02d%02d%02d%02d%02d.imserver.log&quot;</span>, t-&gt;tm_year + <span class="number">1900</span>, t-&gt;tm_mon + <span class="number">1</span>, t-&gt;tm_mday, t-&gt;tm_hour, t-&gt;tm_min, t-&gt;tm_sec);</span><br><span class="line">        filename_ = timestr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fp_ = <span class="built_in">fopen</span>(filename_.<span class="built_in">c_str</span>(), <span class="string">&quot;wt+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp_ == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    spthread_.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">thread</span>(std::<span class="built_in">bind</span>(&amp;Logger::threadfunc, <span class="keyword">this</span>)));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::Stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    exit_ = <span class="literal">true</span>;</span><br><span class="line">    cv_.<span class="built_in">notify_one</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//等待时间线程结束</span></span><br><span class="line">    spthread_-&gt;<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::AddToQueue</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszLevel, <span class="type">const</span> <span class="type">char</span>* pszFile, <span class="type">int</span> lineNo, <span class="type">const</span> <span class="type">char</span>* pszFuncSig, <span class="type">char</span>* pszFmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> msg[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    va_list vArgList;                            </span><br><span class="line">    <span class="built_in">va_start</span>(vArgList, pszFmt);</span><br><span class="line">    <span class="built_in">vsnprintf</span>(msg, <span class="number">256</span>, pszFmt, vArgList);</span><br><span class="line">    <span class="built_in">va_end</span>(vArgList);</span><br><span class="line"> </span><br><span class="line">    <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span>* tmstr = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line">    <span class="type">char</span> content[<span class="number">512</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;[%04d-%02d-%02d %02d:%02d:%02d][%s][0x%04x][%s:%d %s]%s\n&quot;</span>,</span><br><span class="line">                tmstr-&gt;tm_year + <span class="number">1900</span>,</span><br><span class="line">                tmstr-&gt;tm_mon + <span class="number">1</span>,</span><br><span class="line">                tmstr-&gt;tm_mday,</span><br><span class="line">                tmstr-&gt;tm_hour,</span><br><span class="line">                tmstr-&gt;tm_min,</span><br><span class="line">                tmstr-&gt;tm_sec,</span><br><span class="line">                pszLevel,</span><br><span class="line">                std::this_thread::<span class="built_in">get_id</span>(),</span><br><span class="line">                pszFile,</span><br><span class="line">                lineNo,</span><br><span class="line">                pszFuncSig,</span><br><span class="line">                msg);</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        queue_.<span class="built_in">emplace_back</span>(content);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::threadfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fp_ == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (!exit_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//写日志</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (queue_.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (exit_)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">            cv_.<span class="built_in">wait</span>(guard);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//写日志</span></span><br><span class="line">        <span class="type">const</span> std::string&amp; str = queue_.<span class="built_in">front</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">fwrite</span>((<span class="type">void</span>*)str.<span class="built_in">c_str</span>(), str.<span class="built_in">length</span>(), <span class="number">1</span>, fp_);</span><br><span class="line">        <span class="built_in">fflush</span>(fp_);</span><br><span class="line">        queue_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ol><li><p>Stop方法: 设置exit_标志为true。 通过条件变量通知日志线程。 等待日志线程结束 </p><p><strong>请问这里为什么需要通知日志线程</strong></p><p>解答：在<code>Logger</code>类的实现中，日志线程的工作是从队列中获取日志消息并将其写入文件。为了实现这个功能，它在队列为空时通过<code>cv_.wait(guard)</code>进入休眠状态，等待新的日志消息的到来。</p><p>当你调用<code>Stop</code>方法时，你希望日志线程能够尽快结束。但有一种情况需要考虑：当<code>Stop</code>被调用时，队列可能仍然是空的，这意味着日志线程可能处于<code>cv_.wait(guard)</code>的休眠状态。</p><p>在这种情况下，即使你设置了<code>exit_</code>标志为<code>true</code>，日志线程仍然不会醒来检查这个标志，因为它正在等待新的日志消息到来。</p><p>为了确保日志线程能够醒来、检查<code>exit_</code>标志并正确地退出，你需要在<code>Stop</code>方法中通过<code>cv_.notify_one()</code>通知日志线程。这样，日志线程将被唤醒，然后它可以检查<code>exit_</code>标志，并根据该标志的值决定是否退出。</p><p>总之，通知日志线程是为了确保它可以从<code>cv_.wait(guard)</code>中醒来，然后检查退出条件并安全地退出。</p></li><li><p>这个程序没有设计线程来将新的日志信息加入队列吗</p><p>从提供的代码来看，日志系统中只设计了一个专门的日志线程（在<code>Logger::Start()</code>方法中启动），其任务是从队列中提取日志消息并将其写入文件。此外，并没有为添加新日志消息到队列专门设计线程。</p><p>当你希望写入日志时，只需在你的主程序或任何其他线程中调用<code>LogInfo()</code>, <code>LogWarning()</code>, 或 <code>LogError()</code>这样的宏。这些宏内部会调用<code>Logger::AddToQueue()</code>，该方法将日志消息格式化并加入到队列中。这种设计的优点是简单且高效，因为它允许多个线程在运行时无缝地向日志系统添加消息，而无需额外的线程。</p><p>但值得注意的是，<code>Logger::AddToQueue()</code>使用了互斥锁<code>mutex_</code>来保证多个线程同时向队列添加消息时的线程安全。这意味着，即使多个线程同时调用日志宏，<code>Logger::AddToQueue()</code>中的代码仍然是线程安全的。</p><p>总的来说，这个日志系统的设计考虑到了多线程环境，允许多个线程同时添加日志消息，但它并没有专门设置一个线程来完成这项任务，而是允许主程序或其他任何线程来直接调用添加日志的宏。</p><p>自己的话：你自己程序在运行的时候是不是有多个线程，这些线程就是负责啥时候要调用<code>LogInfo()</code>, <code>LogWarning()</code>, 或 <code>LogError()</code>这样的宏。所以当然不需要额外的线程来操作加入队列操作，只需要一个带锁函数即可。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本篇文章主要参考如下文章，主要是对代码做一个较为详尽的解释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;https://blog.csdn.net/qq_46495964/article/details/122952567&quot;&gt;https://</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>webServer</title>
    <link href="http://zcl0219.github.io/2023/08/23/webServer/"/>
    <id>http://zcl0219.github.io/2023/08/23/webServer/</id>
    <published>2023-08-23T13:08:31.000Z</published>
    <updated>2023-09-20T19:17:59.989Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始正式补充完善<code>webServer</code>服务器的内容！想到哪写到哪吧，回头再做整合。</p><h3 id="标准C库IO函数"><a href="#标准C库IO函数" class="headerlink" title="标准C库IO函数"></a>标准C库IO函数</h3><p><img src="PNG1.png"></p><h4 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、如何处理接收到的HTTP请求</span></span><br><span class="line"><span class="comment">2、如何填写HTTP响应</span></span><br><span class="line"><span class="comment">3、如何建立网络连接传输数据</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="HTTP请求处理"><a href="#HTTP请求处理" class="headerlink" title="HTTP请求处理"></a>HTTP请求处理</h4><p>http_conn头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">http_conn</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">http_conn</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">http_conn</span>() &#123;&#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_epollfd;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_user_count;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> so0ckaddr_in &amp;addr)</span></span>;<span class="comment">// 初始化连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close_conn</span><span class="params">(<span class="type">bool</span> real_close = <span class="literal">true</span>)</span></span>;<span class="comment">// 关闭连接，关于需要传入real_close参数的原因，后面会讲到，预留问题</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_sockfd;<span class="comment">// 发起http请求的sockfd</span></span><br><span class="line">    sockaddr_in m_address;<span class="comment">// 发起http请求的socket地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在http_conn类里主要设置五个对外的接口：</p><ul><li><p>初始化新接受的连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> sockaddr_in &amp;addr)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们会把所有事件注册到一张内核事件表上，因此定义一个内核事件就好了。static int m_epollfd;</span></span><br><span class="line"><span class="comment">同时我们会统计当前连接数，同样是使用一个静态变量，所有实例对象共享。static int m_user_count;</span></span><br><span class="line"><span class="comment">每建立一个新连接，m_user_count就会加1；</span></span><br><span class="line"><span class="comment">当我们向内核事件表注册一个事件时，我们需要考虑我们所要监听的事件类型，这里我们考虑：</span></span><br><span class="line"><span class="comment">读事件（EPOLLIN）、边沿触发模式（EPOLLET）、以及EPOLLRDHUP（检测TCP对端连接的关闭或者半关闭状态）</span></span><br><span class="line"><span class="comment">为了配合ET模式和多线程，我们需要做两个操作，第一是将所监听的文件描述符设置为非阻塞的，第二需要设置为EPOLLONESHOT类型</span></span><br><span class="line"><span class="comment">注意：我们对m_epollfd和m_user_count的初始化分别为</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> m_epollfd = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> m_user_count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>设置非阻塞函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例：Linux高性能服务器编程 p113</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> sockfd)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>(sockfd, F_GETFL);  <span class="comment">// 获取文件描述符旧的状态标志</span></span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;<span class="comment">// 设置非阻塞标志</span></span><br><span class="line">    <span class="built_in">fcntl</span>(sockfd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;<span class="comment">// 返回文件描述符旧的状态标志，以便日后恢复该状态标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置感兴趣事件类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们在向内核事件表注册新事件的时候，需要指定自己对这个文件描述符上发生的什么事件感兴趣</span></span><br><span class="line"><span class="comment">// 可读？可写？</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> one_shot)</span></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">if</span>(one_shot)&#123;</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化函数代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::init</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> sockaddr_in &amp;addr)</span></span>&#123;</span><br><span class="line">m_sockfd = sockfd;</span><br><span class="line">    m_address = addr;</span><br><span class="line">    <span class="built_in">addfd</span>(m_epollfd, sockfd, <span class="literal">true</span>);</span><br><span class="line">    m_user_count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关闭连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">close_conn</span><span class="params">(<span class="type">bool</span> real_close)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们可以思考一下有关关闭连接需要涉及到哪些操作。</span></span><br><span class="line"><span class="comment">1、首先，如果一个连接关闭了，我们需要将其从内核事件表上移除</span></span><br><span class="line"><span class="comment">2、当前连接数目也会减一</span></span><br><span class="line"><span class="comment">这里我们准备先实现一个从内核事件表上移除文件描述符的函数（void removefd），在实现关闭连接</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>移除文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removefd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::close_conn</span><span class="params">(<span class="type">bool</span> real_close)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(real_close &amp;&amp; m_sockfd != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">removefd</span>(m_epollfd, m_sockfd);</span><br><span class="line">        m_sockfd = <span class="number">-1</span>;</span><br><span class="line">        m_user_count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理客户请求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于如何处理客户连接请求的问题，我们从最原始的地方出发。</span></span><br><span class="line"><span class="comment">首先，你了解一个http请求的基本格式吗？因为我们只有在了解http请求的通用格式后才知道如何对其进行解析</span></span><br><span class="line"><span class="comment">下面，我将展示一个最基本的GET请求格式</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">GET /path/to/resource?param1=value1&amp;param2=value2 HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agnet: Mozilla/5.0 (platform; rv:geckoversion) Gecko/geckotrail Firefox/firefoxversion</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br><span class="line"><span class="comment"># 关于这个GET请求的详细解释我提一个chatgpt的解释在这，可以阅读一下</span></span><br><span class="line">下面是逐行详细解释：</span><br><span class="line">1. `GET /path/to/resource?param1=value1&amp;param2=value2 HTTP/1.1`</span><br><span class="line">   - `GET`: 这是HTTP请求的方法。`GET` 方法用于请求指定的资源。与POST相比，GET请求是只读的，并且用于获取数据而不是发送数据。</span><br><span class="line">   - `/path/to/resource`: 这是请求的资源路径，通常是文件或者其他资源的位置。</span><br><span class="line">   - `?`: 这个符号表示URL的查询部分的开始。</span><br><span class="line">   - `param1=value1&amp;param2=value2`: 这是查询字符串。在此例中，有两个参数，`param1`和`param2`，它们的值分别是`value1`和`value2`。`&amp;`符号用于分隔查询参数。</span><br><span class="line">   - `HTTP/1.1`: 表示使用的HTTP版本，这里是1.1。</span><br><span class="line"></span><br><span class="line">2. `Host: www.example.com`</span><br><span class="line">   - `Host`: 这是HTTP头的名称。它指定了请求的目标主机和域名。</span><br><span class="line">   - `www.example.com`: 请求的目标域名。</span><br><span class="line"></span><br><span class="line">3. `User-Agent: Mozilla/5.0 (platform; rv:geckoversion) Gecko/geckotrail Firefox/firefoxversion`</span><br><span class="line">   - `User-Agent`: 这是HTTP头的名称。它描述了发出请求的用户代理的类型，通常是浏览器。</span><br><span class="line">   - `Mozilla/5.0`: 这是用户代理的一般标记。虽然名为Mozilla，但它并不仅仅代表Mozilla浏览器，大多数浏览器都会以这种方式标识。</span><br><span class="line">   - `(platform; rv:geckoversion)`: 这部分提供了关于用户代理的详细信息，例如它在哪个平台上运行。</span><br><span class="line">   - `Gecko/geckotrail`: 这是Gecko渲染引擎的标识及其版本。</span><br><span class="line">   - `Firefox/firefoxversion`: 表示用户代理是Firefox浏览器，后面跟着其版本。</span><br><span class="line"></span><br><span class="line">4. `Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8`</span><br><span class="line">   - `Accept`: HTTP头名称，表示客户端可以处理的内容类型。</span><br><span class="line">   - 该头的值列出了浏览器接受的MIME类型，按照优先级排序。例如，`text/html` 表示HTML文档，而`q=0.9`表示相对优先级。</span><br><span class="line"></span><br><span class="line">5. `Accept-Language: en-US,en;q=0.5`</span><br><span class="line">   - `Accept-Language`: HTTP头名称，表示用户代理偏好的自然语言。</span><br><span class="line">   - `en-US,en`: 这指示用户代理首先希望接收美国英语的内容，其次是英语。</span><br><span class="line"></span><br><span class="line">6. `Accept-Encoding: gzip, deflate, br`</span><br><span class="line">   - `Accept-Encoding`: HTTP头名称，表示用户代理可以接受的内容编码。</span><br><span class="line">   - `gzip, deflate, br`: 这些是可以接受的编码方法，用于内容压缩。</span><br><span class="line"></span><br><span class="line">7. `Connection: keep-alive`</span><br><span class="line">   - `Connection`: HTTP头名称，表示是否持续连接。</span><br><span class="line">   - `keep-alive`: 表示浏览器希望服务器保持连接，以便于后续的请求可以复用相同的TCP连接。</span><br><span class="line"></span><br><span class="line">这个请求大体上是一个典型的HTTP GET请求，由HTTP方法、资源路径、HTTP版本、多个头字段组成。每个头字段都有其特定的语义和目的。</span><br></pre></td></tr></table></figure><p>现在我们知道了HTTP请求格式了，那么到底如何解析它呢？这里就要引入一种叫做“有限状态机”的方法了，有关这个方法的具体描述与实现，大家可以看我的另一篇文章。</p></li><li><p>非阻塞读操作</p></li><li><p>非阻塞写操作</p></li></ul><p><strong>第一个知识点：<code>iovec</code></strong></p><p>这里先介绍一个<code>iovec</code>结构体，因为我们在写HTTP响应的时候需要用到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>&#123;</span></span><br><span class="line">  <span class="type">ptr_t</span> iov_base;</span><br><span class="line">  <span class="type">size_t</span> iov_len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct iovec结构体，指针成员iov_base指向一个缓冲区，这个缓冲区是存放read_v所接收的数据或者write_v将要发送的数据。成员iov_len在各种情况下分别确定了接收的最大长度和实际写入的长度。</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *<span class="built_in">vector</span>, <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *<span class="built_in">vector</span>, <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure><p>下面给出一个应用实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> part1[] = <span class="string">&quot;This is from writev&quot;</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> part2 = <span class="number">65</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> part3[] = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[3];</span></span><br><span class="line">    </span><br><span class="line">    iov[<span class="number">0</span>].iov_base = part3;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="built_in">strlen</span>(part3);</span><br><span class="line">    </span><br><span class="line">    iov[<span class="number">1</span>].iov_base = part1;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in">strlen</span>(part1);</span><br><span class="line">    </span><br><span class="line">    iov[<span class="number">2</span>].iov_base = &amp;part2;</span><br><span class="line">    iov[<span class="number">2</span>].iov_len = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    </span><br><span class="line">    writev(<span class="number">1</span>, iov, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二个知识点：<code>va_list</code>, <code>vsnprintf</code></strong></p><p>参考链接：<a href="https://blog.csdn.net/dengzhilong_cpp/article/details/54944676">https://blog.csdn.net/dengzhilong_cpp/article/details/54944676</a></p><p>参考链接：<a href="https://blog.csdn.net/luliplus/article/details/124123219">https://blog.csdn.net/luliplus/article/details/124123219</a></p><p>以上是今天要写代码的基础知识，下面开始正式代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*写HTTP响应*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">http_conn::write</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bytes_have_send = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bytes_to_send = m_write_idx;</span><br><span class="line">    <span class="keyword">if</span>(bytes_to_send == <span class="number">0</span>)&#123;</span><br><span class="line">        modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        temp = writev(m_sockfd, m_iv, m_iv_count);</span><br><span class="line">        <span class="keyword">if</span>(temp &lt;= <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EAGAIN)&#123;</span><br><span class="line">                modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unmap();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bytes_to_send -= temp;</span><br><span class="line">        bytes_have_send += temp;</span><br><span class="line">        <span class="keyword">if</span>(bytes_to_send &lt;= bytes_have_send)&#123;</span><br><span class="line">            unmap();</span><br><span class="line">            <span class="keyword">if</span>(m_linger)&#123;</span><br><span class="line">                init();</span><br><span class="line">                modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                                                                                                                                                           </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天开始正式补充完善&lt;code&gt;webServer&lt;/code&gt;服务器的内容！想到哪写到哪吧，回头再做整合。&lt;/p&gt;
&lt;h3 id=&quot;标准C库IO函数&quot;&gt;&lt;a href=&quot;#标准C库IO函数&quot; class=&quot;headerlink&quot; title=&quot;标准C库IO函数&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>中缀表达式转后缀表达式</title>
    <link href="http://zcl0219.github.io/2023/08/23/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://zcl0219.github.io/2023/08/23/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2023-08-23T09:16:28.000Z</published>
    <updated>2023-10-07T10:31:14.909Z</updated>
    
    <content type="html"><![CDATA[<p>面试时被问到了关于如何将中缀表达式转换为后缀表达式，这里总结一下转换的步骤</p><ol><li>遇到操作数，直接输出</li><li>栈为空时，遇到运算符，入栈</li><li>遇到左括号，将其入栈</li><li>遇到右括号，执行出栈操作，并将出栈的元素输出，直到弹出栈的是左括号，左括号不输出</li><li>遇到其他运算符“+”，“-”，“*”，“&#x2F;”时，弹出所有优先级大于或等于该运算符的栈顶元素，然后将该运算符入栈</li><li>最终将栈中的元素依次出栈，输出</li></ol><p><img src="1.png"></p><p>（啊！先写到这吧，为了弄个图片弄了好久）</p><p>参考链接：<a href="https://blog.csdn.net/y_16041527/article/details/79684188">https://blog.csdn.net/y_16041527/article/details/79684188</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;面试时被问到了关于如何将中缀表达式转换为后缀表达式，这里总结一下转换的步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;遇到操作数，直接输出&lt;/li&gt;
&lt;li&gt;栈为空时，遇到运算符，入栈&lt;/li&gt;
&lt;li&gt;遇到左括号，将其入栈&lt;/li&gt;
&lt;li&gt;遇到右括号，执行出栈操作，并将出栈的元素输出，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>智能指针shared_ptr的实现</title>
    <link href="http://zcl0219.github.io/2023/07/26/shared-ptr/"/>
    <id>http://zcl0219.github.io/2023/07/26/shared-ptr/</id>
    <published>2023-07-26T01:12:27.000Z</published>
    <updated>2023-08-10T15:29:15.120Z</updated>
    
    <content type="html"><![CDATA[<p>我们今天来实现一个简易版的智能指针吧！拖了好久啦，以后会把vector、string的简易版也给补上，<code>gigigi</code></p><p>我们可以先想想<code>shared_ptr</code>最大的特点，就是当他的引用计数为0时，便会自动释放所指对象和析构。所以一个关键点就是这个引用计数怎么设置？static？不可以！static变量同属于一个类的所有对象，这样就会导致不管指的是不是同一个对象，引用计数都相同。所以我们这里决定采用一个指针来进行引用计数。具体实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(T* sPtr = <span class="literal">nullptr</span>)</span>: sPtr_(sPtr)&#123;</span></span><br><span class="line">        <span class="keyword">if</span>(sPtr_)&#123;</span><br><span class="line">            useCount_ = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line">            sMutex_ = <span class="keyword">new</span> std::mutex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>()&#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)&#123;</span><br><span class="line">        useCount_ = sp.useCount_;</span><br><span class="line">        sPtr_ = sp.sPtr_;</span><br><span class="line">        sMutex_ = sp.sMutex_;</span><br><span class="line">        <span class="built_in">addUsecount</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sPtr_ != sp.sPtr_)&#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            sPtr_ = sp.sPtr_;</span><br><span class="line">            useCount_ = sp.useCount_;</span><br><span class="line">            sMutex_ = sp.sMutex_;</span><br><span class="line">            <span class="built_in">addUsecount</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()&#123;</span><br><span class="line">        <span class="keyword">return</span> *sPtr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">        <span class="keyword">return</span> sPtr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">useCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *useCount_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sPtr_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addUsecount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sMutex_-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        ++(*useCount_);</span><br><span class="line">        sMutex_-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">bool</span> deleteFlag = <span class="literal">false</span>;</span><br><span class="line">        sMutex_-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(--(*useCount_) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> useCount_;</span><br><span class="line">            <span class="keyword">delete</span> sPtr_;</span><br><span class="line">            deleteFlag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sMutex_-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span>(deleteFlag)&#123;</span><br><span class="line">            <span class="keyword">delete</span> sMutex_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* useCount_;</span><br><span class="line">    T* sPtr_;</span><br><span class="line">    std::mutex* sMutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;std::string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> std::string(<span class="string">&quot;hello&quot;</span>))</span></span>;</span><br><span class="line">    shared_ptr&lt;std::string&gt; p2 = p1;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; p2.useCount() &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="function">shared_ptr&lt;std::string&gt; <span class="title">p3</span><span class="params">(p2)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; p3.<span class="built_in">useCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p2.<span class="built_in">useCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    p2 = p3;</span><br><span class="line">    std::cout &lt;&lt; p3.<span class="built_in">useCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p2.<span class="built_in">useCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入结果图片有点问题，最近没时间弄，各位自己跑一下验证一下，有错误记得说！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们今天来实现一个简易版的智能指针吧！拖了好久啦，以后会把vector、string的简易版也给补上，&lt;code&gt;gigigi&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们可以先想想&lt;code&gt;shared_ptr&lt;/code&gt;最大的特点，就是当他的引用计数为0时，便会自动释放所指对象</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Cpp高频面经</title>
    <link href="http://zcl0219.github.io/2023/06/29/Cpp%E9%AB%98%E9%A2%91%E9%9D%A2%E7%BB%8F/"/>
    <id>http://zcl0219.github.io/2023/06/29/Cpp%E9%AB%98%E9%A2%91%E9%9D%A2%E7%BB%8F/</id>
    <published>2023-06-28T19:50:53.000Z</published>
    <updated>2023-10-09T08:26:33.676Z</updated>
    
    <content type="html"><![CDATA[<h4 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h4><ul><li><p>属性的区别</p><p>new&#x2F;delete：这两个是C++中的关键字；</p><p>malloc&#x2F;free：这两个是库函数；</p></li><li><p>使用上的区别</p><p>malloc：申请空间需要显式填入申请内存的大小；</p><p>new：无需显式填入申请内存的大小，new会根据new的类型分配内存；</p></li><li><p>返回类型的区别</p><p>new操作符内存分配成功，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，故new是符合类型安全性的操作符。</p><p>malloc内存分配成功返回的是void*指针，需要通过强制类型转换，转换成我们需要的类型。</p><p>所以C++中new比malloc安全可靠。</p></li><li><p>分配失败的区别</p><p>malloc分配失败会返回NULL，我们可以通过判断返回值是否是NULL得知是否分配成功。</p><p>new分配失败会抛出bad_alloc异常。</p></li><li><p>扩张内存的区别</p><p>malloc有内存扩张机制（通过realloc实现）。</p><p>new没有扩张内存机制。</p></li></ul><p><a href="https://zhuanlan.zhihu.com/p/338489910">https://zhuanlan.zhihu.com/p/338489910</a></p><h4 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h4><ul><li>明确动态内存使用范围：在程序中使用动态内存时，需要明确该内存的使用范围，确保在不需要使用该内存时能够及时释放内存。</li><li>使用RAII技术：RAII（Resource Acquisition Is Initialization）是C++中一种常用的资源管理技术，它利用了C++对象的构造函数和析构函数自动调用的特性，在对象的构造函数中申请资源，在对象的析构函数中释放资源，从而避免资源泄漏问题。</li><li>使用智能指针：智能指针可以自动管理动态内存的分配和释放。</li></ul><h4 id="线程池的数量一般怎么设置"><a href="#线程池的数量一般怎么设置" class="headerlink" title="线程池的数量一般怎么设置"></a>线程池的数量一般怎么设置</h4><p>线程池中线程数量的设置主要考虑两个方面：</p><ul><li><p>I&#x2F;O密集型</p></li><li><p>如果说任务是耗时I&#x2F;O型，比如涉及数据库、文件的读写，网络通信等任务，这种任务的特点是不会特别消耗CPU资源，但是我们需要考虑到I&#x2F;O操作耗时较长。这种情况一般会将线程数设置的比较大，达到了CPU核心数的很多倍。因为如果线程数设置的比较少，会造成CPU计算资源的浪费。</p></li><li><p>CPU密集型</p></li><li><p>对于CPU密集型任务，线程数不宜设置的过多，因为过多的线程都会去抢占CPU资源，就会产生不必要的上下文切换，反而会造成整体性能的下降</p></li></ul><p>线程数通用计算公示：线程数 &#x3D; CPU核心数 * (1 + I&#x2F;O耗时 &#x2F; CPU耗时)</p><h4 id="来了一个新任务，线程池是怎么工作的（本答案有待商榷）"><a href="#来了一个新任务，线程池是怎么工作的（本答案有待商榷）" class="headerlink" title="来了一个新任务，线程池是怎么工作的（本答案有待商榷）"></a>来了一个新任务，线程池是怎么工作的（本答案有待商榷）</h4><p>当有一个新任务到来时，线程池会先判断是否有空闲线程，如果有，则将任务分配给空闲线程；</p><p>如果此时线程池里没有空线程，则先将任务放任务任务队列，待有空闲线程之后，再从任务队列中取出任务。</p><h4 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h4><p>在我的理解里，完美转发 &#x3D; std::forward + 万能引用 + 引用折叠。首先引用折叠机制为T&amp;&amp;类型的万能引用中的模板参数T赋予了一个恰到好处的值，而我们用T去指明std::forward的模板参数，从而使得std::forward返回的是正确的类型（这里关于返回的是正确的类型，应该去看std::forward实现的源码，知乎链接如下：<a href="https://zhuanlan.zhihu.com/p/369203981%EF%BC%89">https://zhuanlan.zhihu.com/p/369203981）</a></p><h4 id="去掉std-forward会咋样"><a href="#去掉std-forward会咋样" class="headerlink" title="去掉std::forward会咋样"></a>去掉std::forward会咋样</h4><p>可能会导致在传递参数的时候丢失类型信息，从而导致编译器无法正确推断模板类型或者在模板类型推断中发生错误。</p><h4 id="讲一下C-中的虚继承"><a href="#讲一下C-中的虚继承" class="headerlink" title="讲一下C++中的虚继承"></a>讲一下C++中的虚继承</h4><h4 id="基类的析构函数为什么是虚函数？"><a href="#基类的析构函数为什么是虚函数？" class="headerlink" title="基类的析构函数为什么是虚函数？"></a>基类的析构函数为什么是虚函数？</h4><p>如果基类的虚构函数不是虚函数，当我们定义一个父类指针指向子类对象时，最后子类的析构函数不会调用，导致内存泄漏。</p><h4 id="struct和union的区别（默写）"><a href="#struct和union的区别（默写）" class="headerlink" title="struct和union的区别（默写）"></a>struct和union的区别（默写）</h4><h4 id="C-内存布局-x2F-程序分段（默写）"><a href="#C-内存布局-x2F-程序分段（默写）" class="headerlink" title="C++内存布局&#x2F;程序分段（默写）"></a>C++内存布局&#x2F;程序分段（默写）</h4><h4 id="了解shared-ptr吗？如果让你手写一个shared-ptr，你会怎么设计"><a href="#了解shared-ptr吗？如果让你手写一个shared-ptr，你会怎么设计" class="headerlink" title="了解shared_ptr吗？如果让你手写一个shared_ptr，你会怎么设计"></a>了解shared_ptr吗？如果让你手写一个shared_ptr，你会怎么设计</h4><p>shared_ptr是智能指针里面的共享指针，即多个指针指向同一个内存。每多一个指针指向这片内存，引用计数加1。当对象的引用计数减少为0时，对象会自动析构，对应内存被自动释放。智能指针是模板类，而不是指针。</p><p>设计：将shared_ptr定义为一个模板类，包括两个成员：模板类指针和一个指向引用计数的指针。指向引用计数类型的指针应该包括这些成员函数：增加计数、减少计数、返回现有计数。一个私有成员就是用于计数的变量。共享指针模板类的构造函数接受一个模板类型指针，并且需要声明为explicit，表示必须直接初始化。另外就是拷贝构造函数和移动构造函数。拷贝构造需要注意拷贝的对象的指针是否为nullptr，如果不是nullptr，则需要增加引用计数。移动构造函数需要注意将传入的右值引用对象的指针置空，引用计数清零。析构函数有两个判断条件，第一个最后一个指向对象的指针需要为非nullptr并且此时引用计数减一后为0。然后就是重载*、-&gt;、bool，还有一个函数用于获得指针get()。动态转换（可考虑）。</p><h4 id="介绍一下TCP，TCP粘包如何解决"><a href="#介绍一下TCP，TCP粘包如何解决" class="headerlink" title="介绍一下TCP，TCP粘包如何解决"></a>介绍一下TCP，TCP粘包如何解决</h4><p>解决办法：</p><ul><li>发送端：使用TCP_NODELAY关闭Nagle算法，但是如果不是时延敏感的应用尽量不要关闭</li><li>接收端：没法解决，只能交给应用端解决</li><li>应用层：有三种解决办法<ul><li>只发送固定包长的数据包，但是这个方法基本不用，灵活性太差</li><li>指定标识结尾，比如\r\n之类的</li><li>包头加包体，包头一般是固定长度，并且里面有一个字段可以告知我们接下来的包体有多大</li></ul></li></ul><h4 id="回调函数是什么，回调函数的本质"><a href="#回调函数是什么，回调函数的本质" class="headerlink" title="回调函数是什么，回调函数的本质"></a>回调函数是什么，回调函数的本质</h4><p>回调函数允许我们将一个函数（或函数对象）作为参数传递给另一个函数，并在需要的时候由后者调用执行。回调函数定义了在特定事件或条件满足时应该执行的操作。主调函数是接受回调函数作为参数的函数。</p><h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><ol><li>进程<ul><li>进程拥有独立内存空间和系统资源</li><li>进程之间相互独立，一个进程的崩溃通常不会影响其他进程</li><li>创建、销毁和切换进程开销比较大</li></ul></li><li>线程<ul><li>一个进程可以包含多个线程，所有线程共享相同的地址空间和系统资源</li><li>线程之间可以直接读写进程内的共享数据，执行起来更高效</li><li>线程的创建、销毁和切换开销比较小</li></ul></li></ol><h4 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h4><p>GET用于获取资源，参数通过URL传递，不适合传输敏感信息，幂等，有缓存，传输数据的大小受限于URL的长度。POST用于提交数据，参数通过请求体传递，适合传输敏感信息，不幂等，无缓存，没有数据大小限制。</p><h4 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h4><ol><li>HTTP<ul><li>HTTP是一种应用层协议，用于在Web浏览器和Web服务器之间传输超文本和其他资源</li><li>HTTP是明文传输的协议，意味着数据在传输过程中是未加密的，容易被窃听和篡改</li><li>HTTP默认使用80端口号</li></ul></li><li>HTTPS<ul><li>HTTPS是HTTP协议的安全版本，加强了数据传输的安全性和保密性</li><li>HTTPS使用了SSL&#x2F;TLS协议进行数据加密和身份认证</li><li>HTTPS默认使用443端口通信</li></ul></li></ol><h4 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++ 11新特性"></a>C++ 11新特性</h4><ul><li><p>auto关键字</p></li><li><p>智能指针</p></li><li><p>lambda表达式参考链接（<a href="https://blog.51cto.com/u_15323899/5785594%EF%BC%89">https://blog.51cto.com/u_15323899/5785594）</a></p><p>Lambda表达式是C++11引入的一种新特性，它允许在代码中定义匿名函数。虽然在使用上非常简洁和方便，但lambda表达式背后的实现相对复杂。以下是lambda表达式在底层的工作原理：</p><ol><li><p><strong>转换为类</strong>:</p><ul><li>当你定义一个lambda表达式，编译器会为你生成一个匿名类（也称为闭包类型）。这个类将会覆盖函数调用操作符，使得该对象可以像函数一样被调用。</li><li>如果lambda表达式捕获了外部的局部变量（例如通过值或引用），这些变量将会被添加为该匿名类的成员。</li></ul></li><li><p><strong>成员变量</strong>:</p><ul><li>为了支持捕获，生成的闭包类型可能会包含成员变量。如果使用值捕获，那么这些成员变量将存储捕获的变量的副本；如果使用引用捕获，那么成员变量将存储相应变量的引用。</li></ul></li><li><p><strong>函数调用操作符重载</strong>:</p><ul><li>生成的类会覆盖函数调用操作符<code>operator()</code>. 这个操作符的实现就是lambda表达式的主体。</li></ul></li><li><p><strong>构造函数</strong>:</p><ul><li>该匿名类的构造函数会初始化所有捕获的变量。根据捕获方式（值或引用）来复制或绑定这些变量。</li></ul></li><li><p><strong>生成的类是只移动构造的</strong>:</p><ul><li>这意味着你不能按常规方式复制lambda表达式，但可以移动它。</li></ul></li></ol><p>下面是一个简单的lambda表达式的例子以及一个可能的简化版本的匿名类表示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lambda</span></span><br><span class="line"><span class="keyword">auto</span> lambda = [x](<span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Possible representation by the compiler</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__anonymous</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    __anonymous(<span class="type">int</span> _x) : <span class="built_in">x</span>(_x) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要注意的是，这只是一个简化的表示。实际编译器生成的代码会比这更复杂，尤其是当涉及到更高级的特性（如泛型、<code>mutable</code>关键字或捕获列表）时。</p><p>最后，虽然从概念上讲，lambda表达式是转换为类的，但这并不意味着性能会受到影响。优化后的编译器通常会内联这些生成的类和函数调用操作符，从而消除由于间接调用导致的任何额外开销。</p></li><li><p>右值引用和移动语义</p></li></ul><h4 id="lambda表达式的使用场景"><a href="#lambda表达式的使用场景" class="headerlink" title="lambda表达式的使用场景"></a>lambda表达式的使用场景</h4><p>lambda表达式提供了一种简洁、方便的方式来创建匿名对象。在一些需要传递简单函数对象的场景下，使用lambda表达式可以避免额外的函数对象类。</p><h4 id="vector迭代器失效的原因"><a href="#vector迭代器失效的原因" class="headerlink" title="vector迭代器失效的原因"></a>vector迭代器失效的原因</h4><p>vector底层的实现是一个动态数组，vector里面存储的元素都是连续的，一旦比如删除一个元素，后面的所有元素都需要移动。我们可以考虑一种极端情况，删除最后一个元素，此时指向原vector数组的最后一个元素的迭代器就没指向任何元素了，如何此时我们访问这个迭代器所指向的元素，就会导致未定义行为，所以就会判定迭代器失效。其实所有改变vector大小的操作，都会导致vector迭代器失效。</p><h4 id="map的底层数据结构"><a href="#map的底层数据结构" class="headerlink" title="map的底层数据结构"></a>map的底层数据结构</h4><p>红黑树参考链接：<a href="https://www.jianshu.com/p/e136ec79235c">https://www.jianshu.com/p/e136ec79235c</a></p><p>map是有序容器，底层数据结构是红黑树，时间复杂度为log(n)。红黑树的前身可以说是二叉搜索树。但是二叉搜索树最坏的情况下树的高度为n，那么就导致时间复杂度为o(n), 所以便衍生出来了平衡二叉树。其实红黑树的五大特性就是为了保持二叉搜索树的平衡。保证时间复杂度稳定在o(logn)。</p><h4 id="unordered-map底层数据结构"><a href="#unordered-map底层数据结构" class="headerlink" title="unordered_map底层数据结构"></a>unordered_map底层数据结构</h4><p>unordered_map是无序容器，底层使用哈希表实现的。</p><h4 id="TCP握手为什么是三次握手，两次握手为什么不行呢"><a href="#TCP握手为什么是三次握手，两次握手为什么不行呢" class="headerlink" title="TCP握手为什么是三次握手，两次握手为什么不行呢"></a>TCP握手为什么是三次握手，两次握手为什么不行呢</h4><p>这里有两个大点，第一个字面意思很好理解，第二点举个例子就通透了，面试时最好全部答上来</p><ul><li><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤</p></li><li><p>防止已失效的连接请求又传送到服务器端，因而产生错误</p><p>只有采用三次握手可以减少服务端的资源浪费。解释如下：<br>例如，客户端向服务端发送请求同步报文A，因为网络阻塞等原因，服务端没有收到同步报文A，所以没有发送同步确认报文。过了一段时间，客户端没有收到服务端的确认报文，重新向服务端发送请求同步报文B，服务端接收到报文B后，向客户端发送同步确认报文，客户端接收到确认报文后，向服务端发送确认报文，建立连接。数据传输完毕后，连接断开。客户端进入close状态，此时服务端收到之前的报文A，向客户端返回同步确认报文。如果使用两次握手，服务端回应后不确认客户端的状态，连接建立成功。服务端会长时间等待客户端发送数据，连接长期保持，会造成资源浪费。当多个客户端产生这种情况，服务器就会等待多个客户端的响应，连接数量过多，之后的客户端请求，服务器无法响应。造成服务器处于瘫痪状态。<br>只有使用三次握手，当服务端收到确认报文后，保证当前时刻，客户端可以发送数据时，才能建立有意义的连接。当客户端一段时间不发送数据时，服务器应自动断开连接，来节省自身连接的客户端数量，减少资源的浪费。</p></li></ul><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p>HTTP状态码是在HTTP协议中用于表示服务器对请求的处理结果的三位数字代码。HTTP状态码的分类如下：</p><ol><li><p>1xx（信息性状态码）：表示服务器已接收请求，需要客户端继续操作。</p></li><li><p>2xx（成功状态码）：表示服务器成功处理了请求。</p></li><li><p>3xx（重定向状态码）：表示请求需要进一步的操作，通常用于重定向。</p></li><li><p>4xx（客户端错误状态码）：表示客户端发出的请求有误。</p></li><li><p>5xx（服务器错误状态码）：表示服务器在处理请求时发生了错误。</p></li></ol><p>以下是一些常见的HTTP状态码示例：</p><ol><li><p>200 OK：请求成功，服务器成功处理了请求。</p></li><li><p>201 Created：请求成功，服务器已成功创建了资源。</p></li><li><p>204 No Content：请求成功，但服务器没有新的信息返回。</p></li><li><p>400 Bad Request：请求错误，服务器不理解或无法处理请求。</p></li><li><p>401 Unauthorized：请求需要用户认证，未提供有效的认证信息。</p></li><li><p>403 Forbidden：请求被服务器拒绝，没有访问权限。</p></li><li><p>404 Not Found：请求的资源不存在。</p></li><li><p>500 Internal Server Error：服务器内部错误，无法完成请求。</p></li><li><p>502 Bad Gateway：服务器作为网关或代理，从上游服务器收到无效的响应。</p></li><li><p>503 Service Unavailable：服务器暂时不可用，通常是由于过载或维护。</p></li></ol><p>这只是HTTP状态码中的一部分，实际中可能还会遇到其他状态码。状态码的具体含义可参考HTTP协议的官方文档或RFC文档。不同的状态码代表了服务器对请求的不同响应结果，客户端根据状态码可以做出相应的处理。</p><h4 id="使用智能指针了，普通指针还能用吗？"><a href="#使用智能指针了，普通指针还能用吗？" class="headerlink" title="使用智能指针了，普通指针还能用吗？"></a>使用智能指针了，普通指针还能用吗？</h4><p>个人觉得使用了智能指针后不推荐使用普通指针。因为使用了智能指针后，再使用普通指针指向相同对象，并不会增加引用计数，等智能指针引用计数变为0的时候，对象被销毁，此时普通指针就变为了野指针。</p><h4 id="什么时候使用智能指针，什么时候使用普通指针-（CHATGPT）"><a href="#什么时候使用智能指针，什么时候使用普通指针-（CHATGPT）" class="headerlink" title="什么时候使用智能指针，什么时候使用普通指针 （CHATGPT）"></a>什么时候使用智能指针，什么时候使用普通指针 （CHATGPT）</h4><p>使用智能指针还是普通指针取决于你的代码需求和内存管理需求。以下是一些指导原则：</p><p>使用智能指针的情况：</p><ol><li><p>动态分配内存：如果你需要动态分配内存，尤其是在使用<code>new</code>关键字时，最好使用智能指针来管理这些资源。智能指针会自动在不再需要时释放内存，避免了内存泄漏的问题。</p></li><li><p>所有权传递：当多个地方共享一个资源并且需要明确的所有权传递时，智能指针特别有用。例如，使用<code>std::shared_ptr</code>来共享资源，并在最后一个引用释放时自动删除资源。</p></li><li><p>异常安全：在使用普通指针的代码中，如果在动态分配资源后发生异常，可能会导致资源泄漏。使用智能指针可以更好地处理异常情况，确保资源在退出作用域时得到正确释放。</p></li><li><p>容器存储：如果要在STL容器中存储指针类型，建议使用智能指针。STL容器在元素添加或删除时可能会复制或移动元素，使用智能指针可以正确管理资源的所有权。</p></li></ol><p>使用普通指针的情况：</p><ol><li><p>接口和传统API：某些接口和传统的C API可能要求使用原始指针，此时你无法使用智能指针。在这种情况下，你应该小心管理内存，确保手动释放资源。</p></li><li><p>与C代码交互：当与C语言库或代码进行交互时，普通指针是常用的方式，因为C语言不支持智能指针。</p></li><li><p>临时指针：对于一些临时指针，其生命周期很短且不需要动态内存管理时，可以使用普通指针。</p></li><li><p>最低开销：在某些性能关键的场景，智能指针可能带来额外的开销，此时使用普通指针可能更合适。但请注意，在性能优化前确保使用智能指针没有影响到代码的正确性和可维护性。</p></li></ol><p>综上所述，智能指针在大多数情况下是推荐的内存管理方式，特别是在现代C++代码中。然而，有些特定的场景可能需要使用普通指针，但在这种情况下你需要格外小心以避免内存泄漏和悬挂指针问题。</p><h4 id="Hash-map原理"><a href="#Hash-map原理" class="headerlink" title="Hash_map原理"></a>Hash_map原理</h4><p>Hash_map基于Hash_map（哈希表）。</p><p>哈希表基本原理：使用一个下标范围较大的数组来储存元素。那我们怎么根据关键字知道它应该放在数组的哪个位置呢？这就通过哈希函数（散列函数）来解决。哈希函数使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应。但是，不能保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这就产生了哈希冲突。因此“直接定址”和“解决冲突”是哈希表的两大特点。</p><p>哈希冲突的解决主要有以下四种方法：开放地址法，再哈希法，链地址法和建立公共溢出区。关于这四种方法的解释见知乎链接 <a href="https://zhuanlan.zhihu.com/p/29520044">https://zhuanlan.zhihu.com/p/29520044</a></p><h4 id="C-多态介绍一下"><a href="#C-多态介绍一下" class="headerlink" title="C++多态介绍一下"></a>C++多态介绍一下</h4><p>C++多态主要包括重载、虚函数、模板。重载包括函数重载和运算符重载，编译期，即编译器在编译阶段就会根据函数调用的上下文来决定使用哪一个重载版本。虚函数是在运行期。重载和模板属于静态多态，虚函数属于动态多态。静态多态与动态多态靠编译期与运行期区分。</p><h4 id="虚函数、纯虚函数原理，虚表什么时候建立的https-zhuanlan-zhihu-com-p-37331092"><a href="#虚函数、纯虚函数原理，虚表什么时候建立的https-zhuanlan-zhihu-com-p-37331092" class="headerlink" title="虚函数、纯虚函数原理，虚表什么时候建立的https://zhuanlan.zhihu.com/p/37331092"></a>虚函数、纯虚函数原理，虚表什么时候建立的<a href="https://zhuanlan.zhihu.com/p/37331092">https://zhuanlan.zhihu.com/p/37331092</a></h4><ul><li>虚函数，在类成员方法的声明（不是定义）语句前加“virtual”，如virtual void func</li><li>纯虚函数，在虚函数后加“&#x3D;0”，如virtual void func &#x3D; 0</li><li>对于虚函数，子类可以（也可以不）重写基类的虚函数，该行为称之为override</li><li>对于纯虚函数，子类必须提供纯虚函数的个性化实现</li></ul><p>在派生子类中对虚函数和纯虚函数的个性化实现，都体现了多态特性，但区别在于：</p><ul><li>子类如果不提供虚函数的实现，将会自动调用基类的缺省虚函数实现</li><li>子类如果不提供纯虚函数的实现，将会编译失败</li></ul><p><strong>当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数则由指针指向的实际类型决定</strong></p><p>实现虚函数表的关键就是虚函数表指针，这个指针指向一张名为虚函数表的表，为表中的数据则为函数指针，存储了虚函数具体实现所对应的位置。另外，当一个类有多个虚函数时，仍然只有一个虚函数指针，而此时的虚函数表里会有多个<strong>函数指针</strong>，因此，虚函数实现的过程是：<strong>通过对象内存中的虚函数指针vptr找到虚函数表vtbl，再通过vtbl中的函数指针找到对应虚函数的实现区域并进行调用。</strong>所以虚函数的调用时由指针所指向内存块的具体类型决定的。</p><h4 id="构造函数和析构函数可以是虚函数吗？"><a href="#构造函数和析构函数可以是虚函数吗？" class="headerlink" title="构造函数和析构函数可以是虚函数吗？"></a>构造函数和析构函数可以是虚函数吗？</h4><p>答案是：构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。</p><p>首先，我们已经知道虚函数的实现则是通过对象内存中的vptr来实现的。而构造函数是用来实例化一个对象的，通俗来讲就是为对象内存中的值做初始化操作。那么在构造函数完成之前，也即还没有进行初始化，此时vptr是没有值的，也就无法通过vptr找到作为构造函数和虚函数所在的代码区，所以构造函数只能以普通函数的形式存放在类所指定的代码区中。</p><p>而对于析构函数，当我们delete(a)的时候，如果析构函数不是虚函数，那么调用的将会是基类base的析构函数。而当继承的时候，通常派生类会在基类的基础上定义自己的成员，此时我们当然希望可以调用派生类的析构函数对新定义的成员也进行析构。</p><h4 id="map为啥用红黑树不用avl树？"><a href="#map为啥用红黑树不用avl树？" class="headerlink" title="map为啥用红黑树不用avl树？"></a>map为啥用红黑树不用avl树？</h4><ul><li>平衡调整次数更少</li><li>内存使用更少：AVL树需要存储额外的平衡因子信息</li><li>更适合于频繁的插入和删除操作</li></ul><h4 id="怎么判断map里key值存不存在"><a href="#怎么判断map里key值存不存在" class="headerlink" title="怎么判断map里key值存不存在"></a>怎么判断map里key值存不存在</h4><p>c.at(k)访问关键字为k的元素，如果k不在c中，返回一个out_of_range异常</p><p>c.find(k)如果存在，返回一个迭代器，指向关键字为k的元素；如果不存在，返回尾后迭代器</p><p>c.count(k)不存在返回0，存在返回k关键字的数量</p><h4 id="多进程通信方式"><a href="#多进程通信方式" class="headerlink" title="多进程通信方式"></a>多进程通信方式</h4><p>管道、命名管道、消息队列、信号量、共享内存、套接字、RPC</p><p>管道：一种最简单的进程间通信方式，通常用于父子进程间通信。管道中数据只能朝一个方向流动，即一方读另一方写。管道通过系统调用pipe()创建。</p><p>命名管道：一种更通用的进程间通信方式，它可以在无关的进程之间进行通信。不同于管道，命名管道通过文件系统中的路径名来标识。命名管道可以通过系统调用 <code>mkfifo()</code> 创建。</p><p>信号量：讲好sem_init(), sem_wait(), sem_post()系统整体运作过程就好了</p><p>套接字：服务器监听一个ip+端口，客户端访问连接</p><h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><table><thead><tr><th align="left"></th><th align="center">TCP</th><th align="center">UDP</th></tr></thead><tbody><tr><td align="left">可靠性</td><td align="center">可靠</td><td align="center">不可靠</td></tr><tr><td align="left">连接</td><td align="center">面向连接</td><td align="center">无连接</td></tr><tr><td align="left">数据传输方式</td><td align="center">字节流</td><td align="center">数据报</td></tr><tr><td align="left">双工性</td><td align="center">全双工</td><td align="center">一对一、一对多、多对一、多对多</td></tr><tr><td align="left">流量控制</td><td align="center">滑动窗口</td><td align="center">无</td></tr><tr><td align="left">拥塞控制</td><td align="center">慢启动、拥塞避免、快速重传、快速回复</td><td align="center">无</td></tr><tr><td align="left">效率</td><td align="center">低</td><td align="center">高</td></tr><tr><td align="left">传输速度</td><td align="center">慢</td><td align="center">快</td></tr></tbody></table><h4 id="TCP-x2F-IP协议组"><a href="#TCP-x2F-IP协议组" class="headerlink" title="TCP&#x2F;IP协议组"></a>TCP&#x2F;IP协议组</h4><p>IP协议、TCP协议、UDP协议、ICMP协议、ARP协议、RARP协议</p><h4 id="OSI七层"><a href="#OSI七层" class="headerlink" title="OSI七层"></a>OSI七层</h4><p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p><h4 id="socket编程recv函数"><a href="#socket编程recv函数" class="headerlink" title="socket编程recv函数"></a>socket编程recv函数</h4><p>返回0：对方关闭连接</p><p>返回相应的接收数据大小</p><p>返回错误码：传输出现错误</p><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>快排思想：选定基准元素，小的放一边，大的放一边，最后分治</p><h4 id="HTTP状态码-1"><a href="#HTTP状态码-1" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><ol><li>1XX - 信息状态码：<ul><li>100 Continue：服务端已经收到了客户端请求，继续发送剩余部分</li></ul></li><li>2XX - 成功状态码：<ul><li>200 OK：请求成功，服务器成功处理了请求</li><li>201 Created：请求成功，并创建了资源</li><li>204 No Content：请求成功，但没有返回内容</li></ul></li><li>3XX - 重定向状态码：<ul><li>301 Moved Permanently：永久重定向，请求的资源被永久移到了新位置</li><li>302 Found：临时重定向，请求的资源被临时移到了新位置</li><li>304 Not Modified：客户端缓存资源仍然有效，未修改</li></ul></li><li>4XX - 客户端错误状态码：<ul><li>400 Bad Request：客户端请求错误，服务器无法理解</li><li>401 Unauthorized：请求要求身份验证，客户端未提供有效的身份信息</li><li>403 Forbidden：服务器拒绝请求，没有访问权限</li><li>404 Not Found：请求的资源不存在</li></ul></li><li>5XX - 服务器错误状态码：<ul><li>500 Internet Server Error：服务器内部错误，无法完成请求</li><li>502 Bad Gateway：作为网关或代理的服务器从上游服务器收到无效响应</li><li>503 Service Unavailable：服务器暂时过载或维护中，无法处理请求</li><li>504 Gateway Timeout：作为网关或代理服务器未及时从上游服务器接收响应</li></ul></li></ol><h4 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h4><p>DNS就是域名解析服务，查询过程依次递增。本地域名解析（操作系统首先会查询本地DNS缓存） —–》本地域名服务器查询 —–》根域名服务器查询 —–》顶级域名服务器查询 —–》权威域名服务器查询 —–》返回结果。DNS查询和应答报文具有相同格式，主要区别在于某些字段的标识。下面讲几个重要的字段。</p><ul><li>16位标识：用于标记一对DNS查询和应答，以此区分一个DNS应答是哪一个DNS查询的回应</li><li>16位标志<ul><li>QR：查询报文（0）&#x2F;应答报文（1）</li><li>opcode：标准查询（0）&#x2F;    反向查询（1）就是是通过域名获取ip地址还是通过ip地址获取域名</li></ul></li></ul><h4 id="TCP为什么需要四次挥手，三次挥手有什么问题"><a href="#TCP为什么需要四次挥手，三次挥手有什么问题" class="headerlink" title="TCP为什么需要四次挥手，三次挥手有什么问题"></a>TCP为什么需要四次挥手，三次挥手有什么问题</h4><ol><li>客户端最后一个ACK可能会丢失，这样服务端就无法正常进入CLOSED状态。于是B会重传请求释放的报文，而此时如果A已经关闭了，那就收不到B的重传请求，就会导致B无法正常释放。而如果A还在等待时间内，就会收到B的重传，然后进行应答，这样B就可以进入CLOSED状态</li><li>如果三次挥手的话，服务端收到来自客户端的FIN请求后，需要同时回复ACK和发送FIN断开连接请求。但是在TCP连接中是有一个半关闭状态的，也就是服务端其实还是可以继续发送数据的，如果三次挥手，就无法做到服务器再发送数据了。</li></ol><h4 id="TCP传输为什么是可靠的"><a href="#TCP传输为什么是可靠的" class="headerlink" title="TCP传输为什么是可靠的"></a>TCP传输为什么是可靠的</h4><ul><li>确认与重传：如果一定时间内未收到ACK，则会重传</li><li>序列号与顺序性：TCP为每一个数据包分配一个序列号，接收端会进行数据包重组</li><li>流量控制</li><li>拥塞控制</li><li>连接管理：三次握手与四次挥手</li><li>超时与重试</li></ul><h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p>新建、就绪、运行、阻塞、等待、终止</p><h4 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h4><p>死锁发生的必要条件，通常被称为死锁的四个条件，分别是：</p><ol><li><strong>互斥条件（Mutual Exclusion）：</strong> 指某个资源在一段时间内只能被一个线程或进程占用，其他线程或进程需要等待资源释放才能继续执行。</li><li><strong>请求与保持条件（Hold and Wait）：</strong> 指线程在保持至少一个资源的同时，还请求其他资源，而这些资源可能被其他线程占用，导致请求阻塞。</li><li><strong>不剥夺条件（No Preemption）：</strong> 指资源只能由占有它的线程显式释放，其他线程不能强行抢占资源。</li><li><strong>循环等待条件（Circular Wait）：</strong> 指多个线程形成一个循环，每个线程都在等待下一个线程所持有的资源，导致一个闭环的等待状态。</li></ol><h4 id="死锁解决方案"><a href="#死锁解决方案" class="headerlink" title="死锁解决方案"></a>死锁解决方案</h4><ul><li>系统重新启动</li><li>撤销进程、剥夺资源</li><li>进程回退策略，即让参与死锁的进程回退到没有发生死锁前某一点处。</li></ul><h4 id="树的知识"><a href="#树的知识" class="headerlink" title="树的知识"></a>树的知识</h4><p><a href="https://oi-wiki.org/ds/bplus-tree/">https://oi-wiki.org/ds/bplus-tree/</a></p><h4 id="Linux-API调用返回值汇总"><a href="#Linux-API调用返回值汇总" class="headerlink" title="Linux API调用返回值汇总"></a>Linux API调用返回值汇总</h4><p>int pthread_create：成功时返回0，失败时返回错误码</p><p>void pthread_exit：不会失败</p><p>int pthread_join ( pthread_t thread, void** retval)：成功时返回0，失败时返回错误码。错误码：EDEADLK：可能引起死锁，比如两个线程互相针对对方调用pthread_join，或者线程对自身调用pthread_join；EINVAL：目标线程是不可回收的，或者已经有其他线程在回收该目标线程；ESRCH：目标线程不存在。</p><p>int sem_init( sem_t* sem, int pshared, unsigned int value )</p><p>int sem_destroy( sem_t* sem )</p><p>int sem_wait( sem_t* sem)</p><p>int sem_trywait( sem_t* sem )</p><p>int sem_post( sem_t* sem )：以上五个成功时返回0， 失败时返回-1并设置errno</p><h4 id="DNS的解析过程"><a href="#DNS的解析过程" class="headerlink" title="DNS的解析过程"></a>DNS的解析过程</h4><p>DNS是实现域名和IP地址相互映射的一个分布式数据库。DNS解析过程主要包括以下步骤</p><ol><li>本地缓存查询：当用户通过浏览器访问某域名时，浏览器会首先在自己的缓存里查询是否有该域名对应的IP地址。</li><li>本地系统查询：查看本计算机系统Host文件DNS缓存是否有对应DNS缓存</li><li>查看路由器缓存</li><li>查询ISP DNS缓存：也称本地域名服务器查询，计算机会向你的ISP（互联网服务提供商）分配的本地域名服务器发出查询请求</li><li>根域名服务器</li><li>顶级域名服务器：根域名服务器并不会直接返回用户IP地址，而是会指向查询请求对应的顶级域名服务器</li><li>权威域名服务器：顶级域名服务器会指向域名的权威域名服务器，这些服务器管理特定的域名的DNS服务。</li></ol><h4 id="TCP传输为什么是可靠的-1"><a href="#TCP传输为什么是可靠的-1" class="headerlink" title="TCP传输为什么是可靠的"></a>TCP传输为什么是可靠的</h4><p>总结下来主要包括三个方面：</p><ul><li>检验和</li><li>确认应答（ACK和序列号一应一答）</li><li>超时重传</li></ul><h4 id="NAT协议和跨域（不了解）"><a href="#NAT协议和跨域（不了解）" class="headerlink" title="NAT协议和跨域（不了解）"></a>NAT协议和跨域（不了解）</h4><h4 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h4><p>最明显的一个区别就是GET请求会把参数放在URL（统一资源定位符）中，POST会把参数放在请求体中。</p><p>数据大小限制：GET请求把参数放在URL中，GET请求数据大小收到URL长度限制。POST请求则不会</p><p>幂等性：GET请求每次相同请求返回的结果都一样，多次重复请求不会对资源产生影响。POST请求则相反</p><p>安全性：POST更安全，参数没有暴露在URL上</p><p>缓存：GET请求可以被浏览器缓存，POST请求不会被浏览器缓存</p><h4 id="写一段死锁的代码"><a href="#写一段死锁的代码" class="headerlink" title="写一段死锁的代码"></a>写一段死锁的代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_a;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">another</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in child thread, get mutex a\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_b);</span><br><span class="line">    b += a;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_b);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_a, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_b, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;id, <span class="literal">NULL</span>, another, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in parent thread, get mutex b\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    ++b;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_a);</span><br><span class="line">    a += b;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pro is end\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除字符串头尾空格代码"><a href="#删除字符串头尾空格代码" class="headerlink" title="删除字符串头尾空格代码"></a>删除字符串头尾空格代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::string tmp;</span><br><span class="line">    <span class="built_in">getline</span>(std::cin, s);   <span class="comment">//这里很重要哦，如果用cin，“hello world”会被截断成hello</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = s.<span class="built_in">substr</span>(i, s.<span class="built_in">size</span>() - i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = s.<span class="built_in">substr</span>(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shared-ptr是线程安全的吗？https-cloud-tencent-com-developer-article-1654442"><a href="#shared-ptr是线程安全的吗？https-cloud-tencent-com-developer-article-1654442" class="headerlink" title="shared_ptr是线程安全的吗？https://cloud.tencent.com/developer/article/1654442"></a>shared_ptr是线程安全的吗？<a href="https://cloud.tencent.com/developer/article/1654442">https://cloud.tencent.com/developer/article/1654442</a></h4><ul><li>多线程同时读一个shared_ptr对象是安全的</li><li>多线程同时对一个shared_ptr对象进行读和写是不安全的，需要加锁</li></ul><p>这里给出一个伪代码的简单例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Foo&gt; g(new Foo1);   // 线程之间共享的shared_ptr</span><br><span class="line">shared_ptr&lt;Foo&gt; x;     // 线程A的局部变量</span><br><span class="line">shared_ptr&lt;Foo&gt; n(new Foo2);   // 线程B的局部变量</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">线程A</span><br><span class="line">x = g;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">线程B</span><br><span class="line">g = n;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">测试场景：</span><br><span class="line"></span><br><span class="line">线程A </span><br><span class="line">  智能指针x 读取Foo1,然后还重置Foo1计数。</span><br><span class="line"></span><br><span class="line">线程 B:</span><br><span class="line"> 销毁了Foo1</span><br><span class="line">线程A</span><br><span class="line">重置计数时，foo1已经被销毁。</span><br></pre></td></tr></table></figure><h4 id="mysql读写锁怎么实现-mysql-读写锁和互斥锁的区别https-blog-51cto-com-u-16099299-7031260"><a href="#mysql读写锁怎么实现-mysql-读写锁和互斥锁的区别https-blog-51cto-com-u-16099299-7031260" class="headerlink" title="mysql读写锁怎么实现 mysql 读写锁和互斥锁的区别https://blog.51cto.com/u_16099299/7031260"></a>mysql读写锁怎么实现 mysql 读写锁和互斥锁的区别<a href="https://blog.51cto.com/u_16099299/7031260">https://blog.51cto.com/u_16099299/7031260</a></h4><ul><li>请你讲述一下互斥锁机制，以及互斥锁和读写锁的区别<ul><li>互斥锁（mutex），用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</li><li>读写锁（rwlock），分为读锁和写锁。处于读操作的时候，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其他获得写锁失败的线程将会进入睡眠状态，直到写锁释放时被唤醒。注意;写锁会阻塞其他读写锁。当有一个线程获得写锁在写时，读锁也不能被其他线程获取；写者优于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。<br>读写锁：区分读者和写者，而互斥锁不区分，互斥锁只允许同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。</li></ul></li><li>Linux中的四种锁机制<ul><li>互斥锁：在同一时间内只允许一个线程访问对象</li><li>读写锁：同一时间内允许多个读者同时读对象，同一时间内只允许一个写者访问对象，且当有一个线程获得写操作的时候，读锁也不能被其他的线程获取，写者优于读者，唤醒时先唤醒写者。</li><li>自旋锁：在任何时刻内自能有一个线程访问资源，但是当获取锁操作失败时，不会进入睡眠状态而是会原地自旋，直到锁被释放，这样减少了线程从睡眠状态到被唤醒状态的资源消耗，在加锁时间短暂的情况下使用会提高效率。但是加锁时间过长会非常浪费CPU</li><li>RCU（read-copy-update）：在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改，然后在将老数据update成新数据。在RCU的时候读者几乎不需要同步开销，即不需要获取锁，也不适用原子指令，不会导致竞争因此不用考虑死锁问题了。但是对于写者的同步开销比较大，他需要复制被修改的数据，还必须使用锁机制同步并行其他写者的改操作，在有大量读操作，少量写操作的时候使用。</li></ul></li></ul><h4 id="delete关键字的作用"><a href="#delete关键字的作用" class="headerlink" title="delete关键字的作用"></a>delete关键字的作用</h4><ol><li><p>删除特殊的成员函数：在C++11中可以使用delete来显示的阻止编译器自动生成某些特殊的成员函数。通过在类的声明中将这些特殊函数标记为delete，可以防止这些函数隐式的生成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() = <span class="keyword">delete</span>; <span class="comment">// 阻止生成默认构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp;) = <span class="keyword">delete</span>; <span class="comment">// 阻止生成拷贝构造函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>删除特定的函数重载：在函数重载时，可以使用delete关键字来标记某个特定的函数重载，防止特定的重载函数被调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">(<span class="type">double</span> x)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// 阻止调用带有 double 参数的函数</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="define和const的区别"><a href="#define和const的区别" class="headerlink" title="define和const的区别"></a>define和const的区别</h4><ul><li>就起作用的阶段而言：#define是在编译的预处理阶段起作用，而const是在编译、运行时起作用；</li><li>就起作用的方式而言：#define只是简单的字符串替换，没有类型检查，而const有类型检查，避免相应的错误；</li><li>就存储方式而言：#define只是进行展开，有多少地方使用，就有多少替换。const定义的只读变量在程序运行过程中只有一份备份；</li></ul><h4 id="写时拷贝（COW）https-www-cnblogs-com-biyeymyhjob-archive-2012-07-20-2601655-html"><a href="#写时拷贝（COW）https-www-cnblogs-com-biyeymyhjob-archive-2012-07-20-2601655-html" class="headerlink" title="写时拷贝（COW）https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html"></a>写时拷贝（COW）<a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html">https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html</a></h4><p>在linux里，fork（）会产生一个子进程，子进程与父进程用的是相同的物理空间，也就是说两者的虚拟空间不同，但对应的物理空间是一个。当父&#x2F;子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。这里的相应段你能理解不？其实就是一个程序一般分为哪些段，主要可以分为四大段：栈、堆、数据段、代码段；再细分的话可以加一个bss段，也就是用于存放程序中未初始化的全局变量的一块内存区域。</p><p>还有一个细节问题就是，fork之后内核会将子进程放在队列的前面，以让子进程先执行，以免父进程执行导致写时复制，造成不必要的复制，导致效率的下降。可以这么理解，可能子进程执行的代码并不需要写，完全可以使用原共享段，而父进程反而会改变（fork之后），如果父进程先执行，则子进程就要COW。</p><h4 id="coredump，gdb怎么定位"><a href="#coredump，gdb怎么定位" class="headerlink" title="coredump，gdb怎么定位"></a>coredump，gdb怎么定位</h4><p>整体流程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g source.cpp -o <span class="built_in">source</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./source</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./source ./core</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where(在gdb下输入)</span><br></pre></td></tr></table></figure><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><code>epoll</code></h4><p>关于<code>epoll</code>问题在这暂且不多写，只需记住内核事件表，<code>select</code>和<code>poll</code>都是轮询，事件复杂度：<code>epoll（o1）</code>，其他<code>（on）</code>。</p><p><code>select</code>和<code>poll</code>必须遍历内核事件表上所有已注册的文件描述符以找到其中的就绪者；<code>epoll</code>仅遍历就绪的文件描述符。</p><h4 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用"></a>static的作用</h4><ol><li><p>在函数体内，被声明为静态的变量在这一函数被调用过程中维持其值不变。</p><p>这句话其实是想说如果在函数内部声明了一个静态变量，那么这个变量在函数调用期间不会被重新初始化。它的生命周期是从程序开始到程序结束，但其作用域仍然限制在该函数内。这里给一段示例代码最好理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    num++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num is: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">count</span>();<span class="comment">// num = 1</span></span><br><span class="line">    <span class="built_in">count</span>();<span class="comment">// num = 2 正常情况下，如果是非static，num会被重新置0，但这里并没有体现出来。</span></span><br><span class="line">    <span class="built_in">count</span>();<span class="comment">// num = 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其他函数访问。它是一个本地的全局变量。</p><p>这句话就是表面意思，很好理解，这里给一个代码帮助理解</p><p><strong>moduleA.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> secretValue = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSecretValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; secretValue &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifySecretValue</span><span class="params">(<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">    secretValue = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>moudleB.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">printSecretValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">modifySecretValue</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printSecretValue</span>();</span><br><span class="line">    <span class="built_in">modifySecretValue</span>(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; secretValue &lt;&lt; std::endl; </span></span><br><span class="line">    <span class="comment">// 记住，这句话是会导致编译错误的，模块B不能直接访问模块A的变量。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在模块内，一个被声明为静态的函数只可被本模块内的其他函数调用。也就是，这个函数被限制在声明它的模块的本地范围内使用。</p><p>这里的意思其实就和第二点差不多了，也给一个简单示例代码吧</p><p><strong>moduleA.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个静态函数，只在moduleA.cpp中可见</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">secretFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside secret function of moduleA!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公开的函数，可以被其他模块调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">publicFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside public function of moduleA.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">secretFunction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>moduleB.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">publicFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">publicFunction</span>();  <span class="comment">// 可以调用这个函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能调用 secretFunction，因为它在moduleA.cpp中是静态的</span></span><br><span class="line">    <span class="comment">// secretFunction();  // 这一行会导致编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>moduleA.cpp</code>定义了一个静态函数<code>secretFunction</code>。在<code>moduleB.cpp</code>中，我们可以调用<code>publicFunction</code>，但当我们尝试调用<code>secretFunction</code>时，会导致编译错误，因为<code>secretFunction</code>只在<code>moduleA.cpp</code>中可见。</p></li></ol><h4 id="有关static的必要补充"><a href="#有关static的必要补充" class="headerlink" title="有关static的必要补充"></a>有关static的必要补充</h4><ul><li><p>修饰成员变量</p><p>用static修饰类的数据成员，使其成为类的全局变量，会被类的所有对象共享，包括派生类对象。<strong>所有对象只维持同一个实例。</strong>因此类的static成员必须进行类外初始化，而不能在构造函数内进行初始化，不过也可以用const修饰static数据成员在类内初始化。因为const修饰的变量无法修改。</p></li><li><p>修饰成员函数</p><p>用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针，因而只能访问static成员变量。<strong>注意</strong>：正是因为static修饰的成员函数不含this指针，而const修饰的成员函数会添加一个隐藏的参数const this*，所以这两种语义是矛盾的，所以在成员函数上不能同时用他们。</p></li><li><p>this指针理解</p><p>对象就是大房子，成员就是房子里的物件，this是一个指着房子的指针，如果要获取对象的成员也就是大房子内的物件，需要使用this指针加-&gt;这个符号。</p></li></ul><h4 id="三种智能指针"><a href="#三种智能指针" class="headerlink" title="三种智能指针"></a>三种智能指针</h4><p>智能指针是在栈中的一个类，用于管理堆上分配的内存。传统的C&#x2F;C++对于堆上内存的开辟释放，需要程序手动管理，而智能指针是一个类，有构造函数和析构函数，在超出作用范围后，程序会自动调用析构函数释放其管理的指针指向的内存，不需要手动释放。</p><ul><li>shared_ptr共享智能指针，多个智能指针可以指向同一个对象，对象的资源在最后一个指针销毁时释放，通过引用计数来判断是否是最后一个智能指针。</li><li>unique_ptr独占智能指针，同一时刻只有一个智能指针可以指向该对象，如果要安全重用该指针，标准库函数std::move()可以将unique_ptr赋值给另一个unique_ptr。</li><li>weak_ptr      弱智能指针，不会增加shared_ptr的引用计数，可以避免两个shared_ptr相互引用的死锁问题。weak_ptr只能用shared_ptr或者另一个weak_ptr构造，通过lock()方法weak_ptr可以转化为shared_ptr。</li></ul><p>下面给出代码示例</p><p><strong>unique_ptr</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string str;</span><br><span class="line">    ~<span class="built_in">test</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;test::~test()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> test())</span></span>;</span><br><span class="line">    p1-&gt;str = <span class="string">&quot;test string&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1-&gt;str: &quot;</span> &lt;&lt; p1-&gt;str &lt;&lt; std::endl;</span><br><span class="line">    std::unique_ptr&lt;test&gt; p2;</span><br><span class="line">    p2 = std::<span class="built_in">move</span>(p1);</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; p1-&gt;str &lt;&lt; std::endl; p1此时已经访问不到资源了</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p2-&gt;str: &quot;</span> &lt;&lt; p2-&gt;str &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// p1-&gt;str: test string</span></span><br><span class="line"><span class="comment">// p2-&gt;str: test string</span></span><br><span class="line"><span class="comment">// test::~test() 析构函数发生了调用，自动释放资源</span></span><br></pre></td></tr></table></figure><p><strong>shared_ptr</strong>造成的死锁问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; a;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;A&gt; b;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::~B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*******前边两个类中相互引用，此时引入weak_ptr解决死锁问题*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    p1-&gt;a = p2;</span><br><span class="line">    p2-&gt;b = p1;<span class="comment">//这种情况发生死锁,两个shared_ptr计数都不会为0，资源不会被释放</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count():&quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count():&quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体解释一下死锁的产生主要原因是引用计数无法降为0。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">首先，来理解下为什么这种情况会导致资源不能被释放：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 当你创建`p1`和`p2`时，它们都有一个引用计数为1。</span></span><br><span class="line"><span class="comment">2. 当执行`p1-&gt;a = p2;`，`p2`的引用计数增加到2，因为现在有两个`shared_ptr`对象（`p1-&gt;a`和`p2`）指向同一个`B`对象。</span></span><br><span class="line"><span class="comment">3. 当执行`p2-&gt;b = p1;`，`p1`的引用计数增加到2，因为现在有两个`shared_ptr`对象（`p2-&gt;b`和`p1`）指向同一个`A`对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">到此，我们得到了一个环状结构：`p1`指向`A`对象，`A`对象内部的`shared_ptr`指向`B`对象，`B`对象内部的`shared_ptr`又指向`A`对象。这就形成了循环引用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当`main`函数返回时，`p1`和`p2`的析构函数将被调用，但是它们的引用计数都不会降为0，因为循环引用。所以，`A`和`B`对象的析构函数永远不会被调用，这就导致了资源泄漏。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">要解决这个问题，可以使用`weak_ptr`来打破循环引用。你可以将其中一个类的`shared_ptr`成员变量替换为`weak_ptr`。这样，`weak_ptr`不会增加引用计数，从而避免了循环引用的问题。当你需要从`weak_ptr`获取一个`shared_ptr`时，可以使用`lock`方法。</span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></figure><p><strong>weak_prt</strong>解决循环引用问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; a;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    weak_ptr&lt;A&gt; b;  <span class="comment">// 将 shared_ptr 替换为 weak_ptr</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::~B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line">    p1-&gt;a = p2;</span><br><span class="line">    p2-&gt;b = p1;  <span class="comment">// 这里不会增加 p1 的引用计数</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 use_count(): &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 输出 1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2 use_count(): &quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 当 main 返回时，p1 和 p2 都会被析构，它们所指向的对象也会被正确地销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="STL内存池机制"><a href="#STL内存池机制" class="headerlink" title="STL内存池机制"></a>STL内存池机制</h4><ul><li><p>第一级配置器</p><p>第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。</p></li><li><p>第二级配置器</p><p>在STL的第二级配置器中多了一些机制，避免太多小区造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。</p><p>如果要分配的区块大于128bytes，则移交给第一级配置器处理。<br>如果要分配的区块小于128bytes，则以 内存池管理（memory pool），又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。</p><p>参考连接：<a href="https://blog.csdn.net/a987073381/article/details/52245795">https://blog.csdn.net/a987073381/article/details/52245795</a></p></li></ul><h4 id="索引选B-树的原因"><a href="#索引选B-树的原因" class="headerlink" title="索引选B+树的原因"></a>索引选B+树的原因</h4><p>个人感觉主要就是探讨B+树和B树之间的区别。<br>参考链接：<a href="https://www.cnblogs.com/JCpeng/p/15231338.html">https://www.cnblogs.com/JCpeng/p/15231338.html</a></p><h4 id="服务端TIME-WAIT过多的危害及解决办法"><a href="#服务端TIME-WAIT过多的危害及解决办法" class="headerlink" title="服务端TIME_WAIT过多的危害及解决办法"></a>服务端TIME_WAIT过多的危害及解决办法</h4><p>危害</p><ul><li>导致大量socket连接端口被占用无法释放，导致系统停转</li><li>处理大量的TIME_WAIT状态的连接会占用更多的CPU时间，导致服务器响应时间增加</li></ul><p>解决办法</p><ul><li>调整系统内核参数</li><li>调整短连接为长连接</li></ul><h4 id="set底层数据结构"><a href="#set底层数据结构" class="headerlink" title="set底层数据结构"></a>set底层数据结构</h4><p>set底层数据结构是红黑树。关于map和set的一些问题列举如下：</p><p><strong>为何map和set的插入删除效率比用其他序列容器高？</strong><br>因为对于关联容器来说，不需要做内存拷贝和内存移动。因为map和set容器内部所有元素都是以节点的方式来存储，父节点和子节点。因此插入和删除的时候都是指针的指向换来换去，并没有内存移动。</p><p><strong>为何每次插入&#x2F;删除后以前保存的迭代器不会失效</strong><br>在这里，迭代器就相当于指向节点的指针，内存没有变，指向内存的指针当然不会失效。不同于map&#x2F;set，vector就会失效，比如需要扩容的时候，需要一块更大的内存，就必须把之前的内存释放，申请更大的内存，复制已有的数据元素到新的内存。</p><p><strong>为何map和set不能像vector一样有个reserve函数来预分配数据</strong><br>不懂！预留本问题</p><p><strong>当数据元素增多时（10000到20000个比较），map和set的插入和搜索速度变化如何？</strong><br>map和set使用的是二分查找，举例来说就是，16个元素查四次，32个元素查5次，10000个也就是14次，20000也就15次。</p><h4 id="mapreduce原理（不懂，预留）"><a href="#mapreduce原理（不懂，预留）" class="headerlink" title="mapreduce原理（不懂，预留）"></a>mapreduce原理（不懂，预留）</h4><h4 id="socket哪些操作会产生阻塞"><a href="#socket哪些操作会产生阻塞" class="headerlink" title="socket哪些操作会产生阻塞"></a>socket哪些操作会产生阻塞</h4><p>accept()：在等待客户端的连接请求时会阻塞。如果没有客户端尝试连接，调用这个函数的进程或者线程会被挂起。</p><p>connect()：当客户端尝试与远程主机建立连接时，此操作会阻塞，知道连接成功或失败</p><p>recv()：当数据从网络到达时，如果没有数据可读，函数调用就会被挂起，阻塞</p><p>send()：当发送缓冲区已满，并且无法接受更多数据发送到网络时，操作阻塞。</p><h4 id="申请一块大内存和一块小内存的效率是一样的吗？"><a href="#申请一块大内存和一块小内存的效率是一样的吗？" class="headerlink" title="申请一块大内存和一块小内存的效率是一样的吗？"></a>申请一块大内存和一块小内存的效率是一样的吗？</h4><p>不一样，申请一块小内存通常是不需要一级配置器，小块内存通常由内存分配器从预先分配的内存池中分配，这些池被称为<code>bins</code>，这种分配通常非常快，因为它只是涉及到从已存在的内存池中返回一个指针。大的内存通常要调用<code>mmap()</code>。</p><h4 id="TCP慢启动和拥塞控制"><a href="#TCP慢启动和拥塞控制" class="headerlink" title="TCP慢启动和拥塞控制"></a>TCP慢启动和拥塞控制</h4><p>TCP连接建立好之后，CWND（congestion window，拥塞窗口）被设置为初始值IW（initial window），其大小为2~4个SMSS（TCP报文段的最大长度，仅指数据部分），新的linux内核加大了这个值。此时发送端最多能发送IW字节的数据，此后发送端每收到一个确认，CWND就按照如下公式增长：<br>$$<br>CWND +&#x3D; min(N, SMSS)<br>$$<br>其中N是此次确认中包含的之前未被确认的字节数。<br>如果不施加其他手段，慢启动必然使得CWND增长的很快，所以TCP拥塞控制中有另外一个非常重要的变量：慢启动门限。当CWND超过慢启动门限值时，TCP将进入拥塞避免阶段。</p><h4 id="发送端判断发生拥塞的依据"><a href="#发送端判断发生拥塞的依据" class="headerlink" title="发送端判断发生拥塞的依据"></a>发送端判断发生拥塞的依据</h4><ul><li>传输超时</li><li>接收到重复的确认报文段</li></ul><h4 id="Linux下的POSIX互斥锁和条件变量"><a href="#Linux下的POSIX互斥锁和条件变量" class="headerlink" title="Linux下的POSIX互斥锁和条件变量"></a>Linux下的POSIX互斥锁和条件变量</h4><p>牢记这几个函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">pthread_mutex_destory(&amp;mutex);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">pthread_mutex_trylock(&amp;mutex);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_init(&amp;cond, NULL);</span><br><span class="line">pthread_cond_destory(&amp;cond);</span><br><span class="line">pthread_cond_broadcast(&amp;cond);</span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);</span><br></pre></td></tr></table></figure><p>条件变量要配合互斥锁使用。这里挂一个讲的比较清晰明了的博客链接（<a href="https://punmy.cn/2018/06/07/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condition%20Variables%EF%BC%89.html%EF%BC%89%EF%BC%8C%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E5%8A%A0%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B">https://punmy.cn/2018/06/07/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condition%20Variables%EF%BC%89.html），下面是使用互斥锁加条件变量实现的生产者-消费者模型</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mutex_;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span> condition_;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_t</span> notifying_thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;condition_, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;condition_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span> *args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">    <span class="keyword">while</span>(value != <span class="number">10</span>)&#123;</span><br><span class="line">        value++;</span><br><span class="line">    &#125;</span><br><span class="line">    notifying_thread = <span class="built_in">pthread_self</span>();</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;condition_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">    <span class="keyword">while</span>(value != <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;condition_, &amp;mutex_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value is 10, the pthread is: %lu\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)notifying_thread);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">consumer</span><span class="params">(<span class="type">void</span> *args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">waitCondition</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> a1;</span><br><span class="line">    <span class="type">pthread_t</span> a2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;a1, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;a2, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(a1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(a2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">destory</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写一个生产者-x2F-消费者模型（采用信号量）"><a href="#写一个生产者-x2F-消费者模型（采用信号量）" class="headerlink" title="写一个生产者&#x2F;消费者模型（采用信号量）"></a>写一个生产者&#x2F;消费者模型（采用信号量）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_BUFFERS = <span class="number">10</span>;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> empty;</span><br><span class="line"><span class="type">sem_t</span> full;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        num = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;empty);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">        buffer.<span class="built_in">push</span>(num);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">comsumer</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;full);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">        num = buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Comsumed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> proThread, comPthread;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;empty, <span class="number">0</span>, MAX_BUFFERS);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;full, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;proThread, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;comPthread, <span class="literal">NULL</span>, comsumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(proThread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(comPthread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;empty);</span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;full);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基类的析构函数为什么是虚函数"><a href="#基类的析构函数为什么是虚函数" class="headerlink" title="基类的析构函数为什么是虚函数"></a>基类的析构函数为什么是虚函数</h4><p>当基类的析构函数不是虚函数可能会导致派生类对象的析构函数不被调用。从而引发资源泄露或者其他未定义行为。下面给出示例代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base obj is constructed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="comment">// ~Base() &#123; std::cout &lt;&lt; &quot;Base obj is deconstructed&quot; &lt;&lt; std::endl; &#125;</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base obj is deconstructed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()&#123;</span><br><span class="line">        num_ = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived is constructed&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Derived</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived is deconstructed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *num_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base *base = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）"><a href="#为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）" class="headerlink" title="为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）"></a>为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）</h4><p>当一个基类没有虚析构函数，并且通过基类指针删除一个派生类对象时，只有基类的析构函数会被调用。这是因为编译器在编译时期决定了调用哪个析构函数，而不是在运行时期，这种机制被称为“静态绑定”。</p><p>如果基类的析构函数是虚函数，那么编译器会在运行时决定要调用哪个析构函数，这种机制称为“动态绑定”或“多态”。</p><h4 id="拷贝构造函数为什么要用引用"><a href="#拷贝构造函数为什么要用引用" class="headerlink" title="拷贝构造函数为什么要用引用"></a>拷贝构造函数为什么要用引用</h4><p>避免拷贝构造函数无限递归下去！那传引用为什么行呢？回忆一下引用定义，传引用人家根本就不会涉及到构造函数这玩意，形参相当于实参的一个别名。</p><h4 id="左右值的差别"><a href="#左右值的差别" class="headerlink" title="左右值的差别"></a>左右值的差别</h4><h4 id="C-中的虚继承"><a href="#C-中的虚继承" class="headerlink" title="C++中的虚继承"></a>C++中的虚继承</h4><p>c++中的虚继承主要是为了解决多继承情况中存在的二义性问题。比如，现在类A为基类，类B和类C继承自类A，类D继承自类B和类C，假设此时A中有一个名为x的变量且B和C都定义了x，如果此时D直接访问x会产生二义性问题。因为不清楚是A-&gt;B-&gt;D还是A-&gt;C-&gt;D。此时如果让类B和类C虚继承自A，就使得在派生类中只保留有一份成员变量x，解决了二义性问题。<br>参考链接：<br><a href="http://c.biancheng.net/view/2280.html">http://c.biancheng.net/view/2280.html</a><br><a href="https://zhuanlan.zhihu.com/p/41309205%EF%BC%88%E8%99%9A%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E9%83%BD%E8%AE%B2%E4%BA%86%EF%BC%8C%E5%8D%81%E5%88%86%E8%AF%A6%E7%BB%86%EF%BC%89">https://zhuanlan.zhihu.com/p/41309205（虚继承、虚函数都讲了，十分详细）</a></p><h4 id="C-中的forward函数"><a href="#C-中的forward函数" class="headerlink" title="C++中的forward函数"></a>C++中的forward函数</h4><p>左值引用和右值引用的结果都是左值，无法通过引用区分原本变量的左右值，forward可以保持变量的原本的左右值属性，帮助我们区分。</p><h4 id="如何判断TCP断开"><a href="#如何判断TCP断开" class="headerlink" title="如何判断TCP断开"></a>如何判断TCP断开</h4><ol><li>发送心跳消息</li><li>利用recv&#x2F;send函数的返回值<ul><li>recv返回0代表对方关闭了连接</li><li>recv返回-1并且errno&#x3D;&#x3D;EAGAIN或者EWOULDBLOCK时，表示没有数据可读，可以稍后再试。</li><li><strong>send返回非负值</strong>:<ul><li><code>send</code>返回的是实际发送的字节数，这可能会少于你请求发送的字节数（缓冲区已满）。</li><li>如果没有可用的缓冲区空间，那么在非阻塞模式下，<code>send</code>可能会返回<code>EAGAIN</code>或<code>EWOULDBLOCK</code>。</li></ul></li><li><strong>send返回-1</strong>:<ul><li>与<code>recv</code>类似，这表示出现了错误。</li><li>可以使用<code>perror</code>、<code>strerror</code>或检查<code>errno</code>来确定具体的错误原因。</li><li>常见的错误原因包括<code>EPIPE</code>（对端已关闭，本端仍尝试发送数据导致的”Broken pipe”错误）和<code>ECONNRESET</code>（连接被对端重置）。</li></ul></li></ul></li><li>利用tcp自带的keepalive机制</li></ol><h4 id="如何查看系统的最大进程数和线程数"><a href="#如何查看系统的最大进程数和线程数" class="headerlink" title="如何查看系统的最大进程数和线程数"></a>如何查看系统的最大进程数和线程数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/pid_max    # 最大进程数</span><br><span class="line">cat /proc/sys/kernel/threads-max# 最大线程数</span><br></pre></td></tr></table></figure><h4 id="git-rebase和git-merge的区别（https-joyohub-com-2020-04-06-git-rebase-）"><a href="#git-rebase和git-merge的区别（https-joyohub-com-2020-04-06-git-rebase-）" class="headerlink" title="git rebase和git merge的区别（https://joyohub.com/2020/04/06/git-rebase/）"></a>git rebase和git merge的区别（<a href="https://joyohub.com/2020/04/06/git-rebase/%EF%BC%89">https://joyohub.com/2020/04/06/git-rebase/）</a></h4><h4 id="C-calss-和-struct的区别"><a href="#C-calss-和-struct的区别" class="headerlink" title="C++ calss 和 struct的区别"></a>C++ calss 和 struct的区别</h4><p>class默认访问类型是private，struct默认访问类型是public</p><h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><ol><li>指针是一个变量，它保存了另一个变量的内存地址；引用是另一个变量的别名，与原变量共享内存地址。</li><li>指针可以被重新赋值，指向新的对象；引用绑定对象后不能更改。</li><li>指针可以为nullptr；引用必须初始化。</li></ol><h4 id="为什么模板类的声明和实现不能分别写在-h文件和-cpp文件中"><a href="#为什么模板类的声明和实现不能分别写在-h文件和-cpp文件中" class="headerlink" title="为什么模板类的声明和实现不能分别写在.h文件和.cpp文件中"></a>为什么模板类的声明和实现不能分别写在.h文件和.cpp文件中</h4><p>首先，模板不是传统意义上的代码。它更像是编译器的“代码生成工具”。当你使用一个特定的模板类型（例如<code>std::vector&lt;int&gt;</code>)，<strong>编译器会为你生成这种类型的实例代码</strong>。为了做到这一点，编译器需要能够看到模板的完整定义。注意：这就是模板和普通类的最大区别。普通类在编译阶段并没有（并不依赖于）编译时的类型特化，只需要在链接阶段将所有.cpp文件链接在一起就好了。而如果模板分开写，其他使用模板的.cpp文件在编译时找不到定义，导致链接错误。</p><h4 id="动态链接与静态链接"><a href="#动态链接与静态链接" class="headerlink" title="动态链接与静态链接"></a>动态链接与静态链接</h4><p>静态链接（.a&#x2F;.lib）：把要调用的函数或者过程链接到可执行文件中，成为可执行文件的一部分。如果多个程序使用相同的库，那么该库的代码在每个程序中都会被复制，这浪费了磁盘和内存空间。但是所有代码都在可执行文件中，没有运行时链接开销。</p><p>动态链接（.so&#x2F;.ddl）：动态链接所调用的函数代码并没有被拷贝到应用程序的可执行文件中去，而是仅仅在其中加入了所调用函数的描述信息（往往是一些重定位信息）。仅当应用程序被装入内存开始运行时，在Windows的管理下，才在应用程序与相应的DLL之间建立链接关系。当要执行所调用DLL中的函数时，根据链接产生的重定位信息，Windows才转去执行DLL中相应的函数代码。多份代码可以共享同一份库代码。</p><h4 id="pragma-pack编译宏"><a href="#pragma-pack编译宏" class="headerlink" title="pragma pack编译宏"></a>pragma pack编译宏</h4><p>pragma pack用于指定内存对齐值。</p><h4 id="vector底层实现原理"><a href="#vector底层实现原理" class="headerlink" title="vector底层实现原理"></a>vector底层实现原理</h4><p>理解vector的实现主要考虑四个东西就好了：三个指针加动态内存申请。</p><p>三个指针：</p><ul><li>first_：指向vector容器对象起始地址的位置</li><li>last_：指向vector容器对象中当前最后一个元素的末尾字节</li><li>end_：指向vector容器所占内存空间的最后一个字节</li></ul><p><img src="png1.gif"></p><p>动态内存申请：</p><p>当 vector 的大小和容量相等（size&#x3D;&#x3D;capacity）也就是满载时，如果再向其添加元素，那么 vector 就需要扩容。vector 容器扩容的过程需要经历以下 3 步：</p><ol><li>完全弃用现有的内存空间，重新申请更大的内存空间；</li><li>将旧内存空间中的数据，按原有顺序移动到新的内存空间中；</li><li>最后将旧的内存空间释放。</li></ol><h4 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h4><p>常量指针：记忆方法（常量的指针），指针指向的对象是一个常量，只能读取指针指向的内容，不能修改指针指向的内容。</p><p>指针常量：指针本身是一个常量，不能修改指针指向的地址，可以修改指针指向地址的内容。</p><h4 id="C-中一些特别的关键字（default，override、final、volatile）"><a href="#C-中一些特别的关键字（default，override、final、volatile）" class="headerlink" title="C++中一些特别的关键字（default，override、final、volatile）"></a>C++中一些特别的关键字（default，override、final、volatile）</h4><p>参考链接：<a href="https://blog.csdn.net/u011947630/article/details/103062773">https://blog.csdn.net/u011947630/article/details/103062773</a></p><h4 id="字节算法题：小于N的最大数"><a href="#字节算法题：小于N的最大数" class="headerlink" title="字节算法题：小于N的最大数"></a>字节算法题：小于N的最大数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> value = <span class="number">14132</span>;</span><br><span class="line">string valueStr = <span class="built_in">to_string</span>(value);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index, <span class="type">bool</span> judge, <span class="type">int</span> temp)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(index == valueStr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ans = temp;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(judge) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">true</span>, temp * <span class="number">10</span> + (nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>]));    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> val = valueStr[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val == nums[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">false</span>, temp * <span class="number">10</span> + nums[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; nums[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">true</span>, temp * <span class="number">10</span> + nums[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最终结果为空</span></span><br><span class="line">        <span class="keyword">if</span>(index != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//少了一位，显然小了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">true</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如果同时有大量客户并发建立连接，服务器端有什么机制进行处理"><a href="#如果同时有大量客户并发建立连接，服务器端有什么机制进行处理" class="headerlink" title="如果同时有大量客户并发建立连接，服务器端有什么机制进行处理"></a>如果同时有大量客户并发建立连接，服务器端有什么机制进行处理</h4><ol><li>多进程和多线程</li><li>连接池</li><li>异步I&#x2F;O</li><li>负载均衡</li><li>限流</li><li>短连接与长连接</li></ol><h4 id="HTTP和TCP之间的关系"><a href="#HTTP和TCP之间的关系" class="headerlink" title="HTTP和TCP之间的关系"></a>HTTP和TCP之间的关系</h4><ol><li><p>HTTP是一个应用层协议，TCP是一个传输层协议</p></li><li><p>HTTP依赖于TCP来进行数据的传输。比如，当你使用浏览器访问一个网页时，背后发生的是HTTP请求和响应的交换，而这些HTTP数据包是通过TCP连接发送的。</p></li><li><p>HTTP&#x2F;1.0对于每一个请求-响应都会新建一个TCP连接，使用完之后就关闭</p><p>HTPP&#x2F;1.1引入了keep-alive机制，允许在单个TCP连接上发送多个HTTP请求和响应</p><p>HTTP&#x2F;2进一步扩展了这种机制，允许在单个TCP连接上同时多路复用多个HTTP请求和响应</p></li></ol><h4 id="HTTP从请求到得到结果的过程"><a href="#HTTP从请求到得到结果的过程" class="headerlink" title="HTTP从请求到得到结果的过程"></a>HTTP从请求到得到结果的过程</h4><ol><li><p><strong>域名解析</strong>：</p><ul><li>客户端（通常是浏览器）首先检查URL是否包含域名（例如 <code>www.example.com</code>）。</li><li>如果包含，客户端首先会查找其DNS缓存是否已经有该域名的IP地址。</li><li>如果没有，客户端会发起一个DNS查询到配置的DNS服务器，以获取对应的IP地址。</li></ul></li><li><p><strong>建立TCP连接</strong>：</p><ul><li>使用从DNS查询得到的IP地址，客户端尝试与服务器的80端口（HTTP）或443端口（HTTPS）建立一个TCP连接。</li><li>这涉及到TCP三次握手过程。</li></ul></li><li><p><strong>（HTTPS的情况）SSL&#x2F;TLS握手</strong>：</p><ul><li>如果是HTTPS请求，一旦TCP连接建立，客户端和服务器会进行SSL&#x2F;TLS握手来建立加密的通信通道。</li></ul></li><li><p><strong>发送HTTP请求</strong>：</p><ul><li>连接建立后，客户端会发送HTTP请求报文。这包括请求行（例如 <code>GET /path HTTP/1.1</code>）、请求头和（对于某些请求如POST）请求体。</li></ul></li><li><p><strong>服务器处理请求</strong>：</p><ul><li>服务器接收到请求后，由其HTTP服务软件（如Apache、Nginx等）处理。</li><li>服务器可能会根据请求路径查询文件、与数据库交互或调用其他服务，以生成响应。</li></ul></li><li><p><strong>服务器发送响应</strong>：</p><ul><li>服务器生成响应后，它将响应报文发送回客户端。响应通常包括状态行（例如 <code>HTTP/1.1 200 OK</code>）、响应头和响应体。</li><li>对于动态内容，如由PHP、Python或Node.js等后端语言生成的页面，服务器可能会进行一些额外的处理来生成响应内容。</li></ul></li><li><p><strong>客户端处理响应</strong>：</p><ul><li>客户端（如浏览器）接收响应，并基于响应内容采取相应的行动。</li><li>如果响应是一个HTML页面，浏览器会开始解析HTML，并可能发起其他请求来获取页面上的资源，如图片、CSS、JavaScript文件等。</li></ul></li><li><p><strong>关闭连接</strong>：</p><ul><li>一旦数据交换完成，通常会关闭TCP连接。然而，在HTTP&#x2F;1.1中，默认使用<code>keep-alive</code>，意味着连接可以被复用，从而减少后续请求的延迟。</li></ul></li></ol><h4 id="https和http的区别是什么，https具体是怎么做的"><a href="#https和http的区别是什么，https具体是怎么做的" class="headerlink" title="https和http的区别是什么，https具体是怎么做的"></a>https和http的区别是什么，https具体是怎么做的</h4><p>HTTPS和HTTP唯一的区别就是HTTPS使用TLS&#x2F;SSL来加密普通的HTTP请求和响应。</p><p>关于https具体是如何做的，这里有一个参考博文链接，写的超好（参考链接：<a href="https://www.runoob.com/w3cnote/http-vs-https.html%EF%BC%89">https://www.runoob.com/w3cnote/http-vs-https.html）</a></p><h4 id="gdb中，如何查看每个线程相关的信息"><a href="#gdb中，如何查看每个线程相关的信息" class="headerlink" title="gdb中，如何查看每个线程相关的信息"></a>gdb中，如何查看每个线程相关的信息</h4><p>在 gdb 中，可以使用 <code>info threads</code> 命令查看当前进程中的所有线程信息。这个命令会列出每个线程的编号、状态（如运行、挂起等）以及当前所在的函数名称。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info threads</span><br><span class="line">  Id   Target Id         Frame </span><br><span class="line">  2    Thread 0x7ffff7fc8700 (LWP 13627) <span class="string">&quot;main&quot;</span> __libc_start_main (argc=1, argv=0x7fffffffe4c8, <span class="built_in">env</span>=0x7fffffffe4d8,</span><br><span class="line">      auxvec=0x7fffffffe4d8, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffe4c8) at ../csu/libc-start.c:310</span><br><span class="line">  3    Thread 0x7ffff77c7700 (LWP 13628) <span class="string">&quot;main&quot;</span> foo () at test.c:6</span><br><span class="line">  4    Thread 0x7ffff6fc6700 (LWP 13629) <span class="string">&quot;main&quot;</span> bar () at test.c:11</span><br></pre></td></tr></table></figure><p>你还可以使用 <code>thread &lt;thread-id&gt;</code> 命令来切换到指定的线程，然后使用其他 gdb 命令来查看线程的信息或调试线程。</p><p>例如，你可以输入 <code>thread 3</code> 命令切换到编号为 3 的线程，然后输入 <code>bt</code> 命令来查看线程的调用堆栈：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) thread 3</span><br><span class="line">[Switching to thread 3 (Thread 0x7ffff77c7700 (LWP 13628))]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  foo () at test.c:6</span></span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  foo () at test.c:6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00007ffff7bbb830 <span class="keyword">in</span> start_thread (arg=&lt;optimized out&gt;) at pthread_create.c:486</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007ffff78f95fd <span class="keyword">in</span> <span class="built_in">clone</span> () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span></span><br></pre></td></tr></table></figure><h4 id="构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因"><a href="#构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因" class="headerlink" title="构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因"></a>构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因</h4><p>构造函数从语法上调用虚函数没有任何问题，但这样做可能并不会达到预期的结果。因为在构造函数执行期间，对象的虚表仍在被设置，因此调用的虚函数版本可能并不是我们想要的版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base construct\n&quot;</span>;</span><br><span class="line">        <span class="built_in">call</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base call\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived construct\n&quot;</span>;</span><br><span class="line">        <span class="built_in">call</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived call\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面这段程序，可能我们期望得到的结果是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Derived call</span><br><span class="line">Derived constructor</span><br><span class="line">Derived call</span><br></pre></td></tr></table></figure><p>但我们实际得到的结果是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Base call</span><br><span class="line">Derived constructor</span><br><span class="line">Derived call</span><br></pre></td></tr></table></figure><p>原因是在Base构造函数执行时，Derived部分的对象还没有完全构造出来，因此，此时vtable仍然指向Base类的vtable。因此，当在Base构造函数中调用call虚函数时，他会调用Base版本，而不是Derived版本。</p><p><strong>这里延伸一下不要在析构函数中调用虚函数的原因</strong>：析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经“销毁”，这个时再调用子类的虚函数已经没有意义了。</p><h4 id="迭代器的实现"><a href="#迭代器的实现" class="headerlink" title="迭代器的实现"></a>迭代器的实现</h4><p>参考链接：<a href="https://www.cnblogs.com/wengle520/p/12492708.html">https://www.cnblogs.com/wengle520/p/12492708.html</a></p><h4 id="epoll红黑树的作用"><a href="#epoll红黑树的作用" class="headerlink" title="epoll红黑树的作用"></a>epoll红黑树的作用</h4><p>简单点讲就是在内核事件表上快速注册&#x2F;删除所需连接文件描述符。下面两篇文章基本阐述了这个问题，好好看！</p><p><a href="https://cloud.tencent.com/developer/article/1862671">https://cloud.tencent.com/developer/article/1862671</a></p><p><a href="https://zhuanlan.zhihu.com/p/366955699">https://zhuanlan.zhihu.com/p/366955699</a></p><h4 id="用户态和内核态分别会做什么，怎么切换的"><a href="#用户态和内核态分别会做什么，怎么切换的" class="headerlink" title="用户态和内核态分别会做什么，怎么切换的"></a>用户态和内核态分别会做什么，怎么切换的</h4><p>内核空间主要负责操作系统内核线程以及用户程序系统调用。</p><p>用户空间主要负责用户程序的非系统调用。</p><p>从用户态切换到内核态主要有三种方式：</p><ol><li>系统调用：系统调用本身就是中断，但是<strong>软件中断</strong>，跟硬中断不同。系统调用机制是使用了操作系统为用户特别开放的一个中断来实现，如 Linux 的 int 80h 中断。</li><li>异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，会触发由当前运行进程切换到处理此异常的内核相关进程中</li><li>外围设备中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序。</li></ol><p>有一个面试问题：I&#x2F;O频繁发生内核态和用户态切换，怎么解决？</p><p>答案：使用用户进程缓冲区。</p><p>用户进程缓冲区</p><p>你看一些程序在读取文件时，会先申请一块内存数组，称为buffer，然后每次调用read，读取设定字节长度的数据，写入buffer。之后的程序都是从buffer中获取数据，当buffer使用完后，在进行下一次调用，填充buffer。所以说：用户缓冲区的目的就是是为了减少系统调用次数，从而降低操作系统在用户态与核心态切换所耗费的时间。除了在进程中设计缓冲区，内核也有自己的缓冲区。</p><p>内核缓存区</p><p>当一个用户进程要从磁盘读取数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程缓冲区中。但若是内核缓冲区中没有数据，内核会把对数据块的请求，加入到请求队列，然后把进程挂起，为其它进程提供服务。等到数据已经读取到内核缓冲区时，把内核缓冲区中的数据读取到用户进程中，才会通知进程，当然不同的IO模型，在调度和使用内核缓冲区的方式上有所不同。</p><p>参考链接：</p><p><a href="https://blog.csdn.net/qq_42052956/article/details/111562280">https://blog.csdn.net/qq_42052956/article/details/111562280</a></p><p><a href="https://cloud.tencent.com/developer/article/2131401">https://cloud.tencent.com/developer/article/2131401</a></p><h4 id="进程的创建需要系统分配什么资源"><a href="#进程的创建需要系统分配什么资源" class="headerlink" title="进程的创建需要系统分配什么资源"></a>进程的创建需要系统分配什么资源</h4><p>根据其他博客里写的底层源码来看，分配给一个进程的东西太多啦，我们挑几个记一下：内存、CPU处理时间、输入输出设备、存储空间。</p><p>参考链接：</p><p><a href="https://blog.csdn.net/lvyibin890/article/details/82193900">https://blog.csdn.net/lvyibin890/article/details/82193900</a></p><p><a href="https://juejin.cn/s/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%99%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E4%BB%80%E4%B9%88%E8%B5%84%E6%BA%90">https://juejin.cn/s/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%99%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E4%BB%80%E4%B9%88%E8%B5%84%E6%BA%90</a></p><h4 id="HTTPS加密方式：对称加密、非对称加密"><a href="#HTTPS加密方式：对称加密、非对称加密" class="headerlink" title="HTTPS加密方式：对称加密、非对称加密"></a>HTTPS加密方式：对称加密、非对称加密</h4><p>对称加密：密钥只有一个，加密解密为同一个密码。利用这种加密方式时必须把密钥也发送给对方，密钥在传输过程中被窃取，也就失去了加密的意义。</p><p>非对称加密：密钥成对出现，公钥加密需要私钥解密，私钥加密需要公钥解密。</p><p>参考链接：</p><p><a href="https://www.runoob.com/w3cnote/http-vs-https.html">https://www.runoob.com/w3cnote/http-vs-https.html</a></p><p><a href="https://www.itwork.club/2022/05/27/why-did-https-use-mixed-encryption-algorithm/">https://www.itwork.club/2022/05/27/why-did-https-use-mixed-encryption-algorithm/</a></p><h4 id="线程的三种状态"><a href="#线程的三种状态" class="headerlink" title="线程的三种状态"></a>线程的三种状态</h4><p>就绪态、运行态、阻塞态</p><h4 id="析构函数里能不能抛异常-为什么？"><a href="#析构函数里能不能抛异常-为什么？" class="headerlink" title="析构函数里能不能抛异常?为什么？"></a>析构函数里能不能抛异常?为什么？</h4><p>析构函数从语法上是可以抛出异常的，但是这样做很危险，请尽量不要这要做。原因在《More Effective C++》中提到两个： </p><p>（1）如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。 </p><p>（2）通常异常发生时，c++的异常处理机制在异常的传播过程中会进行栈展开（stack-unwinding），因发生异常而逐步退出复合语句和函数定义的过程，被称为栈展开。在栈展开的过程中就会调用已经在栈构造好的对象的析构函数来释放资源，此时若其他析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃。</p><h4 id="两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？"><a href="#两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？" class="headerlink" title="两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？"></a>两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？</h4><p>有虚函数的大，因为有虚函数的类的会包含一个虚函数指针。注意不同操作系统指针大小不一样。</p><p>参考链接：<a href="https://blog.csdn.net/luolaihua2018/article/details/110736211">https://blog.csdn.net/luolaihua2018/article/details/110736211</a></p><h4 id="数据报和数据流的区别？"><a href="#数据报和数据流的区别？" class="headerlink" title="数据报和数据流的区别？"></a>数据报和数据流的区别？</h4><p>可以这么简单理解：</p><p>假设现在有100字节数据，面向数据流和面向数据报的连接可以分别怎么样处理呢？</p><ul><li>数据流是发送端可以调用10次write，每次10字节。接收端调用一次read。也可以是发送端调用一次write，接收端调用10次read。数据流是没有边界的</li><li>数据报则是一次write就需要一次read，是有边界的。</li></ul><h4 id="在分布式系统中，如果某个节点宕机了咋办？"><a href="#在分布式系统中，如果某个节点宕机了咋办？" class="headerlink" title="在分布式系统中，如果某个节点宕机了咋办？"></a>在分布式系统中，如果某个节点宕机了咋办？</h4><p>做一个数据副本策略，把每一台机器上的数据做几个副本的冗余，放在别的机器上。万一说某一台机器宕机，没事啊，因为其他机器上还有他的副本。</p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>所谓自旋锁就是通过while循环实现的，让拿到锁的线程进入临界区执行代码，让没有拿到锁的线程一直进行while死循环，这其实就是线程自己“旋”在while循环了，因而这种锁就叫做自旋锁。</p><p>自旋锁实现参考链接：<a href="https://blog.csdn.net/jeffasd/article/details/80661804">https://blog.csdn.net/jeffasd/article/details/80661804</a></p><h4 id="线程同步的方式有哪些"><a href="#线程同步的方式有哪些" class="headerlink" title="线程同步的方式有哪些"></a>线程同步的方式有哪些</h4><p>互斥锁、信号量、条件变量、自旋锁、读写锁、屏障</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;new和malloc的区别&quot;&gt;&lt;a href=&quot;#new和malloc的区别&quot; class=&quot;headerlink&quot; title=&quot;new和malloc的区别&quot;&gt;&lt;/a&gt;new和malloc的区别&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;属性的区别&lt;/p&gt;
&lt;p&gt;new&amp;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>RPC</title>
    <link href="http://zcl0219.github.io/2023/06/28/RPC/"/>
    <id>http://zcl0219.github.io/2023/06/28/RPC/</id>
    <published>2023-06-28T14:08:50.000Z</published>
    <updated>2023-09-18T06:18:48.048Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开始补上MPRPC项目的代码实现，从头开始———-day1"><a href="#开始补上MPRPC项目的代码实现，从头开始———-day1" class="headerlink" title="开始补上MPRPC项目的代码实现，从头开始———-day1"></a><strong>开始补上<code>MPRPC</code>项目的代码实现，从头开始———-<code>day1</code></strong></h3><p>简介：项目基于muduo高性能网络库 + protobuf开发，所以命名为mprpc。</p><p>技术栈</p><ul><li>集群和分布式概念及原理</li><li>RPC远程过程调用原理及实现</li><li>Protobuf数据序列化和反序列化协议</li><li>Zookeeper分布式一致性协调服务应用及编程（服务注册中心，方便寻找哪个服务在哪台服务器上）</li><li>muduo网络库编程</li><li>conf配置文件读取</li><li>CMake构建项目集成编译环境</li></ul><h4 id="集群和分布式（搞懂为什么要分布式）"><a href="#集群和分布式（搞懂为什么要分布式）" class="headerlink" title="集群和分布式（搞懂为什么要分布式）"></a><strong>集群和分布式（搞懂为什么要分布式）</strong></h4><p><strong>集群</strong>：每一台服务器独立运行一个工程的所有模块</p><p><strong>分布式</strong>：一个工程拆分了很多模块，每一个模块独立部署运行在一个服务器主机上，所有服务器协同工作共同提供服务，每一台服务器称作分布式的一个节点，根据节点的并发要求，对一个节点可以再做节点模块集群部署。</p><p><img src="png1.PNG"></p><p>如图中<code>server</code>所示，一个聊天系统包括不同模块：用户管理、好友管理、群组管理、消息管理以及后台管理五个模块。每个模块有自己的特定业务，举个例子，用户管理模块包括用户注册、用户登录、用户注销等。</p><p>现在让你提出一些单机聊天服务器的缺陷，你能想到哪些？</p><ol><li>受限于硬件资源，聊天服务器所能承受的用户的并发量，比如端口用光了。</li><li>假设这个单机聊天服务器体系很庞大，项目编译需要两个小时！如果现在消息管理模块有一个小<code>bug</code>，需要改动几行，然后导致需要重新编译、部署整个项代码。</li><li>系统中，有些模块是属于<code>CPU</code>密集型，有些模块是<code>I/O</code>密集型的，造成各模块对于硬件资源的需求是不一样的。既然受限于硬件资源，我们就多部署几台服务器，横向增加服务器数量。但并未解决问题2和3。</li></ol><p>集群的优缺点如下，优点：用户的并发量提升了。缺点：项目代码还是需要整体重新编译，而且需要进行多次部署。</p><p><img src="png2.png"></p><p>现在我们看红色圈，我们把不同模块分类部署在不同服务器上。所有服务器共同构成一个聊天系统，这就是分布式。现在我们将不同服务器分别视为不同分布式节点。比如用户管理模块和消息管理模块对并发要求高，我们可以进行扩容，再部署几台服务器用于用户管理和消息管理（根据节点的并发要求，对一个节点可以再做节点模块集群部署）。分布式系统针对问题2，每个模块独立部署独立运行，哪个模块有<code>bug</code>，我只需要重新编译部署那个模块，其他模块还能正常运行。问题3就很明显了，视不同要求配置不同服务器。</p><p>那分布式就全是优点吗？下面我们说说关于分布式设计的难点。</p><ol><li>大系统的软件模块该怎么划分。</li><li>各模块之间怎么访问？集群服务器所有模块运行在一个进程里，不同模块之间访问简便。而分布式各模块都运行在不同的进程里，那服务器1的模块怎么调用服务器2上的模块的一个业务方法呢？我们这个项目所做的就是封装这种远程调用过程，方便用户调用，也就是程序员方便使用我们写的项目（<code>MPRPC</code>）。</li></ol><h3 id="RPC通信原理———-day2"><a href="#RPC通信原理———-day2" class="headerlink" title="RPC通信原理———-day2"></a><strong><code>RPC</code>通信原理———-<code>day2</code></strong></h3><p><img src="png3.png"></p><p>通过上图我们可以看到，我们设计的框架主要由以下部分和流程组成：</p><ul><li>发起调用端（caller）：调用方需要将调用的函数名、参数打包（序列化），并通过网络发送出去。这里打算采用muduo网络库。</li><li>接收端（callee）：接收方接收到包后，将包里的内容反序列化，就能知道调用哪一个函数、传入的参数是啥，然后返回值依旧是序列化之后通过网络发送回去，发送端接收到后反序列化，得到具体的返回值。</li><li>我们的框架主要是实现图中的黄绿部分。<ol><li>黄色部分是rpc方法参数的打包和解析，也就是数据的序列化与反序列化，通过protobuf完成。</li><li>在图中，有一些东西没画进去，比如我们将黄色块分别取名为client-stub和server-stub。这两个stub都是执行数据的序列化与反序列化。</li><li>如果远程调用过程中函数执行出错，我们可以返回一些错误码，防止接收端读取错误的返回值。</li><li>绿色部分：网络部分，包括寻找rpc服务主机，发起rpc调用请求和响应rpc调用结果，使用muduo网络库和Zookeeper服务配置中心（专门做服务发现）。</li></ol></li></ul><p>protobuf相对于json的好处：</p><p>1、protobuf是二进制存储；xml和json都是文本存储</p><p>2、protobuf不需要存储额外的信息；json通过key-value存储数据</p><ul><li><p>json：name: “zhang san”, pwd: “123456”</p></li><li><p>protobuf: “zhangsan” “123456”</p></li></ul><h3 id="项目环境搭建"><a href="#项目环境搭建" class="headerlink" title="项目环境搭建"></a><strong>项目环境搭建</strong></h3><h4 id="文件组成"><a href="#文件组成" class="headerlink" title="文件组成"></a>文件组成</h4><ul><li>bin：可执行文件</li><li>build：项目编译文件</li><li>lib：项目库文件</li><li>src：源文件</li><li>test：测试代码</li><li>example：框架代码使用范例</li><li>CMakeLists.txt：顶层的</li><li>cmake文件</li><li>README.md：项目自述文件</li><li>autonbuild.sh：一键编译脚本</li></ul><h4 id="Ubuntu-protobuf环境搭建"><a href="#Ubuntu-protobuf环境搭建" class="headerlink" title="Ubuntu protobuf环境搭建"></a>Ubuntu protobuf环境搭建</h4><p>首先在GitHub下载源代码，源码包中src&#x2F;README.md有详细的安装说明，也可以按照如下步骤安装：</p><ol><li>解压压缩包：unzip protobuf-master.zip</li><li>进入解压后的文件夹：cd protobuf-master</li><li>安装所需工具：sudo apt-get install autoconf automake libtool curl make g++ unzip</li><li>自动生成configure配置文件：.&#x2F;autogen.sh</li><li>配置环境：.&#x2F;configure</li><li>编译源代码（时间比较长）：make</li><li>安装：sudo make install</li><li>刷新动态库：sudo ldconfig</li><li>测试：看能否正常执行protoc命令（直接去终端执行）</li></ol><p>源码下载地址：<a href="https://github.com/protocolbuffers/protobuf">https://github.com/protocolbuffers/protobuf</a></p><h4 id="muduo库安装"><a href="#muduo库安装" class="headerlink" title="muduo库安装"></a>muduo库安装</h4><p>关于muduo库安装，强烈推荐按照施老师的步骤来（参考链接：<a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/89023980%EF%BC%89%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%B8%8D%E7%94%A8%E7%9C%8B%E6%88%91%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4%EF%BC%8C%E4%B8%8D%E5%AE%8C%E6%95%B4%EF%BC%81%EF%BC%81%EF%BC%81">https://blog.csdn.net/QIANGWEIYUAN/article/details/89023980），可以不用看我下面的安装步骤，不完整！！！</a></p><ol><li>安装依赖：sudo apt-get install libbost-dev libbost-test-dev sudo apt-get install libcurl4-openssl-dev libc-ares-dev</li><li>拉文件：git clone <a href="https://github.com/chenshuo/muduo.git">https://github.com/chenshuo/muduo.git</a></li><li>.&#x2F;build.sh</li></ol><p>muduo库是否安装成功的测试：muduo_test.cpp实现了一个简单的echo server</p><p>编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++11 muduo_test.cpp -lmuduo_net -lmuduo_base -lpthread -o muduo_test</span><br></pre></td></tr></table></figure><p>执行：</p><p>一个shell终端执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./muduo_test </span><br></pre></td></tr></table></figure><p>另一个shell终端执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 8032</span><br></pre></td></tr></table></figure><p>如下图所示则安装成功</p><p><img src="png4.png"></p><h4 id="创建文件（循序渐进，现在需要哪些文件夹就创建哪些）"><a href="#创建文件（循序渐进，现在需要哪些文件夹就创建哪些）" class="headerlink" title="创建文件（循序渐进，现在需要哪些文件夹就创建哪些）"></a>创建文件（循序渐进，现在需要哪些文件夹就创建哪些）</h4><p>首先，我们可以以自己的名字缩写作为后缀创建一个mprpc文件夹，比如我创建的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir mprpc_zcl</span><br></pre></td></tr></table></figure><p>接下来我们需要在mprpc_zcl文件夹里创建以下这些文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd mprpc_zcl</span><br><span class="line">mkdir bin</span><br><span class="line">mkdir build</span><br><span class="line">mkdir example</span><br><span class="line">mkdir lib</span><br><span class="line">mkdir src</span><br><span class="line">mkdir test</span><br><span class="line">touch autobuild.sh</span><br><span class="line">touch CMakeLists.txt</span><br></pre></td></tr></table></figure><p>好啦，第一件该做的事我们已经完成啦！</p><h4 id="protobuf实践讲解（一）"><a href="#protobuf实践讲解（一）" class="headerlink" title="protobuf实践讲解（一）"></a>protobuf实践讲解（一）</h4><p>首先我们写一个protobuf测试文件来了解一下protobuf的基本使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在<span class="built_in">test</span>文件夹下创建protobuf文件夹，在protobuf文件夹里创建test.proto文件和main.cpp文件</span></span><br><span class="line">cd test/</span><br><span class="line">mkdir protobuf</span><br><span class="line">cd protobuf/</span><br><span class="line">touch main.cpp test.proto</span><br></pre></td></tr></table></figure><p>首先编写test.proto文件，必要的注释我会放在代码块里。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 声明protobuf版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug; <span class="comment">// 声明了代码所在的包（对于C++来说就是namespace）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">message就是消息类型，protobuf就是将我们封装好的数据类型进行序列化与反序列化。</span></span><br><span class="line"><span class="comment">定义登录消息类型：名字 + 密码</span></span><br><span class="line"><span class="comment">string name = 1; 1 代表第一个字段</span></span><br><span class="line"><span class="comment">注意，你的name等变量需要使用什么类型，string要指明。</span></span><br><span class="line"><span class="comment">这里的string是protobuf里的string类型，不是c++里的string类型</span></span><br><span class="line"><span class="comment">我们编译protobuf文件的时候需要使用这样的命令编译：protoc test.proto --cpp_out=./ （=后面是编译生成文件的输出路径）</span></span><br><span class="line"><span class="comment">编译后会生成一个LoginRequest类（这里仅拿LoginRequest举例），类有两个成员：string name 和 string pwd。</span></span><br><span class="line"><span class="comment">如果序列化成功，就把序列化的结果放在了send_str里面了，serializeToString是protobuf编译后人家已经帮我们写好的方法，我们直接用就好了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义登录请求消息类型 name pwd</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定于登录响应消息类型 错误码：errcode，错误消息：errmsg， 成功与否：success</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> errmsg = <span class="number">2</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，编写main.cpp进行测试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// using namespace fixbug</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">protobuf是一个动态库，需要链接，所以整个编译命令为：g++ main.cpp test.pb.cc -lprotobuf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装了login请求对象的数据</span></span><br><span class="line">    fixbug::LoginRequest req;</span><br><span class="line">    req.<span class="built_in">set_name</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    req.<span class="built_in">set_pwd</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象数据序列化</span></span><br><span class="line">    std::string send_str;</span><br><span class="line">    <span class="keyword">if</span>(req.<span class="built_in">SerializeToString</span>(&amp;send_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; send_str.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从send_str反序列化一个login请求对象</span></span><br><span class="line">    fixbug::LoginRequest reqB;</span><br><span class="line">    <span class="keyword">if</span>(reqB.<span class="built_in">ParseFromString</span>(send_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; reqB.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; reqB.<span class="built_in">pwd</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="protobuf实践讲解（二）"><a href="#protobuf实践讲解（二）" class="headerlink" title="protobuf实践讲解（二）"></a>protobuf实践讲解（二）</h4><p>这一小节我们主要引入了两个新知识：</p><ul><li>在一个消息类型中定义另外一个消息类型</li><li>列表</li></ul><p>必要的注释我已经放在代码块里了，大家可以看看，有不对的地方请谅解并麻烦指出来。</p><p>首先是test.proto文件的更新版</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 声明protobuf版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug; <span class="comment">// 声明了代码所在的包（对于C++来说就是namespace）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">message就是消息类型，protobuf就是将我们封装好的数据类型进行序列化与反序列化。</span></span><br><span class="line"><span class="comment">定义登录消息类型：名字 + 密码</span></span><br><span class="line"><span class="comment">string name = 1; 1 代表第一个字段</span></span><br><span class="line"><span class="comment">注意，你的name等变量需要使用什么类型，string要指明。</span></span><br><span class="line"><span class="comment">这里的string是protobuf里的string类型，不是c++里的string类型</span></span><br><span class="line"><span class="comment">我们编译protobuf文件的时候需要使用这样的命令编译：protoc test.proto --cpp_out=./ （=后面是编译生成文件的输出路径）</span></span><br><span class="line"><span class="comment">编译后会生成一个LoginRequest类（这里仅拿LoginRequest举例），类有两个成员：string name 和 string pwd。</span></span><br><span class="line"><span class="comment">如果序列化成功，就把序列化的结果放在了send_str里面了，serializeToString是protobuf编译后人家已经帮我们写好的方法，我们直接用就好了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> errmsg = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义登录请求消息类型 name pwd</span></span><br><span class="line"><span class="comment">// 这里有一个点可以注意一下，一般把string定义成bytes，string也没错，但bytes效率更高</span></span><br><span class="line"><span class="comment">// 因为你定义成string，protobuf还是要转换成bytes</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定于登录响应消息类型 错误码：errcode，错误消息：errmsg， 成功与否：success</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：对于protobuf的消息类型里面定义的成员变量本身又是另外一个消息类型的话，</span></span><br><span class="line"><span class="comment">他都会提供一个mutable用于改变其成员</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在protobuf里还有一个常用的叫列表</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetFriendListsRequest</span>&#123;</span><br><span class="line">    <span class="type">uint32</span> userid = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32</span> age = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">enum </span><span class="title class_">Sex</span>&#123;</span><br><span class="line">        MAN = <span class="number">0</span>;</span><br><span class="line">        WOMAN = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Sex sex = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetFriendListsReponse</span>&#123;</span><br><span class="line">    <span class="comment">// 这里我们注意到，我们每次定义响应的时候好像都会定义errcode和errmsg字段</span></span><br><span class="line">    <span class="comment">// 所以我们决定将其封装起来（ResultCode），便于使用</span></span><br><span class="line">    <span class="comment">// int32 errcode = 1;</span></span><br><span class="line">    <span class="comment">// bytes errmsg = 2;</span></span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的肯定是一个列表，如何表示呢？</span></span><br><span class="line">    <span class="keyword">repeated</span> User friend_list = <span class="number">2</span>; <span class="comment">// 定义了一个列表类型</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>main.cpp更新版</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// using namespace fixbug</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">protobuf是一个动态库，需要链接，所以整个编译命令为：g++ main.cpp test.pb.cc -lprotobuf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装了login请求对象的数据</span></span><br><span class="line">    fixbug::LoginRequest req;</span><br><span class="line">    req.<span class="built_in">set_name</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    req.<span class="built_in">set_pwd</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象数据序列化</span></span><br><span class="line">    std::string send_str;</span><br><span class="line">    <span class="keyword">if</span>(req.<span class="built_in">SerializeToString</span>(&amp;send_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; send_str.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从send_str反序列化一个login请求对象</span></span><br><span class="line">    fixbug::LoginRequest reqB;</span><br><span class="line">    <span class="keyword">if</span>(reqB.<span class="built_in">ParseFromString</span>(send_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; reqB.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; reqB.<span class="built_in">pwd</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixbug::LoginResponse rsp;</span><br><span class="line">    fixbug::ResultCode *rc = rsp.<span class="built_in">mutable_result</span>();</span><br><span class="line">    rc-&gt;<span class="built_in">set_errcode</span>(<span class="number">1</span>);</span><br><span class="line">    rc-&gt;<span class="built_in">set_errmsg</span>(<span class="string">&quot;登陆处理失败了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::string recv_str;</span><br><span class="line">    <span class="keyword">if</span>(rsp.<span class="built_in">SerializeToString</span>(&amp;recv_str))&#123;</span><br><span class="line">        <span class="comment">// 好像设置的errcode并没有输出，暂时不知道为啥</span></span><br><span class="line">        std::cout &lt;&lt; recv_str.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixbug::GetFriendListsReponse rsp2;</span><br><span class="line">    fixbug::ResultCode *rc2 = rsp2.<span class="built_in">mutable_result</span>();</span><br><span class="line">    rc2-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fixbug::User *user1 = rsp2.<span class="built_in">add_friend_list</span>();</span><br><span class="line">    user1-&gt;<span class="built_in">set_name</span>(<span class="string">&quot;zhang san&quot;</span>);</span><br><span class="line">    user1-&gt;<span class="built_in">set_age</span>(<span class="number">20</span>);</span><br><span class="line">    user1-&gt;<span class="built_in">set_sex</span>(fixbug::User::MAN);</span><br><span class="line"></span><br><span class="line">    fixbug::User *user2 = rsp2.<span class="built_in">add_friend_list</span>();</span><br><span class="line">    user2-&gt;<span class="built_in">set_name</span>(<span class="string">&quot;li si&quot;</span>);</span><br><span class="line">    user2-&gt;<span class="built_in">set_age</span>(<span class="number">18</span>);</span><br><span class="line">    user2-&gt;<span class="built_in">set_sex</span>(fixbug::User::MAN);</span><br><span class="line"></span><br><span class="line">    std::string recv_str2;</span><br><span class="line">    <span class="keyword">if</span>(rsp2.<span class="built_in">SerializeToString</span>(&amp;recv_str2))&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; recv_str2.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string user_str;</span><br><span class="line">    <span class="keyword">if</span>(user1-&gt;<span class="built_in">SerializeToString</span>(&amp;user_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; user_str.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; rsp2.<span class="built_in">friend_list_size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="protobuf实践讲解（三）"><a href="#protobuf实践讲解（三）" class="headerlink" title="protobuf实践讲解（三）"></a>protobuf实践讲解（三）</h4><p>这一节我们主要讲了如何引入函数名。因为我们只传输参数给远程rpc服务器是肯定不够的，远程rpc服务器还需要知道我们需要调用哪种方法，因此我们需要使用service在远程rpc服务器上注册函数？（不知道这个理解对不对）同时，方便之后函数调用方传输函数名，里面有一个ServiceDescriptor类型的指针，用于访问方法的各个属性。代码更新如下，主要更新了test.proto文件，main文件没有更新。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 声明protobuf版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug; <span class="comment">// 声明了代码所在的包（对于C++来说就是namespace）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">message就是消息类型，protobuf就是将我们封装好的数据类型进行序列化与反序列化。</span></span><br><span class="line"><span class="comment">定义登录消息类型：名字 + 密码</span></span><br><span class="line"><span class="comment">string name = 1; 1 代表第一个字段</span></span><br><span class="line"><span class="comment">注意，你的name等变量需要使用什么类型，string要指明。</span></span><br><span class="line"><span class="comment">这里的string是protobuf里的string类型，不是c++里的string类型</span></span><br><span class="line"><span class="comment">我们编译protobuf文件的时候需要使用这样的命令编译：protoc test.proto --cpp_out=./ （=后面是编译生成文件的输出路径）</span></span><br><span class="line"><span class="comment">编译后会生成一个LoginRequest类（这里仅拿LoginRequest举例），类有两个成员：string name 和 string pwd。</span></span><br><span class="line"><span class="comment">如果序列化成功，就把序列化的结果放在了send_str里面了，serializeToString是protobuf编译后人家已经帮我们写好的方法，我们直接用就好了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> errmsg = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义登录请求消息类型 name pwd</span></span><br><span class="line"><span class="comment">// 这里有一个点可以注意一下，一般把string定义成bytes，string也没错，但bytes效率更高</span></span><br><span class="line"><span class="comment">// 因为你定义成string，protobuf还是要转换成bytes</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定于登录响应消息类型 错误码：errcode，错误消息：errmsg， 成功与否：success</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：对于protobuf的消息类型里面定义的成员变量本身又是另外一个消息类型的话，</span></span><br><span class="line"><span class="comment">他都会提供一个mutable用于改变其成员</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在protobuf里还有一个常用的叫列表</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetFriendListsRequest</span>&#123;</span><br><span class="line">    <span class="type">uint32</span> userid = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32</span> age = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">enum </span><span class="title class_">Sex</span>&#123;</span><br><span class="line">        MAN = <span class="number">0</span>;</span><br><span class="line">        WOMAN = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Sex sex = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetFriendListsReponse</span>&#123;</span><br><span class="line">    <span class="comment">// 这里我们注意到，我们每次定义响应的时候好像都会定义errcode和errmsg字段</span></span><br><span class="line">    <span class="comment">// 所以我们决定将其封装起来（ResultCode），便于使用</span></span><br><span class="line">    <span class="comment">// int32 errcode = 1;</span></span><br><span class="line">    <span class="comment">// bytes errmsg = 2;</span></span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的肯定是一个列表，如何表示呢？</span></span><br><span class="line">    <span class="keyword">repeated</span> User friend_list = <span class="number">2</span>; <span class="comment">// 定义了一个列表类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">我们在上面已经完成了参数和反回值传输，但我们仅将函数参数传过去，远程服务器并不知道我们要调用哪种方法啊！</span></span><br><span class="line"><span class="comment">protobuf没有rpc通信功能，只进行序列化与反序列化。但我们依旧要在protobuf里完成rpc方法类型的定义描述。</span></span><br><span class="line"><span class="comment">这就需要使用protobuf的service功能，注意此时需要加入option选项， option cc_generic_services = true; 表示生成service服务类和rpc方法描述</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 不管是message还是service，最后都会生成class类。注意message只生成一个，service会生成两个，一个class UserServiceRpc，一个class UserServiceRpc_stub</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserServiceRpc</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Login(LoginRequest) <span class="keyword">returns</span>(LoginResponse)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> GetFriendLists(GetFriendListsRequest) <span class="keyword">returns</span>(GetFriendListsReponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="本地服务如何发布成RPC服务（一）"><a href="#本地服务如何发布成RPC服务（一）" class="headerlink" title="本地服务如何发布成RPC服务（一）"></a>本地服务如何发布成RPC服务（一）</h4><p>这一块算是正式跨入项目第一步，我们通过业务出发，如果要实现我们所需要的具体需求应该怎么办，直接给出更新后的代码，必要的注释都在代码里</p><p>这里先给大家看一个本节之后的文件组成情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── autobuild.sh</span><br><span class="line">├── bin</span><br><span class="line">├── build</span><br><span class="line">├── example</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── callee</span><br><span class="line">│   │   ├── CMakeLists.txt</span><br><span class="line">│   │   └── userservice.cpp</span><br><span class="line">│   ├── caller</span><br><span class="line">│   ├── user.pb.cc</span><br><span class="line">│   ├── user.pb.h</span><br><span class="line">│   └── user.proto</span><br><span class="line">├── lib</span><br><span class="line">├── src</span><br><span class="line">└── test</span><br><span class="line">    └── protobuf</span><br><span class="line">        ├── a.out</span><br><span class="line">        ├── main.cpp</span><br><span class="line">        ├── test.pb.cc</span><br><span class="line">        ├── test.pb.h</span><br><span class="line">        └── test.proto</span><br><span class="line"></span><br><span class="line">9 directories, 13 files</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最上面的小点代表根目录：mprpc_zcl</span></span><br></pre></td></tr></table></figure><p>更新后的mprpc_zcl&#x2F;CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置cmake的最低版本和项目名称</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(mprpc_zcl)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目可执行文件输出的路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目库文件输出路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目编译头文件搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/example)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目库文件搜索路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># src里面放的是框架代码</span></span><br><span class="line"><span class="comment"># add_subdirectory(src)  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># example里面放的是rpc服务的使用者和消费者，业务代码</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(example)</span><br></pre></td></tr></table></figure><p>更新后的mprpc_zcl&#x2F;example&#x2F;user.proto</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> errmsg = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserServiceRpc</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Login_rpc(LoginRequest) <span class="keyword">returns</span>(LoginResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，编写完之后直接使用protoc user.proto --cpp_out=./编译</span></span><br></pre></td></tr></table></figure><p>更新后的mprpc_zcl&#x2F;example&#x2F;CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(callee)</span><br></pre></td></tr></table></figure><p>更新后的mprpc_zcl&#x2F;example&#x2F;callee&#x2F;userservice.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我个人觉得这个项目应该从这里开始讲解，我们现在本地有一个用户登录Login_Local方法（隶属于UserService类）。</span></span><br><span class="line"><span class="comment">我们自己在本地调用那肯定很方便，创建一个UserService类对象，直接调用Login_Local方法即可</span></span><br><span class="line"><span class="comment">可是，如果现在有另外一个进程或者另外一台机器想调用我们这个方法怎么办呢？所以我们就要结合谷歌protobuf提供给我们的工具了</span></span><br><span class="line"><span class="comment">这个文件写的就是rpc服务提供者文件，我们在别人想要调用这个本地方法之前需要做哪些基础工作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1、proto文件经过protobuf编译后生成了UserServiceRpc类</span></span><br><span class="line"><span class="comment">2、我们需要在userservice.cpp文件里对这个类里的方法进行重写</span></span><br><span class="line"><span class="comment">3、注意：message会变为类的成员，service会生成一个类，service里的内容会生成方法</span></span><br><span class="line"><span class="comment">4、现在的问题就是：我们重写过后，远方是怎么调用的呢？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Userservice</span> : <span class="keyword">public</span> fixbug::UserServiceRpc   <span class="comment">// 使用在rpc服务发布端（rpc服务提供者）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Login_local</span><span class="params">(std::string name, std::string pwd)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doing local service: Login&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; pwd:&quot;</span> &lt;&lt; pwd;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，作用过程是这样的，当远端将请求发送过来，先会被我们的rpc框架接受，我们rpc框架根据接收到的参数，函数名等数据</span></span><br><span class="line">    <span class="comment">// 匹配到了我们重写的这个函数，然后调用了这个函数。</span></span><br><span class="line">    <span class="comment">// 所以这一块不属于框架的代码，是我们要使用这个框架必须自己写的代码，实现自己需要的功能。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Login_rpc</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> ::fixbug::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::fixbug::LoginResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::google::protobuf::Closure* done)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 暂时还没写完</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新后的mprpc_zcl&#x2F;example&#x2F;callee&#x2F;CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(SRC_LIST userservice.cpp ../user.pb.cc)</span><br><span class="line"><span class="keyword">add_executable</span>(provider <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><h4 id="本地服务如何发布成RPC服务（二）"><a href="#本地服务如何发布成RPC服务（二）" class="headerlink" title="本地服务如何发布成RPC服务（二）"></a>本地服务如何发布成RPC服务（二）</h4><p>这一节必要的注释我都放在了代码里，以及思考的过程，这一节只对userservice.cpp进行了更新</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我个人觉得这个项目应该从这里开始讲解，我们现在本地有一个用户登录Login_Local方法（隶属于UserService类）。</span></span><br><span class="line"><span class="comment">我们自己在本地调用那肯定很方便，创建一个UserService类对象，直接调用Login_Local方法即可</span></span><br><span class="line"><span class="comment">可是，如果现在有另外一个进程或者另外一台机器想调用我们这个方法怎么办呢？所以我们就要结合谷歌protobuf提供给我们的工具了</span></span><br><span class="line"><span class="comment">这个文件写的就是rpc服务提供者文件，我们在别人想要调用这个本地方法之前需要做哪些基础工作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1、proto文件经过protobuf编译后生成了UserServiceRpc类</span></span><br><span class="line"><span class="comment">2、我们需要在userservice.cpp文件里对这个类里的方法进行重写</span></span><br><span class="line"><span class="comment">3、注意：message会变为类的成员，service会生成一个类，service里的内容会生成方法</span></span><br><span class="line"><span class="comment">4、现在的问题就是：我们重写过后，远方是怎么调用的呢？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Userservice</span> : <span class="keyword">public</span> fixbug::UserServiceRpc   <span class="comment">// 使用在rpc服务发布端（rpc服务提供者）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Login_local</span><span class="params">(std::string name, std::string pwd)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doing local service: Login&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; pwd:&quot;</span> &lt;&lt; pwd;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，作用过程是这样的，当远端将请求发送过来，先会被我们的rpc框架接受，我们rpc框架根据接收到的参数，函数名等数据</span></span><br><span class="line">    <span class="comment">// 匹配到了我们重写的这个函数，然后调用了这个函数。</span></span><br><span class="line">    <span class="comment">// 所以这一块不属于框架的代码，是我们要使用这个框架必须自己写的代码，实现自己需要的功能。</span></span><br><span class="line">    <span class="comment">// 现在的问题是，我callee端收到了参数和函数名，怎么匹配的呢？</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Login_rpc</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> ::fixbug::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::fixbug::LoginResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::google::protobuf::Closure* done)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 框架给业务上报了请求参数LoginRequest，应用获取相应数据做本地业务</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string pwd = request-&gt;<span class="built_in">pwd</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做本地业务</span></span><br><span class="line">        <span class="type">bool</span> login_result = <span class="built_in">Login_local</span>(name, pwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把响应写入，包括错误码、错误消息、返回值。我们不需要管序列化与反序列化，这个是框架来做的</span></span><br><span class="line">        fixbug::ResultCode *code = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        code-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        code-&gt;<span class="built_in">set_errmsg</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(login_result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，我们可以跳进::google::protobuf::Closure类去看看，里面的run是纯虚函数，需要我们进行重新写，那么run应该实现什么功能呢？</span></span><br><span class="line">        <span class="comment">// 其实就是执行响应对象数据的序列化与网络发送</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    总结一下，初始准备步骤：</span></span><br><span class="line"><span class="comment">    写proto文件 ------》继承生成的类，重写类里的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Mprpc框架基础类设计"><a href="#Mprpc框架基础类设计" class="headerlink" title="Mprpc框架基础类设计"></a>Mprpc框架基础类设计</h4><p>这一节我们从服务发布方的需求出发，比如我需要发布一个rpc服务，我需要做什么？我们考虑思路是这样的：假设现在框架写好了，当远端将请求发送过来，先会被我们的rpc框架接受，我们rpc框架根据接收到的参数，函数名等数据。匹配到了我们重写的这个函数，然后调用了这个函数。所以这一块不属于框架的代码，是我们要使用这个框架必须自己写的代码，实现自己需要的功能。<strong>现在的问题是，我callee端收到了参数和函数名，怎么匹配的呢？</strong></p><p>我们现在做好了服务发布方的基础工作，我们现在需要思考一个问题：我怎么能让别人想用我们写的rpc框架呢？答案只有一个，就是越简单越好。</p><ol><li>先进行框架初始化操作</li><li>框架里提供了用于发布服务的类</li></ol><p>这一节更新的文件如下</p><p>新加入src&#x2F;include&#x2F;mprpcapplication.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责框架的初始化操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MprpcApplication</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> MprpcApplication &amp;<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">MprpcApplication</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>(<span class="type">const</span> MprpcApplication&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>(MprpcApplication&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>新加入src&#x2F;include&#x2F;mprpcprovider.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架提供的专门服务发布rpc服务的网络对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个是框架提供给外部使用的，可以发布rpc方法的函数接口 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>新加入src&#x2F;mprpcapplication.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcApplication::Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MprpcApplication &amp;<span class="title">MprpcApplication::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> MprpcApplication app;</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新加入src&#x2F;mprpcprovider.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新了example&#x2F;callee&#x2F;userservice.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我个人觉得这个项目应该从这里开始讲解，我们现在本地有一个用户登录Login_Local方法（隶属于UserService类）。</span></span><br><span class="line"><span class="comment">我们自己在本地调用那肯定很方便，创建一个UserService类对象，直接调用Login_Local方法即可</span></span><br><span class="line"><span class="comment">可是，如果现在有另外一个进程或者另外一台机器想调用我们这个方法怎么办呢？所以我们就要结合谷歌protobuf提供给我们的工具了</span></span><br><span class="line"><span class="comment">这个文件写的就是rpc服务提供者文件，我们在别人想要调用这个本地方法之前需要做哪些基础工作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1、proto文件经过protobuf编译后生成了UserServiceRpc类</span></span><br><span class="line"><span class="comment">2、我们需要在userservice.cpp文件里对这个类里的方法进行重写</span></span><br><span class="line"><span class="comment">3、注意：message会变为类的成员，service会生成一个类，service里的内容会生成方法</span></span><br><span class="line"><span class="comment">4、现在的问题就是：我们重写过后，远方是怎么调用的呢？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;/home/zcl/mprpc_zcl/src/include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;/home/zcl/mprpc_zcl/src/include/mprpcprovider.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> : <span class="keyword">public</span> fixbug::UserServiceRpc   <span class="comment">// 使用在rpc服务发布端（rpc服务提供者）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Login_local</span><span class="params">(std::string name, std::string pwd)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doing local service: Login&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; pwd:&quot;</span> &lt;&lt; pwd;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，作用过程是这样的，当远端将请求发送过来，先会被我们的rpc框架接受，我们rpc框架根据接收到的参数，函数名等数据</span></span><br><span class="line">    <span class="comment">// 匹配到了我们重写的这个函数，然后调用了这个函数。</span></span><br><span class="line">    <span class="comment">// 所以这一块不属于框架的代码，是我们要使用这个框架必须自己写的代码，实现自己需要的功能。</span></span><br><span class="line">    <span class="comment">// 现在的问题是，我callee端收到了参数和函数名，怎么匹配的呢？</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Login_rpc</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> ::fixbug::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::fixbug::LoginResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::google::protobuf::Closure* done)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 框架给业务上报了请求参数LoginRequest，应用获取相应数据做本地业务</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string pwd = request-&gt;<span class="built_in">pwd</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做本地业务</span></span><br><span class="line">        <span class="type">bool</span> login_result = <span class="built_in">Login_local</span>(name, pwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把响应写入，包括错误码、错误消息、返回值。我们不需要管序列化与反序列化，这个是框架来做的</span></span><br><span class="line">        fixbug::ResultCode *code = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        code-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        code-&gt;<span class="built_in">set_errmsg</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(login_result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，我们可以跳进::google::protobuf::Closure类去看看，里面的run是纯虚函数，需要我们进行重新写，那么run应该实现什么功能呢？</span></span><br><span class="line">        <span class="comment">// 其实就是执行响应对象数据的序列化与网络发送</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    总结一下，初始准备步骤：</span></span><br><span class="line"><span class="comment">    写proto文件 ------》继承生成的类，重写类里的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们现在做好了服务发布方的基础工作，我们现在需要思考一个问题：我怎么能让别人想用我们写的rpc框架呢？答案只有一个，就是越简单越好。</span></span><br><span class="line"><span class="comment">1、先进行框架初始化操作</span></span><br><span class="line"><span class="comment">2、框架里提供了用于发布服务的类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="comment">// argc和argv是写ip地址和端口号配置文件这些的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用框架的初始化操作</span></span><br><span class="line">    MprpcApplication::<span class="built_in">Init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// provider是一个rpc网络服务对象。把UserService对象发布到rpc节点上</span></span><br><span class="line">    <span class="comment">// 可能会有很多用户同时使用Rpcprovider，所以这一块必须做到高并发，使用muduo网络库</span></span><br><span class="line">    RpcProvider provider;</span><br><span class="line">    provider.<span class="built_in">NotifyService</span>(<span class="keyword">new</span> <span class="built_in">UserService</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个rpc服务发布节点, Run以后，进程进入阻塞状态，等待远程的rpc调用请求</span></span><br><span class="line">    provider.<span class="built_in">Run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Mprpc框架项目动态库编译"><a href="#Mprpc框架项目动态库编译" class="headerlink" title="Mprpc框架项目动态库编译"></a>Mprpc框架项目动态库编译</h4><p>在init的时候，我们希望用户的输入是这样的：.&#x2F;provider -i config.conf（config.conf是配置文件，自动读取网络服务器和配置中心的ip地址和端口号）。</p><p>这节涉及到一个函数：int getopt(int argc, char * const argv[], const char *optstring); 我先给出这个函数的详细解释，方便解读下面的代码</p><p>首先，让我们看看<code>getopt</code>函数：</p><p><code>getopt</code>函数用于解析命令行参数。其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getopt</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[], <span class="type">const</span> <span class="type">char</span> *optstring)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>argc</code>和<code>argv</code>是从<code>main</code>函数传递过来的命令行参数数量和参数值。</li><li><code>optstring</code>是一个字符串，表示我们期望的选项。例如，如果我们期望一个<code>-i</code>选项，那么<code>optstring</code>就会是<code>&quot;i:&quot;</code>。冒号表示<code>-i</code>后面必须跟一个参数值。</li></ul><p>函数每次调用都会返回一个字符，这个字符表示被解析到的选项。如果选项后面跟有参数值（如<code>-i value</code>），那么这个值可以通过<code>optarg</code>全局变量获得。当所有选项都被解析完毕后，<code>getopt</code>返回-1。</p><p>现在，让我们回到你的代码片段：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;i:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>while</code>循环的目的是持续解析命令行参数，直到所有选项都被解析完毕。</p><ul><li><p><code>c = getopt(argc, argv, &quot;i:&quot;)</code>：这里，<code>getopt</code>被调用，并返回值赋给<code>c</code>。如果有<code>-i</code>选项，<code>c</code>会等于字符<code>&#39;i&#39;</code>。</p></li><li><p><code>c != -1</code>：这个条件检查<code>c</code>是否不等于-1。如果<code>c</code>等于-1，那么说明所有选项都已经被解析完毕，<code>while</code>循环结束。</p></li></ul><p>在<code>while</code>循环的内部，你可能会基于<code>c</code>的值做一些操作，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">        <span class="comment">// do something with optarg, which contains the value after -i</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// possibly handle other options</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">        <span class="comment">// handle unknown option</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简而言之，这个代码片段用<code>getopt</code>函数在命令行参数中寻找<code>-i</code>选项，并将找到的值存储在<code>optarg</code>中。</p><p>在使用 <code>getopt</code> 函数来解析命令行参数时，你可能会遇到几种特定的返回值。当你在 <code>optstring</code> 中指定了一个选项后跟冒号（如 “i:”），这意味着该选项需要一个参数。</p><p>对于 <code>getopt</code> 的返回值：</p><ul><li>如果一个选项被发现，并且它有一个关联的参数（例如 <code>-i &lt;value&gt;</code>），那么 <code>getopt</code> 返回该选项字符。</li><li>如果一个选项被发现，但它缺少一个关联的参数（例如仅仅 <code>-i</code> 而没有后续值），并且在 <code>optstring</code> 中该选项后面有一个冒号，那么 <code>getopt</code> 返回 <code>&#39;:&#39;</code>。</li><li>如果找到一个不在 <code>optstring</code> 中的选项，或者找到一个不应有参数但却有参数的选项，那么 <code>getopt</code> 返回 <code>&#39;?&#39;</code>。</li></ul><p>所以，<code>case &#39;:&#39;</code> 在 <code>switch</code> 语句中处理的是缺少参数的选项情况。</p><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;i:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">            <span class="comment">// handle the -i option with its argument in optarg</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:  <span class="comment">// Missing option argument</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Option -%c requires an argument.\n&quot;</span>, optopt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:  <span class="comment">// Unknown option</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unknown option: -%c\n&quot;</span>, optopt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，如果用户只输入 <code>-i</code> 而没有提供参数，程序将输出 “Option -i requires an argument.”。</p><p>新加入src&#x2F;CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="keyword">add_library</span>(mprpc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)  <span class="comment"># 创建一个动态库，方便用户调用</span></span><br></pre></td></tr></table></figure><p>更新example&#x2F;callee&#x2F;CMakeLists</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(SRC_LIST userservice.cpp ../user.pb.cc)</span><br><span class="line"><span class="keyword">add_executable</span>(provider <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(provider mprpc protobuf)<span class="comment"># 链接我们上面创建的mprpc动态库和protobuf库</span></span><br></pre></td></tr></table></figure><p>更新mprpcapplication.cpp文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showArgHelp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;format: command -i &lt;configfile&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcApplication::Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">showArgHelp</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    std::string config_file;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;i:&quot;</span>)) != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">                config_file = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;invalid args!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">showArgHelp</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);<span class="comment">// 配置文件都没加载进来就不要break啦，直接退出运行吧</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;need config_file&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">showArgHelp</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始加载配置文件了 rpcserver_ip=  rpcserver_port=    zookeeper_ip=   zookeeper_port=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MprpcApplication &amp;<span class="title">MprpcApplication::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> MprpcApplication app;</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Mprpc配置文件的加载（一）"><a href="#Mprpc配置文件的加载（一）" class="headerlink" title="Mprpc配置文件的加载（一）"></a>Mprpc配置文件的加载（一）</h4><p>这一节我们主要讲的是如何加载配置文件，换句话说就是解析配置文件。首先我们规定了配置文件的标准格式，如下所示：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpc节点的ip地址</span></span><br><span class="line">rpcserverip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># rpc节点的port端口号</span></span><br><span class="line">rpcserverport = <span class="number">8000</span></span><br><span class="line"><span class="comment"># zk的IP地址</span></span><br><span class="line">zookeeperip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># zk的port端口号</span></span><br><span class="line">zookeeperport = <span class="number">5000</span></span><br></pre></td></tr></table></figure><p>这一节引入了MprpcConfig类，我们考虑两部分：解析配置文件 + 查询配置信息。一个自然而然要思考的问题就是如何查询配置信息呢？我们这里考虑的是通过一个map映射即通过键找值。具体如何操作看代码就能了解了。</p><p>新加入配置文件&#x2F;bin&#x2F;test.conf</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpc节点的ip地址</span></span><br><span class="line">rpcserverip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># rpc节点的port端口号</span></span><br><span class="line">rpcserverport = <span class="number">8000</span></span><br><span class="line"><span class="comment"># zk的IP地址</span></span><br><span class="line">zookeeperip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># zk的port端口号</span></span><br><span class="line">zookeeperport = <span class="number">5000</span></span><br></pre></td></tr></table></figure><p>新加入&#x2F;src&#x2F;include&#x2F;mprpcconfig.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MprpcConfig</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 负责解析加载配置文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *config_file)</span></span>;</span><br><span class="line">    <span class="comment">// 查询配置项信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 每解析到一组ip---port，就insert进m_configMap</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; m_configMap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>新加入&#x2F;src&#x2F;mprpcconfig.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcconfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责解析加载配置文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcConfig::loadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *config_file)</span></span>&#123;</span><br><span class="line">    FILE *pf = <span class="built_in">fopen</span>(config_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(pf == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; config_file &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、注释 2、正确的配置项通过=判断 3、去掉开头多余的空格</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">feof</span>(pf))&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">fgets</span>(buf, <span class="number">512</span>, pf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串前面的空格</span></span><br><span class="line">        <span class="comment">// 转换成字符串便于后续操作，因为字符串里有很多函数</span></span><br><span class="line">        <span class="function">std::string <span class="title">src_buf</span><span class="params">(buf)</span></span>;</span><br><span class="line">        <span class="type">int</span> idx = src_buf.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// 说明字符串前面有空格</span></span><br><span class="line">            src_buf = src_buf.<span class="built_in">substr</span>(idx, src_buf.<span class="built_in">size</span>() - idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉字符串后面多余的空格</span></span><br><span class="line">        idx = src_buf.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx != <span class="number">-1</span>)&#123;</span><br><span class="line">            src_buf = src_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断#的注释</span></span><br><span class="line">        <span class="keyword">if</span>(src_buf[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || src_buf.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析配置项</span></span><br><span class="line">        idx = src_buf.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// 配置项不合法</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::string key;</span><br><span class="line">        std::string value;</span><br><span class="line">        key = src_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        value = src_buf.<span class="built_in">substr</span>(idx + <span class="number">1</span>, src_buf.<span class="built_in">size</span>() - idx);</span><br><span class="line">        m_configMap.<span class="built_in">insert</span>(&#123;key, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询配置项信息</span></span><br><span class="line"><span class="function">std::string <span class="title">MprpcConfig::load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_configMap.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(it == m_configMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新&#x2F;src&#x2F;include&#x2F;mprpcapplication.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责框架的初始化操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcconfig.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MprpcApplication</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> MprpcApplication &amp;<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> MprpcConfig m_config;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>(<span class="type">const</span> MprpcApplication&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>(MprpcApplication&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>更新&#x2F;src&#x2F;mprpcapplication.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MprpcConfig MprpcApplication::m_config;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showArgHelp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;format: command -i &lt;configfile&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcApplication::Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">showArgHelp</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    std::string config_file;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;i:&quot;</span>)) != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">                config_file = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                <span class="built_in">showArgHelp</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">                <span class="built_in">showArgHelp</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始加载配置文件了 rpcserver_ip=  rpcserver_port=    zookeeper_ip=   zookeeper_port=</span></span><br><span class="line">    <span class="comment">// 这是我们规定的配置文件的标准格式，因为我们后面解析的配置文件也是这个格式</span></span><br><span class="line">    m_config.<span class="built_in">loadConfigFile</span>(config_file.<span class="built_in">c_str</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rpcserverip:&quot;</span> &lt;&lt; m_config.<span class="built_in">load</span>(<span class="string">&quot;reserverip&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rpcserverport:&quot;</span> &lt;&lt; m_config.<span class="built_in">load</span>(<span class="string">&quot;reserverport&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;zookeeperip:&quot;</span> &lt;&lt; m_config.<span class="built_in">load</span>(<span class="string">&quot;zookeeperip&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;zookeeperport:&quot;</span> &lt;&lt; m_config.<span class="built_in">load</span>(<span class="string">&quot;zookeeperport&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MprpcApplication &amp;<span class="title">MprpcApplication::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> MprpcApplication app;</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Mprpc配置文件的加载（二）"><a href="#Mprpc配置文件的加载（二）" class="headerlink" title="Mprpc配置文件的加载（二）"></a>Mprpc配置文件的加载（二）</h4><p>在上一节中好像忘记告诉大家如何编译测试代码了。不知道大家还记不记得我们的可执行文件都是放在bin目录里的，所以我们需要先进入bin目录，即cd bin&#x2F;。</p><p>然后为了我们就可以在终端执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./provider -i test.conf</span><br></pre></td></tr></table></figure><p>从这个编译命令就可以看出来我们为什么要把test.conf文件和provider都放在bin目录下，这样方便我们编译。然后你们可以测试一下上一节的代码，是有bug的！然后我们需要进行gdb调试，进行gdb调试的话，我们需要在最外层的CMakeLists.txt文件加一行这个代码</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE <span class="string">&quot;Debug&quot;</span>)</span><br></pre></td></tr></table></figure><p>bug出现在了mprpcconfig.cpp文件里，你们自己调试一下哈，我下面给出更新后的本节所有代码</p><p>更新后的CMakeLists.txt</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置cmake的最低版本和项目名称</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(mprpc_zcl)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb调试选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE <span class="string">&quot;Debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目可执行文件输出的路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目库文件输出路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目编译头文件搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/example)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目库文件搜索路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># src里面放的是框架代码</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># example里面放的是rpc服务的使用者和消费者，业务代码</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(example)</span><br></pre></td></tr></table></figure><p>更新后的&#x2F;src&#x2F;include&#x2F;mprpcconfig.h文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MprpcConfig</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 负责解析加载配置文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *config_file)</span></span>;</span><br><span class="line">    <span class="comment">// 查询配置项信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; m_configMap;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 去掉字符串前后的空格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Trim</span><span class="params">(std::string &amp;src_buf)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>更新后的mprpcconfig.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcconfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责解析加载配置文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcConfig::loadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *config_file)</span></span>&#123;</span><br><span class="line">    FILE *pf = <span class="built_in">fopen</span>(config_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(pf == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; config_file &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、注释 2、正确的配置项通过=判断 3、去掉开头多余的空格</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">feof</span>(pf))&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">fgets</span>(buf, <span class="number">512</span>, pf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串前面的空格</span></span><br><span class="line">        <span class="comment">// 转换成字符串便于后续操作，因为字符串里有很多函数</span></span><br><span class="line">        <span class="function">std::string <span class="title">read_buf</span><span class="params">(buf)</span></span>;</span><br><span class="line">        <span class="built_in">Trim</span>(read_buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断#的注释</span></span><br><span class="line">        <span class="keyword">if</span>(read_buf[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || read_buf.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析配置项</span></span><br><span class="line">        <span class="type">int</span> idx = read_buf.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// 配置项不合法</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::string key;</span><br><span class="line">        std::string value;</span><br><span class="line">        key = read_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        <span class="built_in">Trim</span>(key);</span><br><span class="line">        <span class="type">int</span> endidx = read_buf.<span class="built_in">find</span>(<span class="string">&#x27;\n&#x27;</span>, idx);</span><br><span class="line">        value = read_buf.<span class="built_in">substr</span>(idx + <span class="number">1</span>, endidx - idx - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Trim</span>(value);</span><br><span class="line">        m_configMap.<span class="built_in">insert</span>(&#123;key, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询配置项信息</span></span><br><span class="line"><span class="function">std::string <span class="title">MprpcConfig::load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_configMap.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(it == m_configMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉字符串前后的空格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcConfig::Trim</span><span class="params">(std::string &amp;src_buf)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = src_buf.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(idx != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 说明字符串前面有空格</span></span><br><span class="line">        src_buf = src_buf.<span class="built_in">substr</span>(idx, src_buf.<span class="built_in">size</span>() - idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去掉字符串后面多余的空格</span></span><br><span class="line">    idx = src_buf.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(idx != <span class="number">-1</span>)&#123;</span><br><span class="line">        src_buf = src_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开发RpcProvider的网络服务"><a href="#开发RpcProvider的网络服务" class="headerlink" title="开发RpcProvider的网络服务"></a>开发RpcProvider的网络服务</h4><p>是这样的，我们现在已经能够读取到配置文件里的信息了，包括哪些信息呢？还记得吗？来一起回顾一下：rpc服务的ip地址和port端口号，zookeeper的ip地址和port端口号。我们现在回到这个配置文件这里，我们从这个角度出发，我们读取配置文件就是为了获取rpc服务发布节点的ip地址和port端口号，我们是为了什么读取呢？是为了让客户端能够接入，能够调用我们发布的这个rpc服务方法。我们之前在mprpcapplication里说过，为了简便用户的操作，我们提供了一个RpcProvoder类来发布服务节点。所以，这节我们要做的就是通过muduo网络库让配置文件里的rpc服务节点运行起来，可以接收客户端的连接请求。Let‘s go！</p><p>新加入mprpcprovider.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架提供的专门服务发布rpc服务的网络对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个是框架提供给外部使用的，可以发布rpc方法的函数接口 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 组合了EventLoop</span></span><br><span class="line">    muduo::net::EventLoop m_eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的socket连接回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已建立连接用户的读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>新加入mprpcprovider.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 你启动一个rpc网络服务节点，总要获取ip地址和port端口号吧</span></span><br><span class="line">    <span class="comment">// 所以这里是获取ip地址和port端口号</span></span><br><span class="line">    std::string ip = MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;m_eventLoop, address, <span class="string">&quot;RpcProvider&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 绑定连接回调和消息读写回调方法 分离了网络代码和业务代码</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">// 设置muduo库线程数量，自动分配I/O线程和工作线程</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    m_eventLoop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RpcProvider发布服务方法（一）"><a href="#RpcProvider发布服务方法（一）" class="headerlink" title="RpcProvider发布服务方法（一）"></a>RpcProvider发布服务方法（一）</h4><p>我们想一下，我们发布的rpc服务节点运行起来阻塞着等待客户的请求连接。假设现在有一个客户端将函数及其参数全部传递过来了，框架应该怎么做匹配呢？框架怎么就能做到这个函数名就匹配这个函数呢？对，有人应该想到了，使用map。我现在的想法也是map。我们将服务与函数对应起来（回忆一下：proto文件里服务生成类，函数就是类成员函数），所以要先限定服务，在限定函数。所以我们使用map将服务函数对应起来就好了。</p><p>更新mprpcprovider.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架提供的专门服务发布rpc服务的网络对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个是框架提供给外部使用的，可以发布rpc方法的函数接口 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 组合了EventLoop</span></span><br><span class="line">    muduo::net::EventLoop m_eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// service服务类型信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ServiceInfo</span>&#123;</span><br><span class="line">        google::protobuf::Service *m_service; <span class="comment">// 保存服务对象</span></span><br><span class="line">        std::unordered_map&lt;std::string, <span class="type">const</span> google::protobuf::MethodDescriptor*&gt; m_methodMap; <span class="comment">// 保存服务方法</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::unordered_map&lt;std::string, ServiceInfo&gt; m_serviceMap;  <span class="comment">// 可不止一个服务类型哦，所以也要建立一个映射到不同服务的表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的socket连接回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已建立连接用户的读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>更新mprpcprovider.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是框架提供给外部使用的，可以发布rpc方法的函数接口</span></span><br><span class="line"><span class="comment">这里有一个很重要的指针（protobuf提供给我们获取服务及函数的）：google::protobuf::ServiceDescriptor *pserviceDesc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line">    ServiceInfo service_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务对象的描述信息</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::ServiceDescriptor *pserviceDesc = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line">    <span class="comment">// 获取服务的名字</span></span><br><span class="line">    std::string service_name = pserviceDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">    <span class="comment">// 获取服务对象service的方法的数量</span></span><br><span class="line">    <span class="type">int</span> methodCnt = pserviceDesc-&gt;<span class="built_in">method_count</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;service_name: &quot;</span> &lt;&lt; service_name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; methodCnt; ++i)&#123;</span><br><span class="line">        <span class="comment">// 获取了服务对象指定下标的服务方法的描述（抽象描述）</span></span><br><span class="line">        <span class="type">const</span> google::protobuf::MethodDescriptor *pmethodDesc = pserviceDesc-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        std::string method_name = pmethodDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">        service_info.m_methodMap.<span class="built_in">insert</span>(&#123;method_name, pmethodDesc&#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    service_info.m_service = service;</span><br><span class="line">    m_serviceMap.<span class="built_in">insert</span>(&#123;service_name, service_info&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 你启动一个rpc网络服务节点，总要获取ip地址和port端口号吧</span></span><br><span class="line">    <span class="comment">// 所以这里是获取ip地址和port端口号</span></span><br><span class="line">    std::string ip = MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;m_eventLoop, address, <span class="string">&quot;RpcProvider&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 绑定连接回调和消息读写回调方法 分离了网络代码和业务代码</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">// 设置muduo库线程数量，自动分配I/O线程和工作线程</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    m_eventLoop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是要处理当rpc服务节点接收到来自客户端的已经序列化的请求该如何处理。首先，我们框架内部RpcProvider和RpcConsumer协商好之间通信用的protobuf数据类型，这样才方便序列化与反序列化。我们考虑将服务名+方法名作为头部字段，同时，为了防止后面的参数与下一次请求产生粘包问题，我们需要在头部字段里声明参数的大小。另外还有一个问题就是，我们如何分离出头部字段和参数字段呢？一个方法就是指明头部字段有多长。所以，我们的代码更新如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcheader.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是框架提供给外部使用的，可以发布rpc方法的函数接口</span></span><br><span class="line"><span class="comment">这里有一个很重要的指针（protobuf提供给我们获取服务及函数的）：google::protobuf::ServiceDescriptor *pserviceDesc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line">    ServiceInfo service_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务对象的描述信息</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::ServiceDescriptor *pserviceDesc = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line">    <span class="comment">// 获取服务的名字</span></span><br><span class="line">    std::string service_name = pserviceDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">    <span class="comment">// 获取服务对象service的方法的数量</span></span><br><span class="line">    <span class="type">int</span> methodCnt = pserviceDesc-&gt;<span class="built_in">method_count</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;service_name: &quot;</span> &lt;&lt; service_name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; methodCnt; ++i)&#123;</span><br><span class="line">        <span class="comment">// 获取了服务对象指定下标的服务方法的描述（抽象描述）</span></span><br><span class="line">        <span class="comment">// 注意，这里建立map表都是依据proto文件建立的！！！思考一下哦！</span></span><br><span class="line">        <span class="type">const</span> google::protobuf::MethodDescriptor *pmethodDesc = pserviceDesc-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        std::string method_name = pmethodDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">        service_info.m_methodMap.<span class="built_in">insert</span>(&#123;method_name, pmethodDesc&#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    service_info.m_service = service;</span><br><span class="line">    m_serviceMap.<span class="built_in">insert</span>(&#123;service_name, service_info&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 你启动一个rpc网络服务节点，总要获取ip地址和port端口号吧</span></span><br><span class="line">    <span class="comment">// 所以这里是获取ip地址和port端口号</span></span><br><span class="line">    std::string ip = MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;m_eventLoop, address, <span class="string">&quot;RpcProvider&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 绑定连接回调和消息读写回调方法 分离了网络代码和业务代码</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">// 设置muduo库线程数量，自动分配I/O线程和工作线程</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    m_eventLoop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!conn-&gt;<span class="built_in">connected</span>())&#123;</span><br><span class="line">        <span class="comment">// 和rpc client的连接断开了</span></span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在框架内部，RpcProvider和RpcConsumer协商好之间通信用的protobuf数据类型</span></span><br><span class="line"><span class="comment">service_name method_name args   定义proto的message类型，进行数据头的序列化与反序列化</span></span><br><span class="line"><span class="comment">                                service_name method_name args_size（args_size是为了防止粘包问题，指定参数长度）</span></span><br><span class="line"><span class="comment">16UserServiceLogin_rpc16zhang san123456</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">header_size + header_str + args_size + args_str</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr &amp;conn, muduo::net::Buffer *buffer, muduo::Timestamp)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 接收到来自客户端的请求</span></span><br><span class="line">    std::string recv_buf = buffer-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字符流中读取前四个字节的内容</span></span><br><span class="line">    <span class="type">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    recv_buf.<span class="built_in">copy</span>((<span class="type">char</span>*)&amp;header_size, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据header_size读取数据头的原始字符流，反序列化数据，得到rpc请求的详细信息</span></span><br><span class="line">    std::string rpc_header_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span>, header_size);</span><br><span class="line">    mprpc::RpcHeader rpcHeader;</span><br><span class="line">    std::string servcie_name;</span><br><span class="line">    std::string method_name;</span><br><span class="line">    <span class="type">uint32_t</span> args_size;</span><br><span class="line">    <span class="keyword">if</span>(rpcHeader.<span class="built_in">ParseFromString</span>(rpc_header_str))&#123;</span><br><span class="line">        servcie_name = rpcHeader.<span class="built_in">service_name</span>();</span><br><span class="line">        method_name = rpcHeader.<span class="built_in">method_name</span>();</span><br><span class="line">        args_size = rpcHeader.<span class="built_in">args_size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;rpc_header_str:&quot;</span> &lt;&lt; rpc_header_str &lt;&lt; <span class="string">&quot; parse error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取rpc方法参数的字符流数据</span></span><br><span class="line">    std::string args_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span> + header_size, args_size);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;header_size: &quot;</span> &lt;&lt; header_size &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rpc_header_str: &quot;</span> &lt;&lt; rpc_header_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;servcie_name: &quot;</span> &lt;&lt; servcie_name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;args_str: &quot;</span> &lt;&lt; args_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RpcProvider响应回调实现"><a href="#RpcProvider响应回调实现" class="headerlink" title="RpcProvider响应回调实现"></a>RpcProvider响应回调实现</h4><p>回忆一下provider应该做的事，调用方法并返回response。所以这一节做的就是这个事情。注意request和response都是继承自google::protobuf::Message。</p><p>更新mprpcprovider.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架提供的专门服务发布rpc服务的网络对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个是框架提供给外部使用的，可以发布rpc方法的函数接口 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 组合了EventLoop</span></span><br><span class="line">    muduo::net::EventLoop m_eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// service服务类型信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ServiceInfo</span>&#123;</span><br><span class="line">        google::protobuf::Service *m_service; <span class="comment">// 保存服务对象</span></span><br><span class="line">        std::unordered_map&lt;std::string, <span class="type">const</span> google::protobuf::MethodDescriptor*&gt; m_methodMap; <span class="comment">// 保存服务方法</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::unordered_map&lt;std::string, ServiceInfo&gt; m_serviceMap;  <span class="comment">// 可不止一个服务类型哦，所以也要建立一个映射到不同服务的表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的socket连接回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已建立连接用户的读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Closure的回调操作，用于序列化rpc的响应和网络发送</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendRpcResponse</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, google::protobuf::Message*)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>更新mprpcprovider.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcheader.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是框架提供给外部使用的，可以发布rpc方法的函数接口</span></span><br><span class="line"><span class="comment">这里有一个很重要的指针（protobuf提供给我们获取服务及函数的）：google::protobuf::ServiceDescriptor *pserviceDesc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line">    ServiceInfo service_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务对象的描述信息</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::ServiceDescriptor *pserviceDesc = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line">    <span class="comment">// 获取服务的名字</span></span><br><span class="line">    std::string service_name = pserviceDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">    <span class="comment">// 获取服务对象service的方法的数量</span></span><br><span class="line">    <span class="type">int</span> methodCnt = pserviceDesc-&gt;<span class="built_in">method_count</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;service_name: &quot;</span> &lt;&lt; service_name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; methodCnt; ++i)&#123;</span><br><span class="line">        <span class="comment">// 获取了服务对象指定下标的服务方法的描述（抽象描述）</span></span><br><span class="line">        <span class="comment">// 注意，这里建立map表都是依据proto文件建立的！！！思考一下哦！</span></span><br><span class="line">        <span class="type">const</span> google::protobuf::MethodDescriptor *pmethodDesc = pserviceDesc-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        std::string method_name = pmethodDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">        service_info.m_methodMap.<span class="built_in">insert</span>(&#123;method_name, pmethodDesc&#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    service_info.m_service = service;</span><br><span class="line">    m_serviceMap.<span class="built_in">insert</span>(&#123;service_name, service_info&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 你启动一个rpc网络服务节点，总要获取ip地址和port端口号吧</span></span><br><span class="line">    <span class="comment">// 所以这里是获取ip地址和port端口号</span></span><br><span class="line">    std::string ip = MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;m_eventLoop, address, <span class="string">&quot;RpcProvider&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 绑定连接回调和消息读写回调方法 分离了网络代码和业务代码</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">// 设置muduo库线程数量，自动分配I/O线程和工作线程</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    m_eventLoop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!conn-&gt;<span class="built_in">connected</span>())&#123;</span><br><span class="line">        <span class="comment">// 和rpc client的连接断开了</span></span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在框架内部，RpcProvider和RpcConsumer协商好之间通信用的protobuf数据类型</span></span><br><span class="line"><span class="comment">service_name method_name args   定义proto的message类型，进行数据头的序列化与反序列化</span></span><br><span class="line"><span class="comment">                                service_name method_name args_size（args_size是为了防止粘包问题，指定参数长度）</span></span><br><span class="line"><span class="comment">16UserServiceLogin_rpc16zhang san123456</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">header_size + header_str + args_size + args_str</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr &amp;conn, muduo::net::Buffer *buffer, muduo::Timestamp)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 接收到来自客户端的请求</span></span><br><span class="line">    std::string recv_buf = buffer-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字符流中读取前四个字节的内容</span></span><br><span class="line">    <span class="type">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    recv_buf.<span class="built_in">copy</span>((<span class="type">char</span>*)&amp;header_size, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据header_size读取数据头的原始字符流，反序列化数据，得到rpc请求的详细信息</span></span><br><span class="line">    std::string rpc_header_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span>, header_size);</span><br><span class="line">    mprpc::RpcHeader rpcHeader;</span><br><span class="line">    std::string servcie_name;</span><br><span class="line">    std::string method_name;</span><br><span class="line">    <span class="type">uint32_t</span> args_size;</span><br><span class="line">    <span class="keyword">if</span>(rpcHeader.<span class="built_in">ParseFromString</span>(rpc_header_str))&#123;</span><br><span class="line">        servcie_name = rpcHeader.<span class="built_in">service_name</span>();</span><br><span class="line">        method_name = rpcHeader.<span class="built_in">method_name</span>();</span><br><span class="line">        args_size = rpcHeader.<span class="built_in">args_size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;rpc_header_str:&quot;</span> &lt;&lt; rpc_header_str &lt;&lt; <span class="string">&quot; parse error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取rpc方法参数的字符流数据</span></span><br><span class="line">    std::string args_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span> + header_size, args_size);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;header_size: &quot;</span> &lt;&lt; header_size &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rpc_header_str: &quot;</span> &lt;&lt; rpc_header_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;servcie_name: &quot;</span> &lt;&lt; servcie_name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;args_str: &quot;</span> &lt;&lt; args_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取servcie对象和method对象</span></span><br><span class="line">    <span class="keyword">auto</span> it = m_serviceMap.<span class="built_in">find</span>(servcie_name);</span><br><span class="line">    <span class="keyword">if</span>(it == m_serviceMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; servcie_name &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> mit = it-&gt;second.m_methodMap.<span class="built_in">find</span>(method_name);</span><br><span class="line">    <span class="keyword">if</span>(mit == it-&gt;second.m_methodMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; servcie_name &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; method_name &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    google::protobuf::Service *service = it-&gt;second.m_service;  <span class="comment">// 获取seivice对象</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::MethodDescriptor *method = mit-&gt;second; <span class="comment">// 获取method对像</span></span><br><span class="line"></span><br><span class="line">    google::protobuf::Message *request = service-&gt;<span class="built_in">GetRequestPrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line">    <span class="keyword">if</span>(!request-&gt;<span class="built_in">ParseFromString</span>(args_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;request parse error, content:&quot;</span> &lt;&lt; args_str &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    google::protobuf::Message *response = service-&gt;<span class="built_in">GetResponsePrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给下面的method方法的调用，绑定一个Closure的回调函数</span></span><br><span class="line">    google::protobuf::Closure *done = google::protobuf::<span class="built_in">NewCallback</span>&lt;RpcProvider, <span class="type">const</span> muduo::net::TcpConnectionPtr &amp;, google::protobuf::Message *&gt;(<span class="keyword">this</span>, &amp;RpcProvider::SendRpcResponse, conn, response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在框架上根据远端rpc请求，调用当前rpc节点上发布的方法</span></span><br><span class="line">    service-&gt;<span class="built_in">CallMethod</span>(method, <span class="literal">nullptr</span>, request, response, done);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Closure的回调操作，用于序列化rpc的响应和网络发送</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::SendRpcResponse</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr &amp;conn, google::protobuf::Message *response)</span></span>&#123;</span><br><span class="line">    std::string response_str;</span><br><span class="line">    <span class="keyword">if</span>(response-&gt;<span class="built_in">SerializeToString</span>(&amp;response_str))&#123; <span class="comment">// response进行序列化</span></span><br><span class="line">        <span class="comment">// 序列化成功后，通过网络把rpc方法执行的结果发送回rpc的调用方</span></span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response_str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;serialize response_str error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    conn-&gt;<span class="built_in">shutdown</span>(); <span class="comment">// 模拟http的短连接服务，由provider主动断开连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RpcController"><a href="#RpcController" class="headerlink" title="RpcController"></a>RpcController</h4><p>为什么需要这个呢？这里我们需要注意到一个问题，举个例子，在我们的callfriendservice.cpp文件中，当我们使用完stub调用函数GetFriendlist之后，就直接开始读取response了。但你有没有想过，如果在序列化、网络发送、反序列化、函数执行等过程中产生错误了呢？那我们根本就拿不到response或者说拿到的response是错误的。RpcController可以帮助我们记录一些rpc调用过程中的状态信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;开始补上MPRPC项目的代码实现，从头开始———-day1&quot;&gt;&lt;a href=&quot;#开始补上MPRPC项目的代码实现，从头开始———-day1&quot; class=&quot;headerlink&quot; title=&quot;开始补上MPRPC项目的代码实现，从头开始———-day1&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>UNIX环境高级编程第一章</title>
    <link href="http://zcl0219.github.io/2023/06/08/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <id>http://zcl0219.github.io/2023/06/08/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/</id>
    <published>2023-06-07T19:01:19.000Z</published>
    <updated>2023-06-07T19:01:19.673Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://zcl0219.github.io/2023/05/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://zcl0219.github.io/2023/05/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2023-05-21T06:12:58.000Z</published>
    <updated>2023-10-15T17:42:21.017Z</updated>
    
    <content type="html"><![CDATA[<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="tips：为什么快速排序算法把基准元素名称定义为pivot"><a href="#tips：为什么快速排序算法把基准元素名称定义为pivot" class="headerlink" title="tips：为什么快速排序算法把基准元素名称定义为pivot"></a>tips：为什么快速排序算法把基准元素名称定义为pivot</h5><p>在快速排序算法中，”<code>pivot</code>“（基准元素）是一个用来将数据集分割成两部分的元素。所有比基准元素小的元素都被放到它的左边，而所有比它大的元素都被放到它的右边。这就是为什么它被称为 “<code>pivot</code>“（枢轴），因为它在排序过程中起到了中心轴的作用，就像一个旋转门或者天平的支点那样。</p><p>在一次快速排序的分割操作中，我们从数组的一端开始，将所有比<code>pivot</code>小的元素放到左边，比<code>pivot</code>大的元素放到右边。这个过程称为分区操作（<code>partitioning</code>）。经过分区操作后，<code>pivot</code>元素会位于数组的某个位置，它左边的所有元素都不大于它，它右边的所有元素都不小于它，所以它就到了排序后应该在的位置。</p><p>然后我们可以递归地对<code>pivot</code>左边的元素和右边的元素分别进行快速排序，这样整个数组就会变得有序。</p><p>所以，<code>pivot</code>元素在快速排序中起到了关键的作用，它是算法的核心部分。</p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>以下是一个C++的快速排序实现示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序的一次划分操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];   <span class="comment">// 选择最右边的元素作为基准元素</span></span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = low; j &lt;= high<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i+<span class="number">1</span>], arr[high]);</span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high);   <span class="comment">// 执行一次划分操作</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>);   <span class="comment">// 对左侧子数组递归执行快速排序</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high);  <span class="comment">// 对右侧子数组递归执行快速排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: \n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个程序中，<code>partition</code>函数是快速排序的核心，它实现了一次划分操作。我们首先选择一个基准元素（这里选择的是数组最右侧的元素），然后将所有比基准元素小的元素移动到数组的左侧，比基准元素大的元素移动到数组的右侧。</p><p><code>quickSort</code>函数是一个递归函数，它首先调用<code>partition</code>函数进行一次划分操作，然后对基准元素左侧和右侧的子数组分别递归调用<code>quickSort</code>函数进行排序。这个过程会一直递归下去，直到子数组的大小为1或0，此时子数组已经是有序的，递归结束。</p><h5 id="在实现代码时犯了一个小错误"><a href="#在实现代码时犯了一个小错误" class="headerlink" title="在实现代码时犯了一个小错误"></a>在实现代码时犯了一个小错误</h5><p>在<code>partition</code>函数实现时，最后一步的交换过程中，应该是<code>swap(arr[i+1], arr[high])</code>，而我第一次实现时写成了<code>swap(arr[i+1], pivot)</code>。为什么这样不行呢？貌似看起来是合理的，因为我们在一开始就有语句：<code>int pivot = arr[high];</code>但是恰巧问题就是出现在了这里，因为我们要交换的是<code>vector</code>容器里的元素，我们在实现<code>int pivot = arr[high];</code>这个语句时<code>pivot</code>只是拿到了<code>arr[high]</code>的值，因此我们并没有实际交换<code>arr[i+1]</code>和<code>arr[high]</code>，所以排序后的结果肯定是错的。（因此，定义成这样<code>int&amp; pivot = arr[high]</code>，就可以这样写：<code>swap(arr[i+1], pivot)</code>）</p><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序是一种基于堆的排序算法。它使用了一种叫做堆的数据结构。堆有两种类型：最大堆和最小堆。最大堆的特性是父节点的值大于或等于其所有子节点的值，最小堆的特性是父节点的值小于或等于其所有子节点的值。</p><p>堆排序的基本步骤如下：</p><ol><li>建立最大堆：将待排序序列构造成一个最大堆，这样就能保证整个序列的最大值就是堆顶的根节点。</li><li>交换数据：将根节点与最后一个元素交换位置，然后断开（排除）最后一个元素。</li><li>重建最大堆：通过调整使剩余元素重新构成最大堆。</li><li>重复步骤2~3，直到整个序列有序。</li></ol><p>这里挂一个讲堆排序很好的博客，一定要耐心阅读！<a href="%5B(92%E6%9D%A1%E6%B6%88%E6%81%AF">引用链接</a> 堆排序详细图解（通俗易懂）_右大臣的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_51609435/article/details/122982075">https://blog.csdn.net/weixin_51609435/article/details/122982075</a>))</p><h5 id="堆排序c-实现"><a href="#堆排序c-实现" class="headerlink" title="堆排序c++实现"></a>堆排序c++实现</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> largest = i;   <span class="comment">//从largest往下开始建立大根堆，暂不考虑largset往上的数据</span></span><br><span class="line"><span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">largest = left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">largest = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line"><span class="built_in">heapify</span>(arr, n, largest);    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line"><span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; arr = &#123; <span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">heapSort</span>(arr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> a : arr) &#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自己初步实现时没有彻底弄明白堆排序，所以有如下这个问题"><a href="#自己初步实现时没有彻底弄明白堆排序，所以有如下这个问题" class="headerlink" title="自己初步实现时没有彻底弄明白堆排序，所以有如下这个问题"></a>自己初步实现时没有彻底弄明白堆排序，所以有如下这个问题</h5><p>为什么第一次需要</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而从<code>i=n-1</code>开始，就直接 <code>heapify(arr, i, 0); </code>就没有<code>i=n/2-1</code>的这个过程</p><p>这是因为我们在开始的时候是在创建最大堆。在创建最大堆的过程中，我们需要从最后一个非叶子节点（即 <code>n / 2 - 1</code>）开始，然后向前遍历到根节点（即 <code>0</code>），对每个节点进行下沉操作，确保其满足最大堆的性质。这是创建最大堆的过程。</p><p>然后，我们进入排序的步骤，每次将当前最大的元素（即堆顶元素）与当前堆的最后一个元素交换，然后断开最后一个元素（即排除最后一个元素，使堆的大小减小1），然后再将新的堆顶元素进行下沉操作，确保剩余元素还是一个最大堆。这个过程一直持续到整个堆的元素都被排除，即整个数组都被排序。</p><p>因此，在排序的过程中，我们不需要再从 <code>n / 2 - 1</code> 开始了，因为除了堆顶元素以外，其他元素都满足最大堆的性质，所以我们只需要将新的堆顶元素进行下沉操作即可，也就是 <code>heapify(arr, i, 0);</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h4&gt;&lt;h5 id=&quot;tips：为什么快速排序算法把基准元素名称定义为pivot&quot;&gt;&lt;a href=&quot;#tips：为什么快速排序算法把基</summary>
      
    
    
    
    
  </entry>
  
</feed>

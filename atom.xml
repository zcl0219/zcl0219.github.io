<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://zcl0219.github.io/atom.xml" rel="self"/>
  
  <link href="http://zcl0219.github.io/"/>
  <updated>2025-07-06T13:51:08.656Z</updated>
  <id>http://zcl0219.github.io/</id>
  
  <author>
    <name>GGBond</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Multi-Agent AI</title>
    <link href="http://zcl0219.github.io/2025/06/22/Multi-Agent-AI/"/>
    <id>http://zcl0219.github.io/2025/06/22/Multi-Agent-AI/</id>
    <published>2025-06-22T13:04:54.000Z</published>
    <updated>2025-07-06T13:51:08.656Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>引言</p><p>q1：多智能体强化学习系统特点</p><p>智能体数量非单个</p><p>智能体之间存在一定联系：合作、对抗、合作+对抗（多智能体多动机）</p><p>智能体不仅需要考虑到环境，还需要考虑到其他智能体的行动</p><p>学习环境动态变化</p></li><li><p>博弈论</p><p>minmax</p><p>nash equilibrium</p><p><img src="image-20250622214102079.png" alt=""></p><p><img src="image-20250622215001166.png" alt="1-2"></p><p><img src="image-20250622215250842.png" alt="1-3"></p><p>上图说明了制定出合理的策略需要智能体之间communication</p><p><img src="image-20250622215526657.png" alt="1-4"></p><p>局部最优并不代表全局最优</p><p><img src="image-20250622221246041.png" alt="1-5"></p><p><img src="image-20250622221913906.png" alt="1-6"></p><p>对彼此的最佳对策被称为纳什均衡</p><p><img src="image-20250622222258083.png" alt="1-7"></p><p>纳什均衡可以有多个</p><p><img src="image-20250622222540677.png" alt="1-8"></p><p>博弈定义</p><p><img src="image-20250622223016230.png" alt="1-9"></p><p>占优策略：对于一个玩家来说，拥有一个策略a，不论其他玩家选择任何策略，选择策略a都会使得他的效用u最大，这个策略a就被称为占优策略</p><p><img src="image-20250622223222044.png" alt="1-10"></p><p>n-玩家纳什均衡定义</p><p>q2：是不是所有博弈情况都存在纳什均衡？</p></li><li><p>混合策略纳什均衡</p><p><img src="image-20250622225345099.png" alt="1-11"></p></li></ol><h2 id="2-1-重复博弈"><a href="#2-1-重复博弈" class="headerlink" title="2.1 重复博弈"></a>2.1 重复博弈</h2><p><img src="image-20250623201854412.png" alt="2-1"></p><ul><li><p>为什么要研究重复博弈？</p><p>生活中我们参与的许多战略互动都是持续进行的，比如，我们会与相同的人重复互动等。重复博弈理论提供了一个框架用以研究这种重复行为</p></li></ul><p><img src="image-20250623202222337.png" alt="2-2"></p><ul><li>重复博弈定义：同一个基础博弈（阶段博弈）被相同的参与者多次重复进行。换句话说，在重复博弈中，一个标准式博弈被同样的参与者反复进行。</li></ul><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250623202435065.png" alt="image-20250623202435065"></p><ul><li><p>惩罚的威胁：</p><p>惩罚的威胁是理解重复博弈引入折扣因子的关键概念。基本思想是参与者可能会因为<strong>“惩罚”的“威胁”</strong>而被阻止利用其短期优势，这种威胁的直观效果就是会降低其长期收益。</p><p>通过未来惩罚的威胁来维持合作。参与者在做决策时不仅要考虑当前收益，还要考虑背叛行为可能招致的未来惩罚，从而在长期利益考量下选择合作而非短期的机会主义行为。</p></li></ul><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250623202916496.png" alt="image-20250623202916496"></p><ul><li><p>重复博弈：囚徒困境</p><p>在单次博弈中，背叛是占优策略，但在重复博弈中，未来惩罚的威胁可能使合作成为可能。这为分析现实中的长期合作关系提供了理论基础。</p></li></ul><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250623203105804.png" alt="image-20250623203105804"></p><ul><li><p>囚徒困境有一个唯一的纳什均衡：每个参与者都选D（背叛）</p></li><li><p>现在引入冷酷触发策略：</p><ul><li><p>只要对方参与者选择C，就选择C；</p></li><li><p>如果在任何时期对方参与者选择D，那么在<strong>此后的每个时期</strong>都选择D</p></li></ul></li><li><p>另一个参与者应该怎么做？</p><ul><li>只要她对未来收益的重视程度与当前收益相比不是太小，她最好在每个时期都选择C</li></ul></li><li><p>冷酷触发策略的工作原理：通过”一旦背叛，永远惩罚”的威胁来维持合作。关键在于参与者对未来收益的重视程度（贴现因子）必须足够高，使得长期合作的收益超过短期背叛的收益。</p></li></ul><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250623203455003.png" alt="image-20250623203455003"></p><ul><li>每次都选择C的策略是应对冷酷触发策略最好的策略</li><li>为什么？<ul><li>如果她在每个时期都选择C，那么每个时期的结果都是(C,C)，她在每个时期获得收益2</li><li>如果她在某个时期转向D，那么她在该时期获得收益3，在此后的每个时期获得收益1</li><li>然而，只要她对未来收益的重视程度与当前收益相比不是太小，收益流(3,1,1,…)对她来说比收益流(2,2,2,…)更差 • 因此她最好在每个时期都选择C</li></ul></li><li>为什么冷酷触发策略能够维持合作：虽然背叛能带来一次性的更高收益（3 vs 2），但随后的永久惩罚（每期收益1）使得总体收益低于持续合作（每期收益2）。关键条件是参与者必须足够重视未来收益。</li></ul><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250623203658761.png" alt="image-20250623203658761"></p><ul><li>这张幻灯片指出了重复博弈中的多重均衡问题。除了通过冷酷触发策略维持的合作均衡外，还存在”总是背叛”的均衡。在这种均衡中，由于对方无论如何都会背叛，自己也最好选择背叛，这与单次囚徒困境的结果相同。这说明重复博弈可能存在多个纳什均衡，既有合作的也有非合作的。</li></ul><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250623203835329.png" alt="image-20250623203835329"></p><ul><li><p>两个关键问题：</p><ul><li><p><strong>耐心程度的量化</strong>：要维持合作均衡，参与者需要多重视未来收益？这涉及贴现因子的临界值计算。</p></li><li><p><strong>均衡结果的多样性</strong>：除了完全合作(C,C)和完全背叛(D,D)之外，还有哪些策略组合和结果可以构成纳什均衡？</p></li></ul></li></ul><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250623204324562.png" alt="image-20250623204324562"></p><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250623204526705.png" alt="image-20250623204526705"></p><ul><li>通过冷酷触发策略结合折扣因子来解释折扣因子的边界取值。分别是一直选择合作（C）以及中途换选择（D），分别计算其策略收益，最后比较收益值，即可计算出折扣因子的边界值。</li><li><strong>当δ &lt; 1/2时，”一直背叛”是纳什均衡</strong>：<ul><li>无论δ值如何，”一直背叛”策略<strong>总是纳什均衡</strong>：<ul><li>如果玩家1总是背叛，玩家2的最佳响应是总是背叛（因为如果玩家2合作，支付为0；如果背叛，支付为1）。</li><li>同样，如果玩家2总是背叛，玩家1的最佳响应也是总是背叛。</li><li>支付为每期(1,1)，现值为11−δ1−<em>δ</em>1。</li><li>没有玩家能通过单方面改变策略（如尝试合作）获得更高支付，因为合作会被立即剥削（支付0），且未来收益折现后不足以补偿。</li></ul></li><li>这个均衡总是存在，但它导致<strong>帕累托低效的结果</strong>（支付(1,1)低于合作时的(2,2)）。</li></ul></li></ul><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250623204705478.png" alt="image-20250623204705478"></p><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250623204723342.png" alt="image-20250623204723342"></p><ul><li>有限步惩罚策略与“以牙还牙”策略计算折扣因子边界值思想与冷酷触发策略计算类似，这里不再详细解释。</li></ul><h2 id="2-2-扩展形式博弈"><a href="#2-2-扩展形式博弈" class="headerlink" title="2.2 扩展形式博弈"></a>2.2 扩展形式博弈</h2><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250623210315029.png" alt="image-20250623210315029"></p><ul><li><p>上述内容对比了策略型博弈和扩展式博弈的核心区别，并定义了一种特定类型的扩展式博弈<strong>（多阶段可观测行动博弈）</strong>。以下是我对关键点的理解：</p><ol><li><p><strong>核心区别 (Sequentiality &amp; Information):</strong></p><ul><li><strong>策略型博弈 (战略式博弈):</strong> 强调<strong>同时决策</strong>。玩家在不知道对手选择的情况下做出一次性决策（如石头剪刀布、静态 Cournot 模型）。收益矩阵是其主要表示形式。</li><li><strong>扩展式博弈 (扩展式):</strong> 强调<strong>行动的先后顺序 (序列性)</strong> 和<strong>信息结构</strong>。玩家在不同时间点行动，并且后行动的玩家可能（但不一定）能观察到先行动玩家的选择（如象棋、动态 Stackelberg 模型、序贯议价）。博弈树是其核心表示工具。</li></ul></li><li><p><strong>关注类型 (Multi-stage with Observed Actions):</strong></p><ul><li><strong>多阶段 (Multi-stage):</strong> 博弈过程被划分为不同的阶段。</li><li><strong>可观测行动 (Observed Actions):</strong> 这是定义中<strong>最关键的信息假设</strong>。它意味着在每个阶段开始时，<strong>所有玩家都完全知道之前所有阶段中所有玩家选择的所有行动</strong>。这被称为<strong>完美信息 (Perfect Information)</strong>，但PPT的表述更一般化，因为它允许同一阶段内的玩家<strong>同时行动 (Simultaneous Moves)</strong>。</li><li><strong>完美信息 vs. 可观测行动：</strong> “完美信息”通常指在<em>每个决策点</em>，玩家确切知道之前发生的<em>所有</em>行动（即知道整个历史，知道当前处于哪个决策节点）。PPT定义的“具有可观测行动的多阶段博弈”在阶段之间是完美信息的（玩家知道之前所有阶段的所有行动），但在一个阶段内部，如果存在同时行动，则在该阶段内行动时，玩家可能不知道同阶段其他玩家的<em>即时</em>选择（但在下一阶段开始前，这些行动会被揭示）。这比严格的“完美信息”博弈（要求每个决策点都无同时行动且完全知晓历史）范围更广。</li></ul></li><li><p><strong>表示工具 (Game Trees):</strong></p><ul><li>博弈树是表示扩展式博弈最直观的方式。树根代表起点，树枝代表玩家可能的行动，树节点代表决策点（轮到哪个或哪些玩家行动），树叶代表终点（对应收益/结果）。</li><li>它天然地刻画了<strong>行动顺序</strong>和可能的<strong>路径 (历史)</strong>。</li></ul></li><li><p><strong>关键概念 (Histories):</strong></p><ul><li><strong>历史记录 (Histories)</strong> 是扩展式博弈模型中的<strong>基础构件</strong>。一个历史就是一个从博弈开始到某个时间点为止，所有玩家按顺序采取的行动的序列。</li><li>每个决策点（博弈树节点）都对应一个<strong>唯一的历史</strong>，该历史描述了到达该节点所经过的路径。</li><li>玩家的<strong>信息集 (Information Sets)</strong> 通常由其无法区分的一组历史（节点）来定义。但在PPT定义的“具有可观测行动的多阶段博弈”中，由于行动完全可观测，每个信息集通常只包含一个节点（即玩家总是确切知道自己处于哪个决策点），除非在同一个阶段内存在同时行动（此时玩家可能不知道同阶段对手的<em>即时</em>选择）。</li></ul></li></ol></li></ul><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250623211203839.png" alt="image-20250623211203839"></p><ul><li><p><strong>玩家角色：</strong></p><ul><li><strong>玩家1 - 进入者 (Entrant):</strong> 考虑是否进入一个新市场（通常是一个已有在位企业的市场）。</li><li><strong>玩家2 - 在位者 (Incumbent):</strong> 是市场现有的主导企业，对进入者的行动做出反应。</li></ul></li><li><p><strong>行动顺序与信息：</strong></p><ul><li>这是一个<strong>序贯博弈</strong>：玩家1先行动，玩家2后行动。</li><li><strong>关键信息假设：</strong> 玩家2在做出决策（容纳还是斗争）之前，<strong>完全观察到了玩家1的选择</strong>（进入或不进入）。这意味着玩家2知道博弈进行到了哪个决策点（即玩家1选了哪个行动）。</li><li>这符合之前定义的“<strong>具有可观测行动</strong>”的多阶段博弈。在这里，只有一个阶段玩家1行动，紧接着一个阶段玩家2行动，且玩家2的行动是基于完全知晓玩家1行动的情况下做出的。</li></ul></li><li><p><strong>博弈树表示：</strong></p><ul><li>这个例子非常适合用<strong>博弈树</strong>来表示：<ul><li><strong>根节点 (Root):</strong> 玩家1的决策点（进入 / 不进入）。</li><li><strong>中间节点 (Decision Nodes):</strong> 玩家1选择“进入”后，会到达玩家2的决策点（容纳 / 斗争）。玩家1选择“不进入”后，博弈直接结束。</li><li><strong>叶节点 / 终点节点 (Terminal Nodes / Leaves):</strong> 代表博弈结束的点，标有收益向量 ((x, y))。每个叶节点对应一个<strong>完整的历史</strong>（行动序列）和最终的收益结果。</li></ul></li></ul></li><li><p><strong>收益：</strong></p><ul><li>收益 ((x, y)) 的具体数值决定了博弈的结果和均衡。虽然没有给出具体数字，但典型的设定可能是：<ul><li><code>(不进入)</code>: 进入者收益为0（无成本无收入），在位者收益较高（维持垄断利润）。</li><li><code>(进入, 容纳)</code>: 进入者获得正利润（但低于垄断利润），在位者利润下降（但仍为正，因为共享市场）。</li><li><code>(进入, 斗争)</code>: 进入者亏损（因在位者发起价格战等），在位者也亏损（价格战成本）。虽然进入者损失可能更大，但斗争通常对双方都不利，是两败俱伤的结果。</li></ul></li><li>玩家2（在位者）的决策取决于哪种行动（容纳或斗争）在给定玩家1已进入的前提下，能给他带来更高的收益 (y)。</li></ul></li><li><p>要分析这个博弈的均衡（例如，子博弈精炼纳什均衡），就需要具体设定收益值，并逆向归纳求解玩家2在观察到“进入”后的最优反应，以及玩家1预测到玩家2的最优反应后，最初是否选择“进入”。</p></li></ul><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250623212809384.png" alt="image-20250623212809384"></p><ul><li>扩展型博弈的一些基本符号定义</li></ul><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250623213442013.png" alt="image-20250623213442013"></p><ul><li><p><strong>纯策略 (Pure Strategy):</strong></p><ul><li>在扩展式博弈中，纯策略不仅仅是玩家在博弈开始时的一个单一选择。它是一个<strong>完整的行动计划</strong>。</li><li>策略必须规定玩家在<strong>博弈的每一个可能阶段 (k)</strong>，面对<strong>每一个可能到达该阶段的历史路径 (hᵏ ∈ Hᵏ)</strong> 时，他会选择哪个可用的行动 (sᵢᵏ(hᵏ) ∈ Sᵢ(hᵏ)。</li><li><strong>为什么需要这么复杂？</strong> <ul><li>因为博弈是序贯的，并且玩家在决策时可能面临不同的局面（由不同的历史 hᵏ 描述）。一个完整的策略必须说明玩家在 <em>所有可能遇到的情况</em> 下会怎么做，即使某些情况在博弈实际进行中可能不会发生（如果玩家遵循这个策略的话）。</li></ul></li><li>形式上，玩家 i 的策略 sᵢ 是一个<strong>函数集合</strong> {sᵢ⁰, sᵢ¹, …, sᵢᴷ}，其中每个函数 sᵢᵏ 将阶段 k 的<em>历史集合 Hᵏ</em> 映射到该玩家在该历史下<em>可用的行动集合 Sᵢ(Hᵏ)</em> 中的一个具体行动。</li></ul></li><li><p><strong>策略组合生成博弈路径:</strong></p><ul><li>当所有玩家都选定他们的纯策略 (s₁, s₂, …, sₗ) 后，博弈的实际进行路径就被唯一确定了。</li><li>路径是通过<strong>递归应用</strong>所有玩家的策略函数来生成的：<ul><li><strong>阶段 0:</strong> 从初始历史 h⁰ = ∅ 开始。所有玩家根据他们的策略 sᵢ⁰(∅) 选择行动，形成行动组合 a⁰ = (s₁⁰(∅), s₂⁰(∅), …, sₗ⁰(∅))。阶段 0 后的历史变为 h¹ = a⁰。</li><li><strong>阶段 1:</strong> 面对历史 h¹ = a⁰。所有玩家根据他们的策略 sᵢ¹(a⁰) 选择行动，形成行动组合 a¹ = (s₁¹(a⁰), s₂¹(a⁰), …, sₗ¹(a⁰))。阶段 1 后的历史变为 h² = (a⁰, a¹)。</li><li><strong>后续阶段:</strong> 以此类推，直到最终阶段 K。阶段 K 后的历史 hᴷ⁺¹ = (a⁰, a¹, …, aᴷ) 就是终端历史。</li></ul></li><li>策略组合 s <strong>完全决定了</strong>终端历史 hᴷ⁺¹。</li></ul></li><li><p><strong>收益 (Payoffs):</strong></p><ul><li>玩家的收益取决于博弈的最终<strong>结果 (outcome)</strong>，即终端历史 hᴷ⁺¹。</li><li>每个玩家 i 有一个<strong>效用函数 (utility function)</strong> uᵢ，该函数将每个可能的终端历史 hᴷ⁺¹ 映射到一个实数，表示玩家 i 在该结果下获得的收益（或效用）。</li><li>由于策略组合 s 决定了终端历史 hᴷ⁺¹，因此我们也可以说策略组合 s 决定了每个玩家的收益，记作 uᵢ(s)。uᵢ(s) 本质上是 uᵢ 在由 s 决定的那个特定终端历史 hᴷ⁺¹ 上的取值。</li></ul></li><li><p>扩展式博弈中的核心概念：</p><ul><li><strong>纯策略:</strong> 是玩家针对<strong>所有可能历史</strong>制定的完整应变计划，表现为一组映射函数 {sᵢᵏ}，每个函数为特定阶段 k 的每个可能历史 hᵏ 指定一个行动。</li><li><strong>策略组合决定路径:</strong> 当所有玩家选定策略后，博弈的路径（行动序列 a⁰, a¹, …, aᴷ）和最终的终端历史 hᴷ⁺¹ 就被策略函数递归地、确定性地生成。</li><li><strong>收益定义在结果上:</strong> 玩家的收益由终端历史（博弈的最终结果）决定。效用函数 uᵢ 量化了玩家对每个可能结果的偏好。策略组合 s 通过决定终端历史 hᴷ⁺¹ 来间接决定每个玩家的收益 uᵢ(s)。</li></ul></li><li><p>理解纯策略的这种“完备应变计划”性质对于分析扩展式博弈的均衡（如子博弈精炼纳什均衡）至关重要，因为它要求玩家即使在“偏离均衡路径”的历史下（即如果博弈意外地到达了那里），也要指定一个行动。</p></li></ul><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250623214724248.png" alt="image-20250623214724248"></p><ul><li><strong>关键总结 (PPT最后一句):</strong></li></ul><blockquote><p>一个玩家的策略规定了该玩家在其<strong>轮到行动的每一个历史</strong>（例如，玩家2在<code>&#123;C&#125;</code>之后或<code>&#123;D&#125;</code>之后）处所选择的行动。</p></blockquote><ul><li>玩家 1 的策略只需要规定在唯一的历史 <code>∅</code> 处选择 <code>C</code> 或 <code>D</code>。</li><li>玩家 2 的策略必须规定在 <em>两个</em> 可能的历史 <code>&#123;C&#125;</code> 和 <code>&#123;D&#125;</code> 处分别选择什么行动（<code>E/F</code> 和 <code>G/H</code> 的组合）。</li></ul><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250624002522709.png" alt="image-20250624002522709"></p><ul><li>在给定的扩展式博弈及其转换后的标准式（策略型）博弈中，策略组合（L, RL）不是纳什均衡（Nash equilibrium）。以下基于提供的收益矩阵和纳什均衡的定义，逐步解释原因。</li></ul><ul><li><p><strong>博弈的收益矩阵</strong>：</p><p>| 玩家1 \ 玩家2 | LL   | LR   | RL   | RR   |<br>| ——————- | —— | —— | —— | —— |<br>| <strong>L</strong>         | 3,2  | 3,2  | 2,3  | 2,3  |<br>| <strong>R</strong>         | 4,1  | 0,1  | 4,1  | 0,1  |</p></li><li><p><strong>玩家2的策略含义</strong>（RL策略）：</p><ul><li>RL = 如果玩家1选择L，则玩家2选择R；如果玩家1选择R，则玩家2选择L。</li></ul></li><li><p><strong>策略组合（L, RL）的含义</strong>：</p><ul><li>玩家1选择L。</li><li>玩家2选择RL策略（因此，当玩家1选L时，玩家2选R）。</li><li>实际发生的行动路径：玩家1选L → 玩家2选R。</li><li>对应收益：从收益矩阵中，行L、列RL的单元格为（2,3），即玩家1收益为2，玩家2收益为3。</li></ul></li><li><h3 id="纳什均衡的定义"><a href="#纳什均衡的定义" class="headerlink" title="纳什均衡的定义"></a>纳什均衡的定义</h3><ul><li>纳什均衡要求：在给定其他玩家的策略下，没有任何一个玩家能通过单方面改变自己的策略而获得更高的收益。也就是说：</li><li>玩家1的策略必须是对玩家2策略的最优响应（best response）。</li><li>玩家2的策略必须是对玩家1策略的最优响应。<br>如果任何一个玩家有激励偏离当前策略，则该组合不是纳什均衡。</li></ul></li><li><h3 id="为什么（L-RL）不是纳什均衡？"><a href="#为什么（L-RL）不是纳什均衡？" class="headerlink" title="为什么（L, RL）不是纳什均衡？"></a>为什么（L, RL）不是纳什均衡？</h3><p>在策略组合（L, RL）下，玩家1有激励单方面改变策略。具体分析如下：</p></li></ul><ol><li><p><strong>给定玩家2的策略RL，玩家1的收益比较</strong>：</p><ul><li>如果玩家1保持选择L（当前策略）：<ul><li>玩家2的RL策略规定：当玩家1选L时，玩家2选R。</li><li>因此，收益为（2,3），玩家1获得收益<strong>2</strong>。</li></ul></li><li>如果玩家1单方面改为选择R：<ul><li>玩家2的RL策略规定：当玩家1选R时，玩家2选L（因为RL策略在玩家1选R时对应选L）。</li><li>因此，行动路径为（R, L），收益为（4,1）（从收益矩阵的行R、列RL单元格可得）。</li><li>玩家1获得收益<strong>4</strong>。</li></ul></li></ul></li><li><p><strong>玩家1的激励分析</strong>：</p><ul><li>玩家1的收益从<strong>2</strong>（选L）变为<strong>4</strong>（选R），收益增加（4 &gt; 2）。</li><li>因此，玩家1有严格激励（strict incentive）偏离策略L，改为选择R。因为收益更高，且这是单方面改变（玩家2的策略RL保持不变）。</li></ul></li><li><p><strong>玩家2的响应（虽不必要，但完整性分析）</strong>：</p><ul><li>在（L, RL）下，玩家2的收益为3（给定玩家1选L，玩家2选R）。</li><li>如果玩家1保持选L，玩家2改变策略（如改为LL、LR或RR）：<ul><li>例如，改为LL：当玩家1选L时，玩家2选L，收益为2（行L、列LL单元格为（3,2），玩家2收益2 &lt; 3）。</li><li>改为LR：当玩家1选L时，玩家2选L，收益为2（行L、列LR单元格为（3,2），玩家2收益2 &lt; 3）。</li><li>改为RR：当玩家1选L时，玩家2选R，收益为3（与当前相同）。</li><li>因此，玩家2无严格激励偏离RL（因为改变策略要么收益降低，要么不变），但这不是关键，因为玩家1的偏离已足够破坏均衡。</li></ul></li></ul></li></ol><ul><li><h3 id="为什么PPT中列出的（R-RL）是纳什均衡，而（L-RL）不是？"><a href="#为什么PPT中列出的（R-RL）是纳什均衡，而（L-RL）不是？" class="headerlink" title="为什么PPT中列出的（R, RL）是纳什均衡，而（L, RL）不是？"></a>为什么PPT中列出的（R, RL）是纳什均衡，而（L, RL）不是？</h3><ul><li><p><strong>（R, RL）是纳什均衡</strong>（如PPT所列）：</p><ul><li>玩家1选R，玩家2选RL（当玩家1选R时，玩家2选L）。</li><li>收益为（4,1）。</li><li>给定玩家2的RL策略，玩家1：选R收益4，选L收益2（因为如果玩家1选L，玩家2选R，收益2），4 &gt; 2，因此玩家1无激励偏离。</li><li>给定玩家1选R，玩家2：任何改变（如改为LL、LR或RR），在玩家1选R时收益均为1（无严格增加），因此玩家2无激励偏离。</li><li>所以（R, RL）满足纳什均衡条件（弱均衡）。</li></ul></li><li><p><strong>（L, RL）不是纳什均衡</strong>：</p><ul><li>如上所述，玩家1有严格激励偏离L到R，因此不满足“无玩家有激励偏离”的条件。</li></ul></li></ul></li><li><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>（L, RL）不是纳什均衡，因为玩家1可以通过单方面改变策略（从L到R）将收益从2提高到4。</strong> 给定玩家2的RL策略，玩家1选择L不是最优响应。</li><li>这体现了纳什均衡的核心要求：每个玩家的策略必须是对其他玩家策略的最优响应。在扩展式博弈中，这种分析也揭示了为什么有些策略组合在标准式中看似可行，但因动态不一致而被排除（如这里玩家1的偏离激励）。</li></ul></li></ul><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250624003714695.png" alt="image-20250624003714695"></p><p>这张PPT探讨了进入博弈的均衡合理性，通过扩展式和标准式表示揭示了纳什均衡的局限性。以下是详细分析：</p><hr><h3 id="博弈结构与收益"><a href="#博弈结构与收益" class="headerlink" title="博弈结构与收益"></a>博弈结构与收益</h3><h4 id="扩展式表示（博弈树）："><a href="#扩展式表示（博弈树）：" class="headerlink" title="扩展式表示（博弈树）："></a>扩展式表示（博弈树）：</h4><ul><li><strong>玩家1（进入者）</strong>：先行动，选择：<ul><li><strong>In</strong>（进入市场）</li><li><strong>Out</strong>（不进入市场）→ 收益 (1,2)</li></ul></li><li><strong>玩家2（在位者）</strong>：观察到进入者行动后选择：<ul><li><strong>A</strong>（容纳）→ 收益 (2,1)</li><li><strong>F</strong>（斗争）→ 收益 (0,0)</li></ul></li></ul><h4 id="标准式表示（收益矩阵）："><a href="#标准式表示（收益矩阵）：" class="headerlink" title="标准式表示（收益矩阵）："></a>标准式表示（收益矩阵）：</h4><div class="table-container"><table><thead><tr><th>进入者 \ 在位者</th><th>容纳 (A)</th><th>斗争 (F)</th></tr></thead><tbody><tr><td><strong>进入 (In)</strong></td><td>(2,1)</td><td>(0,0)</td></tr><tr><td><strong>不进入 (Out)</strong></td><td>(1,2)</td><td>(1,2)</td></tr></tbody></table></div><hr><h3 id="纳什均衡分析"><a href="#纳什均衡分析" class="headerlink" title="纳什均衡分析"></a>纳什均衡分析</h3><ol><li><p><strong>(In, A)</strong>：</p><ul><li>进入者收益：2（若改为Out，收益1&lt;2）→ <strong>无偏离激励</strong></li><li>在位者收益：1（若改为F，收益0&lt;1）→ <strong>无偏离激励</strong><br>✅ <strong>是纳什均衡</strong></li></ul></li><li><p><strong>(Out, F)</strong>：</p><ul><li>进入者收益：1（若改为In，在位者选F则收益0&lt;1）→ <strong>无偏离激励</strong></li><li>在位者收益：2（无论选A或F，收益均为2）→ <strong>无偏离激励</strong><br>✅ <strong>是纳什均衡（弱均衡）</strong></li></ul></li></ol><hr><h3 id="均衡合理性检验"><a href="#均衡合理性检验" class="headerlink" title="均衡合理性检验"></a>均衡合理性检验</h3><h4 id="为什么-Out-F-不合理？"><a href="#为什么-Out-F-不合理？" class="headerlink" title="为什么 (Out, F) 不合理？"></a>为什么 <strong>(Out, F)</strong> 不合理？</h4><p>尽管 <strong>(Out, F)</strong> 是纳什均衡，但它在动态博弈中<strong>不可信</strong>（缺乏子博弈精炼性）：</p><ol><li><p><strong>在位者的空威胁</strong>：</p><ul><li>在位者声称“若你进入，我会斗争（F）”，但若进入者真的选择 <strong>In</strong>：<ul><li>在位者选 <strong>A</strong> 收益为 <strong>1</strong></li><li>在位者选 <strong>F</strong> 收益为 <strong>0</strong>（更差）<br>→ 理性在位者实际会选择 <strong>A</strong>，而非 <strong>F</strong>。</li></ul></li></ul></li><li><p><strong>进入者的理性决策</strong>：</p><ul><li>进入者知道在位者的威胁不可信（一旦进入，在位者必选 <strong>A</strong>）。</li><li>因此进入者应选择 <strong>In</strong>（收益2 &gt; 选Out的收益1）。</li></ul></li></ol><h4 id="逆向归纳验证："><a href="#逆向归纳验证：" class="headerlink" title="逆向归纳验证："></a>逆向归纳验证：</h4><ol><li>若进入者选 <strong>In</strong>，在位者在子博弈中：<ul><li>选 <strong>A</strong> → 收益 <strong>1</strong></li><li>选 <strong>F</strong> → 收益 <strong>0</strong><br>→ 最优选择是 <strong>A</strong>。</li></ul></li><li>进入者预判：<ul><li>选 <strong>In</strong> → 收益 <strong>2</strong>（因在位者会选A）</li><li>选 <strong>Out</strong> → 收益 <strong>1</strong><br>→ 最优选择是 <strong>In</strong>。</li></ul></li></ol><hr><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><div class="table-container"><table><thead><tr><th>均衡</th><th>合理性</th><th>原因</th></tr></thead><tbody><tr><td><strong>(In, A)</strong></td><td>✅ 合理</td><td>威胁可信，符合序贯理性</td></tr><tr><td><strong>(Out, F)</strong></td><td>❌ 不合理</td><td>依赖不可信的空威胁（动态不一致）</td></tr></tbody></table></div><ul><li><strong>核心问题</strong>：纳什均衡在扩展式博弈中可能包含<strong>不可信威胁</strong>，需通过<strong>子博弈精炼纳什均衡</strong>（逆向归纳法）剔除不合理的均衡。</li><li><strong>本例唯一合理均衡</strong>：<strong>(In, A)</strong>，即进入者进入，在位者容纳。</li></ul><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250624004513150.png" alt="image-20250624004513150"></p><ul><li>回顾匹配硬币博弈（matching pennies game）的两阶段扩展式版本。</li><li>在这个博弈中，存在两个<strong>真子博弈（proper subgames）</strong> 以及博弈本身（它也是一个子博弈），因此总共有<strong>三个子博弈</strong>。</li></ul><blockquote><p><strong>定义：</strong> 在一个（完美信息）博弈树中，<strong>每一个节点</strong>，连同从该节点到达之后所剩余的博弈部分，被称为一个<strong>子博弈（subgame）</strong>。<br>即，每一个<strong>非终端历史（non-terminal history）</strong> ( h ) 都对应一个子博弈。</p></blockquote><hr><p><strong>关键概念理解：</strong></p><ol><li><p><strong>子博弈 (Subgame):</strong></p><ul><li>子博弈是<strong>原博弈的一部分</strong>，它起始于博弈树中的<strong>某个单一决策节点</strong>（该节点代表一个特定的非终端历史 ( h^k )），并<strong>包含该节点之后的所有后续决策节点、行动分支和终端节点</strong>。</li><li>它本身必须构成一个<strong>完整的、独立的博弈</strong>，拥有明确的起点（该决策节点）、后续行动规则和最终收益。</li><li>子博弈继承了原博弈的所有规则（玩家、行动、信息、收益函数）。</li></ul></li><li><p><strong>非终端历史 (Non-terminal History):</strong></p><ul><li>指那些<strong>不是博弈最终结果</strong>的历史 ( h^k )（即 ( k &lt; K+1 )，其中 ( K+1 ) 是终端历史的索引）。</li><li>每个这样的历史 ( h^k ) 都标志着博弈进行到了一个<strong>尚未结束的决策点</strong>。</li><li><strong>关键联系：</strong> 每个非终端历史 ( h^k ) 都<strong>唯一确定了一个子博弈的起始点</strong>。这个子博弈就是从历史 ( h^k ) 所对应的那个决策节点开始的剩余游戏部分。</li></ul></li><li><p><strong>子博弈的数量:</strong></p><ul><li>在<strong>完美信息（perfect information）</strong> 博弈（即每个信息集只包含一个节点）中，子博弈的数量等于<strong>非终端决策节点的数量</strong>。</li><li>示例中提到匹配硬币两阶段博弈有<strong>三个子博弈</strong>：<ul><li><strong>子博弈 1：</strong> 起始于<strong>玩家1的第一个决策节点</strong>（对应初始历史 ( h^0 = \emptyset )）。<strong>这就是整个博弈本身。</strong></li><li><strong>子博弈 2：</strong> 起始于<strong>玩家2在玩家1选择“正面”之后的决策节点</strong>（对应历史 ( h^1 = (Heads) )）。</li><li><strong>子博弈 3：</strong> 起始于<strong>玩家2在玩家1选择“反面”之后的决策节点</strong>（对应历史 ( h^1 = (Tails) )）。</li></ul></li><li>后两个是<strong>真子博弈（proper subgames）</strong>，因为它们严格包含在原博弈之内且不等于原博弈。</li></ul></li><li><p><strong>为什么子博弈概念重要？</strong></p><ul><li><strong>均衡精炼：</strong> 子博弈概念是定义<strong>子博弈精炼纳什均衡（Subgame Perfect Nash Equilibrium, SPNE）</strong> 的核心。SPNE 要求均衡策略不仅在原博弈上构成纳什均衡，而且在<strong>每一个可能的子博弈</strong>上也构成纳什均衡。这旨在剔除那些依赖<strong>不可信威胁或承诺</strong>的纳什均衡（例如之前进入博弈中的 <code>(Out, F)</code> 均衡）。</li><li><strong>分析工具：</strong> 子博弈结构使得我们可以使用<strong>逆向归纳法（backward induction）</strong> 来求解完美信息有限博弈的 SPNE。我们从最小的子博弈（最接近终点的）开始求解，将其解（收益或最优行动）代入其父节点，再逐步倒推回根节点。</li><li><strong>模块化分析：</strong> 允许将大型复杂博弈分解为更小的、可管理的子部分进行分析。</li></ul></li><li><p><strong>子博弈求解方法解析</strong></p><p><a href="https://zhuanlan.zhihu.com/p/199055190">https://zhuanlan.zhihu.com/p/199055190</a></p></li></ol><h2 id="2-3-势博弈"><a href="#2-3-势博弈" class="headerlink" title="2.3 势博弈"></a>2.3 势博弈</h2><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250624194410787.png" alt="image-20250624194410787"></p><ul><li><strong>请注意，对于所有厂商 i 和所有 q−i&gt;0 的情况：</strong><ul><li>ui(qi,q−i)−ui(qi′,q−i)&gt;0 <strong>当且仅当 (iff)</strong> Φ(qi,q−i)−Φ(qi′,q−i)&gt;0 ，此条件对于所有 qi,qi′&gt;0 均成立。</li><li>说明：<ul><li>这条关键的陈述指出，在其他厂商产量不变的情况下，厂商 i 从产量 qi′ 转换到 qi 能否增加自身利润，与这个转换能否增加函数 Φ 的值，两者是完全等价的。</li></ul></li></ul></li></ul><p>这张PPT的核心思想是为古诺竞争模型引入一个称为<strong>“势函数”(Potential Function)</strong> 的概念，并证明此模型是一个<strong>“势博弈”(Potential Game)</strong>。</p><ol><li><p>什么是古诺竞争？</p><p>这是一个经典的经济学模型，描述了在一个寡占市场中，几家厂商如何进行产量竞争。每家厂商都假设其竞争对手的产量是固定的，然后选择能让自己利润最大化的产量。当所有厂商都达到一个状态，即没有任何一家厂商可以单方面改变产量来增加自己的利润时，市场就达到了纳什均衡 (Nash Equilibrium)。</p></li><li><p>为什么要引入奇怪的函数 Φ？</p><p>支付函数 ui 非常直观，它就是厂商 i 的利润。然而，函数 Φ 看起来很抽象，它将“所有厂商产量的乘积”与“单位利润”相乘，并没有直接的经济学意义。</p><p>它的真正价值在于其数学性质。投影片的最后一条结论揭示了这个性质：任何单一厂商 i 调整策略 (产量 qi) 所带来的自身利润变化方向，都和函数 Φ 的变化方向完全一致。</p></li><li><p>这意味着什么？(核心理解)</p><p>这意味着，原本一个复杂的多人博弈问题（每个厂商都在最大化自己的 ui），可以被转化为一个相对简单的<strong>“寻找单一函数 Φ 最大值”</strong>的问题。</p><ul><li><strong>简化分析</strong>：我们不再需要同时追踪 I 个不同厂商的利润函数，只需要分析一个共同的“势函数”Φ 即可。</li><li><strong>保证均衡存在</strong>：在势博弈中，势函数 Φ 的局部最大值点对应着该博弈的纳什均衡。因为一个有界的连续函数必然存在最大值，这就为证明古诺均衡的存在性提供了一条优雅的路径。</li><li><strong>收敛性</strong>：势博弈还有一个重要特性，即如果玩家们轮流进行“最优反应”（每次都选择当下能让自己利润最大化的策略），这个过程最终一定会收敛到一个纳什均衡。函数 Φ 就像一个山坡，玩家们的每一步调整都像是在爬坡，最终必然会走到一个山顶（均衡点）。</li></ul></li></ol><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250624200511139.png" alt="image-20250624200511139"></p><p>这两张PPT分别介绍了<strong>序数势博弈</strong>和<strong>精确势博弈</strong>。</p><ol><li><p>与“序数势”的核心区别</p><p>理解“精确势”的关键在于将其与上一张幻灯片中的“序数势”进行对比：</p><ul><li><strong>序数势 (Ordinal Potential)</strong>：只要求参与者收益变化的<strong>方向</strong>与势函数变化的<strong>方向</strong>一致。<ul><li>通俗地说：“只要我换策略能多赚钱，<code>Φ</code> 的值就一定会变大。” 它不关心你多赚了1块钱还是100块钱。</li></ul></li><li><strong>精确势 (Exact Potential)</strong>：要求参与者收益变化的<strong>确切数值</strong>与势函数变化的<strong>确切数值</strong>完全相等。<ul><li>通俗地说：“如果我换策略能多赚10块钱，<code>Φ</code> 的值就也必须不多不少，正好增加10。”</li></ul></li></ul></li><li><p>更严格的条件</p><p>显然，“精确势”是一个比“序数势”严格得多的条件。如果一个博弈是精确势博弈，那么它必然也是一个序数势博弈（因为如果两个改变量的数值相等，它们的正负号必然相同）。但反过来不成立，很多序数势博弈并不能满足精确势的苛刻条件。</p></li><li><p>指正幻灯片中的笔误</p><p>需要指出，幻灯片的最后一行存在一个明显的笔误。它写着 “G is called an exact potential game if it admits an ordinal potential.”（如果一个博弈拥有一个序数势，它就被称为一个精确势博弈）。这在逻辑上是错误的。</p><ul><li><strong>正确表述应为</strong>：“如果一个博弈 G 拥有一个<strong>精确势函数 (exact potential)</strong>，那么它就被称为一个<strong>精确势博弈</strong>。”</li></ul></li></ol><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250624201207684.png" alt="image-20250624201207684"></p><p>这张幻灯片通过一个具体的2x2矩阵博弈（囚徒困境的一个变体）的例子，非常直观地展示了“势函数”是如何运作的。这张幻灯片的核心目的是让我们<strong>验证</strong>所给出的矩阵 <code>P</code> 是否真的是博弈 <code>G</code> 的一个势函数。</p><p>我们可以通过检验定义来验证。让我们看看当某个参与者单方面改变策略时，他个人收益的变化量是否与势函数 <code>P</code> 的变化量相匹配。</p><p><strong>1. 验证过程</strong></p><p>我们分别检查行参与者（玩家1）和列参与者（玩家2）的决策。</p><ul><li><p><strong>检验玩家1（行选择者）</strong></p><ul><li><p>当玩家2选择“左”时</p><p>：玩家1在“上”（收益1）和“下”（收益0）之间选择。</p><ul><li>收益变化: u1(上, 左)−u1(下, 左)=1−0=1</li><li>势函数变化: P(上, 左)−P(下, 左)=4−3=1</li><li>两者<strong>完全相等</strong>。</li></ul></li><li><p>当玩家2选择“右”时</p><p>：玩家1在“上”（收益9）和“下”（收益6）之间选择。</p><ul><li>收益变化: u1(上, 右)−u1(下, 右)=9−6=3</li><li>势函数变化: P(上, 右)−P(下, 右)=3−0=3</li><li>两者<strong>完全相等</strong>。</li></ul></li></ul></li><li><p><strong>检验玩家2（列选择者）</strong></p><ul><li><p>当玩家1选择“上”时</p><p>：玩家2在“左”（收益1）和“右”（收益0）之间选择。</p><ul><li>收益变化: u2(上, 左)−u2(上, 右)=1−0=1</li><li>势函数变化: P(上, 左)−P(上, 右)=4−3=1</li><li>两者<strong>完全相等</strong>。</li></ul></li><li><p>当玩家1选择“下”时</p><p>：玩家2在“左”（收益9）和“右”（收益6）之间选择。</p><ul><li>收益变化: u2(下, 左)−u2(下, 右)=9−6=3</li><li>势函数变化: P(下, 左)−P(下, 右)=3−0=3</li><li>两者<strong>完全相等</strong>。</li></ul></li></ul></li></ul><p><strong>2. 结论</strong></p><p>由于<strong>任何</strong>参与者单方面改变策略所带来的收益变化，都<strong>精确地等于</strong>势函数 <code>P</code> 中对应数值的变化，因此，矩阵 <code>P</code> 是博弈 <code>G</code> 的一个<strong>精确势函数 (exact potential function)</strong>。这个博弈 <code>G</code> 是一个<strong>精确势博弈</strong>。</p><p><strong>3. 势函数的威力：寻找纳什均衡</strong></p><p>这个例子的美妙之处在于，它展示了势函数如何简化均衡的寻找过程。寻找博弈 <code>G</code> 的纯策略纳什均衡，现在等价于寻找势函数矩阵 <code>P</code> 的“稳定点”。</p><p>观察势函数矩阵 P：</p><p>P=(4330)</p><p>矩阵中的最大值是4，位于（上，左）位置。让我们看看这个点是否稳定：</p><ul><li>如果从 <code>P=4</code>（上，左）出发，玩家1单方面移到“下”，<code>P</code>的值会从4变成3，他不会移动。</li><li>如果从 <code>P=4</code>（上，左）出发，玩家2单方面移到“右”，<code>P</code>的值会从4变成3，他也不会移动。</li></ul><p>因为没有任何一方有动机从（上，左）这个位置离开，所以它是一个纳什均衡。这对应于原博弈 <code>G</code> 中的（1,1）这个结果。这个例子清晰地表明，<strong>势函数的局部最大值（在此例中也是全局最大值）对应着博弈的一个纳什均衡</strong>。这正是势函数在博弈分析中的核心价值。</p><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250624201541524.png" alt="image-20250624201541524"></p><p>有限序数势博弈的结果是有限的，势函数会为每一个博弈策略赋予一个值，因此必然存在一个最大值，这个最大值就是纳什均衡点。</p><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250624202953517.png" alt="image-20250624202953517"></p><h4 id="1-核心结论"><a href="#1-核心结论" class="headerlink" title="1. 核心结论"></a>1. 核心结论</h4><p>结论是最后一条：当厂商 <code>i</code> 单方面将自己的产量从 <code>q&#39;_i</code> 变为 <code>q_i</code> 时，他<strong>个人利润的变化量</strong>，与我们构造的那个看起来很复杂的函数 <code>Φ*</code> 的<strong>变化量是完全相等的</strong>。这正是“精确势函数”的定义。</p><h4 id="2-数学证明（为什么这个结论成立？）"><a href="#2-数学证明（为什么这个结论成立？）" class="headerlink" title="2. 数学证明（为什么这个结论成立？）"></a>2. 数学证明（为什么这个结论成立？）</h4><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250624203148105.png" alt="image-20250624203148105"></p><p>最后比较两个Δ即可</p><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250624204837963.png" alt="image-20250624204837963"></p><p><strong>标题：有限序数势博弈中的简单动态 (Simple Dynamics in Finite Ordinal Potential Games)</strong></p><p>定义 (Definition)</p><p>策略空间 S 中的一条路径 (path) 是一个策略向量序列 (s0,s1,⋯)，其中任意两个连续的策略只在一个坐标上不同（即，每一次恰好只有一名参与者改变了他的策略）。</p><p>一条<strong>改进路径 (improvement path)</strong> 是一条路径 (s0,s1,⋯)，它满足：</p><ul><li>uik(sk)&lt;uik(sk+1)，其中策略 sk 和 sk+1 在第 ik 个坐标上不同。换句话说，对于那个改变了策略的参与者来说，他的收益得到了改善。</li></ul><p>一条改进路径可以被认为是<strong>“短视参与者” (myopic players)</strong> 动态生成的结果。</p><hr><p>这张幻灯片将我们的视角从静态的“均衡分析”转向了动态的“演化过程分析”。它为我们描述“一个博弈是如何一步步演变的”提供了正式的语言。这对于理解系统如何达到稳定状态至关重要。</p><h4 id="1-“路径”与“改进路径”的通俗解释"><a href="#1-“路径”与“改进路径”的通俗解释" class="headerlink" title="1. “路径”与“改进路径”的通俗解释"></a>1. “路径”与“改进路径”的通俗解释</h4><ul><li><strong>路径 (Path)</strong>：你可以把它想象成一盘棋的“棋谱”或一个游戏的“回合记录”。它记录了博弈状态是如何一步步变化的，其核心规则是<strong>“一次只动一个”</strong>。在 sk 这一步，只有一名参与者会改变他的行动，从而进入 sk+1 状态。这是一种分析动态过程的合理简化。</li><li><strong>改进路径 (Improvement Path)</strong>：这是一种特殊的、由理性驱动的路径。它不仅记录了系统的演变，还说明了<strong>为什么</strong>会这样演变。每一步的发生，都是因为某个参与者发现“如果我单方面改变策略，我的收益会立刻增加”，于是他就这么做了。这完美地描述了那些只顾眼前利益的参与者的行为。</li></ul><h4 id="2-“短视参与者”-Myopic-Players-的概念"><a href="#2-“短视参与者”-Myopic-Players-的概念" class="headerlink" title="2. “短视参与者” (Myopic Players) 的概念"></a>2. “短视参与者” (Myopic Players) 的概念</h4><p>这是理解“改进路径”背后行为动机的关键。</p><ul><li><strong>“短视”</strong>意味着参与者们并不深谋远虑，他们不会去预测对手的对手的反应。</li><li>他们的决策逻辑非常简单：“在当前这个局面下，我有没有一个别的选择能让我马上赚得更多？”</li><li>如果答案是“有”，那么某个参与者就会采取行动，从而推动整个系统沿着“改进路径”向前走一步。这个过程可以被看作是一系列“更优反应 (better response)”的链式反应。</li></ul><h4 id="3-为什么要在势博弈中讨论这个？（核心洞见）"><a href="#3-为什么要在势博弈中讨论这个？（核心洞见）" class="headerlink" title="3. 为什么要在势博弈中讨论这个？（核心洞见）"></a>3. 为什么要在势博弈中讨论这个？（核心洞见）</h4><p>定义这些概念的最终目的，是为了引出势博弈最强大的性质之一：<strong>动态收敛性</strong>。</p><p>我们可以设想一下：</p><ol><li><strong>在普通博弈中</strong>：一条“改进路径”可能会没完没了地走下去，甚至可能陷入一个循环（比如A动、B动、C动，结果又回到了A动之前的局面），永远无法达到一个稳定的纳什均衡。</li><li><strong>但在势博弈中</strong>：奇迹发生了。我们知道，在势博弈中，只要某个参与者 <code>i</code> 的收益 <code>uᵢ</code> 增加了，全局的势函数 <code>Φ</code> 的值也<strong>必须增加</strong>。</li><li>因此，在势博弈里，<strong>每一条“改进路径”都必然是一条“势函数 <code>Φ</code> 值不断增加的路径”</strong>。</li><li>在一个<strong>有限</strong>博弈中，势函数 <code>Φ</code> 的可能取值是有限的，它必然有一个最大值。<code>Φ</code> 的值不可能无限地增加下去。</li></ol><p><strong>结论</strong>：在有限势博弈中，任何“改进路径”走不了几步就<strong>必然会停止</strong>。它会在哪里停下呢？它会停在一个任何人都无法再单方面改善自己收益的地方——而这个地方，根据定义，<strong>就是一个纯策略纳什均衡</strong>。</p><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250624205950398.png" alt="image-20250624205950398"></p><p><strong>标题：有限精确势博弈的特征描述 (Characterization of Finite Exact Potential Games)</strong></p><ul><li><p>对于一条有限路径 γ=(s0,s1,…,sN)，我们令：</p><p>I(γ)=i=1∑N(umi(si)−umi(si−1))</p><p>其中，mi 指代在路径的第 i 步改变其策略的参与者。</p></li><li><p>如果 s0=sN，则路径 γ=(s0,…,sN) 是<strong>闭合的 (closed)</strong>。如果在此外对于每一个 0≤l&lt;k≤N−1 都有 sl\\=sk，那么它就是一条<strong>简单闭合路径 (simple closed path)</strong>。</p></li></ul><p>定理 (Theorem)</p><p>一个博弈 G 是一个精确势博弈，当且仅当对于所有有限简单闭合路径 γ，都有 I(γ) = 0。此外，只检验长度为4的简单闭合路径就足够了。</p><hr><p>这个数学定理，它为我们提供了一个<strong>“试金石”</strong>，用来检验任何一个有限博弈到底是不是一个“精确势博弈”，而无需我们去猜测或构造那个势函数 <code>Φ</code>。</p><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250624211206447.png" alt="image-20250624211206447"></p><p><strong>标题：网络拥堵博弈 (Network Congestion Games)</strong></p><ul><li>一个包含 n 个用户的<strong>有向图 (directed graph)</strong> G=(V,E)，</li><li>图 G 中的每一条<strong>边 (edge)</strong> e 都有一个<strong>延迟函数 (delay function)</strong> fₑ，</li><li>用户 i 的<strong>策略 (Strategy)</strong> 是选择一条从<strong>起点 (source)</strong> sᵢ 到<strong>终点 (destination)</strong> tᵢ 的<strong>路径 (path)</strong> Aᵢ，</li><li>一条路径的延迟是该路径上所有边的延迟之和，</li><li>每个用户都想通过选择最佳路径来<strong>最小化 (minimize)</strong> 其自身的延迟。</li></ul><hr><p>这张幻灯片介绍了一类在现实世界中应用极其广泛的博弈模型——<strong>网络拥堵博弈</strong>。这是理解交通堵塞、互联网数据包路由、供应链物流等众多问题的核心理论框架。</p><h4 id="1-博弈的核心要素"><a href="#1-博弈的核心要素" class="headerlink" title="1. 博弈的核心要素"></a>1. 博弈的核心要素</h4><p>这个模型非常直观，它完美地捕捉了“拥堵”现象的本质：</p><ul><li><strong>参与者 (Players)</strong>：n 个用户（比如，n 位司机）。</li><li><strong>策略 (Strategies)</strong>：每个司机可以选择的路线（例如，从家 <code>sᵢ</code> 到公司 <code>tᵢ</code> 的不同路径）。</li><li><strong>成本 (Cost)</strong>：每个司机在路上花费的时间，即“延迟”。</li></ul><p>这个博弈最关键、最有趣的地方在于成本（延迟）的计算方式。一条路（边 <code>e</code>）的延迟<code>fₑ</code><strong>不是一个固定的数，而是一个函数</strong>。它的值取决于有多少人同时在使用这条路。</p><h4 id="2-博弈的内在冲突"><a href="#2-博弈的内在冲突" class="headerlink" title="2. 博弈的内在冲突"></a>2. 博弈的内在冲突</h4><p>每个司机都想自私地选择一条“最快”的路。但正是因为所有人都这么想，才导致了问题的产生：</p><ul><li>如果有一条近路看起来最快，所有司机可能都会涌向这条路。</li><li>结果，这条路变得极度拥堵，它的延迟函数 <code>fₑ(x)</code> 因为 <code>x</code>（用户数）变得很大而给出一个非常高的延迟值。</li><li>这条所谓的“最快”的路，实际上可能比其他更长但无人问津的路要慢得多。</li></ul><p><strong>每个人的最优选择都依赖于其他所有人的选择</strong>。我的决策影响你的成本，你的决策也影响我的成本。这就是博弈的核心所在。</p><h4 id="3-与“势博弈”的深刻联系（核心洞见）"><a href="#3-与“势博弈”的深刻联系（核心洞见）" class="headerlink" title="3. 与“势博弈”的深刻联系（核心洞见）"></a>3. 与“势博弈”的深刻联系（核心洞见）</h4><p>这个模型最惊人的特性是，<strong>网络拥堵博弈是“精确势博弈”的经典范例</strong>。这是由学者 Rosenthal 在1973年发现的里程碑式成果。</p><p>存在一个全局的势函数 Φ（通常称为罗森塔尔势函数），它能够完美地刻画整个系统的动态。这个势函数的定义方式非常巧妙：</p><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250624211304691.png" alt="image-20250624211304691"></p><p>其中，xe 是当前选择了边 e 的总用户数。这个公式的含义是，把网络中每一条边的“从第1个用户到第 xe 个用户的延迟依次加起来”，然后再把所有边的这个值汇总。</p><p>可以被严格证明：<strong>当任何一个用户 i 单方面改变自己的路径时，他个人延迟的变化量，与这个全局势函数 <code>Φ</code> 的变化量是完全相等的！</strong></p><h4 id="4-重要推论"><a href="#4-重要推论" class="headerlink" title="4. 重要推论"></a>4. 重要推论</h4><p>既然拥堵博弈是精确势博弈，那么我们之前讨论过的所有优美性质就都可以应用在这里：</p><ol><li><strong>均衡必然存在</strong>：任何一个网络拥堵博弈都<strong>至少存在一个纯策略纳什均衡</strong>。在交通模型里，这被称为“瓦德罗普均衡 (Wardrop equilibrium)”。这意味着，总会存在一种稳定的交通分配格局，在这种格局下，没有单个司机可以通过单方面改变路线来缩短自己的通勤时间。</li><li><strong>动态必然收敛</strong>：如果司机们是“短视的”（例如，每天根据昨天的路况尝试寻找更快的路），这个不断调整、学习的过程<strong>必然会收敛到一个稳定的均衡状态</strong>，而不会永久地混乱或振荡下去。</li></ol><h2 id="3-1-零和博弈及纳什均衡计算"><a href="#3-1-零和博弈及纳什均衡计算" class="headerlink" title="3.1 零和博弈及纳什均衡计算"></a>3.1 零和博弈及纳什均衡计算</h2><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250624232921182.png" alt="image-20250624232921182"></p><p><strong>练习：斯塔克尔伯格双寡头模型 (Exercise: The Stackelberg model of Duopoly)</strong></p><ul><li>斯塔克尔伯格双寡头模型 (1934):<ul><li>一个参与者，被称为主导者或<strong>领导者 (leader)</strong>，首先行动，并且该参与者的选择结果在另一位参与者（<strong>跟随者, follower</strong>）做出选择之前就已告知对方。</li><li>例如，通用汽车公司（General Motors）在美国历史上的某些时期，就曾在汽车行业中扮演了如此主导的角色。</li></ul></li></ul><p><em>（来源：Game Theory, Second Edition, 2014. Thomas S. Ferguson）</em></p><p><strong>标题：练习：斯塔克尔伯格双寡头模型</strong></p><ul><li>厂商1首先选择一个生产数量 q1，其单位成本为 c。</li><li>这个数量会被告知厂商2，然后厂商2再选择自己的生产数量 q2，其单位成本同样为 c。</li><li>之后，市场的单位价格 P 由以下公式决定： P(Q)={a−Q0if 0≤Q≤aif Q&gt;a=(a−Q)+ 其中 Q=q1+q2，并且 a 是一个常数。</li><li>参与者们获得如下支付（利润）： u1(q1,q2)=q1P(q1+q2)−cq1=q1(a−q1−q2)+−cq1 u2(q1,q2)=q2P(q1+q2)−cq2=q2(a−q1−q2)+−cq2 其中单位成本 c&lt;a。</li></ul><p>斯塔克尔伯格模型是产业组织理论中一个基石性的模型。它与我们之前讨论的古诺模型（Cournot model）最大的不同在于，它将“同时行动”改为了<strong>“序贯行动” (Sequential Moves)</strong>，从而引入了<strong>先手优势 (First-mover Advantage)</strong> 的概念。</p><h4 id="1-与古诺模型的根本区别"><a href="#1-与古诺模型的根本区别" class="headerlink" title="1. 与古诺模型的根本区别"></a>1. 与古诺模型的根本区别</h4><ul><li><strong>古诺模型</strong>：两家厂商<strong>同时</strong>决定产量，谁也不知道对方会生产多少，是一个静态的、猜对手心思的博弈。</li><li><strong>斯塔克尔伯格模型</strong>：两家厂商有明确的行动顺序。一家是“领导者”（先动），另一家是“跟随者”（后动）。领导者率先公布自己的产量，跟随者在<strong>观察到</strong>领导者的产量后再决定自己的最优产量。这是一个动态博弈。</li></ul><h4 id="2-如何求解？——-逆向归纳法-Backward-Induction"><a href="#2-如何求解？——-逆向归纳法-Backward-Induction" class="headerlink" title="2. 如何求解？—— 逆向归纳法 (Backward Induction)"></a>2. 如何求解？—— 逆向归纳法 (Backward Induction)</h4><p>对于这种有先后顺序的博弈，标准的解法是“逆向归纳”，即从后往前推。</p><p><strong>第一步：求解跟随者（厂商2）的问题</strong></p><p>我们先站在厂商2的角度。此时，厂商1的产量 q1 已经确定，是一个已知的数字。厂商2的目标是选择自己的产量 q2 来最大化自身利润 u2。</p><p>q2max u2(q1,q2)=q2(a−q1−q2)−cq2</p><p>为了求最大值，我们对 q2 求导并令其为0：</p><p>∂q2∂u2=a−q1−2q2−c=0</p><p>解出 q2，我们就得到了厂商2的反应函数 (Reaction Function)：</p><p>q2∗(q1)=2a−c−q1</p><p>这个函数告诉我们：不论领导者厂商1生产多少 (q1)，跟随者厂商2的最优应对策略是什么。</p><p><strong>第二步：求解领导者（厂商1）的问题</strong></p><p>厂商1非常“聪明”，它完全知道厂商2会如何根据它的 q1 来做出反应。因此，厂商1在做决策时，会把厂商2的反应函数直接代入自己的利润公式中，以此来预测自己选择不同 q1 的最终后果。</p><p>厂商1的利润函数变为：</p><p>u1(q1)=q1(a−q1−q2∗(q1))−cq1=q1(a−q1−2a−c−q1)−cq1</p><p>化简括号内的部分：</p><p>u1(q1)=q1(2a−c−q1)−cq1=2aq1−cq1−q12−cq1</p><p>厂商1的目标是选择 q1 来最大化这个新的利润函数。我们对 q1 求导并令其为0：</p><p>∂q1∂u1=2a−c−2q1=0⟹a−c−2q1=0</p><p>解出领导者厂商1的最优产量：</p><p>q1∗=2a−c</p><p><strong>第三步：得出最终均衡结果</strong></p><p>将厂商1的最优产量代入厂商2的反应函数，得到厂商2的产量：</p><p>q2∗=2a−c−q1∗=2a−c−(a−c)/2=2(a−c)/2=4a−c</p><p><strong>斯塔克尔伯格均衡解为：(领导者产量 q1∗=2a−c， 跟随者产量 q2∗=4a−c)</strong></p><h4 id="3-先手优势"><a href="#3-先手优势" class="headerlink" title="3. 先手优势"></a>3. 先手优势</h4><ul><li>在斯塔克尔伯格均衡中，领导者产量(2a−c)是跟随者(4a−c)的两倍。</li><li>我们可以对比一下古诺均衡的结果：在古诺模型中，两家厂商的产量相同，均为 3a−c。</li><li>比较可知：q1Stackelberg(2a−c)&gt;qCournot(3a−c)&gt;q2Stackelberg(4a−c)。</li><li>这意味着，通过率先行动并承诺一个较高的产量，领导者可以有效地“挤压”跟随者的市场空间，迫使跟随者选择一个较低的产量，从而为自己攫取更高的市场份额和利润。这就是<strong>先手优势</strong>的体现。</li></ul><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250624233936853.png" alt="image-20250624233936853"></p><p><strong>零和博弈 (Zero-Sum Games)</strong></p><p>极小化极大定理 (Minimax Theorem) (约翰·冯·诺伊曼, 1928):</p><p>对于每一个具有有限个纯策略的两人零和博弈，都存在一个适用于各方参与者的混合策略和一个价值 V，使得：</p><ul><li>给定参与者2的策略，参与者1可能获得的最佳支付为 V。</li><li>给定参与者1的策略，参与者2可能获得的最佳支付为 -V。</li></ul><p>策略存在的部分是<strong>纳什定理的一个特例</strong>，也是其先驱。</p><p>这基本上是说，参与者1可以保证自己获得<strong>至少 V</strong> 的支付，而参与者2可以保证自己获得<strong>至少 -V</strong> 的支付。如果双方都采取最优策略，这恰好就是他们将得到的结果。</p><p>它之所以被称为“极小化极大 (minimax)”，是因为参与者是通过一种试图<strong>最小化 (minimize) 对手可能获得的最大 (maximum) 支付</strong>的策略来获得这个价值的。我们稍后会再回到这一点。</p><p><strong>定义</strong>：价值 V 被称为该博弈的<strong>价值 (value)</strong>（或回报、支付）。</p><p><strong>例如</strong>：石头剪刀布的价值是0；假设参与者2采取最优策略（以1/3的概率出每一种手势），参与者1能期望获得的最好结果是0的支付。</p><hr><p>这张幻灯片介绍了博弈论的奠基性概念之一——<strong>两人零和博弈</strong>，以及该领域第一个里程碑式的定理——冯·诺伊曼的<strong>极小化极大定理</strong>。</p><h4 id="1-什么是零和博弈？"><a href="#1-什么是零和博弈？" class="headerlink" title="1. 什么是零和博弈？"></a>1. 什么是零和博弈？</h4><p>首先，零和博弈指的是在一个博弈中，所有参与者的收益（或亏损）加起来永远等于零。这意味着，<strong>一方的所得，必然是另一方的所失</strong>。这是一个纯粹冲突、完全竞争的模型，没有任何合作共赢的可能。经典的例子包括：</p><ul><li><strong>棋类游戏</strong>：如象棋、围棋，一方赢就是另一方输。</li><li><strong>石头剪刀布</strong>：一方赢一分，另一方就输一分。</li><li><strong>竞技体育</strong>：大多数只有两方对阵的比赛。</li></ul><h4 id="2-“极小化极大”定理的通俗解释"><a href="#2-“极小化极大”定理的通俗解释" class="headerlink" title="2. “极小化极大”定理的通俗解释"></a>2. “极小化极大”定理的通俗解释</h4><p>这个定理解决了一个核心问题：在这样你死我活的纯冲突中，“理性”的策略是什么？冯·诺伊曼给出了一个天才的答案，其思考逻辑如下：</p><p><strong>从参与者1（P1）的角度（最大化最小值, Maximin）</strong>：</p><ol><li>P1必须假设P2是完全理性的，并且会尽一切努力损害P1的利益。</li><li>P1会思考：“对于我可能采取的每一个策略，P2都会用对我最不利的方式来回应。我先列出每一种策略下，我最坏会得到什么结果（我的<strong>最小</strong>收益）。”</li><li>“然后，在所有这些‘最坏结果’中，我选择那个能让我得到最好结果的策略。”</li><li>这个过程，就是<strong>最大化自己的最小保证收益 (Maximize a minimum payoff)</strong>，简称 <strong>Maximin</strong>。</li></ol><p><strong>从参与者2（P2）的角度（极小化极大, Minimax）</strong>：</p><ol><li>P2同样假设P1会尽全力损害自己。</li><li>P2会思考：“对于P1的每一个策略，我最坏会损失多少（即P1能获得的最大收益）？”</li><li>“然后，我选择一个策略，能让P1可能获得的最大收益变得最小。”</li><li>这个过程，就是<strong>最小化自己的最大可能损失 (Minimize a maximum loss)</strong>，简称 <strong>Minimax</strong>。</li></ol><p><strong>定理的“奇迹”</strong>：冯·诺伊曼证明，对于任何两人零和博弈，P1通过“最大化最小值”策略能保证得到的收益 <code>V</code>，与P2通过“极小化极大”策略能保证让P1得到的收益 <code>V</code>，是<strong>完全同一个数值</strong>！这个 <code>V</code> 就是该博弈的“价值”。</p><p>这意味着，这类纯冲突博弈存在一个绝对理性的、稳定的解。双方的最佳策略将会在这个点上交汇。</p><h4 id="3-混合策略的重要性"><a href="#3-混合策略的重要性" class="headerlink" title="3. 混合策略的重要性"></a>3. 混合策略的重要性</h4><p>这个定理的成立，往往需要<strong>混合策略</strong>的引入，即以一定的概率随机地选择不同的行动。</p><ul><li>以“石头剪刀布”为例，如果你只出“石头”（一个纯策略），对手会立刻发现并一直出“布”来打败你。</li><li>你唯一能保证自己不输的策略，就是完全随机地出招（石头、剪刀、布各1/3概率）。</li><li>当你的对手也采取这种最优的混合策略时，你期望的平均收益就是0。因此，这个博弈的价值 <code>V=0</code>。</li></ul><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250625000231647.png" alt="image-20250625000231647"></p><p><strong>计算纳什均衡：两人零和博弈 (Computing Nash Equilibria: 2-person, Zero-Sum Games)</strong></p><ul><li>这个博弈没有纯策略纳什均衡。</li><li>根据纳什定理，它必然拥有一个<strong>混合策略</strong>纳什均衡。</li><li>我们该如何找到它呢？</li></ul><p><em>(注：这是一个两人零和博弈)</em></p><hr><p>这张幻灯片提出了一个核心问题：对于一个没有纯策略均衡的博弈，我们如何具体计算出它的混合策略纳什均衡？</p><p>下面是详细的计算步骤：</p><h4 id="第一步：验证不存在纯策略纳什均衡"><a href="#第一步：验证不存在纯策略纳什均衡" class="headerlink" title="第一步：验证不存在纯策略纳什均衡"></a>第一步：验证不存在纯策略纳什均衡</h4><p>我们可以通过“划线法”或“最优反应法”来快速验证。</p><ol><li>如果参与者2选择“列1”，参与者1的最优选择是“行2”（因为收益 +3 &gt; -2）。</li><li>如果参与者2选择“列2”，参与者1的最优选择是“行1”（因为收益 +3 &gt; -4）。</li><li>如果参与者1选择“行1”，参与者2的最优选择是“列1”（因为收益 +2 &gt; -3）。</li><li>如果参与者1选择“行2”，参与者2的最优选择是“列2”（因为收益 +4 &gt; -3）。</li></ol><p>我们发现，没有任何一个单元格是双方共同的最优选择，因此该博弈确实没有纯策略纳什均衡。</p><h4 id="第二步：设定混合策略"><a href="#第二步：设定混合策略" class="headerlink" title="第二步：设定混合策略"></a>第二步：设定混合策略</h4><p>在混合策略均衡中，核心思想是<strong>“无差异原则” (Indifference Principle)</strong>：每个参与者选择自己的混合策略（即概率），目的是让<strong>对方</strong>在自己的几个纯策略选择之间感到<strong>无所谓/无差异</strong>（即期望收益完全相等）。</p><ul><li>我们假设<strong>参与者1</strong>以概率 <strong>p</strong> 选择“行1”，以概率 <strong>(1-p)</strong> 选择“行2”。</li><li>我们假设<strong>参与者2</strong>以概率 <strong>q</strong> 选择“列1”，以概率 <strong>(1-q)</strong> 选择“列2”。</li></ul><h4 id="第三步：计算参与者1的混合策略-p"><a href="#第三步：计算参与者1的混合策略-p" class="headerlink" title="第三步：计算参与者1的混合策略 p"></a>第三步：计算参与者1的混合策略 p</h4><p>为了让<strong>参与者2</strong>感到无差异，参与者2选择“列1”的期望收益必须等于他选择“列2”的期望收益。</p><ul><li>参与者2选择“列1”的期望收益 E(列1) = p<em>(+2)+(1−p)</em>(−3)</li><li>参与者2选择“列2”的期望收益 E(列2) = p<em>(−3)+(1−p)</em>(+4)</li></ul><p>令 E(列1) = E(列2):</p><p>可得p=7/12</p><p>所以，参与者1的最优策略是：以 7/12 的概率选择“行1”，以 5/12 的概率选择“行2”。</p><h4 id="第四步：计算参与者2的混合策略-q"><a href="#第四步：计算参与者2的混合策略-q" class="headerlink" title="第四步：计算参与者2的混合策略 q"></a>第四步：计算参与者2的混合策略 q</h4><p>同样，为了让<strong>参与者1</strong>感到无差异，参与者1选择“行1”的期望收益必须等于他选择“行2”的期望收益。</p><ul><li>参与者1选择“行1”的期望收益 E(行1) = q<em>(−2)+(1−q)</em>(+3)</li><li>参与者1选择“行2”的期望收益 E(行2) = q<em>(+3)+(1−q)</em>(−4)</li></ul><p>令 E(行1) = E(行2):</p><p>q=7/12</p><p>所以，参与者2的最优策略是：以 7/12 的概率选择“列1”，以 5/12 的概率选择“列2”。</p><h4 id="第五步：结论与博弈的价值"><a href="#第五步：结论与博弈的价值" class="headerlink" title="第五步：结论与博弈的价值"></a>第五步：结论与博弈的价值</h4><ol><li><p><strong>混合策略纳什均衡</strong>：该博弈的唯一纳什均衡是：参与者1采取混合策略 ( 7/12 ,5/12)，参与者2采取混合策略 (7/12 ,5/12)。</p></li><li><p>博弈的价值 (Value of the Game)：在均衡状态下，参与者1的期望收益是多少？我们可以把 q = 7/12 代入 E(行1) 的公式中计算：</p><p>E(P1) = 1/12</p><p>因此，这个博弈对参与者1的<strong>价值是 +1/12</strong>，对参与者2的价值是 -1/12。这意味着，如果双方都采取最优的随机策略，长期来看，参与者1平均每次能赢1/12。</p></li></ol><p><strong>为什么目的是让对方在自己的几个纯策略选择之间感到无所谓/无差异？</strong></p><p>简单来说，<strong>让对方“无差异”并不是我们的最终目的，而是我们为了实现自身利益最大化，所必须达到的一个“结果”或“条件”。</strong></p><p>这是一种非常高明的策略思想，我们可以从三个层面来理解它：</p><hr><h3 id="1-核心思想：消除对方的确定性最优解"><a href="#1-核心思想：消除对方的确定性最优解" class="headerlink" title="1. 核心思想：消除对方的确定性最优解"></a>1. 核心思想：消除对方的确定性最优解</h3><p>在一个博弈中，如果你采取的策略让你的对手有一个明确的、唯一的“最优选择”，那你就输了一半。因为：</p><ol><li>一个理性的对手，一定会采取那个对他来说最优的选择。</li><li>这样一来，对手的行动就变得<strong>完全可以预测</strong>了。</li><li>一旦对手的行动是可预测的，你就可以反过来调整自己的策略，去专门“克制”他那个可预测的行动，从而让自己获利更多。</li><li>但这就产生了一个矛盾：如果你能调整策略获利更多，说明你最初的策略就不是最优的。</li></ol><p>这个矛盾循环说明，一个稳定的均衡状态，不应该让任何一方有“唯一的、确定的”最优解。而要做到这一点，你唯一的方法就是调整自己的策略组合（即概率 <code>p</code>），直到你的对手觉得“选A或选B，反正期望收益都一样，我无所谓了”。</p><p><strong>当你让对手“无所谓”时，你就消除了他行动的确定性，他才不得不也用一种随机的方式来对抗你。这才是对自己最有利的局面。</strong></p><hr><h3 id="2-反向思考：如果不让对方无差异会怎样？"><a href="#2-反向思考：如果不让对方无差异会怎样？" class="headerlink" title="2. 反向思考：如果不让对方无差异会怎样？"></a>2. 反向思考：如果不让对方无差异会怎样？</h3><p>我们用上一张幻灯片的例子来思考：</p><ul><li>你的策略是：以概率 <code>p</code> 出“行1”，概率 <code>(1-p)</code> 出“行2”。</li><li>假设你选择的 <code>p</code> 没有让对手无差异，而是让对手觉得<strong>“出‘列1’比出‘列2’的期望收益更高”</strong>。</li></ul><p>接下来会发生什么？</p><ol><li><strong>对手的反应</strong>：理性的对手会想：“既然出‘列1’更好，我为什么还要费事去随机出‘列2’呢？” 于是，他会100%地出“列1”。他的策略就不再是混合策略了。</li><li><strong>你的反应</strong>：你看到对手只会出“列1”，那你还会坚持你原来的概率 <code>p</code> 吗？当然不会！你会看支付矩阵的“列1”那一栏，发现你出“行1”收益是-2，出“行2”收益是+3。你显然会100%地出“行2”来应对他。</li></ol><p><strong>结论</strong>：你最初那个让对手“有差异”的策略 <code>p</code>，最终导致了你自己也想改变策略。这就说明，那个初始状态<strong>根本不稳定</strong>，因此<strong>不是纳什均衡</strong>。</p><p>唯一的稳定状态，就是你选择的概率 <code>p</code>，正好让对手觉得“出‘列1’和出‘列2’没差”，他没有理由偏向任何一方，所以他才愿意继续以一定概率 <code>q</code> 来混合他的策略。</p><hr><h3 id="3-一个直观的例子：点球大战"><a href="#3-一个直观的例子：点球大战" class="headerlink" title="3. 一个直观的例子：点球大战"></a>3. 一个直观的例子：点球大战</h3><p>想象一下足球比赛中的点球大战：</p><ul><li><strong>你的角色</strong>：踢球手。你可以选择踢左边或右边。</li><li><strong>对手的角色</strong>：守门员。他可以选择扑左边或右边。</li></ul><p>你的目标是什么？是让守门员<strong>对于“扑左还是扑右”感到无差异</strong>。</p><ul><li><strong>为什么？</strong> 如果你总喜欢踢左边（比如70%的概率），守门员就会发现这个规律，然后更倾向于扑向左边，这样你的进球率就会下降。你的行为变得“可预测”了。</li><li><strong>你的最优策略</strong>：你必须调整自己踢左边和右边的概率（比如各50%），使得守门员觉得“反正我扑左扑右，猜对的概率都一样，期望丢球数也一样，我无所谓了，只能瞎猜”。</li><li><strong>最终结果</strong>：只有当你成功地让守门员陷入“无所谓”的境地时，他才无法预测你的行动，你才能最大化你的进球率。</li></ul><p><strong>总结：</strong></p><p>在混合策略中，让对方“无所谓”，并不是一种善意的妥协，而是一种<strong>最顶级的进攻策略</strong>。它本质上是：</p><ul><li><strong>为了防止自己被预测和被针对。</strong></li><li><strong>为了迫使对方也必须采取不确定的、随机的策略来应对。</strong></li><li><strong>为了最终能在一个充满不确定性的稳定均衡中，保障自己获得最大化的期望收益。</strong></li></ul><p>所以，“让对方无差异”是<strong>你</strong>实现最优策略的<strong>必要条件</strong>，而不是你的目的本身。</p><h2 id="3-2-极大极小博弈"><a href="#3-2-极大极小博弈" class="headerlink" title="3.2 极大极小博弈"></a>3.2 极大极小博弈</h2><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250625213116525.png" alt="image-20250625213116525"></p><p>这张幻灯片用一个政治竞选的例子，构建了一个经典的两人零和博弈。它给出了问题设定，但没有给出解。核心任务就是根据这些信息，计算出这场博弈的均衡解以及博弈的价值。</p><h4 id="第一步：检查是否存在纯策略均衡"><a href="#第一步：检查是否存在纯策略均衡" class="headerlink" title="第一步：检查是否存在纯策略均衡"></a>第一步：检查是否存在纯策略均衡</h4><p>我们首先检查是否存在一个稳定的单元格，使得任何一方都不想单方面改变策略。</p><ol><li>如果列玩家（候选人2）选择“道德”，行玩家（候选人1）会选择“经济”（因为收益3 &gt; -2）。</li><li>如果列玩家选择“减税”，行玩家会选择“社会”（因为收益1 &gt; -1）。</li><li>如果行玩家选择“经济”，列玩家会选择“减税”（因为收益1 &gt; -3）。</li><li>如果行玩家选择“社会”，列玩家会选择“道德”（因为收益2 &gt; -1）。</li></ol><p>我们发现，不存在任何一个稳定的策略组合。例如，在（经济, 道德）这个组合，行玩家很满意，但列玩家会想换到“减税”策略以获得更好的收益。因此，<strong>该博弈没有纯策略纳什均衡</strong>。我们必须寻找混合策略均衡。</p><h4 id="第二步：计算混合策略纳什均衡"><a href="#第二步：计算混合策略纳什均衡" class="headerlink" title="第二步：计算混合策略纳什均衡"></a>第二步：计算混合策略纳什均衡</h4><p>我们将使用<strong>无差异原则</strong>来求解。</p><ul><li>设行玩家（候选人1）以概率 <strong>x</strong> 选择“经济”，以概率 <strong>(1-x)</strong> 选择“社会”。</li><li>设列玩家（候选人2）以概率 <strong>y</strong> 选择“道德”，以概率 <strong>(1-y)</strong> 选择“减税”。</li></ul><p><strong>A. 计算行玩家的策略 x</strong></p><p>行玩家需要选择一个概率 <code>x</code>，使得列玩家对于选择“道德”还是“减税”感到<strong>无差异</strong>（期望收益相等）。</p><ul><li>列玩家选择“道德”的期望收益 = x⋅(−3)+(1−x)⋅(2)</li><li>列玩家选择“减税”的期望收益 = x⋅(1)+(1−x)⋅(−1)</li></ul><p>令二者相等：</p><script type="math/tex; mode=display">-3x + 2 - 2x =  - 1 + x$$$$2 - 5x = 2x - 1$$$$3 = 7x$$x=73所以，**候选人1的最优策略**是：以 **3/7** 的概率主打“经济”议题，以 **4/7** 的概率主打“社会”议题。**B. 计算列玩家的策略 y**同样，列玩家需要选择一个概率 `y`，使得行玩家对于选择“经济”还是“社会”感到**无差异**。- 行玩家选择“经济”的期望收益 = y⋅(3)+(1−y)⋅(−1)- 行玩家选择“社会”的期望收益 = y⋅(−2)+(1−y)⋅(1)令二者相等：$$3y - 1 + y = -2y + 1 - y$$$$4y - 1 = 1 - 3y$$$$7y = 2$$y=72所以，**候选人2的最优策略**是：以 **2/7** 的概率主打“道德”议题，以 **5/7** 的概率主打“减税”议题。#### 第三步：计算博弈的价值博弈的价值（Value）就是指在双方都采取最优策略时，行玩家的期望收益。我们可以将 y = 2/7 代入行玩家的任一期望收益公式：V=3y−1+y=4y−1=4⋅(72)−1=78−1=71#### 结论- **纳什均衡**：该博弈的唯一纳什均衡是，候选人1采取混合策略 (73,74)，候选人2采取混合策略 (72,75)。这意味着两位候选人都应该以特定的概率随机选择自己的竞选焦点，让对手无法预测。- **博弈价值**：该博弈对行玩家（候选人1）的价值是 **+1/7**。在竞选这个议题上，如果双方都采取最理性的策略，**候选人1平均可以期望净赚 1/7 百万（约14万）的选民**。这表明在这个特定的战略矩阵中，候选人1拥有微弱的优势。![image-20250625214139041](C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250625214139041.png)备注：下面这段话有提到“这代表了**列玩家的理性反应**。由于这是一个零和博弈，列玩家的目标是让行玩家的收益尽可能小。”，结合上面一张PPT的最后一个恒等式，可知，由于这是零和博弈，行玩家收益最少等价于列玩家收益最大。------这张幻灯片从一个更形式化、更根本的角度，展示了作为“领导者”（被迫先宣布策略的一方）应该如何思考，并将这个问题转化为了一个标准的数学优化问题。最终，它揭示了一个关于零和博弈的深刻结论。#### 1. Maximin 公式解读：“在最坏的情况里做到最好”幻灯片给出的第一个公式 maxmin(3x1−2x2,−x1+x2) 是“最大化最小值 (Maximin)”思想的完美数学体现。我们来拆解它：- **内部的两个表达式**：  - 3x1−2x2：这是当列玩家选择“道德”时，行玩家的期望收益。  - −x1+x2：这是当列玩家选择“减税”时，行玩家的期望收益。- **min(...) 部分**：这代表了**列玩家的理性反应**。由于这是一个零和博弈，列玩家的目标是让行玩家的收益尽可能小。所以，当行玩家宣布了一个策略 (x1,x2) 后，列玩家会审视这两个可能的收益，并选择那个能让行玩家收益**更小 (min)** 的策略来应对。这代表了行玩家在宣布策略 (x1,x2) 后，所能得到的**最坏结果保证**。- **max(...) 部分**：这代表了**行玩家的决策**。行玩家知道对手会这样针对他。所以，他在选择自己的策略 (x1,x2) 时，目标就是让这个“最坏的结果保证”变得尽可能好。也就是要**最大化 (max)** 那个最小的收益。这整个公式的逻辑就是：“我（行玩家）要选择一个策略 (x1,x2)，来最大化‘在我宣布这个策略后，对手尽最大努力打压我，我能得到的那个保底收益’”。#### 2. 线性规划的转换：从博弈论到标准数学优化Max-min 问题在数学上直接求解不方便，但可以非常巧妙地转化为一个标准的**线性规划 (Linear Programming, LP)** 问题。- 我们引入一个新变量 `z`，让它代表那个“保底收益”。- 我们的目标是 `最大化 z`。- 约束条件是什么？`z` 必须小于等于所有可能的结果。所以：  - z≤3x1−2x2  (保底收益不能超过对手选“道德”时我的收益)  - z≤−x1+x2  (保底收益不能超过对手选“减税”时我的收益)- 再加上概率本身的基本约束 x1+x2=1 和 x1,x2≥0。这样，我们就把一个博弈问题，变成了一个可以用标准算法（如单纯形法）求解的数学问题。#### 3. 最终结论：结果与之前完全相同！幻灯片最后指出，解这个线性规划得到的结果是 x1=3/7，x2=4/7，并且最优的保底收益 z=1/7。这正是我们之前用“无差异原则”为**同时博弈**计算出的**纳什均衡解**和**博弈价值 V**！为什么会这样？这并非巧合，而是冯·诺伊曼极小化极大定理 (Minimax Theorem) 的直接体现。该定理的核心是：Maximin=Minimax- 我们这张幻灯片求解的“领导者-跟随者”问题，正是行玩家的 **Maximin（最大化最小值）** 问题。- 我们之前求解的“同时博弈”问题，得到的是**Minimax（极小化极大值）** 均衡解。这个定理保证了，在任何两人零和博弈中，这两个值是相等的。这意味着，**在两人零和博弈中，不存在先手优势或后手优势**。你提前公布策略，虽然给了对方信息，但你也可以利用这一点来选择一个最稳妥的策略；对方虽然能看到你的策略，但也只能在你设定的框架内做出反应。最终双方的力量会完美抵消，达到同一个均衡结果。## 3.3 纳什均衡的线性规划解法![image-20250625215726625](C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250625215726625.png)这张幻灯片介绍了一个在线性规划乃至整个优化理论中，都极具美感和威力的核心概念——**对偶性**。它揭示了每个优化问题都存在一个“影子问题”或“镜像问题”，而理解这个镜像能为我们提供关于原问题全新的、深刻的洞察。#### 1. 什么是对偶性？一个直观的例子要理解对偶，与其陷入复杂的数学转换，不如看一个经济学例子：- **原问题 (Primal Problem)**：  - 想象你是一家工厂的老板，你要决定生产多少桌子和椅子，来**最大化你的总利润**。  - 你面临一些**约束**：你拥有的木材、劳动力、设备时间都是有限的。  - 这就是一个典型的线性规划问题：最大化一个目标（利润），同时满足一系列约束（资源）。- **对偶问题 (Dual Problem)**：  - 现在，想象一个商人想来收购你所有的资源（木材、劳动力、设备）。他想**最小化他的收购总成本**。  - 但他面临一个**约束**：他为每种资源开出的“影子价格”组合，必须能让你觉得“卖掉资源比我自己生产产品更划算”。例如，生产一张桌子需要消耗的资源，他打包收购的价格，必须不能低于你自己生产这张桌子能获得的利润。  - 这个商人的问题——在一定约束下最小化成本——就是你那个最大化利润问题的“对偶问题”。#### 2. 对偶性的“魔力”：原问题与对偶问题的关系对偶理论中有两个核心定理，它们揭示了原问题和对偶问题之间的奇妙关系：1. **弱对偶定理 (Weak Duality)**：对偶问题的最优解，永远是原问题最优解的一个“界限”。在上面的例子里，就是说：商人收购资源的**最小成本**，必然**大于等于**工厂老板自己生产的**最大利润**。这很直观，因为如果收购成本低于你的利润，你肯定不会卖。2. 强对偶定理 (Strong Duality)：在绝大多数情况下，这个“大于等于”实际上是**“完全等于”**！也就是说：   工厂能实现的最大利润=商人收购资源的最小成本   这是一个非常深刻的结论。它意味着，你资源的内在价值，恰好等于你能用它们创造的最大利润。对偶问题中的变量（资源的“影子价格”），精确地量化了每一种稀缺资源的边际价值。#### 3. 对偶性与“零和博弈”的惊人联系现在，我们可以把这个概念带回我们之前讨论的博弈论了。这正是引入对偶概念的关键所在。- 在前几张幻灯片中，我们把**行玩家**的问题构建成了一个线性规划：**最大化**他的保底收益 `V`。这可以看作是我们的**原问题 (Primal)**。- 那么，**列玩家**的问题是什么？列玩家的目标是**最小化**行玩家能获得的最大收益 `W`。我们同样可以把列玩家的这个问题也构建成一个线性规划。- **最关键的结论是**：**列玩家的“最小化极大值”线性规划问题，恰好就是行玩家“最大化最小值”线性规划问题的对偶问题！**因此，线性规划的“强对偶定理”（最大值 = 最小值），在零和博弈的语境下，就直接变成了冯·诺伊曼的“极小化极大定理”！max(行玩家的保底收益)=min(列玩家的最大损失)Maximin=Minimax**总结**：对偶性不仅是线性规划的强大工具，它还为博弈论的基石——极小化极大定理——提供了最坚实的数学证明。它优美地揭示了，一个参与者的最大化问题和其对手的最小化问题，实际上是同一个数学结构的两个不同侧面，如同一枚硬币的两面，其价值必然相等。![image-20250625220404379](C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250625220404379.png)线性规划对偶性实例。![image-20250625220536283](C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250625220536283.png)弱对偶性和强对偶性## 3.4 线性互补问题![image-20250625222636285](C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250625222636285.png)**标题：计算两人一般和博弈的纳什均衡 (Computing Nash equilibria of two-player, general-sum games)**- 不幸的是，寻找一个两人**一般和博弈 (general-sum game)** 的纳什均衡，**无法**被构建成一个线性规划问题。  - — 两名参与者的利益不再是***完全\*对立的 (completely opposed)**。  - — 然而，我们仍然可以将我们的问题表述为某种优化问题。------这张幻灯片标志着一个重要的转折点。从“零和博弈”进入了更普遍、也更复杂的“一般和博弈”（或称“非零和博弈”）的世界。幻灯片的核心信息是：之前强大而高效的线性规划（LP）工具，在这里失效了。#### 1. 什么是一般和博弈？一般和博弈指的是，在任何一个结果下，所有参与者的收益之和**不一定为零**。这意味着博弈的结果可以是双赢、双输，或者一方赢多、一方输少。参与者的关系不再是“你死我活”的纯粹冲突，而是**冲突与合作并存**。- 经典例子1：囚徒困境  如果两个囚犯都背叛对方，他们可能各判5年（总收益-10）。如果他们都保持沉默，可能各判1年（总收益-2）。这是一个双输的“负和”博弈。- 经典例子2：性别大战 (Battle of the Sexes)  一对情侣都想待在一起（合作），但一人想看歌剧，另一人想看球赛（冲突）。如果他们去同一个地方，双方都能获得高收益（比如（5,2）或（2,5）），总收益为7。如果去不同地方，则两人都很不开心（0,0），总收益为0。这是一个“正和”博弈。#### 2. 为什么线性规划会失效？—— 对偶性的崩塌这是理解这张幻灯片最关键的地方。线性规划之所以能在零和博弈中大显神威，是因为其背后优美的“对偶性”，而这种对偶性源于双方利益的**完全对立**。- **在零和博弈中**：  - 行玩家的目标是：最大化自己的收益 `u₁`。  - 列玩家的目标是：最大化自己的收益 `u₂`。  - 由于 `u₂ = -u₁`，所以列玩家“最大化`u₂`”就**等价于**“最小化`u₁`”。  - 因此，行玩家的“最大化最小值 (Maximin)”问题和列玩家的“最小化极大值 (Minimax)”问题，形成了一对完美的数学**对偶**。它们就像一枚硬币的两面，可以用同一个线性规划框架来解决。- **在一般和博弈中**：  - `u₂` 不再等于 `-u₁`。  - 列玩家的目标——最大化他自己的 `u₂`——与行玩家的收益 `u₁` **没有直接的、负相关的关系**。  - 列玩家不再是处心积虑地要让行玩家的收益最小化，他只关心自己的收益。  - 这样一来，那种“我之所得即你之所失”的完美对偶关系就**彻底崩塌**了。我们无法再构建出一个单一的线性规划问题来同时描述双方的决策并找到那个共同的解。#### 3. 那问题变成了什么？虽然不能用线性规划，但寻找纳什均衡依然是一个数学优化问题，只是变得更复杂了。- 寻找两人一般和博弈的纳什均衡，在数学上等价于求解一个**线性互补问题 (Linear Complementarity Problem, LCP)**。这是一个比线性规划更复杂的数学结构。- 从计算复杂性的角度看，求解两人零和博弈是“容易”的（属于 **P** 问题），而求解两人一般和博弈则被证明是**PPAD-完全 (PPAD-complete)** 问题。这通常被认为是一个“更难”的计算等级，意味着找到解需要更复杂的算法，计算效率也更低。**总结**：从“零和”到“一般和”的转变，是博弈论中一次巨大的复杂性飞跃。它让我们失去了线性规划这个简洁高效的工具，迫使我们进入一个更困难的计算领域。这也反过来凸显了两人零和博弈及其“极小化极大定理”在理论上的简洁与优美。![image-20250625223646101](C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250625223646101.png)**标题：计算两人一般和博弈的纳什均衡**- 我们首先考虑一个**内部的 (inner)** 或**完全混合的 (totally mixed)** 纳什均衡 (X∗,Y∗)，即对于所有的 i 和 j，都有 xi∗>0 以及 yj∗>0（所有的纯策略都以正概率被使用）。- 让 ai 表示行玩家的支付矩阵A的各行，让 bj 表示列玩家的支付矩阵B的各列。- 利用“**在一个纳什均衡策略的支持集(support)中，所有纯策略都产生相同的支付**”这一事实，并且该支付大于或等于支持集之外的策略的支付，我们得到：  - aiy∗=aky∗,i,k=1,2,…,m.  - (x∗)Tbj=(x∗)Tbk,j,k=1,2,…,n.    (注：此处公式经过订正以符合标准表达)    (绿色文字) 假设每个纯策略都以正概率被使用。- 上述构成了一个可以被高效求解的线性方程组。#### **下图内容**- 然而，“每个策略都以正概率被使用”的假设是有限制性的。大多数博弈并不拥有完全混合的纳什均衡；对于它们而言：- 我们计算一个有限两人博弈的所有纳什均衡：  一个混合策略组合 (x∗,y∗) 是一个具有支持集 S1,S2 的纳什均衡，当且仅当：  - u=aiy∗,∀i∈S1 （对于支持集内的策略i，收益都等于均衡收益u）  - u≥aiy∗,∀i∈/S1 （对于支持集外的策略i，收益不高于u）  - v=(x∗)Tbj,∀j∈S2 （对于支持集内的策略j，收益都等于均衡收益v）  - v≥(x∗)Tbj,∀j∈/S2 （对于支持集外的策略j，收益不高于v）  - xi∗=0,∀i∈/S1, yj∗=0,∀j∈/S2  （u, v 是NE中的收益值）- 要让上述过程可行，我们需要找到正确的**支持集 (supports)**。我们需要遍历所有可能的支持集组合。由于存在 2n+2m 种不同的支持集，这会导致算法具有指数级的复杂度。- **备注 (Remark)**：计算有限博弈的纳什均衡的**计算复杂度**，就在于**找到正确的支持集**。------这两张幻灯片讲述了一个关于“求解一般和博弈”的完整故事：从一个理想化的、简单的特例，到一个普遍的、困难的现实。#### 1. 理想情况：完全混合均衡（上图）幻灯片的上半部分描绘了一种“完美”的均衡状态，即**完全混合均衡**。在这种均衡里，每一个参与者都认为对手的所有可选策略都值得提防，因此自己的最优策略是给自己的每一个选项都分配一个**大于零**的概率。- 为什么这种情况简单？  因为它使得“无差异原则”可以应用到所有策略上。为了让对手混合他的所有策略，你必须让你的对手在选择他的任何一个策略时，期望收益都完全相等。- 如何求解？  这就产生了一个完整的线性方程组（m-1个关于行玩家收益的等式，n-1个关于列玩家收益的等式，再加上两个概率和为1的等式）。这是一个标准的、可以用我们熟悉的方法高效求解的数学问题。然而，这种所有策略都被用上的“雨露均沾”式的均衡，在现实中非常罕见。#### 2. 现实情况：寻找“支持集”（下图）幻灯片的下半部分指出了残酷的现实：在绝大多数博弈中，通常都会有一些策略是“劣势策略”或“糟糕的选项”，一个理性的玩家是永远不会使用它们的（即使用概率为0）。- **支持集 (Support)**：在一个混合策略中，那些**真正以正概率被使用的纯策略的集合**，被称为这个混合策略的“支持集”。- **核心困难**：求解的关键困难在于，我们**事先并不知道**最终的均衡解中，到底哪些策略会是“优势策略”（在支持集里），哪些是“劣势策略”（在支持集外）。这就引出了一个计算上的巨大难题，我喜欢称之为**“寻找嫌疑人”的困境**：- **无差异原则**就像一个完美的“审讯工具”，只要你把正确的“嫌疑人”（支持集里的策略）找来，它就能告诉你每个人的详细“作案手法”（混合策略的精确概率）。- **但问题是**，你不知道谁是真正的“嫌疑人”。你面对着所有可能的策略，不知道该把哪些策略纳入“无差异”的审讯中。#### 3. “暴力搜索”算法及其指数级复杂度理论上，我们可以用一种“暴力”的方法来找到所有均衡：1. **猜测**：我们先猜一个可能的支持集组合。例如，“我猜行玩家只会用策略1和3，而列玩家只会用策略2和4”。2. **求解**：基于这个猜测，我们建立一个只包含这些策略的线性方程组（即只让这些策略满足无差异原则）并求解。3. **验证**：检查解出的结果是否是一个合法的纳什均衡。这包括两部分：   - 解出的概率值是否都在0和1之间？   - 对于那些我们**没猜**的“局外”策略，它们的期望收益是否真的**不优于**我们算出的均衡收益？（这是最关键的验证，确保没人想把局外策略拉进局内）。4. **重复**：如果验证失败，就回到第一步，换一种支持集的猜测，然后重复整个过程，直到遍历完**所有可能的支持集组合**。这个方法的致命缺陷在于，支持集的组合数量是**指数级增长**的。如果一个博弈双方各有20个策略，那么可能的支持集组合数量会是一个天文数字。这就是幻灯片所说的“指数级复杂度”。**总结**：寻找一般和博弈的纳什均衡，其计算上的困难**不在于解方程**，而在于**找到应该用哪些策略来列方程**。这个“寻找正确支持集”的组合搜索过程，是该问题计算复杂度（PPAD-complete）的根源，也使其与可以通过线性规划轻松求解的两人零和博弈产生了本质的区别。## 7.1 多智能体强化学习介绍及基本概念![image-20250630205121221](C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250630205121221.png)这张幻灯片指出了从单智能体学习（比如我们熟知的AlphaGo下围棋的早期版本）迈向多智能体学习（比如王者荣耀或星际争霸中的AI）时，所遇到的一个根本性的、质的困难。#### 1. 核心困难：移动的靶心 (The Moving-Target Problem)- **在单智能体学习中**：环境是**静止的**或有固定规律的。一个智能体（比如一个机器人）学习走路，它只需要掌握如何应对地板、墙壁等物理规律即可。这个“游戏规则”是不会变的。- **在多智能体学习中**：情况发生了根本变化。对于任何一个智能体（我们称之为“我”）来说，**其他的智能体也是环境的一部分**。但问题是，这些“其他的智能体”本身也在学习、在进化、在改变他们的策略。  - **一个生动的例子**：你学习如何开车上班最快。如果只有你一个人在学习，而其他人的路线每天都固定不变，这就是一个简单的单智能体问题。但现实是，成千上万的司机（其他智能体）每天也都在尝试新的路线来优化他们自己的通勤时间。你今天发现的“最优路线”，明天可能因为有几百个和你一样的人也发现了它而变得极度拥堵。  - 你试图瞄准的那个“最优策略”的靶心，因为他人的学习而**不断地移动**。这就是多智能体学习的核心困难，学术上称为**“环境的非平稳性” (Non-stationarity)**。#### 2. 为什么简单的Q学习会失效？标准的单智能体强化学习算法（如Q学习）之所以能成功，是因为它们依赖于一个基本假设：**马尔可夫决策过程 (MDP)**，即环境是平稳的。这意味着，在同一个状态（State）下，采取同一个动作（Action），得到的奖励（Reward）和状态转移的概率应该是基本一致的。但在多智能体环境中，这个假设被彻底打破了：- **今天**：在路口（状态S），你选择直行（动作A），因为其他人都选择了右转，所以一路畅通，你获得了很高的奖励。你的Q表格会更新，认为`(S, A)`是个好选择。- **明天**：在同一个路口（状态S），你根据昨天的经验再次选择直行（动作A）。但昨天和你一样选择直行的其他智能体也获得了高奖励，所以今天他们也选择直行。结果造成了交通堵塞，你得到了一个很低的奖励。你的Q表格又必须更新，认为`(S, A)`是个坏选择。你的Q值会这样剧烈地来回震荡，可能永远无法收敛到一个稳定的策略，因为一个动作的“好”与“坏”不再是固定的，而是完全取决于其他智能体当前正在执行的策略。#### 3. 与博弈论的联系这个学习过程中的“不稳定”问题，正是我们在前面博弈论部分看到的“均衡”问题的动态体现。- 多智能体学习的目标，往往就是让这群智能体通过学习和试错，最终能够收敛到整个博弈的**纳什均衡**。- 幻灯片中的螺旋图可以这样理解：中心点是博弈的纳什均衡点。这条螺旋线代表了所有智能体的联合策略随着时间演变的轨迹。如果学习算法设计得好（例如，在**势博弈**中），这条轨迹就会像图中一样稳定地**收敛**到中心。- 如果算法设计不当或者博弈本身就很“恶劣”（比如“石头剪刀布”），那么学习过程可能永远无法收敛，只会在策略空间中不停地“绕圈子”。**总结**：多智能体学习的困难在于，每个智能体的学习过程都会改变其他智能体的学习环境，形成一个复杂且动态的“移动靶心”问题。简单地将单智能体算法直接套用，会因环境的“非平稳性”而失效。因此，现代多智能体学习研究的核心，就是设计出能够在这种动态博弈中稳定地学习、并最终收敛到纳什均衡等合理状态的算法。![image-20250630205734872](C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250630205734872.png)我们可以通过两个关键问题来区分这些模型：1. **有几个决策者（智能体）？** 一个还是多个？2. **有多少种情况（状态）？** 一种还是多种？#### 1. 马尔可夫决策过程 (MDPs): 单人探索世界- **特征**：**一个**智能体，**多个**状态。- **核心问题**：一个独立的决策者，在一个可以变化的环境中，如何学习一系列的动作以最大化其长期回报。- **通俗例子**：一个机器人学习走迷宫。机器人是**唯一的智能体**，迷宫中不同的位置就是**不同的状态**。机器人需要学习在每个位置（状态）下，应该朝哪个方向走（动作），才能最快找到出口（最大化回报）。- **地位**：这是现代**单智能体强化学习 (Single-Agent Reinforcement Learning)** 的数学基石。我们熟知的AlphaGo下棋，本质上也可以看作是在一个极度复杂的MDP中寻找最优策略。#### 2. 重复博弈 (Repeated Games): 多人重复同一场游戏- **特征**：**多个**智能体，**一个**状态。- **核心问题**：多个决策者，反复地玩**同一个**博弈。- **通俗例子**：两家寡头公司，每个月都要决定自己的产品定价。每个月的定价博弈，其本身的收益矩阵都是一样的，所以可以看作是**单一状态**。但因为博弈是**重复**的，今天的决策会影响声誉，从而影响对手明天的决策。这就引入了如“以牙还牙 (Tit-for-Tat)”这样的动态策略。我们之前讨论的各种矩阵博弈（如囚徒困境、零和博弈），如果将它们连续玩很多次，就构成了重复博弈。#### 3. 随机博弈 / 马尔可夫博弈 (Stochastic/Markov Games): 多人探索动态世界- **特征**：**多个**智能体，**多个**状态。- **核心问题**：多个决策者在一个动态变化的环境中共同决策，他们的联合行动会共同决定环境如何进入下一个状态。- **通俗例子**：一场足球比赛。场上有**多个智能体**（双方队员）。球和所有队员在场上的位置，共同构成了一个**状态**。当大家做出动作（跑动、传球、射门）后，场上的局面会变成一个**新的状态**。在每个不同的状态下，球员们面临的“局部博弈”也是不同的。- **地位**：这是最普适、最复杂的模型，它构成了**多智能体强化学习 (Multi-Agent Reinforcement Learning, MARL)** 的理论基础。总结与联系：这张图清晰地告诉我们，随机博弈是“集大成者”，它统一了另外两个模型：- 当随机博弈的智能体数量减少到1个时，它就退化成了**MDP**。- 当随机博弈的状态数量减少到1个时，它就退化成了**重复博弈**。这与我们上一张幻灯片讨论的**“多智能体学习的困难”**完美地衔接了起来。我们所说的“环境的非平稳性”，正是因为我们身处**随机博弈**的框架中：对于“我”这个智能体而言，环境之所以看起来在不停变化，是因为环境的下一个状态不仅取决于我的行动，还取决于其他所有智能体的行动，而他们本身也在学习和改变。![image-20250630214131295](C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250630214131295.png)这张幻灯片提出了一个非常经典的任务：为任意一个 2x2 零和博弈找到通用的解法，即用矩阵中的参数 a,b,c,d 来表达博弈的价值和双方的最优策略。我们将遵循幻灯片给出的两步计划来完成这个推导。#### 步骤一：检验纯策略均衡（鞍点）一个纯策略纳什均衡（在零和博弈中也称为“鞍点”）存在的条件是：**某一个收益值，既是其所在行的最小值，又是其所在列的最大值**。我们可以通过比较行玩家的“最大化最小值（Maximin）”和列玩家的“最小化极大值（Minimax）”来判断：- 行玩家的保底收益（最大最小值）: max(min(a,b),min(d,c))- 列玩家的保底收益（最小极大值）: min(max(a,d),max(b,c))如果这两个值相等，则存在纯策略均衡，该值就是博弈的价值。例如，如果 `a <= b` 并且 `a >= d`，那么 `a` 就是一个鞍点，（行1，列1）就是纯策略纳什均衡。#### 步骤二：求解混合策略均衡（假设不存在鞍点）如果不存在鞍点，那么双方的最优策略必然是混合策略。我们将使用**无差异原则**来求解。- **策略设定**:  - 行玩家以概率 **p** 选择“行1”，以概率 **(1-p)** 选择“行2”。  - 列玩家以概率 **q** 选择“列1”，以概率 **(1-q)** 选择“列2”。- 推导行玩家的策略 p:  行玩家选择 p 的目的是让列玩家在“列1”和“列2”之间感到无差异。  - 列玩家选择“列1”的期望收益（注意，要用列玩家的收益矩阵`-A`）：p(−a)+(1−p)(−d)  - 列玩家选择“列2”的期望收益：p(−b)+(1−p)(−c)    令二者相等：    $$-ap - d(1-p) = -bp - c(1-p)$$$$-ap - d + dp = -bp - c + cp$$$$d - c = p(a - d - b + c) = p((a+c) - (b+d))</script><pre><code>解得行玩家的最优概率 p：p∗=(a+c)−(b+d)d−c</code></pre><ul><li><p>推导列玩家的策略 q:</p><p>列玩家选择 q 的目的是让行玩家在“行1”和“行2”之间感到无差异。</p><ul><li><p>行玩家选择“行1”的期望收益：q(a)+(1−q)(b)</p></li><li><p>行玩家选择“行2”的期望收益：q(d)+(1−q)(c)</p><p>令二者相等：</p><script type="math/tex; mode=display">aq + b(1-q) = dq + c(1-q)$$$$aq + b - bq = dq + c - cq$$$$b - c = q(d - a - c + b) = q((b+d) - (a+c))</script><p>解得列玩家的最优概率 q：</p><p>q∗=(b+d)−(a+c)b−c=(a+c)−(b+d)c−b</p></li></ul></li></ul><h4 id="推导博弈的价值-V"><a href="#推导博弈的价值-V" class="headerlink" title="推导博弈的价值 V"></a>推导博弈的价值 V</h4><p>博弈的价值 V 是在均衡状态下，行玩家的期望收益。我们可以将求得的 q* 代入行玩家的期望收益公式：</p><p>V=aq∗+b(1−q∗)=q∗(a−b)+bV=(a+c)−(b+d)c−b(a−b)+b</p><p>对上式进行通分并化简：</p><p>V=(a+c)−(b+d)(c−b)(a−b)+b((a+c)−(b+d))</p><script type="math/tex; mode=display">V = \frac{ac - bc - ab + b^2 + ab + bc - b^2 - bd}{(a+c) - (b+d)}$$分子中的 -bc, +bc, -ab, +ab, +b², -b² 项都相互抵消了，最终得到一个非常优美的公式：V=(a+c)−(b+d)ac−bd------### 最终通解对于一个不存在纯策略均衡的 2x2 零和博弈矩阵 A=(adbc)，其通解为：1. 行玩家的最优混合策略 (p∗,1−p∗)：   p∗=(a+c)−(b+d)d−c2. 列玩家的最优混合策略 (q∗,1−q∗)：   q∗=(a+c)−(b+d)c−b3. 该博弈对行玩家的价值 V：   V=(a+c)−(b+d)ac−bd### 为什么行玩家是最大化最小值，而不是最小化极大值？问得特别好！这正是理解零和博弈中双方战略思想的精髓所在。简单来说，答案是：**因为他们的根本目标不同。**- **行玩家的目标**：最大化自己的收益。- **列玩家的目标**：最大化自己的收益，这在零和博弈中就等价于**最小化行玩家的收益**。让我们一步一步地、站在**行玩家（Player 1）**的角度来思考他为什么必须是“最大化最小值 (Maximin)”。### 1. 行玩家的思考过程：“我如何为最坏的情况做准备？”行玩家是一个理性的决策者，他想让自己赚得尽可能多。但他知道两件事：- 他的收益不只取决于自己，还取决于对手的选择。- 他的对手（列玩家）的目标和他完全相反。他每多赚一块钱，就意味着对手要多亏一块钱。所以，对手会想尽一切办法让他赚得最少。基于这个“对手会尽力坑我”的假设，行玩家必须采取一种非常谨慎和保守的策略。他的思考逻辑如下：1. 审视自己的第一个选项（比如“行1”）：   “如果我选择‘行1’，我的对手会怎么做？他会看遍‘行1’的所有结果，然后选择那个能让我收益最低的选项。所以，如果我出‘行1’，我能得到的保底收益就是这一行里的最小值。”2. 审视自己的第二个选项（比如“行2”）：   “同理，如果我选择‘行2’，理性的对手也会选择那一列来让我获得‘行2’里的最低收益。这个最小值就是我出‘行2’的保底收益。”3. 做出最终决策：   现在，行玩家手上有一份“保底收益清单”，清单上的每一项都对应着他选择某一行后，在最坏情况下能得到的最低收益。作为一个想最大化自己收益的人，他会看着这份“保底清单”，然后选择那个能提供**最高（Maximum）**保底收益的选项。整个过程串起来就是：他先找出每一行的**最小值 (Minimum)**，然后在这些最小值中，选择一个**最大值 (Maximum)**。这就是**最大化最小值 (Maximin)**。这是一种“在最坏的情况里，为自己争取最好的结果”的策略。------### 2. 为什么“最小化极大值 (Minimax)”是对手的策略？现在我们换位思考，站到**列玩家（Player 2）**的角度。1. **他的目标**：他的目标是最小化自己的损失，也就是最小化行玩家的收益。2. **他的思考过程**：   - **审视他的第一个选项（比如“列1”）**：“如果我出‘列1’，我的对手会怎么做？他会看遍‘列1’的所有结果，然后选择那个能让他自己收益**最高**的选项。所以，如果我出‘列1’，我可能遭受的**最大损失**（也就是行玩家的最大收益）就是这一列里的**最大值**。”   - **审视他的第二个选项（比如“列2”）**：“同理，如果我出‘列2’，我可能遭受的最大损失就是‘列2’里的**最大值**。”   - **做出最终决策**：现在，列玩家手上也有一份“最大损失清单”。作为一个想最小化自己损失的人，他会看着这份清单，然后选择那个能让他的**最大损失变得最小 (Minimum)** 的选项。整个过程串起来就是：他先找出每一列的**最大值 (Maximum)**，然后在这些最大值中，选择一个**最小值 (Minimum)**。这就是**最小化极大值 (Minimax)**。### 总结|          | **行玩家 (Player 1)**            | **列玩家 (Player 2)**                    || -------- | -------------------------------- | ---------------------------------------- || **目标** | 最大化自己的收益                 | 最小化自己的损失（即最小化行玩家的收益） || **思想** | 在最坏的情况里为自己争取最好结果 | 让对手在最好的情况下也占不到太大便宜     || **策略** | **最大化最小值 (Maximin)**       | **最小化极大值 (Minimax)**               |所以，行玩家之所以是“最大化最小值”，是因为他的出发点是**为自己求利**，同时假设对手会让他**利无可利**；而“最小化极大值”则是从对手的视角出发，目标是**让行玩家的利益最小化**。冯·诺依曼的惊人发现在于，在两人零和博弈中，这两种看似不同的思考路径，最终会指向同一个均衡解。![image-20250630215303870](C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250630215303870.png)这张幻灯片介绍了“序贯决策”框架中那个最普适、最强大的模型——**随机博弈（或称马尔可夫博弈）**。它完美地将我们之前讨论过的“矩阵博弈”和“马尔可夫决策过程(MDP)”融合在了一起，是理解现代**多智能体强化学习 (MARL)** 的理论基石。#### 1. 集大成者：融合了博弈论与强化学习我们可以这样理解随机博弈的构成：- 它借鉴了**矩阵博弈 (Matrix Games)** 的核心思想：在任何一个时刻，都有**多个智能体**在进行策略互动。- 它又借鉴了**马尔可夫决策过程 (MDPs)** 的核心思想：整个系统存在**多个状态**，环境会根据参与者的行动从一个状态转移到另一个状态。**随机博弈 = 多智能体的MDP = 随状态变化的重复博弈**#### 2. 图示解读：一场动态演变的博弈这张图非常直观地展示了随机博弈是如何运作的。我们可以把它想象成一场动态的冒险游戏：1. **身处状态**：假设你和你的对手（参与者1和2）当前身处“**状态1 (State 1)**”。2. **进行博弈**：在这个状态下，你们必须玩“状态1”对应的那个2x2矩阵博弈。比如，你（P1）选择了“下”，对手（P2）选择了“右”。3. **获得即时回报**：根据矩阵，这个`(下, 右)`的联合行动会给你们带来 `(1, 1)` 的即时回报。4. **世界发生改变（状态转移）**：这是最关键的一步。你们的联合行动 `(下, 右)` 触发了状态转移。紫色的箭头告诉我们，接下来会发生什么：   - 有 **40%** 的概率，你们会进入“**状态2**”。   - 有 **60%** 的概率，你们会进入“**状态3**”。5. **进入新博弈**：假设你们进入了“状态2”。现在，你们面对的是一个**全新的2x2矩阵博弈**，有着完全不同的收益规则。你们需要在这个新规则下再次决策，然后获得新的回报，并再次触发新的状态转移。这个过程会一直持续下去。#### 3. 参与者的目标：深谋远虑在一个随机博弈中，一个理性的参与者不会只盯着当前这一轮的得失。他的决策必须是**深谋远虑**的。- 例如，在“状态1”中，`(上, 左)`这个选择能立刻带来`(2, 2)`的高回报。但如果这个选择有90%的概率会让你转移到一个对你极其不利的“惩罚状态”，那你可能就不会选它。- 反之，你可能会选择一个即时回报较低的行动，如果它有很大概率把你带到一个未来回报极高的“天堂状态”。- 这就是**折扣回报 (discounted rewards)** 的作用。玩家的目标是最大化未来所有回报的“总现值”，即找到一个在**所有状态下**都最优的策略（Policy），而不仅仅是当前状态。**总结**：随机博弈为我们描绘了一幅最接近真实世界复杂性的图景——多个决策者在不断变化的环境中持续互动。我们之前讨论的**多智能体学习（MAL）的困难**，例如“环境的非平稳性”，正是源于这个框架。对于任何一个智能体来说，环境之所以“不稳定”，就是因为状态的转移和回报不仅取决于自己的行动，还取决于其他所有同样在学习和适应的智能体的行动。![image-20250630220528288](C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250630220528288.png)**标题：随机博弈 vs. MDP (Stochastic Games vs. MDP)**- 在一个随机博弈中，如果除了一个参与者之外的所有其他参与者都采取**固定的 (fixed)** 策略，那么对于剩下的那个智能体来说，这个问题就**退化 (reverts back)** 回了一个MDP。  - — 这是因为，固定其他智能体的策略（即使这些策略是随机的），会使得状态转移变得**马尔可夫化 (Markovian)**，即只取决于剩下的那个参与者的行动。------这张幻灯片通过一个“思想实验”，精准地指出了**多智能体学习（MARL）与单智能体学习（RL）的根本区别到底在哪里**。它告诉我们，多智能体问题的核心困难，并不在于“有多个会动的个体”，而在于“有多个会**学习和适应**的个体”。#### 1. 问题复杂性的根源：变化的“游戏规则”我们之前讨论，多智能体学习之所以困难，是因为环境的“非平稳性”（Non-stationarity）。对于任何一个智能体“我”来说，其他的智能体都是环境的一部分。当其他智能体也在学习、也在改变他们的策略时，就相当于“我”所面对的游戏规则本身在不断变化，这让学习变得极为困难。#### 2. “固定策略”意味着什么？—— 从“对手”到“自然规律”这张幻灯片提出的“固定其他所有人的策略”这个条件，是问题的关键。这意味着什么呢？让我们用一个生动的例子来说明：- 情景A：随机博弈 (Stochastic Game)  你是一个新手出租车司机（剩下的那个智能体），在一个大城市里学习如何最快地接送客人。城里还有成千上万的老司机（其他智能体），他们经验丰富，每天都在根据实时路况、新闻、个人习惯等调整自己的路线。这是一个极度复杂的多智能体学习问题，因为你的“环境”（即其他司机的行为）每天都在变。- 情景B：退化为MDP  现在，假设奇迹发生，城里所有其他司机都被换成了简单的机器人。这些机器人的行为遵循一套永不改变的固定程序。例如：“在周一上午8点的A路口，这群机器人有70%会右转，30%会直行”。这个概率是固定的，机器人不会再学习或改变了。在这个时刻，对于你（唯一的人类司机）来说，发生了什么？其他司机不再是具有主观能动性的“对手”了，他们变成了城市交通中一个虽然是随机的、但却是稳定的、可预测的自然规律。#### 3. “马尔可夫化”：游戏规则被重新稳定下来一旦其他人的策略被固定，整个系统对于“我”来说，就重新满足了**马尔可夫性质**。- 当“我”在某个路口（状态s），选择直行（动作a），下一分钟会到达哪里、会花多长时间（下一个状态s'），其概率 **p(s′∣s,a)** 现在只取决于“我”的动作`a`和那群机器人固定的行为模式。- 这个转移概率**不再随时间变化**了，因为机器人的“想法”不会变。- 于是，这个复杂的、不可预测的多智能体博弈，就**退化**成了一个经典的、可解的**单智能体马尔可夫决策过程（MDP）**。总结：这张幻灯片通过“固定他人策略”这一巧妙的设定，帮助我们隔离并识别了多智能体问题的“困难之源”。困难不在于环境中存在多个行动者，而在于这些行动者策略的动态演化。这个洞见是许多高级多智能体学习算法的基础，例如，有些算法就是通过“轮流学习”（一个学习，其他暂时固定）或者对其他智能体的策略进行建模和预测，来试图克服这种“非平稳性”带来的挑战。![image-20250630222547667](C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250630222547667.png)这张幻灯片将原本简单的单次博弈，升级成了一个更复杂、也更贴近现实的**双状态随机博弈 (Two-state Stochastic Game)**。这里的“纳什均衡”不再是单个的行动组合，而是一个**策略组合 (a profile of policies)**，即每个厂商在**每种状态下**应该如何行动的完整计划。这个问题的解取决于一个幻灯片上未给出但至关重要的参数——**折扣因子 γ (discount factor)**，它代表了厂商对未来收益的重视程度。#### 1. 分解两个“子博弈”我们首先分析在每个状态下，只考虑当前一轮收益的“短视”均衡是什么。- 在状态1（无税收）：  正如我们上一题分析的，双方都有一个占优策略：“污染”。因此，该状态下的短视纳什均衡是 (污染, 污染)。但这个选择会带来一个后果：根据转移概率 (0,1)，游戏将100%转移到状态2（有税收）。- 在状态2（有税收）：  我们分析这个新的利润矩阵：  - 对厂商1：如果厂商2选择“清洁”，厂商1会选“污染”(4>1)；如果厂商2选“污染”，厂商1还是会选“污染”(3>0)。**“污染”是厂商1的占优策略**。  - 对厂商2：如果厂商1选择“清洁”，厂商2会选“污染”(5>2)；如果厂商1选“污染”，厂商2还是会选“污染”(4>1)。**“污染”也是厂商2的占优策略**。  - 因此，该状态下的短视纳什均衡也是 **(污染, 污染)**。这个选择的后果是，游戏将**100%留在状态2**，继续被征税。#### 2. 长期战略的困境：短视 vs. 远见分析完子博弈后，真正的战略困境浮现了。我们以厂商1在**状态1**的决策为例：- **短视的选择（选择“污染”）**：可以立刻获得很高的收益（如果对方也污染，能得6）。但代价是，从下一轮开始，将永远陷入低收益的“状态2”。- **远见的选择（选择“清洁”）**：会牺牲掉一部分即时收益（如果对方也清洁，只能得4）。但好处是，游戏将**100%留在高收益的“状态1”**，未来每一轮都可以继续获得高收益。厂商会如何选择，完全取决于他们有多“远视”，即折扣因子 `γ` 有多大。#### 3. 可能存在的纳什均衡这个随机博弈可能存在多个纳什均衡。**均衡A：“悲观”的污染均衡**- **策略**：无论在哪种状态，双方都选择“污染”。- **分析**：如果对方的策略是“永远污染”，那么你最好的应对也是“永远污染”。因为如果你单方面选择“清洁”，在状态1你会获得更低的即时收益(3 vs 6)然后还是会进入状态2；在状态2你单方面“清洁”的收益(0 vs 3)也更低。因此，没有任何一方有单方面改变策略的动机。- **结论**：**（策略1=污染, 策略2=污染）是一个纳什均衡**。在这个均衡下，厂商们第一轮在状态1获得(6,7)的收益，然后永久地陷入状态2，每轮获得(3,4)的收益。这是一个低效的、“双输”的均衡。**均衡B：“合作”的清洁均衡**- **策略**：双方约定，只要在状态1，就都选择“清洁”。- **分析**：要让这个“君子协定”成为一个稳定的纳什均衡，就必须保证“背叛”是无利可图的。  - **遵守协定**的收益流（以厂商1为例）：4+4γ+4γ2+⋯=1−γ4  - **单方面背叛**的收益流：在状态1选择“污染”获得一次性的高收益7，但之后游戏进入状态2，双方陷入“永远污染”的均衡，后续每轮收益为3。其收益流为: 7+3γ+3γ2+⋯=7+1−γ3γ  - 要让大家遵守协定，必须满足“遵守的收益 ≥ 背叛的收益”：    1−γ4≥7+1−γ3γ    4≥7(1−γ)+3γ⟹4≥7−4γ⟹4γ≥3⟹γ≥43- **结论**：**如果厂商们对未来的重视程度足够高（即折扣因子 γ ≥ 3/4），那么双方在状态1都选择“清洁”也可以成为一个纳什均衡**。因为对未来的长期高收益的渴望，足以抑制住当前“背叛”以获取短期利益的诱惑。**总结**：这个引入了税收和状态转移的随机博弈模型，比单次博弈要复杂和深刻得多。它的均衡不再是唯一的，而是可能存在多个——一个“坏”的均衡和一个“好”的均衡。系统最终会落入哪个均衡，取决于参与者对未来的耐心和期望（由`γ`体现）。这也为政府政策的设计提供了启示：一个好的制度，应该让“合作”的门槛（即所需的`γ`值）尽可能低，让参与者更容易达成对社会有利的结果。![image-20250630223314800](C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250630223314800.png)**标题：例子：“大冒险”游戏 (Example: the game of Dare)**- 参与者1，**领导者 (the leader)**，和参与者2，**挑战者 (the challenger)**，同时选择“**放弃 (pass)**”或“**挑战 (dare)**”。  - — 如果双方都选择“放弃”，支付为零（且游戏结束）。  - — 如果参与者1“放弃”而参与者2“挑战”，参与者1赢得1。  - — 如果参与者1“挑战”而参与者2“放弃”，参与者1赢得3。  - — 如果双方都选择“挑战”，这个基础游戏将**角色互换**后重新进行。    - (领导者变成挑战者，反之亦然)。  - — 如果参与者们永远地持续“挑战”下去，则支付为零。- 博弈矩阵 G:  $$G = \bordermatrix{ & \text{放弃} & \text{挑战} \cr \text{放弃} & 0 & 1 \cr \text{挑战} & 3 & -G^T }</script><p>  其中 -Gᵀ 代表角色互换后的游戏。（它的矩阵是G矩阵的转置的负数。）-Gᵀ的价值是G的价值的负数。</p><hr><p>这张幻灯片描述了一个非常有趣的<strong>递归博弈 (recursive game)</strong>，它是一种特殊的<strong>随机博弈 (stochastic game)</strong>。这个博弈只有两个状态：“P1是领导者”和“P2是领导者”。当出现 (挑战, 挑战) 的结果时，游戏就在这两个状态之间切换。</p><h4 id="1-问题的核心：递归的价值"><a href="#1-问题的核心：递归的价值" class="headerlink" title="1. 问题的核心：递归的价值"></a>1. 问题的核心：递归的价值</h4><p>这个问题的精髓在于右下角的那个支付 <code>-Gᵀ</code>。</p><ul><li><p>让我们设这个博弈对于<strong>当前的领导者</strong>来说，其<strong>价值 (Value)</strong> 为 <strong>V</strong>。</p></li><li><p>那么，领导者的支付矩阵就可以写成：</p><p>G=(031Value(subgame))</p></li><li><p>当双方都选择“挑战”时，游戏进入子博弈。在这个子博弈中，原先的挑战者（P2）变成了新的领导者。由于游戏的对称性，这个子博弈对于<strong>新的领导者（P2）</strong>来说，价值也应该是 <strong>V</strong>。</p></li><li><p>既然对于新的领导者（P2）价值是 <code>V</code>，那么对于<strong>新的挑战者（也就是原来的P1）</strong>来说，价值就是 <strong>-V</strong>（因为是零和博弈）。</p></li><li><p>因此，原领导者（P1）的支付矩阵可以写成一个包含其自身价值 V 的形式：</p><p>G=(031−V)</p></li></ul><h4 id="2-求解博弈价值-V"><a href="#2-求解博弈价值-V" class="headerlink" title="2. 求解博弈价值 V"></a>2. 求解博弈价值 V</h4><p>现在，问题转化为了：求解这个特殊矩阵的价值 V，并且这个价值 V 必须等于它自身。</p><script type="math/tex; mode=display">V = \text{value} \begin{pmatrix} 0 & 1 \ 3 & -V \end{pmatrix}$$我们可以使用之前推导出的 2x2 零和博弈的通用价值公式：$$V = \frac{ac - bd}{(a+c) - (b+d)}$$其中，a=0, b=1, d=3, c=-V。代入公式：$$V = \frac{(0)(-V) - (1)(3)}{(0)+(-V) - (1)-(3)} = \frac{-3}{-V-4}$$现在我们得到了一个关于 V 的方程，求解它：$$V(-V - 4) = -3$$$$-V^2 - 4V = -3$$$$V^2 + 4V - 3 = 0</script><p>这是一个一元二次方程。使用求根公式 </p><p>我们得到了两个可能的解：V1=7−2≈0.646 和 V2=−7−2≈−4.646。</p><h4 id="3-选择正确的解"><a href="#3-选择正确的解" class="headerlink" title="3. 选择正确的解"></a>3. 选择正确的解</h4><p>哪个才是这个博弈真正的价值呢？</p><p>我们看领导者的支付矩阵，他有一个“放弃”的选项。如果他选择“放弃”，最坏的结果是对手选择“挑战”，此时他的收益是1。这意味着，领导者至少可以为自己保证一个非负的收益。因此，一个负数（比如-4.646）不可能是这个博弈的理性价值。</p><p>所以，这个博弈对于领导者的价值是：根号7减去2</p><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250630224225904.png" alt="image-20250630224225904"></p><p>求解博弈G1和G2的价值：</p><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250630224137356.png" alt="image-20250630224137356"></p><h2 id="7-2-值迭代与策略迭代"><a href="#7-2-值迭代与策略迭代" class="headerlink" title="7.2 值迭代与策略迭代"></a>7.2 值迭代与策略迭代</h2><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250701210516613.png" alt="image-20250701210516613"></p><p>1、学习随机博弈中状态值函数贝尔曼方程推导</p><p>2、与单智能体MDP的关键区别</p><p>这个公式虽然形式上与单智能体MDP的贝尔曼方程很像，但幻灯片的最后一点指出了两个根本性的区别，这也是多智能体问题复杂性的根源：</p><ol><li><strong>价值是个人化的 (for each agent)</strong>：在MDP中，只有一个价值函数 <code>V(s)</code>。但在随机博弈中，<strong>每个参与者 <code>i</code> 都有自己的一套价值函数 Vi(s)</strong>。同一个状态 <code>s</code>，对我来说可能是天堂（Vi很高），对你来说可能却是地狱（Vj很低）。这体现了参与者之间合作与冲突并存的关系。</li><li><strong>价值依赖于联合策略 (on the joint policy)</strong>：这是最致命的区别。在MDP中，价值函数 Vπ(s) 只取决于我自己的策略 <code>π</code>。但在这里，Viπ(s) 的值不仅取决于我的策略 πi，还取决于<strong>其他所有人的策略</strong> π−i，因为是<strong>联合行动</strong>决定了回报和状态转移。<ul><li>这就导致了我们之前讨论的<strong>“非平稳性”</strong>或<strong>“移动靶心”</strong>问题。如果我的对手改变了他的策略，那么即使我的策略和当前状态都没变，我整个的价值函数 Vi(s) 也会跟着改变。我原以为很有价值的状态，可能因为对手策略的改变而突然变得一文不值。</li></ul></li></ol><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250701211212340.png" alt="image-20250701211212340"></p><p>这张幻灯片在重申了状态价值的定义之后，提出了一个关于它的非常重要的数学性质：<strong>有界性 (Boundedness)</strong>。这个性质是随机博弈能够被分析和求解的理论基础之一。</p><h4 id="1-核心思想：无限过程，有限价值"><a href="#1-核心思想：无限过程，有限价值" class="headerlink" title="1. 核心思想：无限过程，有限价值"></a>1. 核心思想：无限过程，有限价值</h4><p>这条结论的核心思想是：尽管一个随机博弈的过程可能永远持续下去，但从任何一个状态开始，任何一个参与者能够获得的<strong>总的“折扣”价值都不是无限的，而是一个有限的、有上限的数值</strong>。</p><p>幻灯片给出了这个上限的计算公式：1−γM。</p><ul><li><strong>M</strong>: 代表在整个游戏所有可能的情况下，任何参与者在<strong>单一一轮</strong>中所能获得的<strong>最大绝对收益</strong>。可以理解为这个游戏里“单次操作的最大奖励或最大惩罚（的绝对值）”。</li><li><strong>γ (gamma)</strong>: 是我们熟悉的折扣因子（0 &lt; γ &lt; 1），代表了我们对未来收益的耐心程度。</li></ul><h4 id="2-这个上限公式是怎么来的？（几何级数）"><a href="#2-这个上限公式是怎么来的？（几何级数）" class="headerlink" title="2. 这个上限公式是怎么来的？（几何级数）"></a>2. 这个上限公式是怎么来的？（几何级数）</h4><p>这个公式的推导非常直观，它基于我们熟知的等比数列（几何级数）求和。</p><ol><li><p>根据定义，状态价值是所有未来折扣回报的总和：</p><p>Viπ(s)=Eπ[r0+γr1+γ2r2+γ3r3+…]</p></li><li><p>在任何一步 <code>k</code>，我们能获得的即时回报 rk 的绝对值，都不可能超过定义好的最大单轮回报 <code>M</code>。即 ∣rk∣≤M。</p></li><li><p>因此，总价值 Viπ(s) 必然小于或等于一种最极端、最理想的情况：假设我们在未来的每一步，都能幸运地获得最大的正回报 M。</p><p>Viπ(s)≤M+γM+γ2M+γ3M+…</p></li><li><p>将 M 提取出来：</p><p>Viπ(s)≤M(1+γ+γ2+γ3+…)</p></li><li><p>括号里的部分是一个公比为 <code>γ</code> 的无穷等比数列。因为 <code>γ &lt; 1</code>，这个级数是收敛的，其和为 1−γ1。</p></li><li><p>因此，我们得到了最终的边界：</p><p>Viπ(s)≤1−γM</p></li></ol><h4 id="3-这个性质为什么重要？"><a href="#3-这个性质为什么重要？" class="headerlink" title="3. 这个性质为什么重要？"></a>3. 这个性质为什么重要？</h4><ol><li><strong>保证问题“有解”</strong>：这个有界性保证了我们要求解的状态价值函数是一个“行为良好”的函数，它的值不会发散到无穷大。这是所有后续分析和算法能够成立的数学前提。如果没有这个保证，我们可能都无法定义“最优策略”，因为所有策略的总回报都是无穷大，无法比较。</li><li><strong>为算法提供基础</strong>：在很多求解随机博弈的算法（例如价值迭代）中，这个边界可以用于初始化价值函数，或者作为算法收敛性的一个判断依据。它确保了算法的计算过程会在一个有限的数值空间内进行，最终能够稳定下来。</li></ol><p><strong>总结</strong>：这张幻灯片的核心是告诉我们，尽管随机博弈的博弈过程可能是无限的，但其价值是有限的。这个有界性不仅为问题的“可解性”提供了理论保障，也为实际的计算算法奠定了基础。</p><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250701215722881.png" alt="image-20250701215722881"></p><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250701215827727.png" alt="image-20250701215827727"></p><h4 id="结论与洞察"><a href="#结论与洞察" class="headerlink" title="结论与洞察"></a>结论与洞察</h4><p>这个例子深刻地揭示了<strong>短期利益与长期战略</strong>之间的权衡。</p><ul><li>从短期看，第1列对列玩家更有利（即时损失更小）。</li><li>但从长期看，第1列有更高的概率让游戏继续下去，这意味着他未来要持续地向行玩家支付价值为<code>v</code>的收益。而第2列能更快地结束游戏，从而“止损”。</li><li>最终的均衡策略显示，<strong>长期战略（避免未来损失）的重要性压倒了短期利益</strong>。因此，列玩家的最优策略是<strong>更频繁地选择那个能更快结束游戏的第2列</strong>，尽管它眼前的损失看起来更大。</li></ul><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250702003904470.png" alt="image-20250702003904470"></p><p><strong>标题：价值迭代 (Value Iteration)</strong></p><ul><li>夏普利证明了 vn(s) 会收敛到从s开始的随机博弈的<strong>真实价值 v(s)</strong>。<ul><li>— 首先，收敛是以<strong>指数速率 (exponential rate)</strong> 进行的：最大误差至少以 γn 的速度下降。</li><li>— 其次，在第 n+1 阶段的最大误差，至多是“<strong>从n到n+1阶段的最大变化量</strong>”乘以 γ/(1−γ)。</li></ul></li></ul><hr><p>这张幻灯片深入探讨了“价值迭代”算法的<strong>性能保证</strong>。它告诉我们，夏普利不仅证明了价值迭代这个方法是<strong>可行</strong>的（即最终能找到正确答案），更证明了它是<strong>高效</strong>和<strong>可靠</strong>的。这使得价值迭代从一个理论上的概念，变成了一个可以在实践中应用的强大工具。</p><h4 id="1-指数速率收敛：为什么说它“高效”？"><a href="#1-指数速率收敛：为什么说它“高效”？" class="headerlink" title="1. 指数速率收敛：为什么说它“高效”？"></a>1. 指数速率收敛：为什么说它“高效”？</h4><p>“指数速率收敛”听起来很抽象，但它的意思是，算法的精确度在每一步迭代后都会得到一个“质的飞跃”。</p><ul><li><strong>一个比喻</strong>：想象你在寻宝，宝藏在1公里外。有一个向导，你每走一步，他都会告诉你：“你现在离宝藏的距离，是你上一步距离的90%”。<ul><li>你的误差（与宝藏的距离）在每一步都会乘以一个固定的因子（0.9）。</li><li>第一次迭代后，误差是 1×0.9。</li><li>第二次迭代后，误差是 1×0.92。</li><li>第n次迭代后，误差是 1×0.9n。</li><li>误差以 0.9n 的速度急剧缩小，这就是指数级的衰减。</li></ul></li><li><strong>在价值迭代中</strong>：折扣因子 <code>γ</code> (一个小于1的数) 就扮演了这个“0.9”的角色。每迭代一次，我们估算的价值函数 vn(s) 与真实价值 v(s) 之间的最大误差，都会大致缩小一个 <code>γ</code> 倍。因为 <code>γ</code> 小于1，所以经过多次迭代后，误差会变得非常小，算法能很快地逼近真实解。这背后的数学原理是，夏普利证明了价值迭代的更新算子是一个<strong>压缩映射 (Contraction Mapping)</strong>。</li></ul><h4 id="2-误差边界：为什么说它“可靠”？"><a href="#2-误差边界：为什么说它“可靠”？" class="headerlink" title="2. 误差边界：为什么说它“可靠”？"></a>2. 误差边界：为什么说它“可靠”？</h4><p>第二点结论解决了一个非常实际的问题：“我怎么知道什么时候可以停止算法，并且保证我的答案足够精确了？”</p><ul><li><p><strong>面临的困境</strong>：我们希望我们的误差，即 <code>|我们的估算值 vₙ - 真实值 v*|</code>，小于一个我们能接受的阈值（比如0.001）。但问题是，我们并不知道那个神秘的“真实值 <code>v*</code>”到底是多少，所以无法直接计算这个误差。</p></li><li><p>夏普利提供的解决方案：他给出了一个可计算的误差上限。公式告诉我们：</p><p>真实的未知误差≤可计算的最大单步变化量×1−γγ</p><p>这里的“可计算的最大单-步变化量”指的是 ∣vn+1(s)−vn(s)∣max，也就是在你最近一次迭代中，所有状态的价值估算值变化最大的那一个。这个值我们在计算过程中是完全知道的。</p></li><li><p><strong>实际应用（停止条件）</strong>：</p><ol><li>我们设定一个目标精度 <code>ε</code>，比如我希望我的最终答案与真实值的误差不超过0.001。</li><li>根据公式，只要我们能让 <code>(可计算的最大单步变化量) * γ/(1-γ)</code> 这个上限小于 <code>ε</code>，那么真实的误差就一定小于 <code>ε</code>。</li><li>因此，我们的算法停止条件就变成了：<strong>持续迭代，直到我们观察到的最大单步变化量小于 ϵ⋅γ1−γ</strong>。</li><li>一旦满足这个条件，我们就可以放心地停止迭代，并宣布当前的估算值 vn+1 就是一个足够精确的解。</li></ol></li></ul><p><strong>总结</strong>：这张幻灯片从理论上为价值迭代算法的有效性提供了强有力的背书。<strong>指数速率收敛</strong>保证了它的计算速度，而<strong>实用的误差边界</strong>则为它在现实中的应用提供了可靠的停止准则，使其成为求解两人零和随机博弈的核心算法之一。</p><p><img src="C:\Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20250702005255997.png" alt="image-20250702005255997"></p><p><strong>为什么最小停止概率是0.5？</strong></p><h3 id="1-“最小停止概率是0-5”的来源分析"><a href="#1-“最小停止概率是0-5”的来源分析" class="headerlink" title="1. “最小停止概率是0.5”的来源分析"></a>1. “最小停止概率是0.5”的来源分析</h3><p>这个结论来自于对 G₁ 和 G₂ 两个矩阵中所有单元格的<strong>“持续概率”</strong>的分析。</p><p>在一个随机博弈的支付单元格中，形如 <code>“即时回报 + 概率 × 未来价值”</code> 的结构，那个<strong>概率</strong>就代表了游戏<strong>继续下去的可能性</strong>。而<strong>“停止概率”</strong>则等于 <strong>1 - 继续概率</strong>。</p><p>让我们来逐一检查两个矩阵中所有结果的“停止概率”：</p><p>对于博弈 G₁:</p><p>G(1)=(4+0.3G(1)1+0.4G(2)0+0.4G(2)3+0.5G(1))</p><ul><li>(行1, 列1): 继续概率是 0.3。 <strong>停止概率 = 1 - 0.3 = 0.7</strong></li><li>(行1, 列2): 继续概率是 0.4。 <strong>停止概率 = 1 - 0.4 = 0.6</strong></li><li>(行2, 列1): 继续概率是 0.4。 <strong>停止概率 = 1 - 0.4 = 0.6</strong></li><li>(行2, 列2): 继续概率是 0.5。 <strong>停止概率 = 1 - 0.5 = 0.5</strong></li></ul><p>对于博弈 G₂:</p><p>G(2)=(0+0.5G(1)−4−51+0.5G(2))</p><ul><li>(行1, 列1): 继续概率是 0.5。 <strong>停止概率 = 1 - 0.5 = 0.5</strong></li><li>(行1, 列2): 支付是-5（没有未来价值项）。继续概率是 0。<strong>停止概率 = 1 - 0 = 1</strong></li><li>(行2, 列1): 支付是-4。继续概率是 0。<strong>停止概率 = 1 - 0 = 1</strong></li><li>(行2, 列2): 继续概率是 0.5。<strong>停止概率 = 1 - 0.5 = 0.5</strong></li></ul><p>现在，我们把所有计算出的停止概率放在一起：{ 0.7, 0.6, 0.5, 1 }。</p><p>在所有这些可能性中，最小的那个值，就是 0.5。</p><p>这就是“最小停止概率是0.5”这句话的直接来源。</p><h3 id="2-这个数字为什么如此重要？"><a href="#2-这个数字为什么如此重要？" class="headerlink" title="2. 这个数字为什么如此重要？"></a>2. 这个数字为什么如此重要？</h3><p>这个“最小停止概率”反过来告诉了我们整个系统的<strong>“最大继续概率”</strong>。</p><ul><li>最小停止概率 = 0.5</li><li>最大继续概率 = 1 - 最小停止概率 = 1 - 0.5 = 0.5</li></ul><p>这个<strong>“最大继续概率”</strong>，可以被看作是整个随机博弈系统的<strong>有效折扣因子 γ (effective discount factor)</strong>。</p><p>为什么呢？</p><p>价值迭代算法的收敛速度，取决于其更新算子是不是一个“压缩映射”，而其“压缩程度”就由折扣因子γ决定。为了保证整个系统一定收敛，我们必须考虑最坏的情况。</p><ul><li><strong>收敛的最坏情况是什么？</strong> 就是收敛得最慢的情况。</li><li><strong>什么时候收敛得最慢？</strong> 就是“折扣”打得最少的时候，也就是游戏最不容易结束、<strong>继续下去的概率最大</strong>的时候。</li></ul><p>在这个博弈中，游戏继续下去的最大概率是0.5。因此，整个价值迭代算法的收敛速度就由这个0.5来决定。</p><ul><li><strong>收敛速率</strong>：因为有效折扣因子<code>γ</code>是0.5，所以算法的误差是以 (0.5)n 的指数速率下降的。</li><li><strong>误差边界</strong>：根据我们之前学过的误差边界公式 <code>真实误差 ≤ 最大单步变化量 × γ/(1-γ)</code>，代入<code>γ=0.5</code>，我们得到 <code>γ/(1-γ) = 0.5/0.5 = 1</code>。这意味着，真实的未知误差，不会超过我们在上一步迭代中能观测到的最大变化量。幻灯片中说v₆的误差至多是0.0002，就是基于这个原理计算出来的（从v₅到v₆的最大变化量约为0.0001，其上限0.0002是完全正确的）。</li></ul><p><strong>总结</strong>： “最小停止概率是0.5”这个结论，是通过分析所有可能结果得出的。它的真正意义在于，它为我们确定了整个动态系统的有效折扣因子 <code>γ=0.5</code>，从而为算法的<strong>收敛速度</strong>和<strong>误差分析</strong>提供了坚实的理论依据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;引言&lt;/p&gt;
&lt;p&gt;q1：多智能体强化学习系统特点&lt;/p&gt;
&lt;p&gt;智能体数量非单个&lt;/p&gt;
&lt;p&gt;智能体之间存在一定联系：合作、对抗、合作+对抗（多智能体多动机）&lt;/p&gt;
&lt;p&gt;智能体不仅需要考虑到环境，还需要考虑到其他智能体的行动&lt;/p&gt;
&lt;p&gt;学习环境</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ATTENTION-GUIDED CONTRASTIVE ROLE REPRESENTATIONS FOR MULTI-AGENT REINFORCEMENT LEARNING</title>
    <link href="http://zcl0219.github.io/2025/05/15/ATTENTION-GUIDED-CONTRASTIVE-ROLE-REPRESENTATIONS-FOR-MULTI-AGENT-REINFORCEMENT-LEARNING/"/>
    <id>http://zcl0219.github.io/2025/05/15/ATTENTION-GUIDED-CONTRASTIVE-ROLE-REPRESENTATIONS-FOR-MULTI-AGENT-REINFORCEMENT-LEARNING/</id>
    <published>2025-05-15T12:22:33.000Z</published>
    <updated>2025-05-15T16:17:28.217Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：<br>1、受角色与智能体行为模式之间相关性的启发，我们提出了一种名为 Attention-guided COntrastive Role representation learning for MARL（ACORM）的新型框架</p><blockquote id="fn_注释"><sup>注释</sup>. 不同类型的角色具有不同类型的行为模式，比如有的偏向于拆塔，有的偏向于生产资源等等。作者应该是考虑利用不同角色与之对应的行为模式建立关系<a href="#reffn_注释" title="Jump back to footnote [注释] in the text."> &#8617;</a></blockquote><hr><p>2、引入互信息最大化来形式化角色表示学习，推导出一个对比学习目标，并简洁地近似负样本的分布</p><blockquote id="fn_注释"><sup>注释</sup>. 1. <strong>Mutual Information Maximization（互信息最大化）</strong>：互信息是信息论中的一个概念，用于衡量两个随机变量之间的相关性。最大化互信息意味着让模型学习到的角色表示（role representations）与智能体的行为模式尽可能相关。这可能意味着通过优化互信息，使角色的表示能够更好地捕捉到不同角色之间的行为差异。2. <strong>Formalize Role Representation Learning（形式化角色表示学习）</strong>：这里“形式化”指的是将角色表示的学习过程转化为数学框架或优化问题。通过互信息最大化，将角色表示的学习转化为一个明确的优化目标，使得角色表示能够系统地学习到有用的特征。3. <strong>Derive a Contrastive Learning Objective（推导对比学习目标）</strong>：对比学习是一种自监督学习方法，通过比较正样本对和负样本对来学习表示。在这里，作者可能将互信息最大化转化为对比损失函数，通过对比不同角色或行为模式，使得相似的行为在表示空间中更接近，不同的更远。4. <strong>Concisely Approximate the Distribution of Negative Pairs（简洁地近似负样本对的分布）</strong>：对比学习中需要生成负样本对，但直接采样所有可能的负样本可能计算量大。这里“简洁地近似”可能指通过某种方法有效生成或选择负样本，减少计算复杂度，同时保持对比学习的有效性。<a href="#reffn_注释" title="Jump back to footnote [注释] in the text."> &#8617;</a></blockquote><hr><p>3、利用注意力机制提示全局状态关注价值分解中学习到的角色表示，隐式地引导智能体在技能型角色空间中进行协调，以产生更具表现力的信用分配。</p><blockquote id="fn_注释"><sup>注释</sup>. 总的来说，还是解决信用分配问题？<a href="#reffn_注释" title="Jump back to footnote [注释] in the text."> &#8617;</a></blockquote><hr><p>引言</p><p>1、主要思想是学习一个紧凑的角色表征，以捕捉智能体的复杂行为模式，并使用该角色表征来促进智能体之间的行为异质性、知识迁移和熟练协调。首先，我们将学习目标形式化为角色与其表征之间的互信息最大化，以在给定智能体行为的情况下最大限度地减少角色不确定性，同时最大限度地保留与角色无关的信息。我们引入了一种对比学习方法来优化 infoNCE 损失，即互信息的下界。为了简洁地近似负样本的分布，我们通过将智能体的轨迹编码到潜在空间中来提取智能体行为，并定期根据其潜在嵌入将所有智能体划分为几个集群，来自不同集群的点被配对为负样本。其次，在集中式训练期间，我们采用注意力机制来提示全局状态关注价值分解中学习到的角色表征。 注意力机制在技能角色空间中隐式地指导智能体协调，从而在角色出现时产生更丰富的信用分配。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;摘要：&lt;br&gt;1、受角色与智能体行为模式之间相关性的启发，我们提出了一种名为 Attention-guided COntrastive Role representation learning for MARL（ACORM）的新型框架&lt;/p&gt;
&lt;blockquote id=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BYZANTINE ROBUST COOPERATIVE MULTI-AGENT REINFORCEMENT LEARNING AS A BAYESIAN GAME</title>
    <link href="http://zcl0219.github.io/2025/05/15/BYZANTINE-ROBUST-COOPERATIVE-MULTI-AGENT-REINFORCEMENT-LEARNING-AS-A-BAYESIAN-GAME/"/>
    <id>http://zcl0219.github.io/2025/05/15/BYZANTINE-ROBUST-COOPERATIVE-MULTI-AGENT-REINFORCEMENT-LEARNING-AS-A-BAYESIAN-GAME/</id>
    <published>2025-05-15T12:12:57.000Z</published>
    <updated>2025-05-15T12:22:45.285Z</updated>
    
    <content type="html"><![CDATA[<p>本片文章主要是依据历史经验来判断出干扰者，目标是合作方在最坏对抗干扰下，寻求最优策略<br>\begin{equation} \label{eq:ex_ante_equilibrium}<br>(\pi_{<em>}^{EA}(\cdot|H), \hat{\pi}_{</em>}^{EA}(\cdot|H, \theta)) \in \arg \max_{\pi(\cdot|H)} \mathbb{E}_{p(\theta)} \left[ \min_{\hat{\pi}(\cdot|H, \theta)} V_{\theta}(s) \right]<br>\end{equation}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本片文章主要是依据历史经验来判断出干扰者，目标是合作方在最坏对抗干扰下，寻求最优策略&lt;br&gt;&#92;begin{equation} &#92;label{eq:ex_ante_equilibrium}&lt;br&gt;(&#92;pi_{&lt;em&gt;}^{EA}(&#92;cdot|H), &#92;hat{&#92;pi}_{&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>VDN</title>
    <link href="http://zcl0219.github.io/2025/04/17/VDN/"/>
    <id>http://zcl0219.github.io/2025/04/17/VDN/</id>
    <published>2025-04-16T17:21:22.000Z</published>
    <updated>2025-05-07T16:23:00.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用于协作式多智能体学习的价值分解网络"><a href="#用于协作式多智能体学习的价值分解网络" class="headerlink" title="用于协作式多智能体学习的价值分解网络"></a>用于协作式多智能体学习的价值分解网络</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>我们研究了具有单个联合奖励信号的协作式多智能体强化学习问题。这类学习问题很困难，因为通常有很大的动作和观察组合空间。在完全集中式和去中心化的方法中，我们发现了虚假奖励的问题和一种我们称之为 “惰性代理” 问题的现象，这是由于部分可观察性而出现的。我们通过使用一种新的价值分解网络架构来训练单个代理来解决这些问题，该架构学习将团队价值函数分解为代理价值函数。我们在一系列部分可观察的多智能体领域进行了实验评估，并表明学习这种价值分解会带来卓越的结果，特别是当与权重共享、角色信息和信息通道相结合时。</p><hr><p><sup><a href="#fn_什么是单个联合奖励信号的协作式多智能体强化学习问题" id="reffn_什么是单个联合奖励信号的协作式多智能体强化学习问题">什么是单个联合奖励信号的协作式多智能体强化学习问题</a></sup>: </p><p>首先，协作式多智能体强化学习（Cooperative MARL）是指多个智能体共同合作完成一个任务，他们的目标一致，共享奖励或各自有奖励，但这里提到的是单个联合奖励信号，所以应该是所有智能体共享同一个奖励。那单个联合奖励信号是什么意思呢？可能是指所有智能体的行为共同影响一个全局奖励，比如团队胜利或任务完成。比如足球游戏里的多个球员，进球了大家都有同样的奖励，被进球了都扣分。这种情况下，每个智能体的行为都会影响整个团队的奖励，但每个智能体可能需要自己学习策略，或者有集中式的训练。接下来需要解释协作式MARL的基本概念，然后结合单个联合奖励来展开。可能需要比较一下其他情况，比如每个智能体有独立奖励的情况，或者竞争式MARL。然后说明这种单个联合奖励带来的挑战和常见解决方法。挑战可能包括信用分配问题，因为所有智能体共享同一个奖励，难以确定每个个体的贡献。比如在团队游戏中，某个关键动作可能由某个智能体做出，但奖励是大家共享的，其他智能体如何知道该动作的重要性？这时候可能需要某种方法来分配信用，比如COMA算法中的反事实基线，或者VDN、QMIX这类值分解的方法。另外，还需要提到环境的部分可观测性，每个智能体可能只能看到局部信息，这会影响决策。还有策略的协调问题，如何让多个智能体的策略在分散执行时保持一致，可能需要集中式训练、分散式执行的框架。常见的方法可能包括值分解网络（VDN, QMIX），这些方法通过分解联合Q值到个体Q值，从而在训练时利用全局信息，执行时每个智能体根据自己的Q值行动。还有Actor-Critic方法，如MADDPG，虽然每个智能体有自己的策略，但Critic可能会用到全局信息进行训练。另外，可能需要提到信用分配的具体技术，比如差异奖励（Difference Rewards），即每个智能体的奖励基于其贡献与全局奖励的关系，或者利用反事实基线来评估某个智能体是否存在时的奖励差异。总结的话，单个联合奖励的协作式MARL问题需要解决信用分配、环境复杂性、策略协调等问题，常用方法有值分解、集中训练分散执行、信用分配技术等。这样用户应该能理解这个问题的定义、挑战和解决思路了。</p><hr><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>我们考虑合作式多智能体强化学习（MARL）问题[，, , ]，其中多个学习智能体需要共同优化随时间累积的单一奖励信号——即<strong>团队奖励</strong>。每个智能体只能访问自身的“局部”观测信息，并负责从其自身的动作集中选择动作。协作式MARL问题出现在诸如协调自动驾驶车辆和/或交通信号系统、优化由多个交互组件组成的工厂生产效率等应用中。更广泛地说，随着AI智能体的普及，它们必须学会协作以实现共同目标。</p><p>尽管某些实际应用可能需要局部自治，但原则上合作式MARL问题可以通过<strong>集中式</strong>方法处理，即将问题简化为单智能体强化学习（RL），通过拼接观测空间和组合动作空间进行学习。然而，我们证明集中式方法在相对简单的协作式MARL问题上始终失败。我们设计了一个简单实验：集中式方法会学习到低效的策略，仅有一个智能体活跃，而另一个变得“懒惰”。这是因为当一个智能体学习到有用策略时，第二个智能体因探索行为可能妨碍前者并导致团队奖励下降，从而被抑制学习。</p><p><sup><a href="#fn_" id="reffn_"></a></sup>: </p><p>另一种方法是训练<strong>独立学习者</strong>以优化团队奖励。然而，由于每个智能体的环境动态会随着其他智能体行为的变化而改变，每个智能体实际上面临非稳态学习问题[]。此外，由于单个智能体的视角是部分可观测的，它们可能接收到来自队友（未被观测的）行为的虚假奖励信号。这种无法解释自身观测奖励的缺陷使得朴素独立RL通常无法成功：例如[]表明，独立Q学习器无法区分队友的探索与环境本身的随机性，甚至无法解决一个看似简单的2智能体、无状态、3×3动作的问题。而一般的Dec-POMDP问题已被证明是难解的[, ]。尽管本文聚焦于双智能体协作，但需注意独立学习者和集中式方法的问题会随智能体数量增加而恶化，因为此时大多数奖励与个体无关，而集中式方法的动作空间会指数级膨胀。</p><p>改进独立学习者的方法之一是设计更直接关联个体观测的局部奖励函数。然而，即使在单智能体场景中，奖励塑形也极为困难，仅有一小类塑形奖励函数能保证与真实目标的最优性一致[, ]。本文旨在探索更通用的自主解决方案，即通过学习分解团队价值函数。</p><p>我们提出一种新型的<strong>可学习加性价值分解</strong>方法，通过对个体智能体的价值函数进行线性组合。具体而言，价值分解网络（VDN）旨在通过反向传播团队Q值的梯度到表示个体价值函数的深度神经网络中，从而从团队奖励信号中学习最优的线性价值分解。这种加性分解的动机是避免独立学习者中出现的虚假奖励信号。每个智能体隐式学习到的价值函数仅依赖于局部观测，因此更易训练。该方法还缓解了[]中强调的独立学习的协调问题，因为它在训练时以集中方式学习，而部署时智能体可独立运行。</p><p>此外，我们结合权重共享、角色信息和信息通道等近期被证明可提升样本效率与降低内存需求的技术[, , ]，对所提出的智能体进行增强。但本文的核心比较集中在三种架构：基于个体的价值分解、独立学习者和集中式方法。我们在一系列新颖的双智能体协作场景中对这些技术的组合进行了实验与基准测试。结果表明，价值分解方法在性能上显著优于集中式或完全独立的学习者，且结合附加技术后，其表现更是大幅领先。</p><hr><p><sup><a href="#fn_备注" id="reffn_备注">备注</a></sup>: </p><p>集中式学习的缺点是随着智能体数量的增加，动作空间指数级增长；<br>独立式学习的缺点是每个智能体面临的是非稳态环境，学习不稳定还会影响其他智能体的学习；<br>因此，本文推出了一种可学习加性价值分解方法。换句话说就是如何将团队奖励（团队Q值）进行合理分解</p><hr><h4 id="2-3-多智能体强化学习"><a href="#2-3-多智能体强化学习" class="headerlink" title="2.3 多智能体强化学习"></a>2.3 多智能体强化学习</h4><p>如果我们将(\bar{h} := (h^1, h^2, …, h^d))定义为智能体历史记录的元组（其中每个(h^i)表示第(i)个智能体的历史），则联合策略通常是一个映射(\pi : \mathcal{H}^d \to \mathcal{P}(\mathcal{A}^d))。此映射基于所有智能体的联合历史(\bar{h})，输出联合动作空间(\mathcal{A}^d)上的概率分布。  </p><p>不过，我们特别关注一类特殊的策略：对于任意历史(\bar{h})，其输出的分布(\pi(\bar{h}))在(\mathcal{P}(\mathcal{A})^d)中具有<strong>独立分量</strong>。即，每个智能体的动作分布仅依赖于联合历史(\bar{h})，但各智能体的动作选择在概率上是相互独立的。因此，这类策略可表示为(\pi : \mathcal{H}^d \to \mathcal{P}(\mathcal{A})^d)。  </p><p>唯一的例外是使用最朴素的集中式智能体（即<strong>联合动作学习者</strong>）时，此时策略直接操作组合动作空间（(\mathcal{A}^d)），输出的分布属于(\mathcal{P}(\mathcal{A}^d))。  </p><hr><p><sup><a href="#fn_备注" id="reffn_备注">备注</a></sup>: </p><p>这段文字定义了多智能体强化学习（MARL）中的联合策略，并比较了两种不同的策略形式：</p><h3 id="核心概念解释"><a href="#核心概念解释" class="headerlink" title="核心概念解释"></a>核心概念解释</h3><ol><li><p><strong>智能体历史元组</strong>：<br>用(\bar{h} := (h^1, h^2, …, h^d))表示所有智能体的历史记录集合，其中(h^i)是第(i)个智能体的历史（包含其观测和动作序列）。</p></li><li><p><strong>联合策略的一般形式</strong>：<br>联合策略通常定义为映射(\pi : \mathcal{H}^d \to \mathcal{P}(\mathcal{A}^d))，即基于所有智能体的联合历史(\bar{h})，输出一个联合动作空间(\mathcal{A}^d)上的概率分布。  </p><ul><li>(\mathcal{H}^d)：所有智能体历史记录的联合空间。  </li><li>(\mathcal{P}(\mathcal{A}^d))：所有可能的联合动作的概率分布集合。  </li></ul></li><li><p><strong>独立分量的联合策略</strong>：<br>作者特别考虑一种特殊形式：对于任何联合历史(\bar{h})，策略输出的分布(\pi(\bar{h}))在(\mathcal{P}(\mathcal{A})^d)中具有<strong>独立分量</strong>。这意味着：  </p><ul><li>每个智能体的动作选择仅依赖于联合历史(\bar{h})，但动作之间的概率分布是独立的。  </li><li>数学上可分解为(\pi(\bar{h}) = (\pi^1(\bar{h}), \pi^2(\bar{h}), …, \pi^d(\bar{h})))，其中每个(\pi^i(\bar{h}) \in \mathcal{P}(\mathcal{A}))表示第(i)个智能体的局部策略。  </li><li><strong>优势</strong>：避免了组合动作空间的复杂性，同时仍能利用全局历史信息进行决策。</li></ul></li><li><p><strong>例外：集中式联合动作学习者</strong>：<br>当使用“最朴素的集中式智能体”时，策略直接操作组合动作空间（combinatorial action space），即联合动作学习者（joint action learners）。  </p><ul><li>此时，策略输出的分布(\pi(\bar{h}))属于(\mathcal{P}(\mathcal{A}^d))，需考虑所有智能体动作的联合分布，而非独立分量。  </li><li><strong>问题</strong>：动作空间维度随智能体数量(d)指数增长（(\mathcal{A}^d)），导致计算和训练复杂度极高。</li></ul></li></ol><h3 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a>关键区别</h3><div class="table-container"><table><thead><tr><th><strong>策略类型</strong></th><th><strong>输入</strong></th><th><strong>输出分布</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td>独立分量联合策略</td><td>联合历史(\bar{h})</td><td>(\mathcal{P}(\mathcal{A})^d)</td><td>动作分布独立，利用全局信息但保持动作解耦，复杂度线性增长（(d \times \</td><td>\mathcal{A}\</td><td>)）。</td></tr><tr><td>集中式联合动作学习者</td><td>联合历史(\bar{h})</td><td>(\mathcal{P}(\mathcal{A}^d))</td><td>动作分布耦合，需建模联合动作，复杂度指数增长（(\</td><td>\mathcal{A}\</td><td>^d)），难以扩展。</td></tr></tbody></table></div><h3 id="实际意义"><a href="#实际意义" class="headerlink" title="实际意义"></a>实际意义</h3><ul><li><strong>独立分量策略</strong>：适用于需要平衡全局协调与计算效率的场景，例如价值分解网络（VDN）等算法，通过共享观测历史但独立选择动作，缓解组合爆炸问题。  </li><li><strong>集中式联合动作学习者</strong>：尽管理论上能直接优化全局最优策略，但因动作空间过大，仅适用于智能体数量极少或动作空间极小的任务，实际应用受限。</li></ul><p>这一区分为后续讨论集中式方法在复杂任务中的失败（如动作空间爆炸、探索效率低）以及独立学习者或价值分解方法的优势奠定了基础。</p><hr><h3 id="三、深度强化学习（Deep-RL）架构用于合作型多智能体强化学习（Coop-MARL）"><a href="#三、深度强化学习（Deep-RL）架构用于合作型多智能体强化学习（Coop-MARL）" class="headerlink" title="三、深度强化学习（Deep-RL）架构用于合作型多智能体强化学习（Coop-MARL）"></a>三、深度强化学习（Deep-RL）架构用于合作型多智能体强化学习（Coop-MARL）</h3><p>减少可学习参数数量的一个方法是在代理之间共享某些网络权重。权重共享还引发了代理不变性的概念，这对于避免懒惰代理问题是有用的。</p><hr><p><sup><a href="#fn_备注" id="reffn_备注">备注</a></sup>: </p><p>首先，提到“减少可学习参数数量的方法之一是共享智能体之间的某些网络权重”。这里的“可学习参数”指的是神经网络中的权重，共享权重意味着不同的智能体使用相同的权重参数，而不是每个智能体都有自己独立的参数。这样可以减少整体的参数数量，从而降低模型的复杂度和训练所需的计算资源。</p><p>接下来，提到“权重共享还产生了智能体不变性的概念，这对避免懒惰智能体问题很有用”。“智能体不变性”应该是指通过共享权重，不同智能体在功能上变得相似或一致，从而避免某些智能体变得不活跃（即“懒惰智能体问题”）。</p><hr><h3 id="VDN代码实现"><a href="#VDN代码实现" class="headerlink" title="VDN代码实现"></a>VDN代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VDN类由五个函数组成：init, learn, get_inputs, get_q_values, init_hidden, save_model;</span><br><span class="line">其中，初始化init包括：智能体数量，状态空间，观察空间，输入维度，动作空间，四种神经网络，是否使用GPU，是否加载已存在模型，初始化相同网络参数，初始化需要优化网络参数个数，初始化优化器，初始化隐藏元。</span><br><span class="line">输入维度不等于观察空间原因：当args.last_action为<span class="literal">True</span>时，输入中会加入上一个时间步的动作信息</span><br><span class="line">四种神经网络分别为：每个agent选择动作的网络，每个agent的目标网络，VDN累加Q值的网络，VDN目标网络</span><br><span class="line">网络参数优化器：注意网络参数优化器是针对哪些网络参数进行反向传递优化，这对于VDN算法的实现很重要</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;用于协作式多智能体学习的价值分解网络&quot;&gt;&lt;a href=&quot;#用于协作式多智能体学习的价值分解网络&quot; class=&quot;headerlink&quot; title=&quot;用于协作式多智能体学习的价值分解网络&quot;&gt;&lt;/a&gt;用于协作式多智能体学习的价值分解网络&lt;/h2&gt;&lt;h3 id=&quot;摘</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>强化学习综述</title>
    <link href="http://zcl0219.github.io/2025/04/16/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/"/>
    <id>http://zcl0219.github.io/2025/04/16/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/</id>
    <published>2025-04-16T15:50:40.000Z</published>
    <updated>2025-04-16T18:10:35.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多智能体强化学习通信方法综述"><a href="#多智能体强化学习通信方法综述" class="headerlink" title="多智能体强化学习通信方法综述"></a>多智能体强化学习通信方法综述</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>通信是协调多个智能体行为、拓宽它们对环境的认识以及支持它们协作的有效机制。在多智能体深度强化学习（MADRL）领域，智能体可以通过通信来提高整体学习性能并实现其目标。智能体可以与所有智能体或特定智能体组通信，或者根据特定约束条件进行通信。随着 MADRL 通信（Comm-MADRL）研究工作的不断增多，目前缺乏一种系统性和结构化的方法来区分和分类现有的 Comm-MADRL 方法。在本文中，我们回顾了 Comm-MADRL 领域的最新研究成果，并考虑了在设计和开发多智能体强化学习系统中可能发挥作用的通信的各个方面。考虑到这些方面，我们提出了 9 个维度，沿着这些维度可以对 Comm-MADRL 方法进行分析、开发和比较。通过将现有工作投射到多维空间中，我们发现了一些有趣的趋势。 我们还通过探索可能性的组合，提出了一些设计未来 Comm-MADRL 系统的创新方向。</p><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><p>许多现实场景，如自动驾驶<sup>[1]</sup>、传感器网络[2]、机器人[3]和游戏[4, 5]，都可以建模为多智能体系统。这些多智能体系统可以通过多智能体强化学习（MARL）技术进行设计和开发，以学习单个智能体的行为，这些行为可以是合作，竞争，或者它们的混合体。由于智能体通常分布在环境中，它们只能访问局部观察而不是环境的完整状态，因此在多智能体强化学习（MARL）中，部分可观测性成为一个基本假设[6-8]。此外，MARL 还面临着非平稳问题[9]，因为每个智能体都面临着受其他智能体变化和适应策略影响的动态环境。通信被视为解决 MARL 中部分可观测性和非平稳问题的关键手段。智能体可以交流个人信息，例如观察、意图、经验或派生特征，从而对环境有更全面的了解，这反过来又使他们能够做出明智的决策[9, 10]。</p><p>由于深度学习[11]及其在强化学习[12]中的应用最近的成功，多智能体深度强化学习（MADRL）近年来取得了巨大成就，其中智能体可以处理高维数据，并在大状态和动作空间中具有泛化能力[7, 8]。我们注意到，大量研究工作集中在具有通信的学习任务上，这些任务旨在通过通信和共享信息来学习解决特定领域的任务，如导航、交通和视频游戏。据我们所知，目前还没有涵盖多智能体深度强化学习（Comm-MADRL）中关于具有通信的学习任务最新工作的综述文献。早期的综述考虑了通信在多智能体强化学习（MARL）中的作用，但将其视为预定义的，而不是学习主题[13-15]。大多数 Comm-MADRL 综述仅涵盖少量研究工作，没有提出一个精细的分类系统来比较和分析它们。在合作场景中，Hernandez-Leal 等人 [16] 使用学习通信来表示学习通信协议的领域，以促进智能体的合作。我们发现的唯一一份将一些早期工作分类到 Comm-MADRL 的综述来自 Gronauer 和 Diepold [17]，它基于区分消息是否被所有智能体、一组智能体或智能体网络接收。然而，Comm-MADRL 的其他方面，如消息类型和训练范式，对于通信至关重要，可以帮助描述现有的通信协议，却被忽略了。因此，关于具有通信的学习任务的近期综述中，所审查的论文相当有限，提出的分类过于狭窄，无法区分 Comm-MADRL 中的现有工作。另一方面，还有一个密切相关的研究领域，即涌现语言/通信，它也通过各种强化学习技术考虑通过学习通信。[18] 与 Comm-MADRL 不同，涌现语言研究的主要目标是学习一种符号语言。然而，涌现语言研究的一部分工作追求一个额外的目标，即利用可学习的符号语言来提高任务级别的性能。值得注意的是，这些研究成果尚未被现有 Comm-MADRL 综述所涵盖，但被纳入我们的调查，称为具有涌现语言的认知任务。总之，我们的调查在范围上与涌现语言的调查重叠（即在具有涌现语言的认知任务中），但我们的调查关注不同的主要目标（即实现特定领域的任务，而不是学习符号语言）。我们进一步在第 2.2 节中阐明具有通信和学习涌现语言的学习任务之间的区别。</p><p>在我们的调查论文中，我们通过关注通信如何被利用来提高多智能体深度强化学习技术的性能，回顾了 Comm-MADRL 文献。具体来说，我们专注于可学习的通信协议，这些协议与强调通过深度强化学习技术开发动态和自适应通信的近期工作相一致，包括学习何时、如何以及与谁进行通信。通过对近期 Comm-MADRL 文献的全面回顾，我们提出了一种系统性和结构化的分类方法，旨在区分和分类各种 Comm-MADRL 方法。这种方法还将为新的 Comm-MADRL 系统的设计和进步提供指导。假设我们计划为当前领域任务开发一个 Comm-MADRL 系统。从何时、如何以及与谁进行通信的问题开始，系统可以从多个方面进行描述。智能体需要学习何时进行通信、与谁进行通信、传达什么信息、如何整合接收到的信息，最后，通过通信可以实现哪些学习目标。 我们提出了 9 个维度，对应于 Comm-MADRL 系统的独特方面：控制目标、通信约束、通信者类型、通信策略、传递消息、消息组合、内部整合、学习方法以及训练方案。这些维度构成了 Comm-MADRL 系统的骨架，可用于全面分析和深入了解设计的 Comm-MADRL 方法。通过将最近的 Comm-MADRL 方法映射到这个多维结构中，我们不仅提供了对该领域当前技术水平的洞察，还确定了设计未来 Comm-MADRL 系统的一些重要方向。</p><p>本文剩余部分的结构如下。第 2 节讨论了多智能体强化学习的预备知识，以及关于通信的现有扩展和近期调查的详细比较。第 3 节，我们提出了我们的建议维度，解释了如何将近期的工作按每个维度的类别进行分组。第 4 节，我们讨论了文献中发现的趋势，并受建议维度驱动，提出了该研究领域的可能研究方向。第 5 节，我们总结了本文的结论。</p><h3 id="2-背景"><a href="#2-背景" class="headerlink" title="2. 背景"></a>2. 背景</h3><p>在本节中，我们首先提供关于多智能体强化学习的必要背景知识。然后，我们展示如何将多智能体强化学习扩展到考虑智能体之间的通信。最后，我们介绍并比较了涉及通信的近期调查，从中我们可以直接看到我们填补现有调查中空白的原因。</p><h4 id="2-1-多智能体强化学习"><a href="#2-1-多智能体强化学习" class="headerlink" title="2.1 多智能体强化学习"></a>2.1 多智能体强化学习</h4><p>现实世界的应用通常包含多个在环境中运行的智能体。智能体通常被认为是自主的，并且需要学习策略以实现其目标。多智能体环境可以根据环境是否完全可观测、智能体的目标如何相关联等因素以多种方式形式化[6]。其中，部分可观测随机博弈（POSG）[19, 20]是最灵活的形式化之一。POSG 由一个元组定义，其中 I 是（有限）智能体集合，按{1, …, n}索引，S 是环境状态集合，𝜌是状态空间 S 上的初始状态分布，A 是智能体 i 可用的动作集合，O 是智能体 i 的观察集合。我们表示联合动作空间为 A = ×A，智能体联合观察空间为 O = ×O。因此，P ∶ S × A → Δ(S)表示从状态 s ∈ S 到新状态 s∈ S 的转移概率，给定智能体的联合动作⃗ a = ⟨a, …, a ⟩，其中⃗ a ∈ A。当环境过渡到新状态 s 时，给定联合动作⃗</p><p>a 根据观察概率函数 O ∶ S × A → Δ(O)确定。然后，每个智能体根据其自身的奖励函数 R∶ S × A × S → ℝ获得即时奖励。与联合动作和观察类似，我们可以将⃗ r = ⟨r, …, r⟩表示为联合奖励。如果智能体的奖励函数恰好相同，即它们具有相同的目标，那么对于每个时间步，r= r= … = r 都成立。在这种情况下，POSG 简化为 Dec-POMDP [6]。如果每个时间步的状态可以从智能体的当前观察集中唯一确定，即 s ≡⃗ o，则 Dec-POMDP 简化为 Dec-MDP。如果每个智能体都知道真实的环境状态，则 Dec-MDP 简化为多智能体 MDP。如果智能体集合中只有一个智能体，即 I = {1}，则多智能体 MDP 简化为 MDP，而 DecPOMDP 简化为 POMDP。由于部分可观测性，MARL 方法通常使用每个智能体的观察-动作历史𝜏= {o , a, o, …, o }直到时间步 t 来近似环境状态。请注意，为了简化，时间步 t 通常被省略。</p><p>在多智能体强化学习环境中，智能体可以以去中心化或中心化的方式学习其策略。在去中心化学习中（例如，去中心化 Q 学习[21, 22]），n 个智能体的多智能体强化学习问题被分解为 n 个去中心化的单智能体问题，其中每个智能体通过将所有其他智能体视为环境的一部分来学习自己的策略[23, 24]。在这样的去中心化设置中，每个智能体学习的策略取决于其局部观察和历史。去中心化学习的一个主要问题是环境的所谓非平稳性，即每个智能体在一个其他智能体同时探索和学习的环境中学习。中心化学习可以训练所有智能体的单个联合策略或中心化的价值函数，以促进 n 个去中心化策略的学习。虽然中心化（联合）学习消除了或减轻了部分可观察性和非平稳性问题，但它面临着联合行动（和观察）空间随着智能体数量及其行动的指数级扩展的挑战。 想要深入了解多智能体强化学习（MARL）中使用的各种训练方案，我们推荐阅读[17]的全面综述，该综述为策略的训练和执行提供了宝贵的见解。根据策略是从值函数导出还是直接学习，多智能体强化学习方法可以分为基于值的方法和基于策略的方法。这两种方法在通信多智能体深度强化学习（Comm-MADRL）中得到了广泛的应用。</p><h5 id="基于值"><a href="#基于值" class="headerlink" title="基于值"></a>基于值</h5><p>在多智能体情况下，基于值的方法借鉴了单智能体案例中的许多想法。作为最流行的基于值的方法之一，分布式 Q 学习为每个智能体学习一个局部 Q 函数。在智能体共享共同奖励的协作设置中，智能体 i 的更新规则如下：<br>其中 r 是共享奖励，ais 是下一个状态 s 中具有最高 Q 值的动作。在部分可观察环境中，环境状态不是完全可观察的，通常由每个代理的个体观察或历史记录来代替。每个状态-动作对的 Q 值根据 TD 误差逐步更新。这个误差，即 r + 𝛾 maxQ(s, a) − Q(s, a )，表示基于 Bellman 方程[25]的新估计（即 r + 𝛾 maxQ(s, a)）和当前估计（即 Q(s, a)）之间的差异。由于状态和动作空间可能太大，难以频繁遇到以进行准确估计，因此函数逼近方法，如深度神经网络，已经变得流行，为价值或策略模型赋予在离散和连续状态和动作上的泛化能力[12]。例如，深度 Q 网络（DQN）[12]最小化从采样奖励计算的新估计与参数化 Q 函数的当前估计之间的差异。在基于 DQN 的方法中，方程 1 中的 Q 函数表示为 Q(s, a ;𝜃)，它依赖于可学习的参数𝜃。 然而，基于价值的集中式学习方法学习一个联合 Q 函数 Q(s,⃗ a;𝜃)与参数𝜃。然而，这种方法在代理数量增加时难以扩展。值分解方法[26-29]是流行的多智能体强化学习（MARL）方法，可以将联合 Q 函数分解以实现高效的训练。这些方法也广泛应用于 Comm-MADRL 的研究工作中[30-32]。在部分可观察环境中，线性值分解方法将基于历史的联合 Q 函数分解如下：<br>其中，联合 Q 函数基于所有代理的联合历史，并基于个体历史分解为局部 Q 函数。权重 w 可以是固定值[26, 28]或受特定约束的可学习参数[29]。优势函数也可以替换上述方程中的 Q 函数以减少方差[33]。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;多智能体强化学习通信方法综述&quot;&gt;&lt;a href=&quot;#多智能体强化学习通信方法综述&quot; class=&quot;headerlink&quot; title=&quot;多智能体强化学习通信方法综述&quot;&gt;&lt;/a&gt;多智能体强化学习通信方法综述&lt;/h2&gt;&lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DRL Algorithms</title>
    <link href="http://zcl0219.github.io/2024/10/30/DRL-Algorithms/"/>
    <id>http://zcl0219.github.io/2024/10/30/DRL-Algorithms/</id>
    <published>2024-10-29T16:26:54.000Z</published>
    <updated>2024-10-29T17:20:24.879Z</updated>
    
    <content type="html"><![CDATA[<p>在深度强化学习中，(\mathbb{E}_{S}[V(S, \theta)]) 表示对状态 (S) 的期望值。虽然 (S) 是状态，具体理解上可以这样考虑：</p><ol><li><p><strong>状态的分布</strong>：在强化学习中，状态 (S) 是随机变量，它遵循一个分布 (p(S))，该分布反映了状态在环境中的出现概率。这个分布可以是初始状态分布，也可以是策略执行时经过各个状态的访问分布。我们可以理解为期望值 (\mathbb{E}_{S}[V(S, \theta)]) 是对状态分布 (p(S)) 的加权平均。</p></li><li><p><strong>求期望的含义</strong>：当我们求 (\mathbb{E}_{S}[V(S, \theta)]) 时，实际上是在所有可能的状态上计算一个加权平均值，即把每个状态的价值函数 (V(S, \theta)) 按其出现的概率 (p(S)) 来进行加权。这种期望值通常用于估计模型在整个状态空间上的表现。</p></li><li><p><strong>样本估计</strong>：在实际中，这种期望值可以通过采样实现，比如通过从 (p(S)) 中采样得到一系列状态 (\{S_i\})，然后计算这些状态上 (V(S, \theta)) 的平均值来逼近 (\mathbb{E}_{S}[V(S, \theta)])。</p></li></ol><p>综上，(\mathbb{E}_{S}[V(S, \theta)]) 是对状态空间中的每个状态价值的加权平均，权重来自状态的分布 (p(S))。这种方法在强化学习中帮助我们通过全局状态分布来评估价值函数，从而更有效地训练模型。</p><p>随机梯度是对期望的蒙特卡洛近似</p><p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030002933171.png" alt="image-20241030002933171"></p><p>通常来说，J(\theta)是一个很复杂的函数，而L(\theta | \theta_{old})是一个相对简单的函数</p><p>构建L的方法多种多样，可以是J的二阶泰勒展开，也可以是J的蒙特卡洛近似</p><p>要maximization，即相当于求解一个带置信域约束的最优化问题，求解速度没有梯度上升和随机梯度上升算法快</p><p>但置信域算法强在比这两种算法表现稳定，哪怕最优化问题求解不是很准确。</p><p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030003652735.png" alt="image-20241030003652735"></p><p>J(\theta) = E_{S}[V_{\pi}(S)]中对S求期望，相当于消除了S，只剩下策略网络参数\theta</p><p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030004813870.png" alt="image-20241030004813870"></p><p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030005237667.png" alt="image-20241030005237667"></p><p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030005401769.png" alt="image-20241030005401769"></p><p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030010211366.png" alt="image-20241030010211366"></p><p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030010802155.png" alt="image-20241030010802155"></p><p>第四步需要内层循环求解最大化问题，第四步两个超参数，一个\delta，一个学习步长。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在深度强化学习中，(&#92;mathbb{E}_{S}[V(S, &#92;theta)]) 表示对状态 (S) 的期望值。虽然 (S) 是状态，具体理解上可以这样考虑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;状态的分布&lt;/strong&gt;：在强化学习中，状态 (S) 是随机变量</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DiaDSP</title>
    <link href="http://zcl0219.github.io/2024/10/22/DiaDSP/"/>
    <id>http://zcl0219.github.io/2024/10/22/DiaDSP/</id>
    <published>2024-10-22T13:38:57.000Z</published>
    <updated>2024-10-27T11:06:54.954Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Differentially-Private-Distributed-Optimization-via-State-and-Direction-Perturbation-in-Multiagent-Systems"><a href="#Differentially-Private-Distributed-Optimization-via-State-and-Direction-Perturbation-in-Multiagent-Systems" class="headerlink" title="Differentially Private Distributed Optimization via State and Direction Perturbation in Multiagent Systems"></a>Differentially Private Distributed Optimization via State and Direction Perturbation in Multiagent Systems</h3><span id="more"></span><h4 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h4><p><a href="https://differential-privacy.cn/">Differential privacy</a> <i class="fa fa-external-link"></i></p><h4 id="Prerequisite-Knowledge"><a href="#Prerequisite-Knowledge" class="headerlink" title="Prerequisite Knowledge"></a>Prerequisite Knowledge</h4><p>What is state perturbation ?</p><ul><li>State perturbation refers to the intentional modification of an agent’s current state by introducing randomness or noise.</li></ul><p>What is differential privacy ?</p><ul><li>Differential privacy is a formal framework designed to ensure the privacy of individual’s data. <a href="https://arxiv.org/pdf/1401.2596">Achieving differential privacy requires that any change in the statistics of the messages</a>.<i class="fa fa-external-link"></i></li></ul><p>What is direction perturbation ?</p><p>Direction perturbation involves introducing randomness or noise into the direction of the optimization process in a distributed algorithm. This technique modifies the gradient or update direction that agents use when adjusting their parameters during optimization.<br>By perturbing the direction, the algorithm can maintain privacy by making it more challenging for other agents or observers to infer the true gradient information, thereby protecting individual agents’ objective functions. Additionally, direction perturbation can help enhance the robustness of the optimization process and contribute to convergence properties, particularly in scenarios where privacy is a critical concern.</p><p>What is differential privacy ?</p><p>In simple terms, Laplace noise refers to a random variable that follows a Laplace distribution. The probability density function of Laplace noise is represented as follows:<br>$$f(x \mid \mu, b) = \frac{1}{2b} e^{-\frac{|x-\mu|}{b}}.$$<br>Now, let us introduce the concept of $\epsilon$-differential privacy. Consider a mapping network $\mathbf{A}$ and two sibling datasets $\mathbf{D}$ and $\mathbf{D^{\prime}}$. Note that $\mathbf{D}$ and $\mathbf{D’}$ differ by at most one data point. The mathematical condition for the mapping network $\mathbf{A}$ to satisfy $\epsilon$-differential privacy is as follows<br>$$\operatorname{Pr}\left[A(\mathbf{D})=O\right] \leq e^{\varepsilon} \operatorname{Pr}\left[A\left(\mathbf{D^{\prime}}\right)=O\right].$$<br>The proof is provided here: <a href="https://blog.csdn.net/A13526_/article/details/121300367">$\epsilon$-differential privacy proof</a>.<i class="fa fa-external-link"></i></p><p>$x \in \mathbb{R}^u$ represents local observation.</p><p>$\mathbf{x} \in \mathbb{R}^{n \times u},$ The rows of $\mathbf{x}$ represent the local observation of each agent $i$.</p><p>$\min \sum_{i=1}^{n} f_{i}(x_{i})$ represents the objective function, associated with four properties as below</p><ol><li><p>$\textit{Existence}$ : </p><p>$$\mathbf{x}^{*}= \mathbf{1} \left( x^{*} \right)^{T} \text{ and } \sum_{i=1}^{n} \nabla f_{i} \left( x^{*} \right) = 0.$$</p></li><li></li></ol><h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>The article focuses on the distributed optimization problem in multi-agent system, where the objective is to minimize the sum of cost functions. It demonstrates that achieving both convergence and differential privacy is impossible through state perturbation in existing algorithms. The authors propose a new algorithm called DiaDSP, which utilizes both state and direction perturbations with decaying Laplace noise to ensure differential privacy. Unlike many prior methods that require diminishing step sizes for convergence, DiaDSP converges in mean and almost surely with a constant step size. The authors establish conditions for linear convergence under strong convexity of the cost functions and R-linear convergence with Lipschitz gradients. The authors also analyze the trade-off between privacy and convergence accuracy and validate their findings through simulations in a sensor fusion context.</p><h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><h4 id="Problem-Formulation"><a href="#Problem-Formulation" class="headerlink" title="Problem Formulation"></a>Problem Formulation</h4><p>The objectives of this article are twofold:</p><ol><li>Design a fully distributed update rule $h(\cdot)$ and a noise adding mechanism $g(\cdot)$ only based on local information to solve the DO problem $\min \sum_{i=1}^{n} f_{i}(x_{i})$ while preserving the differential privacy.</li><li>Characterize the trade-off between the accuracy of convergence and the level of differential privacy.</li></ol><p>Notes:</p><ol><li>The update rule can be represented in a compact form as follows: $$\mathbf{x}(k + 1) = h(\mathbf{x}(k), \mathbf{z}(k), \textbf(A), \mathcal{F}).$$</li><li>The attacker has access to all the transmitted messages, which are usually masked by noise $\zeta(k)$, i.e.,<br>$$\mathbf{z}(k) = g(\mathbf{x}(k), \zeta(k)).$$</li><li>The privacy level of $\epsilon$-differential privacy is generally determined by $\epsilon$. The smaller $\epsilon$ is, the higher the privacy level. In other words, it becomes more challenging to distinguish between the two target functions when $\epsilon$ is small.</li></ol><h4 id="DiaDSP-Algorithm"><a href="#DiaDSP-Algorithm" class="headerlink" title="DiaDSP Algorithm"></a>DiaDSP Algorithm</h4><p>A. Motivation: An Impossibility Result</p><p>Summary: The result shows that the convergence and differential privacy cannot be guaranteed simultaneously for any global exact DO algorithm.</p><p>Proof of Proposition 1 (convergence ($\surd$))</p><p>$\mathbf{x}^{(l)}(k) \rightarrow$ the convergence point by $\mathbf{x}_{l}^{\infty}$. Hence, there is $\delta^{*} &gt; 0$, satisfying $\big| g(\mathbf{x}_{1}^{*}, \mathbf{0}) - g(\mathbf{x}_{2}^{*}, \mathbf{0})\big|_{\textit{F}}$ We set an upper threshold $\frac{\delta^{*}}{3}$. Therefore, there exists $k_{\delta^{*}}^{(l)} &gt; 0$ such that $\big| \mathbf{z}^{l}(k) - g(\mathbf{x}_{l}^{*}, \mathbf{0})\big| &lt; \frac{\delta^{*}}{3}.$<br>$$\big| z^{(1)}(k) - z^{(2)}(k)| \geq |g(x_1^{*}, 0) - g(x_2^{*}, 0)| - |g(x_1^{*}, 0) - z^{(1)}(k)| - |g(x_2^{*}, 0) - z^{(2)}(k)\big|.$$<br>$$|a + b + c| \geq |b| - |a| - |c|.$$<br>$$a = z^{(1)}(k) - g(x_1^{*}, 0), \quad b = g(x_1^{*}, 0) - g(x_2^{*}, 0), \quad c = g(x_2^{*}, 0) - z^{(2)}(k).$$<br>$$|z^{(1)}(k) - z^{(2)}(k)| \geq |g(x_1^{*}, 0) - g(x_2^{*}, 0)| - |z^{(1)}(k) - g(x_1^{*}, 0)| - |g(x_2^{*}, 0) - z^{(2)}(k)|.$$<br>$$|z^{(1)}(k) - z^{(2)}(k)| \geq |g(x_i^{*}, 0) - g(x_2^{*}, 0)| - \frac{2\delta^{*}}{3}.$$</p><p>B. Development of DiaDSP</p><p>We employ the combine-then-adapt strategy for each agent $i$, which is expressed as $$x_{i}(k+1) = \sum_{j=1}^{n} a_{ij} x_{j}(k) - \alpha_{i} y_{i}(k).$$ This formula is analogous to the parameter update mechanism in neural networks. $x_i(k)$ can be considered as the transition between different states. $y_i(k)$  is regarded as the gradient of the cost function. Therefore, $y_i(k)$ is supposed to have the same direction as $\sum_{i=1}^{n} \nabla f_i(x_i(k)).$ One advantage of adopting the GT method is that the iterations $$x_{i}(k+1) = \sum_{j=1}^{n} a_{ij} x_{j}(k) - \alpha_{i} y_{i}(k).$$ and $$y_i(k+1) = \sum_{j=1}^{n} a_{ij} y_j(k) + \nabla f_i(x_i(k+1)) - \nabla f_i(x_i(k)).$$ share the same network and we do not need to generate another network for the GT iteration. The reason is that they have the same input dimension and both update around the gradient of the cost function with respect to $f_i(x_i(k))$.</p><h4 id="Convergence-Analysis-of-DiaDSP"><a href="#Convergence-Analysis-of-DiaDSP" class="headerlink" title="Convergence Analysis of DiaDSP"></a>Convergence Analysis of DiaDSP</h4><p>This section mainly include three key points:</p><ol><li>Analyze the convergence of DiaDSP</li><li>Prove the R-linear convergence of DiaDSP</li><li>Determine the optimal step size</li></ol><p>Differential Privacy</p><p>Simulations</p><p>Conclusion</p><p>Questions and Insights</p><ol><li>What is R-linear convergence ?</li></ol>    <style>    #refplus, #refplus li{         padding:0;        margin:0;        list-style:none;    }；    </style>    <script src="https://unpkg.com/@popperjs/core@2"></script>    <script src="https://unpkg.com/tippy.js@6"></script>    <script>    document.querySelectorAll(".refplus-num").forEach((ref) => {        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');        let refel = document.querySelector(refid);        let refnum = refel.dataset.num;        let ref_content = refel.innerText.replace(`[${refnum}]`,'');        tippy(ref, {            content: ref_content,        });    });    </script>    ]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Differentially-Private-Distributed-Optimization-via-State-and-Direction-Perturbation-in-Multiagent-Systems&quot;&gt;&lt;a href=&quot;#Differentially-Private-Distributed-Optimization-via-State-and-Direction-Perturbation-in-Multiagent-Systems&quot; class=&quot;headerlink&quot; title=&quot;Differentially Private Distributed Optimization via State and Direction Perturbation in Multiagent Systems&quot;&gt;&lt;/a&gt;Differentially Private Distributed Optimization via State and Direction Perturbation in Multiagent Systems&lt;/h3&gt;</summary>
    
    
    
    <category term="Scholarly Reads" scheme="http://zcl0219.github.io/categories/Scholarly-Reads/"/>
    
    
    <category term="Distributed Optimization Algorithm" scheme="http://zcl0219.github.io/tags/Distributed-Optimization-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://zcl0219.github.io/2023/11/10/%E7%AE%97%E6%B3%95/"/>
    <id>http://zcl0219.github.io/2023/11/10/%E7%AE%97%E6%B3%95/</id>
    <published>2023-11-10T10:44:01.000Z</published>
    <updated>2024-10-20T12:40:55.432Z</updated>
    
    <content type="html"><![CDATA[<p>2023-11-10</p><p>并查集：<a href="https://blog.csdn.net/YSJ367635984/article/details/113504723">https://blog.csdn.net/YSJ367635984/article/details/113504723</a></p><span id="more"></span><p>C++代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisjointSets</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DisjointSets</span>();</span><br><span class="line">    ~<span class="built_in">DisjointSets</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findParentNode</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionSetNode</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DisjointSets::<span class="built_in">DisjointSets</span>(): <span class="built_in">count</span>(<span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)&#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DisjointSets::~<span class="built_in">DisjointSets</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int DisjointSets::findParentNode(int x)&#123;</span></span><br><span class="line"><span class="comment">    if(x != parent[x])&#123;</span></span><br><span class="line"><span class="comment">        findParentNode(parent[x]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return x;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化版本的并查集，减小以后查找时间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DisjointSets::findParentNode</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x != parent[x])&#123;</span><br><span class="line">        <span class="comment">// 找一次x只是压缩一次，多找几次就会导致父节点为根节点</span></span><br><span class="line">        parent[x] = parent[parent[x]];</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisjointSets::unionSetNode</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> parent_x = <span class="built_in">findParentNode</span>(x);</span><br><span class="line">    <span class="type">int</span> parent_y = <span class="built_in">findParentNode</span>(y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(parent_x == parent_y) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    parent[parent_y] = parent_x;</span><br><span class="line">    </span><br><span class="line">    --count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;2023-11-10&lt;/p&gt;
&lt;p&gt;并查集：&lt;a href=&quot;https://blog.csdn.net/YSJ367635984/article/details/113504723&quot;&gt;https://blog.csdn.net/YSJ367635984/article/details/113504723&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Zookeeper</title>
    <link href="http://zcl0219.github.io/2023/10/22/Zookeeper/"/>
    <id>http://zcl0219.github.io/2023/10/22/Zookeeper/</id>
    <published>2023-10-22T10:27:16.000Z</published>
    <updated>2023-10-22T12:52:38.677Z</updated>
    
    <content type="html"><![CDATA[<p>一、Zookeeper特点</p><ol><li>Zookeeper:一个领导者(Leader)，多个跟随者(Follower)组成的集群。<br>2)集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器。<br>3)全局数据一致:每个Server保存一份相同的数据副本， Client无论连接到哪个Server，数据都是一致的。<br>4)更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行。<br>5)数据更新原子性，一次数据更新要么成功，要么失败。<br>6)实时性，在一定时间范围内，Client能读到最新数据。</li></ol><p>二、数据结构<br>ZooKeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一棵树，每个节点称做一个ZNode。每一个ZNode默认能够存储1MB 的数据，每个ZNode都可以通过其路径唯一标识。</p><p>三、应用场景</p><p>提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。</p><p>四、配置参数</p><p>tickTime &#x3D; 2000：通信心跳时间，Zookeeper服务器与客户端心跳时间，单位毫秒</p><p>initLimit &#x3D; 10：LF初始通信时限，10次心跳，也就是20s，Leader和Follower初始链接时限</p><p>syncLimit &#x3D; 5：LF同步通信时限，两者之间的通信时间（5s）</p><p>dataDir：保存Zookeeper中的数据，可以修改</p><p>clientPort &#x3D; 2181：客户端连接端口，通常不做修改</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、Zookeeper特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Zookeeper:一个领导者(Leader)，多个跟随者(Follower)组成的集群。&lt;br&gt;2)集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器。&lt;br&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>对象的优化</title>
    <link href="http://zcl0219.github.io/2023/10/22/%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://zcl0219.github.io/2023/10/22/%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BC%98%E5%8C%96/</id>
    <published>2023-10-22T08:31:53.000Z</published>
    <updated>2023-10-22T10:26:35.842Z</updated>
    
    <content type="html"><![CDATA[<p>一、拷贝构造、赋值运算符重载的相关知识</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> a = <span class="number">10</span>): <span class="built_in">ma</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test &amp;t): <span class="built_in">ma</span>(t.ma) &#123; cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    Test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Test &amp;t)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">        ma = t.ma;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test t1;</span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;</span><br><span class="line">    Test t3 = t1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Test(20)显式生成临时对象 生存周期：所在的语句</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    c++编译器对于对象构造的优化：</span></span><br><span class="line"><span class="comment">    用临时对象生成新对象的时候，临时对象就不产生了，直接构造新对象就可以了。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Test t4 = <span class="built_in">Test</span>(<span class="number">20</span>); <span class="comment">// Test t4(20)没有区别的!</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t4 = t2; <span class="comment">// t4已经存在，这是赋值</span></span><br><span class="line">    t4 = <span class="built_in">Test</span>(<span class="number">30</span>); <span class="comment">// t4.operator=(const Test &amp;t)</span></span><br><span class="line">    t4 = (Test)<span class="number">30</span>; <span class="comment">// int -&gt; Test,强制转换编译器会看有没有合适的构造函数</span></span><br><span class="line">    t4 = <span class="number">30</span>; <span class="comment">// 隐式生成临时对象 隐式类型转换，注意如果30换成一个char类型变量，那就不行了，因为没有对应的构造  函数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Test *p = &amp;<span class="built_in">Test</span>(<span class="number">40</span>); <span class="comment">// p指向的是一个已经析构的临时对象</span></span><br><span class="line">    <span class="type">const</span> Test &amp;ref = <span class="built_in">Test</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="comment">// 使用引用引用一个临时变量，临时变量的周期就变为了变量的生命周期</span></span><br><span class="line">    <span class="comment">// 自己思考为引用给变量起了一个别名，在引用的生命周期内，就可以继续访问这个临时变量了</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> a = <span class="number">5</span>, <span class="type">int</span> b = <span class="number">5</span>): <span class="built_in">ma</span>(a), <span class="built_in">mb</span>(b)&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test(int, int)&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test &amp;src): <span class="built_in">ma</span>(src.ma), <span class="built_in">mb</span>(src.mb)&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Test &amp;src)&#123;</span><br><span class="line">        ma = src.ma;</span><br><span class="line">        mb = src.mb;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">    <span class="type">int</span> mb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;  <span class="comment">//1. Test(int , int)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;  <span class="comment">//3. Test(int , int)</span></span><br><span class="line">    Test t3 = t2; <span class="comment">// 4.Test(const Test&amp;)</span></span><br><span class="line">    <span class="type">static</span> Test t4 = <span class="built_in">Test</span>(<span class="number">30</span>, <span class="number">30</span>); <span class="comment">//5. Test(int, int)</span></span><br><span class="line">    t2 = <span class="built_in">Test</span>(<span class="number">40</span>, <span class="number">40</span>); <span class="comment">//6.Test(int, int), operetor=, ~Test()</span></span><br><span class="line">    t2 = (Test)(<span class="number">50</span>, <span class="number">50</span>); <span class="comment">//7.Test(int, int), operetor=, ~Test()</span></span><br><span class="line">    t2 = <span class="number">60</span>; <span class="comment">//8.Test(int, int), operetor=, ~Test()</span></span><br><span class="line">    Test *p1 = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">70</span>, <span class="number">70</span>); <span class="comment">// 9.Test(int, int),堆上需要显式释放</span></span><br><span class="line">    Test *p2 = <span class="keyword">new</span> Test[<span class="number">2</span>]; <span class="comment">// 10.Test(int, int), Test(int, int)</span></span><br><span class="line">    Test *p3 = &amp;<span class="built_in">Test</span>(<span class="number">80</span>, <span class="number">80</span>); <span class="comment">//11.Test(int, int), ~Test()</span></span><br><span class="line">    <span class="type">const</span> Test &amp;p4 = <span class="built_in">Test</span>(<span class="number">90</span>, <span class="number">90</span>); <span class="comment">//12.Test(int, int)</span></span><br><span class="line">    <span class="keyword">delete</span> p1; <span class="comment">// 13.~Test()</span></span><br><span class="line">    <span class="keyword">delete</span> []p2; <span class="comment">// 14. ~Test(), ~Test()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Test <span class="title">t5</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;  <span class="comment">//2. Test(int , int)</span></span><br><span class="line"><span class="comment">// 注意，t4的析构最晚，它在数据段，需要等程序结束。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、拷贝构造、赋值运算符重载的相关知识&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>OS_ucore</title>
    <link href="http://zcl0219.github.io/2023/10/18/OS-ucore/"/>
    <id>http://zcl0219.github.io/2023/10/18/OS-ucore/</id>
    <published>2023-10-18T02:11:15.000Z</published>
    <updated>2023-12-25T18:08:19.076Z</updated>
    
    <content type="html"><![CDATA[<p>1、操作系统要干啥？哪些操作&#x2F;任务不属于操作系统的管理范畴？</p><p>2、工具使用</p><p>阅读源码工具：<code>understannd</code></p><p>源码文档自动生成工具：<code>doxygen</code></p><p>虚拟运行环境：<code>qemu</code></p><p><code>Lab0</code></p><p>1、了解汇编</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;cld \n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;rep \n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;stosl&quot;</span></span><br><span class="line">        :</span><br><span class="line">        : <span class="string">&quot;c&quot;</span> (count), <span class="string">&quot;a&quot;</span>(value), <span class="string">&quot;D&quot;</span> (buf[<span class="number">0</span>])</span><br><span class="line">        :</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这段 C 代码给出了一个简单的函数，其中包括了一段内联汇编。</span></span><br><span class="line"><span class="comment">该代码试图展示如何使用 `rep stos` 指令来填充一个缓冲区，但存在一些问题和错误。</span></span><br><span class="line"><span class="comment">我会逐步解释代码，然后提出建议的更正。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 变量定义:</span></span><br><span class="line"><span class="comment">    ```c</span></span><br><span class="line"><span class="comment">    int count = 1;</span></span><br><span class="line"><span class="comment">    int value = 1;</span></span><br><span class="line"><span class="comment">    int buf[10];</span></span><br><span class="line"><span class="comment">    ```</span></span><br><span class="line"><span class="comment">    你定义了三个变量：一个 `count` 用于记录要重复的次数，</span></span><br><span class="line"><span class="comment">                    一个 `value` 用于指定要存储的值，</span></span><br><span class="line"><span class="comment">                    以及一个 `buf` 数组用于存储数据。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 主函数和内联汇编:</span></span><br><span class="line"><span class="comment">    ```c</span></span><br><span class="line"><span class="comment">    void main()&#123;</span></span><br><span class="line"><span class="comment">        asm(</span></span><br><span class="line"><span class="comment">            &quot;cld \n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;rep \n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;stsol&quot;</span></span><br><span class="line"><span class="comment">            :</span></span><br><span class="line"><span class="comment">            : &quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf[0])</span></span><br><span class="line"><span class="comment">        );</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    ```</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    - `cld`: 清除方向标志（Direction Flag）。这确保了字符串操作（如 `stos`）从低地址向高地址操作。</span></span><br><span class="line"><span class="comment">    - `rep stos`: 这应该是一个组合的指令，意思是&quot;重复存储&quot;。</span></span><br><span class="line"><span class="comment">      你试图使用这个指令将 `value` 的内容存储到 `buf` 指定的内存位置，</span></span><br><span class="line"><span class="comment">      并根据 `count` 的值重复该操作。但这里有个小错误: 你写的是 `&quot;stsol&quot;`，它是不正确的。应该是 `&quot;stosl&quot;`。</span></span><br><span class="line"><span class="comment">    - 输出约束（Output operands）: 这里没有列出输出操作数，所以你只有一个冒号。</span></span><br><span class="line"><span class="comment">    - 输入约束（Input operands）: `&quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf[0])`，这里:</span></span><br><span class="line"><span class="comment">        * `&quot;c&quot; (count)`：把 `count` 放入 `ECX` 寄存器（这是 `rep` 指令使用的计数寄存器）。</span></span><br><span class="line"><span class="comment">        * `&quot;a&quot;(value)`：把 `value` 放入 `EAX` 寄存器（这是 `stosl` 指令使用的源数据寄存器）。</span></span><br><span class="line"><span class="comment">        * `&quot;D&quot; (buf[0])`：把 `buf` 的首地址放入 `EDI` 寄存器（这是 `stosl` 指令使用的目标地址寄存器）。</span></span><br><span class="line"><span class="comment">          但这样写是不准确的，应该是 `&quot;D&quot; (buf)`。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">修正后的代码如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">```c</span></span><br><span class="line"><span class="comment">int count = 1;</span></span><br><span class="line"><span class="comment">int value = 1;</span></span><br><span class="line"><span class="comment">int buf[10];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void main()&#123;</span></span><br><span class="line"><span class="comment">    asm(</span></span><br><span class="line"><span class="comment">        &quot;cld \n\t&quot;</span></span><br><span class="line"><span class="comment">        &quot;rep \n\t&quot;</span></span><br><span class="line"><span class="comment">        &quot;stosl&quot;</span></span><br><span class="line"><span class="comment">        :</span></span><br><span class="line"><span class="comment">        : &quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf)</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">```</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：使用内联汇编通常是平台和编译器特定的。</span></span><br><span class="line"><span class="comment">上述代码假定你正在使用 GCC 或其它支持 GNU 汇编语法的编译器，并且在一个 x86 架构的机器上运行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在 GCC 的内联汇编中，第三个冒号后面的部分是用于指定被汇编代码修改的寄存器列表的，也叫做“Clobber List”。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以下是 `asm` 的基本格式：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">asm ( assembly code </span></span><br><span class="line"><span class="comment">     : output operands                  // optional</span></span><br><span class="line"><span class="comment">     : input operands                   // optional</span></span><br><span class="line"><span class="comment">     : list of clobbered registers      // optional</span></span><br><span class="line"><span class="comment">     );</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. Assembly Code: 包含汇编指令的字符串。</span></span><br><span class="line"><span class="comment">2. Output Operands: 输出操作数列表。</span></span><br><span class="line"><span class="comment">3. Input Operands: 输入操作数列表。</span></span><br><span class="line"><span class="comment">4. Clobber List: 表示汇编指令可能会更改的寄存器列表，</span></span><br><span class="line"><span class="comment">   这告诉编译器这些寄存器的值可能会被修改，所以不要依赖它们的原始值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在你的例子中，你使用了 `&quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf[0])` 为汇编指令提供输入操作数，</span></span><br><span class="line"><span class="comment">但你并没有指定输出操作数，也没有列出任何可能被修改的寄存器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">虽然在此例中，你知道 `ECX`, `EAX`, 和 `EDI` 寄存器会被修改，</span></span><br><span class="line"><span class="comment">但在许多情况下，列出clobbered registers是很有必要的，因为它可以帮助编译器更好地优化生成的代码。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以，理论上，你的代码应该像这样：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int count = 1;</span></span><br><span class="line"><span class="comment">int value = 1;</span></span><br><span class="line"><span class="comment">int buf[10];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void main()&#123;</span></span><br><span class="line"><span class="comment">    asm(</span></span><br><span class="line"><span class="comment">        &quot;cld \n\t&quot;</span></span><br><span class="line"><span class="comment">        &quot;rep \n\t&quot;</span></span><br><span class="line"><span class="comment">        &quot;stosl&quot;</span></span><br><span class="line"><span class="comment">        :</span></span><br><span class="line"><span class="comment">        : &quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf)</span></span><br><span class="line"><span class="comment">        : &quot;ecx&quot;, &quot;eax&quot;, &quot;edi&quot;</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这里，`&quot;ecx&quot;, &quot;eax&quot;, &quot;edi&quot;` 是clobber list，告诉编译器这些寄存器的值已经被汇编代码修改了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>3、掌握指针和类型转换相关的Ｃ编程</p><p>实验源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_IG32 0xE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_TG32 0xF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">uint32_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)&#123;\</span></span><br><span class="line"><span class="meta">    (gate).gd_off_15_0 = (uint32_t)(off) &amp; 0xffff;\</span></span><br><span class="line"><span class="meta">    (gate).gd_ss = (sel);\</span></span><br><span class="line"><span class="meta">    (gate).gd_args = 0;\</span></span><br><span class="line"><span class="meta">    (gate).gd_rsv1 = 0;\</span></span><br><span class="line"><span class="meta">    (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;\</span></span><br><span class="line"><span class="meta">    (gate).gd_s = 0;\</span></span><br><span class="line"><span class="meta">    (gate).gd_dpl = (dpl);\</span></span><br><span class="line"><span class="meta">    (gate).gd_p = 1;\</span></span><br><span class="line"><span class="meta">    (gate).gd_off_31_16 = (uint32_t)(off) &gt;&gt; 16;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> gd_off_15_0: <span class="number">16</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_ss: <span class="number">16</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_args: <span class="number">5</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_rsv1: <span class="number">3</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_type: <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_s: <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_dpl: <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_p: <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_off_31_16: <span class="number">16</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> before;</span><br><span class="line">    <span class="type">unsigned</span> intr;</span><br><span class="line">    <span class="type">unsigned</span> after;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> <span class="title">gintr</span>;</span></span><br><span class="line"></span><br><span class="line">    intr = <span class="number">8</span>;</span><br><span class="line">    before = after = <span class="number">0</span>;</span><br><span class="line">    gintr = *((<span class="keyword">struct</span> gatedesc*)&amp;intr);</span><br><span class="line">    SETGATE(gintr, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    intr = *((<span class="type">unsigned</span>*)&amp;(gintr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;intr is 0x%x\n&quot;</span>, intr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gintr is 0x%llx\n&quot;</span>, gintr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己根据输出即可推出来是怎么做的。注意，<code>gintr</code>等于<code>0xee0000010002</code>中，最高16位全部等于0没有展示出来。而%x只能展示32位，所以<code>intr</code>的输出结果为：<code>0x10002</code>。</p><h4 id="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"><a href="#一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？" class="headerlink" title="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"></a>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</h4><p>硬盘主引导扇区（Master Boot Record，MBR）是位于硬盘第一个扇区（通常是逻辑地址0号扇区）的512字节的数据结构，用于引导计算机操作系统。一个符合规范的硬盘主引导扇区应该包含以下几个特征：</p><ol><li><p><strong>引导代码（Boot Code）：</strong> 前446个字节用于存储引导代码，这是引导加载程序（Boot Loader）的代码，负责加载操作系统。这段代码必须是有效的汇编代码，能够启动计算机。</p></li><li><p><strong>分区表（Partition Table）：</strong> 接下来的64字节用于存储分区表，每个分区表项占16字节。一个硬盘可以分为最多4个主分区，每个分区表项描述一个分区的起始位置、大小和分区类型等信息。</p></li><li><p><strong>签名字节（Signature）：</strong> 最后的两个字节（0x55AA）是MBR的签名，标志这个扇区是有效的MBR扇区。这个签名是个小端字节序的16位值，它告诉操作系统这个扇区包含了引导信息，是一个有效的MBR。</p></li></ol><p>总结起来，一个被系统认为是符合规范的硬盘主引导扇区应该包含引导代码、分区表和签名字节。这些特征是为了确保引导加载程序可以正确地读取分区信息，从而启动操作系统。如果这些特征中的任何一个缺失或损坏，可能导致系统无法正确引导。</p><p>引导扇区代码（<code>tools/sign.c</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span> </span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: &lt;input filename&gt; &lt;output filename&gt;\n&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stat(argv[<span class="number">1</span>], &amp;st) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error opening file &#x27;%s&#x27;: %s\n&quot;</span>, argv[<span class="number">1</span>], strerror(errno)); </span><br><span class="line">        <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&#x27;%s&#x27; size: %lld bytes\n&quot;</span>, argv[<span class="number">1</span>], (<span class="type">long</span> <span class="type">long</span>)st.st_size); </span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; <span class="number">510</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%lld &gt;&gt; 510!!\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)st.st_size); </span><br><span class="line">        <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf)); </span><br><span class="line">    FILE*ifp=fopen(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="type">int</span> size = fread(buf, <span class="number">1</span>,st.st_size, ifp); </span><br><span class="line">    <span class="keyword">if</span> (size != st.st_size) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;read &#x27;%s&#x27; error, size is %d.\n&quot;</span>, argv[<span class="number">1</span>], size); </span><br><span class="line">        <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ifp);</span><br><span class="line">    buf[<span class="number">510</span>]= <span class="number">0x55</span>; </span><br><span class="line">    buf[<span class="number">511</span>] =<span class="number">0xAA</span>;</span><br><span class="line">    FILE*ofp = fopen(argv[<span class="number">2</span>], <span class="string">&quot;wb+&quot;</span>);</span><br><span class="line">    size = fwrite(buf, <span class="number">1</span>, <span class="number">512</span>, ofp); </span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">512</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;write &#x27;%s&#x27; error, size is %d.\n&quot;</span>, argv[<span class="number">2</span>], size); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ofp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;build 512 bytes boot sector: &#x27;%s&#x27; success!\n&quot;</span>, argv[<span class="number">2</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">这是一个简单的C程序，用于生成一个包含引导代码的512字节的引导扇区（Boot Sector）。这样的引导扇区通常用于创建可引导的存储介质，例如硬盘、U盘等。以下是程序的主要功能和流程：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 使用 `stat` 函数获取指定输入文件（`argv[1]`）的信息，主要是文件大小。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 打印输入文件的大小。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 检查文件大小是否超过了510字节。如果超过，打印错误信息并退出程序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 读取输入文件的内容（最多510字节），将内容存储在一个大小为512字节的缓冲区中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5. 在缓冲区的倒数第二个字节（第510字节）写入0x55，倒数第一个字节（第511字节）写入0xAA。这是引导扇区的标志，用于告诉计算机系统这是一个有效的引导扇区。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6. 打开输出文件（`argv[2]`），将修改后的缓冲区写入文件。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">7. 打印成功信息并返回0。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这个程序的目的是创建一个符合标准的引导扇区，其中包含引导代码和标志字节。请注意，生成的引导扇区在实际使用时需要按照引导扇区的规范进行进一步配置，以确保它能够正确地引导计算机系统。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以下是程序的一些可能的改进和注意事项：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 添加更多的错误检查，例如检查文件是否成功打开。</span></span><br><span class="line"><span class="comment">- 考虑处理更多的边界情况，例如文件是否为空。</span></span><br><span class="line"><span class="comment">- 考虑使用二进制文件读写模式（&quot;rb&quot; 和 &quot;wb+&quot;）而不是文本模式。</span></span><br><span class="line"><span class="comment">- 考虑使用 `perror` 函数来打印与 `fopen`、`fread`、`fwrite` 相关的错误信息。</span></span><br><span class="line"><span class="comment">- 考虑处理大端和小端字节序的问题，特别是当涉及到二进制文件时。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、操作系统要干啥？哪些操作&amp;#x2F;任务不属于操作系统的管理范畴？&lt;/p&gt;
&lt;p&gt;2、工具使用&lt;/p&gt;
&lt;p&gt;阅读源码工具：&lt;code&gt;understannd&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;源码文档自动生成工具：&lt;code&gt;doxygen&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;虚拟</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://zcl0219.github.io/2023/10/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zcl0219.github.io/2023/10/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-10-06T18:57:06.000Z</published>
    <updated>2023-10-06T18:57:06.148Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器-第八章</title>
    <link href="http://zcl0219.github.io/2023/09/07/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
    <id>http://zcl0219.github.io/2023/09/07/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%AC%AC%E5%85%AB%E7%AB%A0/</id>
    <published>2023-09-07T01:30:19.000Z</published>
    <updated>2023-09-07T01:44:27.621Z</updated>
    
    <content type="html"><![CDATA[<p>这里因为做项目的需要，我先写下8.6节有关有限状态机的内容</p><p>这一节我们介绍逻辑单元内部的一种高效编程方法：有限状态机。有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里因为做项目的需要，我先写下8.6节有关有限状态机的内容&lt;/p&gt;
&lt;p&gt;这一节我们介绍逻辑单元内部的一种高效编程方法：有限状态机。有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CMake</title>
    <link href="http://zcl0219.github.io/2023/08/29/CMake/"/>
    <id>http://zcl0219.github.io/2023/08/29/CMake/</id>
    <published>2023-08-29T14:34:47.000Z</published>
    <updated>2023-09-06T02:00:51.820Z</updated>
    
    <content type="html"><![CDATA[<p>这里画一个图直接直接展示一下CMake和Makefile的使用过程</p><p><img src="png1.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ *.cpp -o app  <span class="comment">//直接编译    </span></span><br></pre></td></tr></table></figure><p>使用#注释</p><p>块注释#[[ ]]</p><p>camke_minimum_required：指定使用的cmake的最低版本</p><p>project：定义工程名称</p><p>add_executable：定义工程会生成一个可执行程序 add_executable(可执行程序名称 源文件名称（空格或者分号隔离源文件)）</p><p>cmake CMakeLists.txt：文件所在路径</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(app, add.cpp div.cpp mult.cpp main.cpp sub.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果CMakeLists.txt文件就在当前目录下，直接执行以下命令</span></span><br><span class="line">cmake .</span><br><span class="line">make</span><br><span class="line"><span class="comment">#就会出现app可执行文件</span></span><br></pre></td></tr></table></figure><p>生成了很多其他文件，我们可以把这些临时文件放在一个文件夹里，一般为build文件夹。创建build文件后，cd进build文件，执行camke ..，则cmake执行后生成的文件都放在了build文件夹里。</p><h3 id="set的使用"><a href="#set的使用" class="headerlink" title="set的使用"></a><code>set</code>的使用</h3><p>set是为了简化add_executable(app, add.cpp div.cpp mult.cpp main.cpp sub.cpp)的编写，要不然这样和直接编译感觉没啥区别。set给一个变量赋值都是字符串类型，这些文件的名字会作为一个字符串存在变量里。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set指令的语法是：</span></span><br><span class="line"><span class="comment"># [] 中的参数为可选项，如不需要可以不写</span></span><br><span class="line"><span class="keyword">set</span>(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># VAR：变量名</span></span><br><span class="line"><span class="comment"># VALUE：变量值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一：各个源文件之间使用空格间隔</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST add.c div.c main.c mult.c sub.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二：各个源文件之间使用;间隔</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST add.c;div.c;main.c;mult.c;sub.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><p>取变量值必须以这种方式。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &quot;$ + &#123;变量名&#125;&quot;</span></span><br><span class="line"><span class="variable">$&#123;SRC_LIST&#125;</span></span><br></pre></td></tr></table></figure><p>还可以通过set设置使用C++的标准（C++11，C++17）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正常编译选定c++标准</span></span><br><span class="line">g++ *.cpp -std=c++11 -o app</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用camke指定c++标准，对应有一个宏叫做DCMAKE_Cxx_STANDARD</span></span><br><span class="line"><span class="comment"># 由两种方式指定C++标准</span></span><br><span class="line"><span class="comment"># 第一种：在CMakeLists.txt中通过set命令指定</span></span><br><span class="line"><span class="keyword">set</span>(CAMKE_CXX_STANDARD <span class="number">11</span>)  <span class="comment"># 等价于增加 -std=c++11</span></span><br><span class="line"><span class="keyword">set</span>(CAMKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="keyword">set</span>(CAMKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种：在执行camke命令的时候制定出这个宏的值</span></span><br><span class="line">camke CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=<span class="number">11</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=<span class="number">14</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=<span class="number">17</span></span><br></pre></td></tr></table></figure><p>set还可以指定输出路径，建议使用绝对路径，如果这个路径中的子目录不存在，会自动生成，无需自己手动创建。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在CMake中指定可执行程序输出的路径，也对应一个宏，叫做EXECUTABLE_OUTPUT_PATH，它的值还是通过set命令设置</span></span><br><span class="line"><span class="keyword">set</span>(HOME /home/zcl/linux/soft)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_UOTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>/bin)</span><br><span class="line"><span class="comment"># 第一行：定义一个变量用于存储一个绝对路径</span></span><br><span class="line"><span class="comment"># 第二行：将拼接好的路径值设置给EXECUTABLE_OUTPUT_PATH宏</span></span><br></pre></td></tr></table></figure><h3 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h3><p>我们可以看到我们上面所讲的使用set并没有解决要将所有源文件名字写出来的本质问题。为了解决这个问题，这里我们讲一下通过搜索某个目录下的文件来引入源文件的方法。CMake给我们提供了两种方法来搜索文件，aux_source_directory命令或者file命令。</p><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>在CMake中使用aux_source_directory命令可以查找某个路径下的所有源文件。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(&lt;dir&gt; &lt;variable&gt;)</span><br><span class="line"><span class="comment"># dir：要搜索的目录</span></span><br><span class="line"><span class="comment"># variable：将从dir目录下搜索到的源文件列表存储到该变量中</span></span><br><span class="line"><span class="comment"># 这里介绍一个宏，PROJECT_SOURCE_DIR宏代表的就是我们在camke命令后携带的那个路径。比如camke ..，PROJECT_SORCE_DIR宏代表的就是`..`</span></span><br><span class="line"><span class="comment"># 再介绍另外一个宏，CMAKE_CURRENT_SOURCE_DIR宏代表的就是当前CMakelists.txt文件所在的路径</span></span><br><span class="line"><span class="comment"># 下面进入实操，比如搜索当前CMakelists.txt文件所在目录下的src目录</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src SRC_LIST)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>通过file命令来搜索出所有需要的源文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line"><span class="keyword">file</span>(GLOB 变量名 要搜索的文件路径和文件类型)</span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</span><br><span class="line"><span class="comment"># GLOB：将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中</span></span><br><span class="line"><span class="comment"># GLOB_RECURSE：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中</span></span><br><span class="line"><span class="comment"># 比如：搜索当前目录的src目录下所有的源文件，并将其存储到变量中</span></span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="variable">$&#123;CAMKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/*.h)</span><br><span class="line"><span class="comment"># 注：关于要搜索的文件路径和类型可以加双引号，也可不加</span></span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="搜索头文件路径"><a href="#搜索头文件路径" class="headerlink" title="搜索头文件路径"></a>搜索头文件路径</h3><p>在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能找到这些头文件。在CMake里搜索头文件的命令也很简单</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(headpath)</span><br><span class="line"><span class="comment"># headpath就是头文件路径，这里建议写绝对路径</span></span><br><span class="line"><span class="comment"># 实操</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><h3 id="通过CMake制作库文件"><a href="#通过CMake制作库文件" class="headerlink" title="通过CMake制作库文件"></a>通过CMake制作库文件</h3><p>有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来讲解在cmake中生成这两类库文件的方法。</p><h4 id="制作静态库"><a href="#制作静态库" class="headerlink" title="制作静态库"></a>制作静态库</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在cmake中，如果要制作静态库，需要使用的命令如下：</span></span><br><span class="line"><span class="keyword">add_library</span>(库名称 STATIC 源文件<span class="number">1</span> [源文件<span class="number">2</span>] ...) </span><br><span class="line"><span class="comment"># 注：在Linux中，静态库名字分为三部分：lib+库名字+.a，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。</span></span><br><span class="line"><span class="comment"># 如果是动态库，最终生成的库的名字就是：libXXX.so(Linux)，libXXX.dll(Windows)；</span></span><br><span class="line"><span class="comment"># 如果是静态库，最终生成的库的名字就是：libXXX.a(Linux)，libXXX.lib(Windows)；</span></span><br><span class="line"><span class="comment"># 下面有一个目录，需要将src目录中的源文件编译成静态库，然后再使用：</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── <span class="keyword">include</span>           <span class="comment"># 头文件目录</span></span><br><span class="line">│   └── head.h</span><br><span class="line">├── main.cpp          <span class="comment"># 用于测试的源文件</span></span><br><span class="line">└── src               <span class="comment"># 源文件目录</span></span><br><span class="line">    ├── add.cpp</span><br><span class="line">    ├── div.cpp</span><br><span class="line">    ├── mult.cpp</span><br><span class="line">    └── sub.cpp</span><br><span class="line"><span class="comment"># 根据上面的目录结构，可以这样编写CMakeLists.txt文件:</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 注：STATIC对应的是静态库，SHARED对应的是动态库</span></span><br></pre></td></tr></table></figure><h4 id="制作动态库"><a href="#制作动态库" class="headerlink" title="制作动态库"></a>制作动态库</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(calc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><h4 id="指定输出路径"><a href="#指定输出路径" class="headerlink" title="指定输出路径"></a>指定输出路径</h4><p>对于生成的库文件来说和可执行程序一样都可以指定输出路径。这里使用LIBRARY_OUTPUT_PATH宏，这个宏对应静态库文件和动态库文件都适用。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="comment"># 设置动态库/静态库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="comment">#add_library(calc SHARED $&#123;SRC_LIST&#125;)</span></span><br><span class="line"><span class="comment"># 生成静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="包含库文件"><a href="#包含库文件" class="headerlink" title="包含库文件"></a>包含库文件</h3><p>在编写程序的过程中，可能会用到一些系统提供的动态库或者自己制作出的动态库或者静态库文件，cmake中也为我们提供了相关的加载动态库的命令。</p><h4 id="链接静态库"><a href="#链接静态库" class="headerlink" title="链接静态库"></a>链接静态库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── add.cpp</span><br><span class="line">├── div.cpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── mult.cpp</span><br><span class="line">└── sub.cpp</span><br></pre></td></tr></table></figure><p>现在我们把上面src目录中的add.cpp、div.cpp、mult.cpp、sub.cpp编译成一个静态库文件libcalc.a。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试目录结构</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span> </span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.a     # 制作出的静态库的名字</span><br><span class="line">└── src</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br><span class="line">4 directories, 4 files</span><br></pre></td></tr></table></figure><p>在cmake中，链接静态库的命令如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_libraries</span>(&lt;static lib&gt; [&lt;static lib&gt;...])</span><br><span class="line"><span class="comment"># 参数1：指定出要链接的静态库的名字，可以是全名 libxxx.a，也可以是掐头（lib）去尾（.a）之后的名字 xxx</span></span><br><span class="line"><span class="comment"># 参数2-N：要链接的其它静态库的名字</span></span><br></pre></td></tr></table></figure><p>如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(&lt;lib path&gt;)</span><br></pre></td></tr></table></figure><p>这样，修改之后的CMakeLists.txt文件内容如下:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="comment"># 搜索指定目录下源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="comment"># 包含头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 包含静态库路径 添加了这行代码，就可以根据参数指定的路径找到这个静态库了。</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 链接静态库</span></span><br><span class="line"><span class="keyword">link_libraries</span>(calc)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><h4 id="链接动态库"><a href="#链接动态库" class="headerlink" title="链接动态库"></a>链接动态库</h4><p>target不知道这个符号是来自它链接的多个库中的哪一个库，它只知道有这么一个库。</p><p>FATAL_ERROR：CMake 错误, 终止所有处理过程（CMake在生成”message to display”这条消息之后就不在执行了，直接中断）</p><p>CMake在底层管理的时候会将子字符串通过分号隔开，但通过message打印变量值的时候，看不到这个分号。这个分号有助于cmake进行字符串删除操作。只能删除组成变量的子串。比如一开始SRC&#x3D;”A123”，后来apeend了“456”, “789”，如果没有分号，你可能可以删除”345”，但有了分号后，就删除不了了，你只能删除组成SRC的完整的子串，比如”A123”, “456”等。</p><p>注意，存储列表长度的output variable依旧是一个字符串类型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里画一个图直接直接展示一下CMake和Makefile的使用过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;png1.png&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://zcl0219.github.io/2023/08/29/MySQL/"/>
    <id>http://zcl0219.github.io/2023/08/29/MySQL/</id>
    <published>2023-08-29T13:56:11.000Z</published>
    <updated>2023-10-09T08:27:20.733Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DAY1"><a href="#DAY1" class="headerlink" title="DAY1"></a><code>DAY1</code></h3><p>使用指令创建数据库：CREATE DATABASE zcl_db01;</p><p>删除数据库指令：DROP DATABASE zcl_db01;</p><p>创建一个使用utf8字符集的zcl_db02数据库：CREATE DATABASE zcl_db02 CHARACTER SET utf8</p><p>创建一个使用utf8字符集，并带校对规则的zcl_db03数据库：CREATE DATABASE zcl_db03 CHARACTER SET utf8 COLLATE utf8_bin<br>utf8_bin区分大小写，utf8_general_ci不区分大小写</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查看当前数据库服务器中的所有数据库</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES</span><br><span class="line"></span><br><span class="line">#查看前面创建的zcl_db01数据库的定义信息</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE `zcl_db01`</span><br><span class="line"></span><br><span class="line">#在创建数据库、表的时候，为了规避关键字，可以使用``解决</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE `<span class="keyword">CREATE</span>`</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#备份数据库</span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p <span class="operator">-</span>B zcl_db03 <span class="operator">&gt;</span> e:\\tmp.sql (文件名)</span><br><span class="line"></span><br><span class="line">#恢复数据库</span><br><span class="line">source e:\\tmp.sql</span><br><span class="line"></span><br><span class="line">#备份数据库的表</span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p zcl_db03 t1 t2 (t1和t2是表名) <span class="operator">&gt;</span> e:\\tmp1.sql</span><br></pre></td></tr></table></figure><h3 id="DAY2"><a href="#DAY2" class="headerlink" title="DAY2"></a><code>DAY2</code></h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 创建表</span><br><span class="line"># create table table_name</span><br><span class="line"># (</span><br><span class="line"># filed1 datatype,</span><br><span class="line">#filed2 datatype,</span><br><span class="line">#filed3 datatype</span><br><span class="line"># )character set 字符集 collate 校对规则 engine 存储引擎</span><br><span class="line">#  filed：指定列名   datatype：指定列类型（字段类型）</span><br><span class="line">#  character set：如不指定则为所在数据库字符集</span><br><span class="line">#  collate：如不指定则为所在数据库校对规则</span><br><span class="line"></span><br><span class="line"># 实操</span><br><span class="line">create table `user`(</span><br><span class="line">id int,</span><br><span class="line">    `name` varchar(255),</span><br><span class="line">    `passward` varchar(255),</span><br><span class="line">    `birthday` date</span><br><span class="line">)character set utf8 collate utf8_general_ci engine innodb; </span><br></pre></td></tr></table></figure><h4 id="Mysql常用数据类型"><a href="#Mysql常用数据类型" class="headerlink" title="Mysql常用数据类型"></a>Mysql常用数据类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Mysql列类型就是Mysql的数据类型</span><br><span class="line"># 数值类型：</span><br><span class="line"># 整型：tinyint(1个字节)smallint(2个字节)mediumint(3个字节)int(4个字节)bigint(8个字节)</span><br><span class="line"># 小数类型：float(单精度 4个字节)double(双精度 8个字节)decimal[M,D](大小不确定，M代表长度，D代表小数位数)</span><br><span class="line"></span><br><span class="line"># 文本类型（字符串类型）</span><br><span class="line"># char(0-255)varchar(0~65535)text(0~2^16-1)longtext(0~2^32-1)</span><br><span class="line"></span><br><span class="line"># 二进制数据类型</span><br><span class="line"># blob[0~2^16-1]longblob[0~2^32-1]</span><br><span class="line"></span><br><span class="line"># 日期类型</span><br><span class="line"># date[日期 年月日] time[时间 时分秒]datetime[年月日 时分秒 YYYY-MM-DD HH:MM:SS]timestamp[时间戳]</span><br></pre></td></tr></table></figure><p>在满足需求的情况下，尽量选择占用空间小的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t3(</span><br><span class="line">id TINYINT</span><br><span class="line">);</span><br><span class="line"># INSERT INTO t3 VALUES(128); 错误：越界了，超过了tinyint范围。 </span><br><span class="line">INSERT INTO t3 VALUES(127);</span><br><span class="line"># 定义无符号的整数 指定unsigned</span><br><span class="line">CREATE TABLE t4(</span><br><span class="line">id TINYINT UNSIGNED</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># BIT(M), M在1-64。显示按照bit。</span><br><span class="line">CREATE TABLE t5(</span><br><span class="line">num BIT(8)</span><br><span class="line">);</span><br><span class="line">INSERT INTO t5 VALUES(255);</span><br><span class="line">SELECT * FROM t5;</span><br><span class="line"># 输出：11111111</span><br><span class="line">SELECT * FROM t5 WHERE num = 255;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># DECIMAL[M, D] </span><br><span class="line"># M是小数位数（精度）的总数，D是小数点（标度）后面的位数。</span><br><span class="line"># 如果D是0，则值没有小数点或分数部分，M最大是65，D最大是30。如果D被省略，则默认是0，如果M被省略，默认是10。</span><br><span class="line">CREATE TABLE t6(</span><br><span class="line">num1 FLOAT,</span><br><span class="line">    num2 DOUBLE,</span><br><span class="line">    num3 DECIMAL(30, 20)</span><br><span class="line">);</span><br><span class="line">INSERT INTO t6 VALUES(88.123456789123456, 88.123456789123456, 88.123456789123456)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># char(4) 这个4表示字符数（最大255），不是字节数，不管是中文还是英文都是放四个，按字符计算，定长，即使你插入&#x27;aa&#x27;，也会占用分配的4个字符的空间</span><br><span class="line"># varchar(4) 这个4表示字符数，是变长，如果你插入&#x27;aa&#x27;，实际占用空间并不是4个字符，而是实际占用的空间。</span><br><span class="line"># utf-8：一个字符占三个字节</span><br><span class="line">CREATE TABLE t11(</span><br><span class="line">&#x27;name&#x27; CHAR(4)</span><br><span class="line">);</span><br><span class="line"># INSERT INTO t11 VALUES(&#x27;ABCDE&#x27;) 报错，太长</span><br><span class="line">INSERT INTO t11 VALUES(&#x27;ABCD&#x27;)</span><br><span class="line">INSERT INTO t11 VALUES(&#x27;你好&#x27;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 日期类型 date datetime timestamp</span><br><span class="line">CREATE TABLE birthday11(</span><br><span class="line">birthday DATE,</span><br><span class="line">    worktime DATETIME,</span><br><span class="line">    login_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</span><br><span class="line">);</span><br><span class="line">INSERT INTO bithday11(birthday, worktime) VALUES(&#x27;2022-11-11&#x27;, &#x27;2022-11-11 10:10:10&#x27;);</span><br></pre></td></tr></table></figure><h4 id="创建表的课堂练习"><a href="#创建表的课堂练习" class="headerlink" title="创建表的课堂练习"></a>创建表的课堂练习</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#x27;emp&#x27;(</span><br><span class="line">id INT,</span><br><span class="line">    &#x27;name&#x27; VARCHAR(32),</span><br><span class="line">    sex CHAR(1),</span><br><span class="line">    birthday DATE,</span><br><span class="line">    entry_date DATETIME,</span><br><span class="line">    job VARCHAR(32),</span><br><span class="line">    saraly DOUBLE,</span><br><span class="line">    &#x27;resume&#x27; TEXT</span><br><span class="line">) CHARSET utf8 COLLATE utf8_bin ENGINE INNODB;</span><br><span class="line">INSERT INTO &#x27;emp&#x27; VALUES(</span><br><span class="line">100, &#x27;小妖怪&#x27;, &#x27;男&#x27;, &#x27;2000-11-11&#x27;, &#x27;巡山的&#x27;, 3000, &#x27;大王叫我来巡山&#x27;</span><br><span class="line">);</span><br><span class="line">SELECT * FROM &#x27;emp&#x27;;</span><br><span class="line"></span><br><span class="line"># 增加列</span><br><span class="line">ALTER TABLE emp ADD image VARCHAR(32) NOT NULL DEFAULT &#x27;&#x27; AFTER RESUME</span><br><span class="line"></span><br><span class="line"># 显示表结构</span><br><span class="line">DESC emp</span><br><span class="line"></span><br><span class="line"># 修改job长度</span><br><span class="line">ALTER TABLE emp MODIFY job VARCHAR(60) NOT NULL DEFAULT &#x27;&#x27;</span><br><span class="line"></span><br><span class="line"># 删除列</span><br><span class="line">ALTER TABLE emp DROP sex</span><br><span class="line"></span><br><span class="line"># 修改表名</span><br><span class="line">RENAME TABLE emp TO employee</span><br><span class="line"></span><br><span class="line"># 修改表的字符集</span><br><span class="line">ALTER TABLE employee CHARACTER SET utf8</span><br><span class="line"></span><br><span class="line"># 修改列名</span><br><span class="line">ALTER TABLE employee CHANGE &#x27;name&#x27; user_name VARCHAR(64) NOT NULL DEFAULT &#x27;&#x27;</span><br></pre></td></tr></table></figure><h4 id="数据库CRUD语句"><a href="#数据库CRUD语句" class="headerlink" title="数据库CRUD语句"></a>数据库CRUD语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 使用INSERT语句向表中插入数据</span><br><span class="line">CREATE TABLE &#x27;goods&#x27;(</span><br><span class="line">id INT,</span><br><span class="line">    goods_name VARCHAR(10),</span><br><span class="line">    price DOUBLE</span><br><span class="line">);</span><br><span class="line">INSERT INTO &#x27;goods&#x27; (id, goods_name, price) VALUES (10, &#x27;华为手机&#x27;, 2000);</span><br><span class="line">INSERT INTO &#x27;goods&#x27; (id, goods_name, price) VALUES (20, &#x27;苹果手机&#x27;, 20000);</span><br><span class="line"></span><br><span class="line"># INSERT语句的细节</span><br><span class="line">-- 插入的数据应与字段的数据类型相同，比如把&#x27;abc&#x27;添加到int类型会错误。</span><br><span class="line">-- 数据的长度应在列的规定范围内，不能将一个长度为80的字符串加入到长度为40的列中。</span><br><span class="line">-- 在VALUES中列出的数据位置必须与被加入的列的排列位置相对应。</span><br><span class="line">-- 字符和日期类型应包含在单引号中</span><br><span class="line">-- 列可以插入空值，前提是该字段允许为空（没有NOT NULL）</span><br><span class="line">-- INSERT INTO TABLE_NAME (列名) VALUES (),(),()，添加多条数据一次性</span><br><span class="line">-- 如果是给表中的所有字段添加数据，(id, goods_name, price)这个可以省略</span><br><span class="line">-- 默认值的使用，当不给某个字段赋值时，如果有默认值就会添加，否则报错。</span><br><span class="line">-- 如果我们希望指定某个列的默认值，可以在创建表时指定。</span><br><span class="line">CREATE TABLE &#x27;goods2&#x27;(</span><br><span class="line">id INT,</span><br><span class="line">    goods_name VARCHAR(10),</span><br><span class="line">    price DOUBLE NOT NULL DEFAULT 100</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 演示update语句</span><br><span class="line">-- employee是表名，salary是列名</span><br><span class="line">-- 将所有员工薪水修改为5000，如果没有带where条件，会修改所有的记录，因此要小心</span><br><span class="line">UPDATE employee SET salary = 5000 </span><br><span class="line">-- 将姓名为小妖怪的员工薪水修改为3000</span><br><span class="line">UPDATE employee SET salary = 3000 WHERE user_name = &#x27;小妖怪&#x27;</span><br><span class="line">-- 将老妖怪的薪水在原有基础上增加1000</span><br><span class="line">INSERT INTO employee VALUES(200, &#x27;老妖怪&#x27;, &#x27;1990-11-11&#x27;, &#x27;2000-11-11 10:10:10&#x27;, &#x27;捶背的&#x27;, 5000,  &#x27;给大王捶背的&#x27;);</span><br><span class="line">UPDATE employee SET salary = salary + 1000 WHERE user_name = &#x27;老妖怪&#x27;</span><br><span class="line">UPDATE employee SET salary = salary + 1000, job = &#x27;出主意的&#x27; WHERE user_name = &#x27;老妖怪&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 演示delete语句</span><br><span class="line">-- 删除表中名称为‘老妖怪’的记录</span><br><span class="line">DELETE FROM employee WHERE user_name = &#x27;老妖怪&#x27;;</span><br><span class="line">-- 删除表中所有记录</span><br><span class="line">DELETE FROM employee</span><br><span class="line">-- DELETE删除不了一列的值，但可以使用UPDATE语句置为null</span><br><span class="line">UPDATE employee SET job = NULL WHERE user_name = &#x27;老妖怪&#x27;;</span><br><span class="line">-- 要删除这个表</span><br><span class="line">DROP TABLE employee</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">-- select指定查询哪些列的数据</span><br><span class="line">-- *代表查询所有列</span><br><span class="line">-- from指定查询哪张表</span><br><span class="line">-- DISTINCT可选，指显示结果时，是否去掉重复数据</span><br><span class="line">CREATE TABLE student(</span><br><span class="line">id INT NOT NULL DEFAULT 1,</span><br><span class="line">    NAME VARCHAR(20) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">    chinese FLOAT NOT NULL DEFAULT 0.0,</span><br><span class="line">    english FLOAT NOT NULL DEFAULT 0.0,</span><br><span class="line">    math FLOAT NOT NULL DEFAULT 0.0</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(1, &#x27;韩顺平&#x27;, 89, 78, 90);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(2, &#x27;张飞&#x27;, 67, 98, 56);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(3, &#x27;宋江&#x27;, 87, 78, 77);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(4, &#x27;关羽&#x27;, 88, 98, 90);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(5, &#x27;赵云&#x27;, 82, 84, 67);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(6, &#x27;欧阳锋&#x27;, 55, 85, 45);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(7, &#x27;黄蓉&#x27;, 75, 65, 30);</span><br><span class="line"></span><br><span class="line">SELECT * FROM student;</span><br><span class="line"></span><br><span class="line">-- 查寻表中所有学生的信息</span><br><span class="line">SELECT * FROM student;</span><br><span class="line"></span><br><span class="line">-- 查询表中所有学生的姓名和对应的英语成绩</span><br><span class="line">SELECT &#x27;NAME&#x27;, english FROM student;</span><br><span class="line"></span><br><span class="line">-- 过滤表中重复数据distinct</span><br><span class="line">-- 要查询的记录每个字段都相同，才会去重</span><br><span class="line">SELECT DISTINCT english FROM student;</span><br><span class="line"></span><br><span class="line">-- 统计每个学生的总分</span><br><span class="line">SELECT &#x27;NAME&#x27;, (chinese + english + math) FROM student;</span><br><span class="line"></span><br><span class="line">-- 在所有学生总分加10分</span><br><span class="line">SELECT &#x27;NAME&#x27;, (chinese + english + math + 10) FROM student;</span><br><span class="line"></span><br><span class="line">-- 使用别名表示学生分数</span><br><span class="line">SELECT &#x27;NAME&#x27;, (chinese + english + math + 10) AS total_score FROM student;</span><br><span class="line">SELECT &#x27;NAME&#x27; AS &#x27;名字&#x27;, (chinese + english + math + 10) AS total_score FROM student;</span><br><span class="line"></span><br><span class="line">-- 查询姓名为赵云的学生成绩</span><br><span class="line">SELECT * FROM student WHERE &#x27;NAME&#x27; = &#x27;赵云&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询英语成绩大于90分的同学</span><br><span class="line">SELECT * FROM student WHERE english &gt; 90;</span><br><span class="line"></span><br><span class="line">-- 查询总分大于200分的所有同学</span><br><span class="line">SELECT * FROM student WHERE (chinese + english + math) &gt; 200;</span><br><span class="line"></span><br><span class="line">-- 查询math大于60并且id大于4的学生成绩</span><br><span class="line">SELECT * FROM student WHERE math &gt; 60 AND id &gt; 4;</span><br><span class="line"></span><br><span class="line">-- 查询英语成绩大于语文成绩的同学</span><br><span class="line">SELECT * FROM student WHERE english &gt; chinese;</span><br><span class="line"></span><br><span class="line">-- 查询总分大于200分并且数学成绩小于语文成绩的姓韩的学生</span><br><span class="line">-- 韩% 表示名字以韩开头的就可以</span><br><span class="line">SELECT * FROM student WHERE (chinese + english + math) &gt; 200 AND </span><br><span class="line">  math &lt; chinese AND &#x27;NAME&#x27; LIKE &#x27;韩%&#x27;;</span><br><span class="line">  </span><br><span class="line">-- 查询英语分数在80-90之间的同学</span><br><span class="line">SELECT * FROM student WHERE english &gt;= 80 AND english &lt;= 90;</span><br><span class="line">SELECT * FROM student WHERE english BETWWWN 80 AND 90; -- BETWEEN AND 是闭区间</span><br><span class="line"></span><br><span class="line">-- 查询数学分数为89，90，91的同学</span><br><span class="line">SELECT * FROM student WHERE math = 89 OR math = 90 OR math = 91;</span><br><span class="line">SELECT * FROM student WHERE math IN (89, 90, 91);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;DAY1&quot;&gt;&lt;a href=&quot;#DAY1&quot; class=&quot;headerlink&quot; title=&quot;DAY1&quot;&gt;&lt;/a&gt;&lt;code&gt;DAY1&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;使用指令创建数据库：CREATE DATABASE zcl_db01;&lt;/p&gt;
&lt;p&gt;删除数据库指</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux 高性能服务器--第五章</title>
    <link href="http://zcl0219.github.io/2023/08/27/Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <id>http://zcl0219.github.io/2023/08/27/Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%AC%AC%E4%BA%94%E7%AB%A0/</id>
    <published>2023-08-27T04:45:48.000Z</published>
    <updated>2023-11-08T18:52:29.127Z</updated>
    
    <content type="html"><![CDATA[<h4 id="5-1-1-判断主机是小端字节序还是大端字节序"><a href="#5-1-1-判断主机是小端字节序还是大端字节序" class="headerlink" title="5.1.1 判断主机是小端字节序还是大端字节序"></a>5.1.1 判断主机是小端字节序还是大端字节序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">byteOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">short</span> value;</span><br><span class="line">        <span class="type">char</span> union_bytes[<span class="built_in">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    &#125;test;</span><br><span class="line">    </span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span>(test.union_bytes[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; test.union_bytes[<span class="number">1</span>] == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端字节序\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(test.union_bytes[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; test.union_bytes[<span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端字节序\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不清楚\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">byteOrder</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-3专用socket地址"><a href="#5-1-3专用socket地址" class="headerlink" title="5.1.3专用socket地址"></a>5.1.3专用<code>socket</code>地址</h4><p><code>TCP/IP</code>协议族有<code>sockaddr_in</code>和<code>sockaddr_in6</code>两个专用<code>socket</code>地址结构体，他们分别用于<code>IPv4</code>和<code>IPv6</code>，这里我只介绍<code>sockaddr_in</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;  <span class="comment">// 地址族：AF_INET</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin_port;<span class="comment">// 端口号：要用网络字节序表示</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;<span class="comment">// IPv4地址结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span>&#123;</span><br><span class="line">    <span class="type">u_int32_t</span> s_addr;<span class="comment">// 要用网络字节序表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：所有专用<code>socket</code>地址类型的变量在实际使用时都需要转换为通用<code>socket</code>地址类型<code>sockaddr</code>（强制转换即可），因为所有<code>socket</code>编程接口使用的地址参数的类型都是<code>sockaddr</code>。</p><h4 id="5-1-4IP地址转换函数"><a href="#5-1-4IP地址转换函数" class="headerlink" title="5.1.4IP地址转换函数"></a>5.1.4<code>IP</code>地址转换函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span>;<span class="comment">// 用于将字符串表示的IP地址转换为用网络字节序整数表示的IP地址</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> cnt)</span></span>;<span class="comment">// 最后一个参数指定目标存储单元的大小，这两个宏可以帮我们指定</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">inet_pton成功时返回1，失败时返回0并设置errno</span></span><br><span class="line"><span class="comment">inet_ntop成功时返回目标存储单元的地址，失败返回NULL并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET6_ADDRSTRLEN 64</span></span><br></pre></td></tr></table></figure><h4 id="5-2创建socket"><a href="#5-2创建socket" class="headerlink" title="5.2创建socket"></a>5.2创建socket</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">domain一般为PF_INET(IPv4)，或者PF_INET6(IPv6)</span></span></span><br><span class="line"><span class="comment"><span class="function">type参数指定服务类型，主要有SOCK_STREAM和SOCK_UGRAM</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span> </span></span><br></pre></td></tr></table></figure><p>socket系统调用成功时返回一个socket文件描述符，失败返回-1并设置errno</p><h4 id="5-3命名socket"><a href="#5-3命名socket" class="headerlink" title="5.3命名socket"></a>5.3命名socket</h4><p>创建socket时，我们给它指定了地址族，但是并未指定使用该地址族中的哪个具体socket地址。将一个socket与socket地址绑定称为给socket命名。在服务器程序中，我们通常需要命名socket，<strong>因为只有命名后客户端才知道该如何连接它</strong>。客户端通常不需要命名socket，而是采用匿名方式，也就是使用操作系统自动分配的socket地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* my_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bind将my_addr所指的socket地址分配给未命名的socket文件描述符，addrlen参数指出该socket地址的长度</span></span><br><span class="line"><span class="comment">bind成功时返回0，失败时返回-1并设置errno，其中两种常见的errno是：EACCES和EADDRINUSE。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="5-4监听socket"><a href="#5-4监听socket" class="headerlink" title="5.4监听socket"></a>5.4监听socket</h4><p>socket被命名之后，还不能立即接收客户端连接，我们需要使用如下系统调用来创建一个监听队列以存放待处理的客户连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sockfd参数指定被监听的socket，backlog参数提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客户端连接，客户端也将收到ECONNREFUSED错误信息。（实际上最多可以接收backlog + 1个客户端连接）</span></span><br><span class="line"><span class="comment">listen成功时返回0，失败时返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>下面我们编写一个程序测试一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">basename使用示例：</span></span><br><span class="line"><span class="comment">`basename()` 是一个常用于处理文件路径和程序参数的库函数。</span></span><br><span class="line"><span class="comment">它的主要目的是从一个给定的路径中提取基础名（base name），也就是最后一部分的名称，不包含任何前导的目录。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">来自 `&lt;libgen.h&gt;`（或在某些系统中是 `&lt;string.h&gt;` 或 `&lt;strings.h&gt;`），`basename()` 函数的原型如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">char *basename(char *path);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">让我们看一些使用 `basename()` 的例子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 输入 `/home/user/documents/file.txt` 返回 `file.txt`</span></span><br><span class="line"><span class="comment">2. 输入 `/home/user/documents/folder/` 返回 `folder`</span></span><br><span class="line"><span class="comment">3. 输入 `/home/user/documents/` 返回 `documents`</span></span><br><span class="line"><span class="comment">4. 输入 `file.txt` 返回 `file.txt`</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在给出的代码示例中：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">printf(&quot;usage: %s ip_address port_num backlog\n&quot;, basename(argv[0]));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">`argv[0]` 通常是程序的名称，包括它被执行时的完整路径。</span></span><br><span class="line"><span class="comment">使用 `basename()` 函数，你可以仅提取程序的实际名称，而不包括其路径，这在显示帮助或错误消息时特别有用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">举个例子，假设程序的完整路径是 `/home/user/my_program`，那么 `basename(argv[0])` 就会返回 `my_program`。这样，上述的 `printf` 语句将输出：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">usage: my_program ip_address port_num backlog</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">需要注意的是，`basename()` 函数可能会修改其参数，也可能返回一个指向静态存储区的指针。</span></span><br><span class="line"><span class="comment">因此，如果原始路径字符串不应被修改，那么在调用 `basename()` 之前，最好先复制这个字符串。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">term_handler</span><span class="params">(<span class="type">int</span> sig)</span>&#123;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    signal(SIGTERM, term_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_num backlog\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sockfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sign = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    server_addr.sin_family = PF_INET;</span><br><span class="line">    server_addr.sin_port = htons(port);</span><br><span class="line">    inet_pton(PF_INET, ip, &amp;server_addr.sin_addr);</span><br><span class="line"></span><br><span class="line">    sign = bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    assert(sign != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    sign = listen(sockfd, <span class="number">5</span>);</span><br><span class="line">    assert(sign != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果忘记截图了，大家可以自己试一下，具体步骤</span></span><br><span class="line"><span class="comment">./test 172.30.78.145 8000 5</span></span><br><span class="line"><span class="comment">另开终端多次telnet 172.30.78.145 8000</span></span><br><span class="line"><span class="comment">netstat -nt | grep 8000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个命令组合使用了两个命令：<code>netstat</code> 和 <code>grep</code>，并通过管道（<code>|</code>）将第一个命令的输出作为第二个命令的输入。我会为你逐步解释它：</p><ol><li><p><strong><code>netstat -nt</code></strong>:</p><ul><li><code>netstat</code>: 这是一个命令行工具，用于显示网络状态，包括网络连接、路由表、接口统计等。</li><li><code>-n</code>: 表示以数字形式显示地址和端口号，而不是尝试解析它们的名称。</li></ul></li></ol><ul><li><code>-t</code>: 仅显示TCP连接。</li></ul><p>因此，<code>netstat -nt</code> 的输出会列出系统上所有活动的TCP连接，同时显示它们的源和目标IP地址以及端口号，并直接显示数字而不进行名称解析。</p><ol start="2"><li><strong><code>|</code></strong>:</li></ol><ul><li>这是一个管道操作符，用于将前一个命令的输出作为后一个命令的输入。</li></ul><ol start="3"><li><p><strong><code>grep 8000</code></strong>:</p><ul><li><code>grep</code>: 是一个强大的文本搜索工具，用于搜索匹配的字符串。</li><li><code>8000</code>: 是你想在 <code>netstat</code> 的输出中搜索的字符串。</li></ul><p>这个命令会从 <code>netstat</code> 的输出中筛选出所有包含 “8000” 的行，这通常意味着你正在查找与端口 <code>8000</code> 相关的所有活动连接。</p></li></ol><p>综上所述，<code>netstat -nt | grep 8000</code> 会显示所有在端口 <code>8000</code> 上的活动TCP连接。</p><h4 id="5-5接受连接"><a href="#5-5接受连接" class="headerlink" title="5.5接受连接"></a>5.5接受连接</h4><p>代码：接受一个异常的连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libgen.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;运行程序，需输入这三个参数：%s, ip_address, port_num\n&quot;</span>, <span class="built_in">basename</span>(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = <span class="built_in">ntohs</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(sock, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">    <span class="type">socklen_t</span> client_len = <span class="built_in">sizeof</span>(client);</span><br><span class="line">    <span class="type">int</span> connfd = <span class="built_in">accept</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;client_len);</span><br><span class="line">    <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">char</span> remote[INET_ADDRSTRLEN];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>, <span class="built_in">inet_ntop</span>(AF_INET, &amp;client.sin_addr, remote, client_len),</span><br><span class="line">                <span class="built_in">ntohs</span>(client.sin_port));</span><br><span class="line">        <span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、第一次运行报错，<code>undefined reference to main</code>，这种情况一般有三种可能：</p><ul><li>没有定义main函数</li><li>main函数的main拼写错误</li><li>刚写的代码忘记保存了</li></ul><p>2、<code>accept</code>函数是阻塞的，上述代码即服务器端运行的时候，会阻塞在<code>accept</code>处，一旦客户端请求建立连接，服务器立马终止程序。注意<code>accept</code>只是从<code>listen</code>监听队列中取出连接，它不会理会客户端处于什么状态。</p><p>3、一直在思考<code>select/poll/epoll</code>这些有什么用。首先因为listen是有监听队列的，劣势就在于只能一个个处理，并且同时接入的连接数有限。比如队列长度为5，处理完一个，再建立下一个连接，这样如果某一个连接处理很长时间一直阻塞在那里，就导致后面的新请求连接建立超时。很直观的想法是<code>fork</code>新进程或者创建新线程来处理新连接，每来一个连接我就创建一个来跟他对接。这样资源消耗太大。因此就有了<code>select/poll/epoll</code>，先把连接建立起来并放进文件描述符，最后从这里面寻找哪些发生了可读可写事件，也避免了因为读写事件造成的阻塞（没有数据到来就阻塞了）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;5-1-1-判断主机是小端字节序还是大端字节序&quot;&gt;&lt;a href=&quot;#5-1-1-判断主机是小端字节序还是大端字节序&quot; class=&quot;headerlink&quot; title=&quot;5.1.1 判断主机是小端字节序还是大端字节序&quot;&gt;&lt;/a&gt;5.1.1 判断主机是小端字节序还</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++内存管理</title>
    <link href="http://zcl0219.github.io/2023/08/27/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://zcl0219.github.io/2023/08/27/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2023-08-27T03:48:36.000Z</published>
    <updated>2023-08-28T01:05:57.661Z</updated>
    
    <content type="html"><![CDATA[<p>有关C++内存管理问题总结如下</p><h3 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h3><h4 id="C-中堆和栈的区别是什么"><a href="#C-中堆和栈的区别是什么" class="headerlink" title="C++中堆和栈的区别是什么"></a><code>C++</code>中堆和栈的区别是什么</h4><ol><li>栈由系统分配释放，栈上变量的生命周期是确定的，一般与作用域有关。栈的地址由高到低，栈上分配的空间大小在编译时通常已知。</li><li>堆由程序员手动开辟释放，堆上的变量除非被显示释放，否则会持续存在。堆的地址由低到高，堆上几乎可以分配任意大小的内存块，但可能会造成内存碎片。</li><li>这里说一下<code>C++</code>的内存分区：堆区、栈区、<code>data</code>区、<code>bss</code>段、代码段。数据<code>data</code>区存放的是静态变量和初始化的全局变量，<code>bss</code>段存放的是未初始化的全局变量。</li></ol><h4 id="什么是RAII？为什么它在C-中很重要"><a href="#什么是RAII？为什么它在C-中很重要" class="headerlink" title="什么是RAII？为什么它在C++中很重要"></a>什么是<code>RAII</code>？为什么它在<code>C++</code>中很重要</h4><p><code>RAII</code>是一种编程思想和设计模式，核心思想是：将资源的获取与对象的初始化捆绑在一起，将资源的释放与对象的销毁捆绑在一起。这样，资源管理就与对象的生命周期紧密关联。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::fstream fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">File</span>(<span class="type">const</span> std::string&amp; filename) &#123;</span><br><span class="line">        fs.<span class="built_in">open</span>(filename, std::ios::in | std::ios::out);</span><br><span class="line">        <span class="keyword">if</span> (!fs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to open the file&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他与文件相关的操作...</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">File</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (fs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            fs.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">File <span class="title">myFile</span><span class="params">(<span class="string">&quot;sample.txt&quot;</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 进行文件操作...</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当myFile对象离开其作用域时，它的析构函数会自动被调用，从而关闭文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释new和delete，与malloc和free的区别"><a href="#解释new和delete，与malloc和free的区别" class="headerlink" title="解释new和delete，与malloc和free的区别"></a>解释<code>new</code>和<code>delete</code>，与<code>malloc</code>和<code>free</code>的区别</h4><ul><li><p>属性的区别</p><p><code>new/delete</code>：这两个是<code>C++</code>中的关键字；</p><p><code>malloc/free</code>：这两个是库函数；</p></li><li><p>使用上的区别</p><p><code>malloc</code>：申请空间需要显式填入申请内存的大小；</p><p><code>new</code>：无需显式填入申请内存的大小，<code>new</code>会根据<code>new</code>的类型分配内存；</p></li><li><p>返回类型的区别</p><p><code>new</code>操作符内存分配成功，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，故<code>new</code>是符合类型安全性的操作符。</p><p><code>malloc</code>内存分配成功返回的是<code>void*</code>指针，需要通过强制类型转换，转换成我们需要的类型。</p><p>所以<code>C++</code>中<code>new</code>比<code>malloc</code>安全可靠。</p></li><li><p>分配失败的区别</p><p><code>malloc</code>分配失败会返回<code>NULL</code>，我们可以通过判断返回值是否是<code>NULL</code>得知是否分配成功。</p><p><code>new</code>分配失败会抛出<code>bad_alloc</code>异常。</p></li><li><p>扩张内存的区别</p><p><code>malloc</code>有内存扩张机制（通过<code>realloc</code>实现）。</p><p><code>new</code>没有扩张内存机制。</p></li></ul><h3 id="中级问题"><a href="#中级问题" class="headerlink" title="中级问题"></a>中级问题</h3><h4 id="为什么C-推荐使用智能指针，如shared-ptr和unique-ptr"><a href="#为什么C-推荐使用智能指针，如shared-ptr和unique-ptr" class="headerlink" title="为什么C++推荐使用智能指针，如shared_ptr和unique_ptr"></a>为什么<code>C++</code>推荐使用智能指针，如<code>shared_ptr</code>和<code>unique_ptr</code></h4><ul><li>自动管理内存：对于<code>unique_ptr</code>，当它超出作用域或者被重新分配时，它指向的对象会被删除。对于<code>shared_ptr</code>，当它的引用计数为0时，它指向的对象会被删除。</li><li>异常安全：当函数抛出异常，智能指针确保资源被正确清理，避免资源泄露。</li><li>防止悬挂指针：悬挂指针是指指向已经释放内存的指针。<code>unique_ptr</code>和<code>shared_ptr</code>可以减少悬挂指针的风险，因为他们确保在没有引用的时候释放资源。</li></ul><h4 id="你能解释shared-ptr中的引用计数机制是如何工作的吗"><a href="#你能解释shared-ptr中的引用计数机制是如何工作的吗" class="headerlink" title="你能解释shared_ptr中的引用计数机制是如何工作的吗"></a>你能解释<code>shared_ptr</code>中的引用计数机制是如何工作的吗</h4><ul><li>通过一个指针实现引用计数功能，加锁，保证线程安全</li></ul><h4 id="什么情况下会导致内存泄漏，你如何检测和预防"><a href="#什么情况下会导致内存泄漏，你如何检测和预防" class="headerlink" title="什么情况下会导致内存泄漏，你如何检测和预防"></a>什么情况下会导致内存泄漏，你如何检测和预防</h4><ul><li><p>指针重新赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line"><span class="type">int</span> *np = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line">p = np;</span><br><span class="line"><span class="comment">//p原来的指向的内存无法释放，因为现在没有指针指向这块内存</span></span><br></pre></td></tr></table></figure></li><li><p>错误的内存释放</p><p>假设有一个指针<code>p</code>指向10字节的内存，该内存的第三个字节<code>np</code>又指向某个动态分配的内存， 如果此时你直接<code>delete(p)</code>，则会导致<code>np</code>指向的内存无法释放。</p></li><li><p>返回值的不正确处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于没有对函数f()的返回值做正确接收，将会导致f函数分配的内存无法释放。</span></span><br></pre></td></tr></table></figure></li></ul><p>关于内存泄露可以使用工具：<code>Valgrind</code>。</p><h3 id="高级问题"><a href="#高级问题" class="headerlink" title="高级问题"></a>高级问题</h3><h4 id="描述C-的内存模型是什么？如何保证线程间的数据同步？"><a href="#描述C-的内存模型是什么？如何保证线程间的数据同步？" class="headerlink" title="描述C++的内存模型是什么？如何保证线程间的数据同步？"></a>描述C++的内存模型是什么？如何保证线程间的数据同步？</h4><h4 id="什么是内存屏障-memory-barrier-或内存栅栏？在哪些场景中需要使用它？"><a href="#什么是内存屏障-memory-barrier-或内存栅栏？在哪些场景中需要使用它？" class="headerlink" title="什么是内存屏障(memory barrier)或内存栅栏？在哪些场景中需要使用它？"></a>什么是内存屏障(memory barrier)或内存栅栏？在哪些场景中需要使用它？</h4><h4 id="你有没有用过定制的内存分配器，比如为某些高性能的应用场景？如果有，请描述其工作原理和使用场景。"><a href="#你有没有用过定制的内存分配器，比如为某些高性能的应用场景？如果有，请描述其工作原理和使用场景。" class="headerlink" title="你有没有用过定制的内存分配器，比如为某些高性能的应用场景？如果有，请描述其工作原理和使用场景。"></a>你有没有用过定制的内存分配器，比如为某些高性能的应用场景？如果有，请描述其工作原理和使用场景。</h4><h3 id="实践问题"><a href="#实践问题" class="headerlink" title="实践问题"></a>实践问题</h3><h4 id="描述一个你曾遇到的复杂的内存相关bug，你是如何诊断和解决的？"><a href="#描述一个你曾遇到的复杂的内存相关bug，你是如何诊断和解决的？" class="headerlink" title="描述一个你曾遇到的复杂的内存相关bug，你是如何诊断和解决的？"></a>描述一个你曾遇到的复杂的内存相关bug，你是如何诊断和解决的？</h4><h4 id="你如何评估一个C-程序的内存使用效率？你使用过哪些工具或技术"><a href="#你如何评估一个C-程序的内存使用效率？你使用过哪些工具或技术" class="headerlink" title="你如何评估一个C++程序的内存使用效率？你使用过哪些工具或技术"></a>你如何评估一个C++程序的内存使用效率？你使用过哪些工具或技术</h4><h4 id="请编写一个小程序，其中创建一个有资源泄漏的类，然后展示如何使用工具或方法找到并修复该泄漏。"><a href="#请编写一个小程序，其中创建一个有资源泄漏的类，然后展示如何使用工具或方法找到并修复该泄漏。" class="headerlink" title="请编写一个小程序，其中创建一个有资源泄漏的类，然后展示如何使用工具或方法找到并修复该泄漏。"></a>请编写一个小程序，其中创建一个有资源泄漏的类，然后展示如何使用工具或方法找到并修复该泄漏。</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有关C++内存管理问题总结如下&lt;/p&gt;
&lt;h3 id=&quot;基础问题&quot;&gt;&lt;a href=&quot;#基础问题&quot; class=&quot;headerlink&quot; title=&quot;基础问题&quot;&gt;&lt;/a&gt;基础问题&lt;/h3&gt;&lt;h4 id=&quot;C-中堆和栈的区别是什么&quot;&gt;&lt;a href=&quot;#C-中堆和栈的区别是</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>单例懒汉模式</title>
    <link href="http://zcl0219.github.io/2023/08/25/%E5%8D%95%E4%BE%8B%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zcl0219.github.io/2023/08/25/%E5%8D%95%E4%BE%8B%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-08-25T03:31:52.000Z</published>
    <updated>2023-08-25T03:35:53.069Z</updated>
    
    <content type="html"><![CDATA[<p>话不多说，直接上代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//双重检查锁定模式</span></span><br><span class="line">    <span class="comment">//这样做的目的是，如果实例已经被创建，可以避免每次加锁解锁的操作，提高性能</span></span><br><span class="line">    <span class="comment">//但看文字可能不好理解，这里给出不是双重检查锁定模式就好理解了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    static Singleton&amp; getInstance()&#123;</span></span><br><span class="line"><span class="comment">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</span></span><br><span class="line"><span class="comment">        if(instance_ == nullptr)&#123;</span></span><br><span class="line"><span class="comment">            instance_ = new Singleton();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return *instance_;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    这种写法性能非常低下，因为每次调用instance()都会加锁释放锁，而这个步骤只有在第一次new Singleton()才是有必要的。</span></span><br><span class="line"><span class="comment">    只要p被创建出来了，不管多少线程同时访问，使用if (p == nullptr) 进行判断都是足够的（只是读操作，不需要加锁），没有线程安全问题，</span></span><br><span class="line"><span class="comment">    加了锁之后反而存在性能问题。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance_ == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(instance_ == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                instance_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *instance_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::mutex mutex_;</span><br><span class="line">    <span class="type">static</span> Singleton *instance_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::mutex Singleton::mutex_;</span><br><span class="line">Singleton* Singleton::instance_ = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p><strong>问题</strong></p><p>构造析构为什么要私有</p><p>解答：</p><p>在单例模式中，构造函数和析构函数被设置为私有的原因是为了确保满足单例模式的核心要求：系统中某个类只能存在一个实例。</p><p>通过将构造函数和析构函数设为私有，我们可以确保以下几点：</p><ol><li><p><strong>外部无法实例化</strong>：由于构造函数是私有的，这意味着不能在类的外部直接创建该类的实例。这确保了实例的创建只能通过单例类提供的某些特定方法（如<code>getInstance</code>）来完成，从而控制实例的数量。</p></li><li><p><strong>禁止复制</strong>：单例模式要确保只有一个实例存在，所以我们不希望该类的对象被复制。将构造函数设为私有可以防止复制构造，但为了进一步确保不被复制，我们通常还需要禁止拷贝构造函数和拷贝赋值操作符（通过<code>= delete</code>）。</p></li><li><p><strong>外部无法销毁</strong>：将析构函数设为私有可以确保外部代码无法直接删除单例对象。通常，单例对象在程序结束时自动销毁，或者单例类提供了一个专门的方法来手动销毁它。</p></li><li><p><strong>继承控制</strong>：由于构造函数和析构函数是私有的，这也意味着这个类不能被继承（因为派生类的构造函数需要调用基类的构造函数）。</p></li></ol><p>综上所述，将构造函数和析构函数设为私有是为了确保满足单例模式的设计原则，即系统中该类只有一个实例，并提供对该实例的全局访问点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;话不多说，直接上代码&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>日志模块设计</title>
    <link href="http://zcl0219.github.io/2023/08/25/%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/"/>
    <id>http://zcl0219.github.io/2023/08/25/%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/</id>
    <published>2023-08-25T02:45:23.000Z</published>
    <updated>2023-08-25T02:57:50.778Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本篇文章主要参考如下文章，主要是对代码做一个较为详尽的解释</strong></p><p>参考链接：<a href="https://blog.csdn.net/qq_46495964/article/details/122952567">https://blog.csdn.net/qq_46495964/article/details/122952567</a></p><p><strong>前言：</strong><br>日志系统在程序运行中有着非常大的作用，用于记录程序的运行情况，在程序出错后查看日志，方便地定位出错的大概范围。在设计日志系统之前，先考虑一下日志需要输出什么信息呢？什么信息才是有用的信息，都知道写日志是一种对文件的<code>io</code>操作，所以尽可能避免输出没用的信息。<br><strong>有用的信息：关键变量的值、运行的位置（哪个文件、哪个函数、哪一行）、时间、线程号、进程号等等。</strong></p><h4 id="日志系统的设计"><a href="#日志系统的设计" class="headerlink" title="日志系统的设计"></a>日志系统的设计</h4><ol><li><p>日志的级别</p><p>在测试、调试、交付等场景需要输出不同的级别日志。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见的日志级别</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LOGLEVEL</span></span><br><span class="line">&#123;</span><br><span class="line">LOG_LEVEL_NONE,</span><br><span class="line">LOG_LEVEL_ERROR,     <span class="comment">// error</span></span><br><span class="line">LOG_LEVEL_WARNING,   <span class="comment">// warning</span></span><br><span class="line">LOG_LEVEL_DEBUG,     <span class="comment">// debug</span></span><br><span class="line">LOG_LEVEL_INFO,      <span class="comment">// info</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>日志的输出地</p><p>日志输出的地方可能不同，终端、控制台、UI界面、文件等等都有。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">LOGTARGET</span></span><br><span class="line">&#123;</span><br><span class="line">LOG_TERM      = <span class="number">0x00</span>,</span><br><span class="line">LOG_FILE      = <span class="number">0x01</span>,</span><br><span class="line">LOG_UI        = <span class="number">0x10</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>日志的作用域</p><p>日志做到什么时候都可以输出，可作用于全程序文件，考虑到多线程情况下，必须保证日志的输出需要得到线程安全的保障，所以需要一个<strong>全局且唯一的日志器</strong>。使用设计模式中的<strong>单例模式—–日志器</strong></p></li></ol><h4 id="C-版本的日志系统的实现"><a href="#C-版本的日志系统的实现" class="headerlink" title="C++版本的日志系统的实现"></a>C++版本的日志系统的实现</h4><p><strong>Logger.h</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">这是一个基本的线程安全日志系统的头文件，其目的是为应用程序提供日志功能。以下是对这个头文件的详细解释：</span><br><span class="line"></span><br><span class="line">1. **预处理指令和宏**:</span><br><span class="line">    - `<span class="comment">#ifndef`, `#define`, 和 `#endif` 用于保证头文件只被包含一次，避免重复定义。</span></span><br><span class="line">    - `<span class="comment">#define` 宏定义了三个日志级别：`LogInfo`, `LogWarning`, 和 `LogError`。这些宏都使用了变参（`...`），允许用户为日志提供自定义的格式和参数。这些宏捕获了日志消息的来源（文件、行号和函数）并将其添加到日志队列中。</span></span><br><span class="line"></span><br><span class="line">2. **类定义：Logger**</span><br><span class="line">    - 是一个单例类，这意味着整个程序中只能有一个实例。这通过私有的默认构造函数、删除的复制构造函数和赋值运算符来实现。</span><br><span class="line">    - `GetInstance()` 方法提供了对单例实例的访问。</span><br><span class="line">    - `SetFileName()` 允许设置日志文件的名称。</span><br><span class="line">    - `Start()` 和 `Stop()` 用于启动和停止日志线程。</span><br><span class="line">    - `AddToQueue()` 是用于将新的日志消息添加到日志队列的方法。</span><br><span class="line">    - `threadfunc()` 是日志线程的工作函数，它持续从日志队列中读取消息并写入文件。</span><br><span class="line"></span><br><span class="line">3. **类的私有成员**:</span><br><span class="line">    - `filename_`: 存储日志文件的名称。</span><br><span class="line">    - `fp_`: 用于文件操作的文件指针。请注意，在所给代码中，`FILE` 的声明被注释掉了，你需要包含 `&lt;cstdio&gt;` 或者直接使用 C++ 的文件流类（如 `std::ofstream`）。</span><br><span class="line">    - `spthread_`: 一个智能指针，指向日志线程。</span><br><span class="line">    - `mutex_`: 用于保护日志队列和其他共享资源，确保多线程访问时的线程安全。</span><br><span class="line">    - `cv_`: 条件变量，用于通知日志线程有新的消息到来。</span><br><span class="line">    - `exit_`: 一个标志，指示日志线程何时退出。</span><br><span class="line">    - `queue_`: 存储待处理日志消息的队列。</span><br><span class="line"></span><br><span class="line">4. **注释**: </span><br><span class="line">    - 提供了关于该文件的基本信息，如文件名称和日期。</span><br><span class="line"></span><br><span class="line">总之，这个日志系统设计的思路是：</span><br><span class="line">1. 用户调用预定义的宏添加日志消息。</span><br><span class="line">2. 日志消息被添加到一个线程安全的队列。</span><br><span class="line">3. 一个独立的日志线程从队列中取出消息并写入文件。</span><br><span class="line"></span><br><span class="line">这种设计允许应用程序非阻塞地添加日志消息，而将I/O操作留给专门的线程，从而提高应用程序的性能。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 日志类头文件, Logger.h</span></span><br><span class="line"><span class="comment"> *  2022.02.1</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LOGGER_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LOGGER_H__</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//struct FILE;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LogInfo(...)        Logger::GetInstance().AddToQueue(<span class="string">&quot;INFO&quot;</span>, __FILE__, __LINE__, __PRETTY_FUNCTION__, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LogWarning(...)     Logger::GetInstance().AddToQueue(<span class="string">&quot;WARNING&quot;</span>, __FILE__, __LINE__, __PRETTY_FUNCTION__, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LogError(...)       Logger::GetInstance().AddToQueue(<span class="string">&quot;ERROR&quot;</span>, __FILE__, __LINE__, __PRETTY_FUNCTION__, __VA_ARGS__)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetFileName</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddToQueue</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszLevel, <span class="type">const</span> <span class="type">char</span>* pszFile, <span class="type">int</span> lineNo, <span class="type">const</span> <span class="type">char</span>* pszFuncSig, <span class="type">char</span>* pszFmt, ...)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Logger</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> Logger&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    Logger&amp; <span class="keyword">operator</span> =(Logger&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadfunc</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string                     filename_;</span><br><span class="line">    FILE*                           fp_&#123;&#125;;</span><br><span class="line">    std::shared_ptr&lt;std::thread&gt;    spthread_;</span><br><span class="line">    std::mutex                      mutex_;</span><br><span class="line">    std::condition_variable         cv_;            <span class="comment">//有新的日志到来的标识</span></span><br><span class="line">    <span class="type">bool</span>                            exit_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    std::list&lt;std::string&gt;          queue_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//!__LOGGER_H__</span></span></span><br></pre></td></tr></table></figure><p>Logger.cpp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">这是日志类的实现文件`Logger.cpp`。它对`Logger.h`中定义的函数进行了具体的实现。我将分步解释这个文件的内容：</span><br><span class="line"></span><br><span class="line">1. **<span class="comment">#include语句**: 引入了所需的头文件，其中`Logger.h`是之前你展示的日志类的头文件，其他的是C和C++标准库中的头文件。</span></span><br><span class="line"></span><br><span class="line">2. **GetInstance方法**: 实现了单例模式的核心功能。通过使用局部静态对象`logger`，它确保只创建一次`Logger`类的实例。</span><br><span class="line"></span><br><span class="line">3. **SetFileName方法**: 允许用户设置日志文件的名称。</span><br><span class="line"></span><br><span class="line">4. **Start方法**: </span><br><span class="line">    - 如果用户没有提供日志文件名，它会生成一个默认的日志文件名，该文件名包含当前的日期和时间。</span><br><span class="line">    - 尝试打开日志文件以写入和读取。</span><br><span class="line">    - 创建一个新线程来处理日志消息。</span><br><span class="line"></span><br><span class="line">5. **Stop方法**: </span><br><span class="line">    - 设置`exit_`标志为`<span class="literal">true</span>`。</span><br><span class="line">    - 通过条件变量通知日志线程。</span><br><span class="line">    - 等待日志线程结束。</span><br><span class="line"></span><br><span class="line">6. **AddToQueue方法**: </span><br><span class="line">    - 使用变长参数列表格式化日志消息。</span><br><span class="line">    - 生成一个包含日期、时间、日志级别、线程ID、源文件名、行号、函数签名和日志消息的完整日志字符串。</span><br><span class="line">    - 使用互斥锁将完整的日志字符串添加到队列。</span><br><span class="line">    - 通过条件变量通知日志线程有新的消息到来。</span><br><span class="line"></span><br><span class="line">7. **threadfunc方法**:</span><br><span class="line">    - 日志线程的核心功能。</span><br><span class="line">    - 检查文件指针是否为空。</span><br><span class="line">    - 在`exit_`为`<span class="literal">false</span>`的情况下，循环处理日志消息。</span><br><span class="line">    - 使用互斥锁和条件变量等待新的消息到来。</span><br><span class="line">    - 当有新的消息时，从队列中取出并写入日志文件。</span><br><span class="line">    - 如果设置了退出标志并且队列为空，线程将退出。</span><br><span class="line"></span><br><span class="line">总体上，这是一个简单但功能完整的日志系统实现。它使用了多线程，互斥锁和条件变量来确保线程安全，并使日志操作与应用程序的其他部分异步进行，从而提高了性能。</span><br><span class="line"></span><br><span class="line">然而，也有一些可以进一步优化或改进的地方：</span><br><span class="line">1. 在`Start()`中，文件是以<span class="string">&quot;wt+&quot;</span>模式打开的，这意味着如果文件已经存在，它会被覆盖。如果希望在现有文件中追加日志，则应使用<span class="string">&quot;at+&quot;</span>。</span><br><span class="line">2. 代码中没有明确的错误处理或异常处理策略。例如，如果`fopen`失败或`std::thread`创建失败时。</span><br><span class="line">3. 在`threadfunc`中，当队列不为空时，每处理一个消息就会刷新文件，这可能影响性能。可以考虑在队列中有多个消息时，一次性写入多个消息，然后再刷新。</span><br><span class="line">4. 可能会考虑添加一个`Rotate`功能，当日志文件大小超过某个限制时，自动将当前日志文件重命名，并创建一个新的日志文件。</span><br><span class="line">5. 为了提高性能，可以考虑使用双缓冲技术，这样可以减少互斥锁的争用。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 日志类实现文件, Logger.cpp</span></span><br><span class="line"><span class="comment"> *  2022.02.1</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">Logger&amp; <span class="title">Logger::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Logger logger;</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::SetFileName</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    filename_ = filename;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Logger::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (filename_.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">tm</span>* t = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line">        <span class="type">char</span> timestr[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(timestr, <span class="string">&quot;%04d%02d%02d%02d%02d%02d.imserver.log&quot;</span>, t-&gt;tm_year + <span class="number">1900</span>, t-&gt;tm_mon + <span class="number">1</span>, t-&gt;tm_mday, t-&gt;tm_hour, t-&gt;tm_min, t-&gt;tm_sec);</span><br><span class="line">        filename_ = timestr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fp_ = <span class="built_in">fopen</span>(filename_.<span class="built_in">c_str</span>(), <span class="string">&quot;wt+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp_ == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    spthread_.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">thread</span>(std::<span class="built_in">bind</span>(&amp;Logger::threadfunc, <span class="keyword">this</span>)));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::Stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    exit_ = <span class="literal">true</span>;</span><br><span class="line">    cv_.<span class="built_in">notify_one</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//等待时间线程结束</span></span><br><span class="line">    spthread_-&gt;<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::AddToQueue</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszLevel, <span class="type">const</span> <span class="type">char</span>* pszFile, <span class="type">int</span> lineNo, <span class="type">const</span> <span class="type">char</span>* pszFuncSig, <span class="type">char</span>* pszFmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> msg[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    va_list vArgList;                            </span><br><span class="line">    <span class="built_in">va_start</span>(vArgList, pszFmt);</span><br><span class="line">    <span class="built_in">vsnprintf</span>(msg, <span class="number">256</span>, pszFmt, vArgList);</span><br><span class="line">    <span class="built_in">va_end</span>(vArgList);</span><br><span class="line"> </span><br><span class="line">    <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span>* tmstr = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line">    <span class="type">char</span> content[<span class="number">512</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;[%04d-%02d-%02d %02d:%02d:%02d][%s][0x%04x][%s:%d %s]%s\n&quot;</span>,</span><br><span class="line">                tmstr-&gt;tm_year + <span class="number">1900</span>,</span><br><span class="line">                tmstr-&gt;tm_mon + <span class="number">1</span>,</span><br><span class="line">                tmstr-&gt;tm_mday,</span><br><span class="line">                tmstr-&gt;tm_hour,</span><br><span class="line">                tmstr-&gt;tm_min,</span><br><span class="line">                tmstr-&gt;tm_sec,</span><br><span class="line">                pszLevel,</span><br><span class="line">                std::this_thread::<span class="built_in">get_id</span>(),</span><br><span class="line">                pszFile,</span><br><span class="line">                lineNo,</span><br><span class="line">                pszFuncSig,</span><br><span class="line">                msg);</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        queue_.<span class="built_in">emplace_back</span>(content);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::threadfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fp_ == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (!exit_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//写日志</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (queue_.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (exit_)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">            cv_.<span class="built_in">wait</span>(guard);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//写日志</span></span><br><span class="line">        <span class="type">const</span> std::string&amp; str = queue_.<span class="built_in">front</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">fwrite</span>((<span class="type">void</span>*)str.<span class="built_in">c_str</span>(), str.<span class="built_in">length</span>(), <span class="number">1</span>, fp_);</span><br><span class="line">        <span class="built_in">fflush</span>(fp_);</span><br><span class="line">        queue_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ol><li><p>Stop方法: 设置exit_标志为true。 通过条件变量通知日志线程。 等待日志线程结束 </p><p><strong>请问这里为什么需要通知日志线程</strong></p><p>解答：在<code>Logger</code>类的实现中，日志线程的工作是从队列中获取日志消息并将其写入文件。为了实现这个功能，它在队列为空时通过<code>cv_.wait(guard)</code>进入休眠状态，等待新的日志消息的到来。</p><p>当你调用<code>Stop</code>方法时，你希望日志线程能够尽快结束。但有一种情况需要考虑：当<code>Stop</code>被调用时，队列可能仍然是空的，这意味着日志线程可能处于<code>cv_.wait(guard)</code>的休眠状态。</p><p>在这种情况下，即使你设置了<code>exit_</code>标志为<code>true</code>，日志线程仍然不会醒来检查这个标志，因为它正在等待新的日志消息到来。</p><p>为了确保日志线程能够醒来、检查<code>exit_</code>标志并正确地退出，你需要在<code>Stop</code>方法中通过<code>cv_.notify_one()</code>通知日志线程。这样，日志线程将被唤醒，然后它可以检查<code>exit_</code>标志，并根据该标志的值决定是否退出。</p><p>总之，通知日志线程是为了确保它可以从<code>cv_.wait(guard)</code>中醒来，然后检查退出条件并安全地退出。</p></li><li><p>这个程序没有设计线程来将新的日志信息加入队列吗</p><p>从提供的代码来看，日志系统中只设计了一个专门的日志线程（在<code>Logger::Start()</code>方法中启动），其任务是从队列中提取日志消息并将其写入文件。此外，并没有为添加新日志消息到队列专门设计线程。</p><p>当你希望写入日志时，只需在你的主程序或任何其他线程中调用<code>LogInfo()</code>, <code>LogWarning()</code>, 或 <code>LogError()</code>这样的宏。这些宏内部会调用<code>Logger::AddToQueue()</code>，该方法将日志消息格式化并加入到队列中。这种设计的优点是简单且高效，因为它允许多个线程在运行时无缝地向日志系统添加消息，而无需额外的线程。</p><p>但值得注意的是，<code>Logger::AddToQueue()</code>使用了互斥锁<code>mutex_</code>来保证多个线程同时向队列添加消息时的线程安全。这意味着，即使多个线程同时调用日志宏，<code>Logger::AddToQueue()</code>中的代码仍然是线程安全的。</p><p>总的来说，这个日志系统的设计考虑到了多线程环境，允许多个线程同时添加日志消息，但它并没有专门设置一个线程来完成这项任务，而是允许主程序或其他任何线程来直接调用添加日志的宏。</p><p>自己的话：你自己程序在运行的时候是不是有多个线程，这些线程就是负责啥时候要调用<code>LogInfo()</code>, <code>LogWarning()</code>, 或 <code>LogError()</code>这样的宏。所以当然不需要额外的线程来操作加入队列操作，只需要一个带锁函数即可。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本篇文章主要参考如下文章，主要是对代码做一个较为详尽的解释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;https://blog.csdn.net/qq_46495964/article/details/122952567&quot;&gt;https://</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>webServer</title>
    <link href="http://zcl0219.github.io/2023/08/23/webServer/"/>
    <id>http://zcl0219.github.io/2023/08/23/webServer/</id>
    <published>2023-08-23T13:08:31.000Z</published>
    <updated>2023-09-20T19:17:59.989Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始正式补充完善<code>webServer</code>服务器的内容！想到哪写到哪吧，回头再做整合。</p><h3 id="标准C库IO函数"><a href="#标准C库IO函数" class="headerlink" title="标准C库IO函数"></a>标准C库IO函数</h3><p><img src="PNG1.png"></p><h4 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、如何处理接收到的HTTP请求</span></span><br><span class="line"><span class="comment">2、如何填写HTTP响应</span></span><br><span class="line"><span class="comment">3、如何建立网络连接传输数据</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="HTTP请求处理"><a href="#HTTP请求处理" class="headerlink" title="HTTP请求处理"></a>HTTP请求处理</h4><p>http_conn头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">http_conn</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">http_conn</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">http_conn</span>() &#123;&#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_epollfd;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_user_count;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> so0ckaddr_in &amp;addr)</span></span>;<span class="comment">// 初始化连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close_conn</span><span class="params">(<span class="type">bool</span> real_close = <span class="literal">true</span>)</span></span>;<span class="comment">// 关闭连接，关于需要传入real_close参数的原因，后面会讲到，预留问题</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_sockfd;<span class="comment">// 发起http请求的sockfd</span></span><br><span class="line">    sockaddr_in m_address;<span class="comment">// 发起http请求的socket地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在http_conn类里主要设置五个对外的接口：</p><ul><li><p>初始化新接受的连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> sockaddr_in &amp;addr)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们会把所有事件注册到一张内核事件表上，因此定义一个内核事件就好了。static int m_epollfd;</span></span><br><span class="line"><span class="comment">同时我们会统计当前连接数，同样是使用一个静态变量，所有实例对象共享。static int m_user_count;</span></span><br><span class="line"><span class="comment">每建立一个新连接，m_user_count就会加1；</span></span><br><span class="line"><span class="comment">当我们向内核事件表注册一个事件时，我们需要考虑我们所要监听的事件类型，这里我们考虑：</span></span><br><span class="line"><span class="comment">读事件（EPOLLIN）、边沿触发模式（EPOLLET）、以及EPOLLRDHUP（检测TCP对端连接的关闭或者半关闭状态）</span></span><br><span class="line"><span class="comment">为了配合ET模式和多线程，我们需要做两个操作，第一是将所监听的文件描述符设置为非阻塞的，第二需要设置为EPOLLONESHOT类型</span></span><br><span class="line"><span class="comment">注意：我们对m_epollfd和m_user_count的初始化分别为</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> m_epollfd = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> m_user_count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>设置非阻塞函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例：Linux高性能服务器编程 p113</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> sockfd)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>(sockfd, F_GETFL);  <span class="comment">// 获取文件描述符旧的状态标志</span></span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;<span class="comment">// 设置非阻塞标志</span></span><br><span class="line">    <span class="built_in">fcntl</span>(sockfd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;<span class="comment">// 返回文件描述符旧的状态标志，以便日后恢复该状态标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置感兴趣事件类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们在向内核事件表注册新事件的时候，需要指定自己对这个文件描述符上发生的什么事件感兴趣</span></span><br><span class="line"><span class="comment">// 可读？可写？</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> one_shot)</span></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">if</span>(one_shot)&#123;</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化函数代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::init</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> sockaddr_in &amp;addr)</span></span>&#123;</span><br><span class="line">m_sockfd = sockfd;</span><br><span class="line">    m_address = addr;</span><br><span class="line">    <span class="built_in">addfd</span>(m_epollfd, sockfd, <span class="literal">true</span>);</span><br><span class="line">    m_user_count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关闭连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">close_conn</span><span class="params">(<span class="type">bool</span> real_close)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们可以思考一下有关关闭连接需要涉及到哪些操作。</span></span><br><span class="line"><span class="comment">1、首先，如果一个连接关闭了，我们需要将其从内核事件表上移除</span></span><br><span class="line"><span class="comment">2、当前连接数目也会减一</span></span><br><span class="line"><span class="comment">这里我们准备先实现一个从内核事件表上移除文件描述符的函数（void removefd），在实现关闭连接</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>移除文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removefd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::close_conn</span><span class="params">(<span class="type">bool</span> real_close)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(real_close &amp;&amp; m_sockfd != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">removefd</span>(m_epollfd, m_sockfd);</span><br><span class="line">        m_sockfd = <span class="number">-1</span>;</span><br><span class="line">        m_user_count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理客户请求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于如何处理客户连接请求的问题，我们从最原始的地方出发。</span></span><br><span class="line"><span class="comment">首先，你了解一个http请求的基本格式吗？因为我们只有在了解http请求的通用格式后才知道如何对其进行解析</span></span><br><span class="line"><span class="comment">下面，我将展示一个最基本的GET请求格式</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">GET /path/to/resource?param1=value1&amp;param2=value2 HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agnet: Mozilla/5.0 (platform; rv:geckoversion) Gecko/geckotrail Firefox/firefoxversion</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br><span class="line"><span class="comment"># 关于这个GET请求的详细解释我提一个chatgpt的解释在这，可以阅读一下</span></span><br><span class="line">下面是逐行详细解释：</span><br><span class="line">1. `GET /path/to/resource?param1=value1&amp;param2=value2 HTTP/1.1`</span><br><span class="line">   - `GET`: 这是HTTP请求的方法。`GET` 方法用于请求指定的资源。与POST相比，GET请求是只读的，并且用于获取数据而不是发送数据。</span><br><span class="line">   - `/path/to/resource`: 这是请求的资源路径，通常是文件或者其他资源的位置。</span><br><span class="line">   - `?`: 这个符号表示URL的查询部分的开始。</span><br><span class="line">   - `param1=value1&amp;param2=value2`: 这是查询字符串。在此例中，有两个参数，`param1`和`param2`，它们的值分别是`value1`和`value2`。`&amp;`符号用于分隔查询参数。</span><br><span class="line">   - `HTTP/1.1`: 表示使用的HTTP版本，这里是1.1。</span><br><span class="line"></span><br><span class="line">2. `Host: www.example.com`</span><br><span class="line">   - `Host`: 这是HTTP头的名称。它指定了请求的目标主机和域名。</span><br><span class="line">   - `www.example.com`: 请求的目标域名。</span><br><span class="line"></span><br><span class="line">3. `User-Agent: Mozilla/5.0 (platform; rv:geckoversion) Gecko/geckotrail Firefox/firefoxversion`</span><br><span class="line">   - `User-Agent`: 这是HTTP头的名称。它描述了发出请求的用户代理的类型，通常是浏览器。</span><br><span class="line">   - `Mozilla/5.0`: 这是用户代理的一般标记。虽然名为Mozilla，但它并不仅仅代表Mozilla浏览器，大多数浏览器都会以这种方式标识。</span><br><span class="line">   - `(platform; rv:geckoversion)`: 这部分提供了关于用户代理的详细信息，例如它在哪个平台上运行。</span><br><span class="line">   - `Gecko/geckotrail`: 这是Gecko渲染引擎的标识及其版本。</span><br><span class="line">   - `Firefox/firefoxversion`: 表示用户代理是Firefox浏览器，后面跟着其版本。</span><br><span class="line"></span><br><span class="line">4. `Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8`</span><br><span class="line">   - `Accept`: HTTP头名称，表示客户端可以处理的内容类型。</span><br><span class="line">   - 该头的值列出了浏览器接受的MIME类型，按照优先级排序。例如，`text/html` 表示HTML文档，而`q=0.9`表示相对优先级。</span><br><span class="line"></span><br><span class="line">5. `Accept-Language: en-US,en;q=0.5`</span><br><span class="line">   - `Accept-Language`: HTTP头名称，表示用户代理偏好的自然语言。</span><br><span class="line">   - `en-US,en`: 这指示用户代理首先希望接收美国英语的内容，其次是英语。</span><br><span class="line"></span><br><span class="line">6. `Accept-Encoding: gzip, deflate, br`</span><br><span class="line">   - `Accept-Encoding`: HTTP头名称，表示用户代理可以接受的内容编码。</span><br><span class="line">   - `gzip, deflate, br`: 这些是可以接受的编码方法，用于内容压缩。</span><br><span class="line"></span><br><span class="line">7. `Connection: keep-alive`</span><br><span class="line">   - `Connection`: HTTP头名称，表示是否持续连接。</span><br><span class="line">   - `keep-alive`: 表示浏览器希望服务器保持连接，以便于后续的请求可以复用相同的TCP连接。</span><br><span class="line"></span><br><span class="line">这个请求大体上是一个典型的HTTP GET请求，由HTTP方法、资源路径、HTTP版本、多个头字段组成。每个头字段都有其特定的语义和目的。</span><br></pre></td></tr></table></figure><p>现在我们知道了HTTP请求格式了，那么到底如何解析它呢？这里就要引入一种叫做“有限状态机”的方法了，有关这个方法的具体描述与实现，大家可以看我的另一篇文章。</p></li><li><p>非阻塞读操作</p></li><li><p>非阻塞写操作</p></li></ul><p><strong>第一个知识点：<code>iovec</code></strong></p><p>这里先介绍一个<code>iovec</code>结构体，因为我们在写HTTP响应的时候需要用到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>&#123;</span></span><br><span class="line">  <span class="type">ptr_t</span> iov_base;</span><br><span class="line">  <span class="type">size_t</span> iov_len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct iovec结构体，指针成员iov_base指向一个缓冲区，这个缓冲区是存放read_v所接收的数据或者write_v将要发送的数据。成员iov_len在各种情况下分别确定了接收的最大长度和实际写入的长度。</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *<span class="built_in">vector</span>, <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *<span class="built_in">vector</span>, <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure><p>下面给出一个应用实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> part1[] = <span class="string">&quot;This is from writev&quot;</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> part2 = <span class="number">65</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> part3[] = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[3];</span></span><br><span class="line">    </span><br><span class="line">    iov[<span class="number">0</span>].iov_base = part3;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="built_in">strlen</span>(part3);</span><br><span class="line">    </span><br><span class="line">    iov[<span class="number">1</span>].iov_base = part1;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in">strlen</span>(part1);</span><br><span class="line">    </span><br><span class="line">    iov[<span class="number">2</span>].iov_base = &amp;part2;</span><br><span class="line">    iov[<span class="number">2</span>].iov_len = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    </span><br><span class="line">    writev(<span class="number">1</span>, iov, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二个知识点：<code>va_list</code>, <code>vsnprintf</code></strong></p><p>参考链接：<a href="https://blog.csdn.net/dengzhilong_cpp/article/details/54944676">https://blog.csdn.net/dengzhilong_cpp/article/details/54944676</a></p><p>参考链接：<a href="https://blog.csdn.net/luliplus/article/details/124123219">https://blog.csdn.net/luliplus/article/details/124123219</a></p><p>以上是今天要写代码的基础知识，下面开始正式代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*写HTTP响应*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">http_conn::write</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bytes_have_send = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bytes_to_send = m_write_idx;</span><br><span class="line">    <span class="keyword">if</span>(bytes_to_send == <span class="number">0</span>)&#123;</span><br><span class="line">        modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        temp = writev(m_sockfd, m_iv, m_iv_count);</span><br><span class="line">        <span class="keyword">if</span>(temp &lt;= <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EAGAIN)&#123;</span><br><span class="line">                modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unmap();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bytes_to_send -= temp;</span><br><span class="line">        bytes_have_send += temp;</span><br><span class="line">        <span class="keyword">if</span>(bytes_to_send &lt;= bytes_have_send)&#123;</span><br><span class="line">            unmap();</span><br><span class="line">            <span class="keyword">if</span>(m_linger)&#123;</span><br><span class="line">                init();</span><br><span class="line">                modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                                                                                                                                                           </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天开始正式补充完善&lt;code&gt;webServer&lt;/code&gt;服务器的内容！想到哪写到哪吧，回头再做整合。&lt;/p&gt;
&lt;h3 id=&quot;标准C库IO函数&quot;&gt;&lt;a href=&quot;#标准C库IO函数&quot; class=&quot;headerlink&quot; title=&quot;标准C库IO函数&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
  </entry>
  
</feed>

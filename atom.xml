<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://zcl0219.github.io/atom.xml" rel="self"/>
  
  <link href="http://zcl0219.github.io/"/>
  <updated>2025-04-16T18:10:39.060Z</updated>
  <id>http://zcl0219.github.io/</id>
  
  <author>
    <name>GGBond</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VDN</title>
    <link href="http://zcl0219.github.io/2025/04/17/VDN/"/>
    <id>http://zcl0219.github.io/2025/04/17/VDN/</id>
    <published>2025-04-16T17:21:22.000Z</published>
    <updated>2025-04-16T18:10:39.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用于协作式多智能体学习的价值分解网络"><a href="#用于协作式多智能体学习的价值分解网络" class="headerlink" title="用于协作式多智能体学习的价值分解网络"></a>用于协作式多智能体学习的价值分解网络</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>我们研究了具有单个联合奖励信号的协作式多智能体强化学习问题。这类学习问题很困难，因为通常有很大的动作和观察组合空间。在完全集中式和去中心化的方法中，我们发现了虚假奖励的问题和一种我们称之为 “惰性代理” 问题的现象，这是由于部分可观察性而出现的。我们通过使用一种新的价值分解网络架构来训练单个代理来解决这些问题，该架构学习将团队价值函数分解为代理价值函数。我们在一系列部分可观察的多智能体领域进行了实验评估，并表明学习这种价值分解会带来卓越的结果，特别是当与权重共享、角色信息和信息通道相结合时。</p><hr><p><sup><a href="#fn_什么是单个联合奖励信号的协作式多智能体强化学习问题" id="reffn_什么是单个联合奖励信号的协作式多智能体强化学习问题">什么是单个联合奖励信号的协作式多智能体强化学习问题</a></sup>: </p><p>首先，协作式多智能体强化学习（Cooperative MARL）是指多个智能体共同合作完成一个任务，他们的目标一致，共享奖励或各自有奖励，但这里提到的是单个联合奖励信号，所以应该是所有智能体共享同一个奖励。那单个联合奖励信号是什么意思呢？可能是指所有智能体的行为共同影响一个全局奖励，比如团队胜利或任务完成。比如足球游戏里的多个球员，进球了大家都有同样的奖励，被进球了都扣分。这种情况下，每个智能体的行为都会影响整个团队的奖励，但每个智能体可能需要自己学习策略，或者有集中式的训练。接下来需要解释协作式MARL的基本概念，然后结合单个联合奖励来展开。可能需要比较一下其他情况，比如每个智能体有独立奖励的情况，或者竞争式MARL。然后说明这种单个联合奖励带来的挑战和常见解决方法。挑战可能包括信用分配问题，因为所有智能体共享同一个奖励，难以确定每个个体的贡献。比如在团队游戏中，某个关键动作可能由某个智能体做出，但奖励是大家共享的，其他智能体如何知道该动作的重要性？这时候可能需要某种方法来分配信用，比如COMA算法中的反事实基线，或者VDN、QMIX这类值分解的方法。另外，还需要提到环境的部分可观测性，每个智能体可能只能看到局部信息，这会影响决策。还有策略的协调问题，如何让多个智能体的策略在分散执行时保持一致，可能需要集中式训练、分散式执行的框架。常见的方法可能包括值分解网络（VDN, QMIX），这些方法通过分解联合Q值到个体Q值，从而在训练时利用全局信息，执行时每个智能体根据自己的Q值行动。还有Actor-Critic方法，如MADDPG，虽然每个智能体有自己的策略，但Critic可能会用到全局信息进行训练。另外，可能需要提到信用分配的具体技术，比如差异奖励（Difference Rewards），即每个智能体的奖励基于其贡献与全局奖励的关系，或者利用反事实基线来评估某个智能体是否存在时的奖励差异。总结的话，单个联合奖励的协作式MARL问题需要解决信用分配、环境复杂性、策略协调等问题，常用方法有值分解、集中训练分散执行、信用分配技术等。这样用户应该能理解这个问题的定义、挑战和解决思路了。</p><hr><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>我们考虑合作式多智能体强化学习（MARL）问题[，, , ]，其中多个学习智能体需要共同优化随时间累积的单一奖励信号——即<strong>团队奖励</strong>。每个智能体只能访问自身的“局部”观测信息，并负责从其自身的动作集中选择动作。协作式MARL问题出现在诸如协调自动驾驶车辆和/或交通信号系统、优化由多个交互组件组成的工厂生产效率等应用中。更广泛地说，随着AI智能体的普及，它们必须学会协作以实现共同目标。</p><p>尽管某些实际应用可能需要局部自治，但原则上合作式MARL问题可以通过<strong>集中式</strong>方法处理，即将问题简化为单智能体强化学习（RL），通过拼接观测空间和组合动作空间进行学习。然而，我们证明集中式方法在相对简单的协作式MARL问题上始终失败。我们设计了一个简单实验：集中式方法会学习到低效的策略，仅有一个智能体活跃，而另一个变得“懒惰”。这是因为当一个智能体学习到有用策略时，第二个智能体因探索行为可能妨碍前者并导致团队奖励下降，从而被抑制学习。</p><p>另一种方法是训练<strong>独立学习者</strong>以优化团队奖励。然而，由于每个智能体的环境动态会随着其他智能体行为的变化而改变，每个智能体实际上面临非稳态学习问题[]。此外，由于单个智能体的视角是部分可观测的，它们可能接收到来自队友（未被观测的）行为的虚假奖励信号。这种无法解释自身观测奖励的缺陷使得朴素独立RL通常无法成功：例如[]表明，独立Q学习器无法区分队友的探索与环境本身的随机性，甚至无法解决一个看似简单的2智能体、无状态、3×3动作的问题。而一般的Dec-POMDP问题已被证明是难解的[, ]。尽管本文聚焦于双智能体协作，但需注意独立学习者和集中式方法的问题会随智能体数量增加而恶化，因为此时大多数奖励与个体无关，而集中式方法的动作空间会指数级膨胀。</p><p>改进独立学习者的方法之一是设计更直接关联个体观测的局部奖励函数。然而，即使在单智能体场景中，奖励塑形也极为困难，仅有一小类塑形奖励函数能保证与真实目标的最优性一致[, ]。本文旨在探索更通用的自主解决方案，即通过学习分解团队价值函数。</p><p>我们提出一种新型的<strong>可学习加性价值分解</strong>方法，通过对个体智能体的价值函数进行线性组合。具体而言，价值分解网络（VDN）旨在通过反向传播团队Q值的梯度到表示个体价值函数的深度神经网络中，从而从团队奖励信号中学习最优的线性价值分解。这种加性分解的动机是避免独立学习者中出现的虚假奖励信号。每个智能体隐式学习到的价值函数仅依赖于局部观测，因此更易训练。该方法还缓解了[]中强调的独立学习的协调问题，因为它在训练时以集中方式学习，而部署时智能体可独立运行。</p><p>此外，我们结合权重共享、角色信息和信息通道等近期被证明可提升样本效率与降低内存需求的技术[, , ]，对所提出的智能体进行增强。但本文的核心比较集中在三种架构：基于个体的价值分解、独立学习者和集中式方法。我们在一系列新颖的双智能体协作场景中对这些技术的组合进行了实验与基准测试。结果表明，价值分解方法在性能上显著优于集中式或完全独立的学习者，且结合附加技术后，其表现更是大幅领先。</p><hr><p><sup><a href="#fn_备注" id="reffn_备注">备注</a></sup>: </p><p>集中式学习的缺点是随着智能体数量的增加，动作空间指数级增长；<br>独立式学习的缺点是每个智能体面临的是非稳态环境，学习不稳定还会影响其他智能体的学习；<br>因此，本文推出了一种可学习加性价值分解方法。换句话说就是如何将团队奖励（团队Q值）进行合理分解</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;用于协作式多智能体学习的价值分解网络&quot;&gt;&lt;a href=&quot;#用于协作式多智能体学习的价值分解网络&quot; class=&quot;headerlink&quot; title=&quot;用于协作式多智能体学习的价值分解网络&quot;&gt;&lt;/a&gt;用于协作式多智能体学习的价值分解网络&lt;/h2&gt;&lt;h3 id=&quot;摘</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>强化学习综述</title>
    <link href="http://zcl0219.github.io/2025/04/16/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/"/>
    <id>http://zcl0219.github.io/2025/04/16/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/</id>
    <published>2025-04-16T15:50:40.000Z</published>
    <updated>2025-04-16T18:10:35.086Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多智能体强化学习通信方法综述"><a href="#多智能体强化学习通信方法综述" class="headerlink" title="多智能体强化学习通信方法综述"></a>多智能体强化学习通信方法综述</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>通信是协调多个智能体行为、拓宽它们对环境的认识以及支持它们协作的有效机制。在多智能体深度强化学习（MADRL）领域，智能体可以通过通信来提高整体学习性能并实现其目标。智能体可以与所有智能体或特定智能体组通信，或者根据特定约束条件进行通信。随着 MADRL 通信（Comm-MADRL）研究工作的不断增多，目前缺乏一种系统性和结构化的方法来区分和分类现有的 Comm-MADRL 方法。在本文中，我们回顾了 Comm-MADRL 领域的最新研究成果，并考虑了在设计和开发多智能体强化学习系统中可能发挥作用的通信的各个方面。考虑到这些方面，我们提出了 9 个维度，沿着这些维度可以对 Comm-MADRL 方法进行分析、开发和比较。通过将现有工作投射到多维空间中，我们发现了一些有趣的趋势。 我们还通过探索可能性的组合，提出了一些设计未来 Comm-MADRL 系统的创新方向。</p><h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><p>许多现实场景，如自动驾驶<sup>[1]</sup>、传感器网络[2]、机器人[3]和游戏[4, 5]，都可以建模为多智能体系统。这些多智能体系统可以通过多智能体强化学习（MARL）技术进行设计和开发，以学习单个智能体的行为，这些行为可以是合作，竞争，或者它们的混合体。由于智能体通常分布在环境中，它们只能访问局部观察而不是环境的完整状态，因此在多智能体强化学习（MARL）中，部分可观测性成为一个基本假设[6-8]。此外，MARL 还面临着非平稳问题[9]，因为每个智能体都面临着受其他智能体变化和适应策略影响的动态环境。通信被视为解决 MARL 中部分可观测性和非平稳问题的关键手段。智能体可以交流个人信息，例如观察、意图、经验或派生特征，从而对环境有更全面的了解，这反过来又使他们能够做出明智的决策[9, 10]。</p><p>由于深度学习[11]及其在强化学习[12]中的应用最近的成功，多智能体深度强化学习（MADRL）近年来取得了巨大成就，其中智能体可以处理高维数据，并在大状态和动作空间中具有泛化能力[7, 8]。我们注意到，大量研究工作集中在具有通信的学习任务上，这些任务旨在通过通信和共享信息来学习解决特定领域的任务，如导航、交通和视频游戏。据我们所知，目前还没有涵盖多智能体深度强化学习（Comm-MADRL）中关于具有通信的学习任务最新工作的综述文献。早期的综述考虑了通信在多智能体强化学习（MARL）中的作用，但将其视为预定义的，而不是学习主题[13-15]。大多数 Comm-MADRL 综述仅涵盖少量研究工作，没有提出一个精细的分类系统来比较和分析它们。在合作场景中，Hernandez-Leal 等人 [16] 使用学习通信来表示学习通信协议的领域，以促进智能体的合作。我们发现的唯一一份将一些早期工作分类到 Comm-MADRL 的综述来自 Gronauer 和 Diepold [17]，它基于区分消息是否被所有智能体、一组智能体或智能体网络接收。然而，Comm-MADRL 的其他方面，如消息类型和训练范式，对于通信至关重要，可以帮助描述现有的通信协议，却被忽略了。因此，关于具有通信的学习任务的近期综述中，所审查的论文相当有限，提出的分类过于狭窄，无法区分 Comm-MADRL 中的现有工作。另一方面，还有一个密切相关的研究领域，即涌现语言/通信，它也通过各种强化学习技术考虑通过学习通信。[18] 与 Comm-MADRL 不同，涌现语言研究的主要目标是学习一种符号语言。然而，涌现语言研究的一部分工作追求一个额外的目标，即利用可学习的符号语言来提高任务级别的性能。值得注意的是，这些研究成果尚未被现有 Comm-MADRL 综述所涵盖，但被纳入我们的调查，称为具有涌现语言的认知任务。总之，我们的调查在范围上与涌现语言的调查重叠（即在具有涌现语言的认知任务中），但我们的调查关注不同的主要目标（即实现特定领域的任务，而不是学习符号语言）。我们进一步在第 2.2 节中阐明具有通信和学习涌现语言的学习任务之间的区别。</p><p>在我们的调查论文中，我们通过关注通信如何被利用来提高多智能体深度强化学习技术的性能，回顾了 Comm-MADRL 文献。具体来说，我们专注于可学习的通信协议，这些协议与强调通过深度强化学习技术开发动态和自适应通信的近期工作相一致，包括学习何时、如何以及与谁进行通信。通过对近期 Comm-MADRL 文献的全面回顾，我们提出了一种系统性和结构化的分类方法，旨在区分和分类各种 Comm-MADRL 方法。这种方法还将为新的 Comm-MADRL 系统的设计和进步提供指导。假设我们计划为当前领域任务开发一个 Comm-MADRL 系统。从何时、如何以及与谁进行通信的问题开始，系统可以从多个方面进行描述。智能体需要学习何时进行通信、与谁进行通信、传达什么信息、如何整合接收到的信息，最后，通过通信可以实现哪些学习目标。 我们提出了 9 个维度，对应于 Comm-MADRL 系统的独特方面：控制目标、通信约束、通信者类型、通信策略、传递消息、消息组合、内部整合、学习方法以及训练方案。这些维度构成了 Comm-MADRL 系统的骨架，可用于全面分析和深入了解设计的 Comm-MADRL 方法。通过将最近的 Comm-MADRL 方法映射到这个多维结构中，我们不仅提供了对该领域当前技术水平的洞察，还确定了设计未来 Comm-MADRL 系统的一些重要方向。</p><p>本文剩余部分的结构如下。第 2 节讨论了多智能体强化学习的预备知识，以及关于通信的现有扩展和近期调查的详细比较。第 3 节，我们提出了我们的建议维度，解释了如何将近期的工作按每个维度的类别进行分组。第 4 节，我们讨论了文献中发现的趋势，并受建议维度驱动，提出了该研究领域的可能研究方向。第 5 节，我们总结了本文的结论。</p><h3 id="2-背景"><a href="#2-背景" class="headerlink" title="2. 背景"></a>2. 背景</h3><p>在本节中，我们首先提供关于多智能体强化学习的必要背景知识。然后，我们展示如何将多智能体强化学习扩展到考虑智能体之间的通信。最后，我们介绍并比较了涉及通信的近期调查，从中我们可以直接看到我们填补现有调查中空白的原因。</p><h4 id="2-1-多智能体强化学习"><a href="#2-1-多智能体强化学习" class="headerlink" title="2.1 多智能体强化学习"></a>2.1 多智能体强化学习</h4><p>现实世界的应用通常包含多个在环境中运行的智能体。智能体通常被认为是自主的，并且需要学习策略以实现其目标。多智能体环境可以根据环境是否完全可观测、智能体的目标如何相关联等因素以多种方式形式化[6]。其中，部分可观测随机博弈（POSG）[19, 20]是最灵活的形式化之一。POSG 由一个元组定义，其中 I 是（有限）智能体集合，按{1, …, n}索引，S 是环境状态集合，𝜌是状态空间 S 上的初始状态分布，A 是智能体 i 可用的动作集合，O 是智能体 i 的观察集合。我们表示联合动作空间为 A = ×A，智能体联合观察空间为 O = ×O。因此，P ∶ S × A → Δ(S)表示从状态 s ∈ S 到新状态 s∈ S 的转移概率，给定智能体的联合动作⃗ a = ⟨a, …, a ⟩，其中⃗ a ∈ A。当环境过渡到新状态 s 时，给定联合动作⃗</p><p>a 根据观察概率函数 O ∶ S × A → Δ(O)确定。然后，每个智能体根据其自身的奖励函数 R∶ S × A × S → ℝ获得即时奖励。与联合动作和观察类似，我们可以将⃗ r = ⟨r, …, r⟩表示为联合奖励。如果智能体的奖励函数恰好相同，即它们具有相同的目标，那么对于每个时间步，r= r= … = r 都成立。在这种情况下，POSG 简化为 Dec-POMDP [6]。如果每个时间步的状态可以从智能体的当前观察集中唯一确定，即 s ≡⃗ o，则 Dec-POMDP 简化为 Dec-MDP。如果每个智能体都知道真实的环境状态，则 Dec-MDP 简化为多智能体 MDP。如果智能体集合中只有一个智能体，即 I = {1}，则多智能体 MDP 简化为 MDP，而 DecPOMDP 简化为 POMDP。由于部分可观测性，MARL 方法通常使用每个智能体的观察-动作历史𝜏= {o , a, o, …, o }直到时间步 t 来近似环境状态。请注意，为了简化，时间步 t 通常被省略。</p><p>在多智能体强化学习环境中，智能体可以以去中心化或中心化的方式学习其策略。在去中心化学习中（例如，去中心化 Q 学习[21, 22]），n 个智能体的多智能体强化学习问题被分解为 n 个去中心化的单智能体问题，其中每个智能体通过将所有其他智能体视为环境的一部分来学习自己的策略[23, 24]。在这样的去中心化设置中，每个智能体学习的策略取决于其局部观察和历史。去中心化学习的一个主要问题是环境的所谓非平稳性，即每个智能体在一个其他智能体同时探索和学习的环境中学习。中心化学习可以训练所有智能体的单个联合策略或中心化的价值函数，以促进 n 个去中心化策略的学习。虽然中心化（联合）学习消除了或减轻了部分可观察性和非平稳性问题，但它面临着联合行动（和观察）空间随着智能体数量及其行动的指数级扩展的挑战。 想要深入了解多智能体强化学习（MARL）中使用的各种训练方案，我们推荐阅读[17]的全面综述，该综述为策略的训练和执行提供了宝贵的见解。根据策略是从值函数导出还是直接学习，多智能体强化学习方法可以分为基于值的方法和基于策略的方法。这两种方法在通信多智能体深度强化学习（Comm-MADRL）中得到了广泛的应用。</p><h5 id="基于值"><a href="#基于值" class="headerlink" title="基于值"></a>基于值</h5><p>在多智能体情况下，基于值的方法借鉴了单智能体案例中的许多想法。作为最流行的基于值的方法之一，分布式 Q 学习为每个智能体学习一个局部 Q 函数。在智能体共享共同奖励的协作设置中，智能体 i 的更新规则如下：<br>其中 r 是共享奖励，ais 是下一个状态 s 中具有最高 Q 值的动作。在部分可观察环境中，环境状态不是完全可观察的，通常由每个代理的个体观察或历史记录来代替。每个状态-动作对的 Q 值根据 TD 误差逐步更新。这个误差，即 r + 𝛾 maxQ(s, a) − Q(s, a )，表示基于 Bellman 方程[25]的新估计（即 r + 𝛾 maxQ(s, a)）和当前估计（即 Q(s, a)）之间的差异。由于状态和动作空间可能太大，难以频繁遇到以进行准确估计，因此函数逼近方法，如深度神经网络，已经变得流行，为价值或策略模型赋予在离散和连续状态和动作上的泛化能力[12]。例如，深度 Q 网络（DQN）[12]最小化从采样奖励计算的新估计与参数化 Q 函数的当前估计之间的差异。在基于 DQN 的方法中，方程 1 中的 Q 函数表示为 Q(s, a ;𝜃)，它依赖于可学习的参数𝜃。 然而，基于价值的集中式学习方法学习一个联合 Q 函数 Q(s,⃗ a;𝜃)与参数𝜃。然而，这种方法在代理数量增加时难以扩展。值分解方法[26-29]是流行的多智能体强化学习（MARL）方法，可以将联合 Q 函数分解以实现高效的训练。这些方法也广泛应用于 Comm-MADRL 的研究工作中[30-32]。在部分可观察环境中，线性值分解方法将基于历史的联合 Q 函数分解如下：<br>其中，联合 Q 函数基于所有代理的联合历史，并基于个体历史分解为局部 Q 函数。权重 w 可以是固定值[26, 28]或受特定约束的可学习参数[29]。优势函数也可以替换上述方程中的 Q 函数以减少方差[33]。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;多智能体强化学习通信方法综述&quot;&gt;&lt;a href=&quot;#多智能体强化学习通信方法综述&quot; class=&quot;headerlink&quot; title=&quot;多智能体强化学习通信方法综述&quot;&gt;&lt;/a&gt;多智能体强化学习通信方法综述&lt;/h2&gt;&lt;h3 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DRL Algorithms</title>
    <link href="http://zcl0219.github.io/2024/10/30/DRL-Algorithms/"/>
    <id>http://zcl0219.github.io/2024/10/30/DRL-Algorithms/</id>
    <published>2024-10-29T16:26:54.000Z</published>
    <updated>2024-10-29T17:20:24.879Z</updated>
    
    <content type="html"><![CDATA[<p>在深度强化学习中，(\mathbb{E}_{S}[V(S, \theta)]) 表示对状态 (S) 的期望值。虽然 (S) 是状态，具体理解上可以这样考虑：</p><ol><li><p><strong>状态的分布</strong>：在强化学习中，状态 (S) 是随机变量，它遵循一个分布 (p(S))，该分布反映了状态在环境中的出现概率。这个分布可以是初始状态分布，也可以是策略执行时经过各个状态的访问分布。我们可以理解为期望值 (\mathbb{E}_{S}[V(S, \theta)]) 是对状态分布 (p(S)) 的加权平均。</p></li><li><p><strong>求期望的含义</strong>：当我们求 (\mathbb{E}_{S}[V(S, \theta)]) 时，实际上是在所有可能的状态上计算一个加权平均值，即把每个状态的价值函数 (V(S, \theta)) 按其出现的概率 (p(S)) 来进行加权。这种期望值通常用于估计模型在整个状态空间上的表现。</p></li><li><p><strong>样本估计</strong>：在实际中，这种期望值可以通过采样实现，比如通过从 (p(S)) 中采样得到一系列状态 (\{S_i\})，然后计算这些状态上 (V(S, \theta)) 的平均值来逼近 (\mathbb{E}_{S}[V(S, \theta)])。</p></li></ol><p>综上，(\mathbb{E}_{S}[V(S, \theta)]) 是对状态空间中的每个状态价值的加权平均，权重来自状态的分布 (p(S))。这种方法在强化学习中帮助我们通过全局状态分布来评估价值函数，从而更有效地训练模型。</p><p>随机梯度是对期望的蒙特卡洛近似</p><p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030002933171.png" alt="image-20241030002933171"></p><p>通常来说，J(\theta)是一个很复杂的函数，而L(\theta | \theta_{old})是一个相对简单的函数</p><p>构建L的方法多种多样，可以是J的二阶泰勒展开，也可以是J的蒙特卡洛近似</p><p>要maximization，即相当于求解一个带置信域约束的最优化问题，求解速度没有梯度上升和随机梯度上升算法快</p><p>但置信域算法强在比这两种算法表现稳定，哪怕最优化问题求解不是很准确。</p><p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030003652735.png" alt="image-20241030003652735"></p><p>J(\theta) = E_{S}[V_{\pi}(S)]中对S求期望，相当于消除了S，只剩下策略网络参数\theta</p><p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030004813870.png" alt="image-20241030004813870"></p><p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030005237667.png" alt="image-20241030005237667"></p><p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030005401769.png" alt="image-20241030005401769"></p><p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030010211366.png" alt="image-20241030010211366"></p><p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030010802155.png" alt="image-20241030010802155"></p><p>第四步需要内层循环求解最大化问题，第四步两个超参数，一个\delta，一个学习步长。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在深度强化学习中，(&#92;mathbb{E}_{S}[V(S, &#92;theta)]) 表示对状态 (S) 的期望值。虽然 (S) 是状态，具体理解上可以这样考虑：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;状态的分布&lt;/strong&gt;：在强化学习中，状态 (S) 是随机变量</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DiaDSP</title>
    <link href="http://zcl0219.github.io/2024/10/22/DiaDSP/"/>
    <id>http://zcl0219.github.io/2024/10/22/DiaDSP/</id>
    <published>2024-10-22T13:38:57.000Z</published>
    <updated>2024-10-27T11:06:54.954Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Differentially-Private-Distributed-Optimization-via-State-and-Direction-Perturbation-in-Multiagent-Systems"><a href="#Differentially-Private-Distributed-Optimization-via-State-and-Direction-Perturbation-in-Multiagent-Systems" class="headerlink" title="Differentially Private Distributed Optimization via State and Direction Perturbation in Multiagent Systems"></a>Differentially Private Distributed Optimization via State and Direction Perturbation in Multiagent Systems</h3><span id="more"></span><h4 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h4><p><a href="https://differential-privacy.cn/">Differential privacy</a> <i class="fa fa-external-link"></i></p><h4 id="Prerequisite-Knowledge"><a href="#Prerequisite-Knowledge" class="headerlink" title="Prerequisite Knowledge"></a>Prerequisite Knowledge</h4><p>What is state perturbation ?</p><ul><li>State perturbation refers to the intentional modification of an agent’s current state by introducing randomness or noise.</li></ul><p>What is differential privacy ?</p><ul><li>Differential privacy is a formal framework designed to ensure the privacy of individual’s data. <a href="https://arxiv.org/pdf/1401.2596">Achieving differential privacy requires that any change in the statistics of the messages</a>.<i class="fa fa-external-link"></i></li></ul><p>What is direction perturbation ?</p><p>Direction perturbation involves introducing randomness or noise into the direction of the optimization process in a distributed algorithm. This technique modifies the gradient or update direction that agents use when adjusting their parameters during optimization.<br>By perturbing the direction, the algorithm can maintain privacy by making it more challenging for other agents or observers to infer the true gradient information, thereby protecting individual agents’ objective functions. Additionally, direction perturbation can help enhance the robustness of the optimization process and contribute to convergence properties, particularly in scenarios where privacy is a critical concern.</p><p>What is differential privacy ?</p><p>In simple terms, Laplace noise refers to a random variable that follows a Laplace distribution. The probability density function of Laplace noise is represented as follows:<br>$$f(x \mid \mu, b) = \frac{1}{2b} e^{-\frac{|x-\mu|}{b}}.$$<br>Now, let us introduce the concept of $\epsilon$-differential privacy. Consider a mapping network $\mathbf{A}$ and two sibling datasets $\mathbf{D}$ and $\mathbf{D^{\prime}}$. Note that $\mathbf{D}$ and $\mathbf{D’}$ differ by at most one data point. The mathematical condition for the mapping network $\mathbf{A}$ to satisfy $\epsilon$-differential privacy is as follows<br>$$\operatorname{Pr}\left[A(\mathbf{D})=O\right] \leq e^{\varepsilon} \operatorname{Pr}\left[A\left(\mathbf{D^{\prime}}\right)=O\right].$$<br>The proof is provided here: <a href="https://blog.csdn.net/A13526_/article/details/121300367">$\epsilon$-differential privacy proof</a>.<i class="fa fa-external-link"></i></p><p>$x \in \mathbb{R}^u$ represents local observation.</p><p>$\mathbf{x} \in \mathbb{R}^{n \times u},$ The rows of $\mathbf{x}$ represent the local observation of each agent $i$.</p><p>$\min \sum_{i=1}^{n} f_{i}(x_{i})$ represents the objective function, associated with four properties as below</p><ol><li><p>$\textit{Existence}$ : </p><p>$$\mathbf{x}^{*}= \mathbf{1} \left( x^{*} \right)^{T} \text{ and } \sum_{i=1}^{n} \nabla f_{i} \left( x^{*} \right) = 0.$$</p></li><li></li></ol><h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>The article focuses on the distributed optimization problem in multi-agent system, where the objective is to minimize the sum of cost functions. It demonstrates that achieving both convergence and differential privacy is impossible through state perturbation in existing algorithms. The authors propose a new algorithm called DiaDSP, which utilizes both state and direction perturbations with decaying Laplace noise to ensure differential privacy. Unlike many prior methods that require diminishing step sizes for convergence, DiaDSP converges in mean and almost surely with a constant step size. The authors establish conditions for linear convergence under strong convexity of the cost functions and R-linear convergence with Lipschitz gradients. The authors also analyze the trade-off between privacy and convergence accuracy and validate their findings through simulations in a sensor fusion context.</p><h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><h4 id="Problem-Formulation"><a href="#Problem-Formulation" class="headerlink" title="Problem Formulation"></a>Problem Formulation</h4><p>The objectives of this article are twofold:</p><ol><li>Design a fully distributed update rule $h(\cdot)$ and a noise adding mechanism $g(\cdot)$ only based on local information to solve the DO problem $\min \sum_{i=1}^{n} f_{i}(x_{i})$ while preserving the differential privacy.</li><li>Characterize the trade-off between the accuracy of convergence and the level of differential privacy.</li></ol><p>Notes:</p><ol><li>The update rule can be represented in a compact form as follows: $$\mathbf{x}(k + 1) = h(\mathbf{x}(k), \mathbf{z}(k), \textbf(A), \mathcal{F}).$$</li><li>The attacker has access to all the transmitted messages, which are usually masked by noise $\zeta(k)$, i.e.,<br>$$\mathbf{z}(k) = g(\mathbf{x}(k), \zeta(k)).$$</li><li>The privacy level of $\epsilon$-differential privacy is generally determined by $\epsilon$. The smaller $\epsilon$ is, the higher the privacy level. In other words, it becomes more challenging to distinguish between the two target functions when $\epsilon$ is small.</li></ol><h4 id="DiaDSP-Algorithm"><a href="#DiaDSP-Algorithm" class="headerlink" title="DiaDSP Algorithm"></a>DiaDSP Algorithm</h4><p>A. Motivation: An Impossibility Result</p><p>Summary: The result shows that the convergence and differential privacy cannot be guaranteed simultaneously for any global exact DO algorithm.</p><p>Proof of Proposition 1 (convergence ($\surd$))</p><p>$\mathbf{x}^{(l)}(k) \rightarrow$ the convergence point by $\mathbf{x}_{l}^{\infty}$. Hence, there is $\delta^{*} &gt; 0$, satisfying $\big| g(\mathbf{x}_{1}^{*}, \mathbf{0}) - g(\mathbf{x}_{2}^{*}, \mathbf{0})\big|_{\textit{F}}$ We set an upper threshold $\frac{\delta^{*}}{3}$. Therefore, there exists $k_{\delta^{*}}^{(l)} &gt; 0$ such that $\big| \mathbf{z}^{l}(k) - g(\mathbf{x}_{l}^{*}, \mathbf{0})\big| &lt; \frac{\delta^{*}}{3}.$<br>$$\big| z^{(1)}(k) - z^{(2)}(k)| \geq |g(x_1^{*}, 0) - g(x_2^{*}, 0)| - |g(x_1^{*}, 0) - z^{(1)}(k)| - |g(x_2^{*}, 0) - z^{(2)}(k)\big|.$$<br>$$|a + b + c| \geq |b| - |a| - |c|.$$<br>$$a = z^{(1)}(k) - g(x_1^{*}, 0), \quad b = g(x_1^{*}, 0) - g(x_2^{*}, 0), \quad c = g(x_2^{*}, 0) - z^{(2)}(k).$$<br>$$|z^{(1)}(k) - z^{(2)}(k)| \geq |g(x_1^{*}, 0) - g(x_2^{*}, 0)| - |z^{(1)}(k) - g(x_1^{*}, 0)| - |g(x_2^{*}, 0) - z^{(2)}(k)|.$$<br>$$|z^{(1)}(k) - z^{(2)}(k)| \geq |g(x_i^{*}, 0) - g(x_2^{*}, 0)| - \frac{2\delta^{*}}{3}.$$</p><p>B. Development of DiaDSP</p><p>We employ the combine-then-adapt strategy for each agent $i$, which is expressed as $$x_{i}(k+1) = \sum_{j=1}^{n} a_{ij} x_{j}(k) - \alpha_{i} y_{i}(k).$$ This formula is analogous to the parameter update mechanism in neural networks. $x_i(k)$ can be considered as the transition between different states. $y_i(k)$  is regarded as the gradient of the cost function. Therefore, $y_i(k)$ is supposed to have the same direction as $\sum_{i=1}^{n} \nabla f_i(x_i(k)).$ One advantage of adopting the GT method is that the iterations $$x_{i}(k+1) = \sum_{j=1}^{n} a_{ij} x_{j}(k) - \alpha_{i} y_{i}(k).$$ and $$y_i(k+1) = \sum_{j=1}^{n} a_{ij} y_j(k) + \nabla f_i(x_i(k+1)) - \nabla f_i(x_i(k)).$$ share the same network and we do not need to generate another network for the GT iteration. The reason is that they have the same input dimension and both update around the gradient of the cost function with respect to $f_i(x_i(k))$.</p><h4 id="Convergence-Analysis-of-DiaDSP"><a href="#Convergence-Analysis-of-DiaDSP" class="headerlink" title="Convergence Analysis of DiaDSP"></a>Convergence Analysis of DiaDSP</h4><p>This section mainly include three key points:</p><ol><li>Analyze the convergence of DiaDSP</li><li>Prove the R-linear convergence of DiaDSP</li><li>Determine the optimal step size</li></ol><p>Differential Privacy</p><p>Simulations</p><p>Conclusion</p><p>Questions and Insights</p><ol><li>What is R-linear convergence ?</li></ol>    <style>    #refplus, #refplus li{         padding:0;        margin:0;        list-style:none;    }；    </style>    <script src="https://unpkg.com/@popperjs/core@2"></script>    <script src="https://unpkg.com/tippy.js@6"></script>    <script>    document.querySelectorAll(".refplus-num").forEach((ref) => {        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');        let refel = document.querySelector(refid);        let refnum = refel.dataset.num;        let ref_content = refel.innerText.replace(`[${refnum}]`,'');        tippy(ref, {            content: ref_content,        });    });    </script>    ]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Differentially-Private-Distributed-Optimization-via-State-and-Direction-Perturbation-in-Multiagent-Systems&quot;&gt;&lt;a href=&quot;#Differentially-Private-Distributed-Optimization-via-State-and-Direction-Perturbation-in-Multiagent-Systems&quot; class=&quot;headerlink&quot; title=&quot;Differentially Private Distributed Optimization via State and Direction Perturbation in Multiagent Systems&quot;&gt;&lt;/a&gt;Differentially Private Distributed Optimization via State and Direction Perturbation in Multiagent Systems&lt;/h3&gt;</summary>
    
    
    
    <category term="Scholarly Reads" scheme="http://zcl0219.github.io/categories/Scholarly-Reads/"/>
    
    
    <category term="Distributed Optimization Algorithm" scheme="http://zcl0219.github.io/tags/Distributed-Optimization-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>算法</title>
    <link href="http://zcl0219.github.io/2023/11/10/%E7%AE%97%E6%B3%95/"/>
    <id>http://zcl0219.github.io/2023/11/10/%E7%AE%97%E6%B3%95/</id>
    <published>2023-11-10T10:44:01.000Z</published>
    <updated>2024-10-20T12:40:55.432Z</updated>
    
    <content type="html"><![CDATA[<p>2023-11-10</p><p>并查集：<a href="https://blog.csdn.net/YSJ367635984/article/details/113504723">https://blog.csdn.net/YSJ367635984/article/details/113504723</a></p><span id="more"></span><p>C++代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisjointSets</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DisjointSets</span>();</span><br><span class="line">    ~<span class="built_in">DisjointSets</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findParentNode</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionSetNode</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DisjointSets::<span class="built_in">DisjointSets</span>(): <span class="built_in">count</span>(<span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)&#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DisjointSets::~<span class="built_in">DisjointSets</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int DisjointSets::findParentNode(int x)&#123;</span></span><br><span class="line"><span class="comment">    if(x != parent[x])&#123;</span></span><br><span class="line"><span class="comment">        findParentNode(parent[x]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return x;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化版本的并查集，减小以后查找时间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DisjointSets::findParentNode</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x != parent[x])&#123;</span><br><span class="line">        <span class="comment">// 找一次x只是压缩一次，多找几次就会导致父节点为根节点</span></span><br><span class="line">        parent[x] = parent[parent[x]];</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisjointSets::unionSetNode</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> parent_x = <span class="built_in">findParentNode</span>(x);</span><br><span class="line">    <span class="type">int</span> parent_y = <span class="built_in">findParentNode</span>(y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(parent_x == parent_y) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    parent[parent_y] = parent_x;</span><br><span class="line">    </span><br><span class="line">    --count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;2023-11-10&lt;/p&gt;
&lt;p&gt;并查集：&lt;a href=&quot;https://blog.csdn.net/YSJ367635984/article/details/113504723&quot;&gt;https://blog.csdn.net/YSJ367635984/article/details/113504723&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Zookeeper</title>
    <link href="http://zcl0219.github.io/2023/10/22/Zookeeper/"/>
    <id>http://zcl0219.github.io/2023/10/22/Zookeeper/</id>
    <published>2023-10-22T10:27:16.000Z</published>
    <updated>2023-10-22T12:52:38.677Z</updated>
    
    <content type="html"><![CDATA[<p>一、Zookeeper特点</p><ol><li>Zookeeper:一个领导者(Leader)，多个跟随者(Follower)组成的集群。<br>2)集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器。<br>3)全局数据一致:每个Server保存一份相同的数据副本， Client无论连接到哪个Server，数据都是一致的。<br>4)更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行。<br>5)数据更新原子性，一次数据更新要么成功，要么失败。<br>6)实时性，在一定时间范围内，Client能读到最新数据。</li></ol><p>二、数据结构<br>ZooKeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一棵树，每个节点称做一个ZNode。每一个ZNode默认能够存储1MB 的数据，每个ZNode都可以通过其路径唯一标识。</p><p>三、应用场景</p><p>提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。</p><p>四、配置参数</p><p>tickTime &#x3D; 2000：通信心跳时间，Zookeeper服务器与客户端心跳时间，单位毫秒</p><p>initLimit &#x3D; 10：LF初始通信时限，10次心跳，也就是20s，Leader和Follower初始链接时限</p><p>syncLimit &#x3D; 5：LF同步通信时限，两者之间的通信时间（5s）</p><p>dataDir：保存Zookeeper中的数据，可以修改</p><p>clientPort &#x3D; 2181：客户端连接端口，通常不做修改</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、Zookeeper特点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Zookeeper:一个领导者(Leader)，多个跟随者(Follower)组成的集群。&lt;br&gt;2)集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器。&lt;br&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>对象的优化</title>
    <link href="http://zcl0219.github.io/2023/10/22/%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BC%98%E5%8C%96/"/>
    <id>http://zcl0219.github.io/2023/10/22/%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BC%98%E5%8C%96/</id>
    <published>2023-10-22T08:31:53.000Z</published>
    <updated>2023-10-22T10:26:35.842Z</updated>
    
    <content type="html"><![CDATA[<p>一、拷贝构造、赋值运算符重载的相关知识</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> a = <span class="number">10</span>): <span class="built_in">ma</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test &amp;t): <span class="built_in">ma</span>(t.ma) &#123; cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    Test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Test &amp;t)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">        ma = t.ma;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test t1;</span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;</span><br><span class="line">    Test t3 = t1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Test(20)显式生成临时对象 生存周期：所在的语句</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    c++编译器对于对象构造的优化：</span></span><br><span class="line"><span class="comment">    用临时对象生成新对象的时候，临时对象就不产生了，直接构造新对象就可以了。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Test t4 = <span class="built_in">Test</span>(<span class="number">20</span>); <span class="comment">// Test t4(20)没有区别的!</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t4 = t2; <span class="comment">// t4已经存在，这是赋值</span></span><br><span class="line">    t4 = <span class="built_in">Test</span>(<span class="number">30</span>); <span class="comment">// t4.operator=(const Test &amp;t)</span></span><br><span class="line">    t4 = (Test)<span class="number">30</span>; <span class="comment">// int -&gt; Test,强制转换编译器会看有没有合适的构造函数</span></span><br><span class="line">    t4 = <span class="number">30</span>; <span class="comment">// 隐式生成临时对象 隐式类型转换，注意如果30换成一个char类型变量，那就不行了，因为没有对应的构造  函数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Test *p = &amp;<span class="built_in">Test</span>(<span class="number">40</span>); <span class="comment">// p指向的是一个已经析构的临时对象</span></span><br><span class="line">    <span class="type">const</span> Test &amp;ref = <span class="built_in">Test</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="comment">// 使用引用引用一个临时变量，临时变量的周期就变为了变量的生命周期</span></span><br><span class="line">    <span class="comment">// 自己思考为引用给变量起了一个别名，在引用的生命周期内，就可以继续访问这个临时变量了</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> a = <span class="number">5</span>, <span class="type">int</span> b = <span class="number">5</span>): <span class="built_in">ma</span>(a), <span class="built_in">mb</span>(b)&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test(int, int)&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test &amp;src): <span class="built_in">ma</span>(src.ma), <span class="built_in">mb</span>(src.mb)&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Test &amp;src)&#123;</span><br><span class="line">        ma = src.ma;</span><br><span class="line">        mb = src.mb;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">    <span class="type">int</span> mb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;  <span class="comment">//1. Test(int , int)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;  <span class="comment">//3. Test(int , int)</span></span><br><span class="line">    Test t3 = t2; <span class="comment">// 4.Test(const Test&amp;)</span></span><br><span class="line">    <span class="type">static</span> Test t4 = <span class="built_in">Test</span>(<span class="number">30</span>, <span class="number">30</span>); <span class="comment">//5. Test(int, int)</span></span><br><span class="line">    t2 = <span class="built_in">Test</span>(<span class="number">40</span>, <span class="number">40</span>); <span class="comment">//6.Test(int, int), operetor=, ~Test()</span></span><br><span class="line">    t2 = (Test)(<span class="number">50</span>, <span class="number">50</span>); <span class="comment">//7.Test(int, int), operetor=, ~Test()</span></span><br><span class="line">    t2 = <span class="number">60</span>; <span class="comment">//8.Test(int, int), operetor=, ~Test()</span></span><br><span class="line">    Test *p1 = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">70</span>, <span class="number">70</span>); <span class="comment">// 9.Test(int, int),堆上需要显式释放</span></span><br><span class="line">    Test *p2 = <span class="keyword">new</span> Test[<span class="number">2</span>]; <span class="comment">// 10.Test(int, int), Test(int, int)</span></span><br><span class="line">    Test *p3 = &amp;<span class="built_in">Test</span>(<span class="number">80</span>, <span class="number">80</span>); <span class="comment">//11.Test(int, int), ~Test()</span></span><br><span class="line">    <span class="type">const</span> Test &amp;p4 = <span class="built_in">Test</span>(<span class="number">90</span>, <span class="number">90</span>); <span class="comment">//12.Test(int, int)</span></span><br><span class="line">    <span class="keyword">delete</span> p1; <span class="comment">// 13.~Test()</span></span><br><span class="line">    <span class="keyword">delete</span> []p2; <span class="comment">// 14. ~Test(), ~Test()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Test <span class="title">t5</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;  <span class="comment">//2. Test(int , int)</span></span><br><span class="line"><span class="comment">// 注意，t4的析构最晚，它在数据段，需要等程序结束。</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、拷贝构造、赋值运算符重载的相关知识&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>OS_ucore</title>
    <link href="http://zcl0219.github.io/2023/10/18/OS-ucore/"/>
    <id>http://zcl0219.github.io/2023/10/18/OS-ucore/</id>
    <published>2023-10-18T02:11:15.000Z</published>
    <updated>2023-12-25T18:08:19.076Z</updated>
    
    <content type="html"><![CDATA[<p>1、操作系统要干啥？哪些操作&#x2F;任务不属于操作系统的管理范畴？</p><p>2、工具使用</p><p>阅读源码工具：<code>understannd</code></p><p>源码文档自动生成工具：<code>doxygen</code></p><p>虚拟运行环境：<code>qemu</code></p><p><code>Lab0</code></p><p>1、了解汇编</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;cld \n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;rep \n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;stosl&quot;</span></span><br><span class="line">        :</span><br><span class="line">        : <span class="string">&quot;c&quot;</span> (count), <span class="string">&quot;a&quot;</span>(value), <span class="string">&quot;D&quot;</span> (buf[<span class="number">0</span>])</span><br><span class="line">        :</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这段 C 代码给出了一个简单的函数，其中包括了一段内联汇编。</span></span><br><span class="line"><span class="comment">该代码试图展示如何使用 `rep stos` 指令来填充一个缓冲区，但存在一些问题和错误。</span></span><br><span class="line"><span class="comment">我会逐步解释代码，然后提出建议的更正。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 变量定义:</span></span><br><span class="line"><span class="comment">    ```c</span></span><br><span class="line"><span class="comment">    int count = 1;</span></span><br><span class="line"><span class="comment">    int value = 1;</span></span><br><span class="line"><span class="comment">    int buf[10];</span></span><br><span class="line"><span class="comment">    ```</span></span><br><span class="line"><span class="comment">    你定义了三个变量：一个 `count` 用于记录要重复的次数，</span></span><br><span class="line"><span class="comment">                    一个 `value` 用于指定要存储的值，</span></span><br><span class="line"><span class="comment">                    以及一个 `buf` 数组用于存储数据。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 主函数和内联汇编:</span></span><br><span class="line"><span class="comment">    ```c</span></span><br><span class="line"><span class="comment">    void main()&#123;</span></span><br><span class="line"><span class="comment">        asm(</span></span><br><span class="line"><span class="comment">            &quot;cld \n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;rep \n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;stsol&quot;</span></span><br><span class="line"><span class="comment">            :</span></span><br><span class="line"><span class="comment">            : &quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf[0])</span></span><br><span class="line"><span class="comment">        );</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    ```</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    - `cld`: 清除方向标志（Direction Flag）。这确保了字符串操作（如 `stos`）从低地址向高地址操作。</span></span><br><span class="line"><span class="comment">    - `rep stos`: 这应该是一个组合的指令，意思是&quot;重复存储&quot;。</span></span><br><span class="line"><span class="comment">      你试图使用这个指令将 `value` 的内容存储到 `buf` 指定的内存位置，</span></span><br><span class="line"><span class="comment">      并根据 `count` 的值重复该操作。但这里有个小错误: 你写的是 `&quot;stsol&quot;`，它是不正确的。应该是 `&quot;stosl&quot;`。</span></span><br><span class="line"><span class="comment">    - 输出约束（Output operands）: 这里没有列出输出操作数，所以你只有一个冒号。</span></span><br><span class="line"><span class="comment">    - 输入约束（Input operands）: `&quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf[0])`，这里:</span></span><br><span class="line"><span class="comment">        * `&quot;c&quot; (count)`：把 `count` 放入 `ECX` 寄存器（这是 `rep` 指令使用的计数寄存器）。</span></span><br><span class="line"><span class="comment">        * `&quot;a&quot;(value)`：把 `value` 放入 `EAX` 寄存器（这是 `stosl` 指令使用的源数据寄存器）。</span></span><br><span class="line"><span class="comment">        * `&quot;D&quot; (buf[0])`：把 `buf` 的首地址放入 `EDI` 寄存器（这是 `stosl` 指令使用的目标地址寄存器）。</span></span><br><span class="line"><span class="comment">          但这样写是不准确的，应该是 `&quot;D&quot; (buf)`。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">修正后的代码如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">```c</span></span><br><span class="line"><span class="comment">int count = 1;</span></span><br><span class="line"><span class="comment">int value = 1;</span></span><br><span class="line"><span class="comment">int buf[10];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void main()&#123;</span></span><br><span class="line"><span class="comment">    asm(</span></span><br><span class="line"><span class="comment">        &quot;cld \n\t&quot;</span></span><br><span class="line"><span class="comment">        &quot;rep \n\t&quot;</span></span><br><span class="line"><span class="comment">        &quot;stosl&quot;</span></span><br><span class="line"><span class="comment">        :</span></span><br><span class="line"><span class="comment">        : &quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf)</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">```</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：使用内联汇编通常是平台和编译器特定的。</span></span><br><span class="line"><span class="comment">上述代码假定你正在使用 GCC 或其它支持 GNU 汇编语法的编译器，并且在一个 x86 架构的机器上运行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在 GCC 的内联汇编中，第三个冒号后面的部分是用于指定被汇编代码修改的寄存器列表的，也叫做“Clobber List”。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以下是 `asm` 的基本格式：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">asm ( assembly code </span></span><br><span class="line"><span class="comment">     : output operands                  // optional</span></span><br><span class="line"><span class="comment">     : input operands                   // optional</span></span><br><span class="line"><span class="comment">     : list of clobbered registers      // optional</span></span><br><span class="line"><span class="comment">     );</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. Assembly Code: 包含汇编指令的字符串。</span></span><br><span class="line"><span class="comment">2. Output Operands: 输出操作数列表。</span></span><br><span class="line"><span class="comment">3. Input Operands: 输入操作数列表。</span></span><br><span class="line"><span class="comment">4. Clobber List: 表示汇编指令可能会更改的寄存器列表，</span></span><br><span class="line"><span class="comment">   这告诉编译器这些寄存器的值可能会被修改，所以不要依赖它们的原始值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在你的例子中，你使用了 `&quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf[0])` 为汇编指令提供输入操作数，</span></span><br><span class="line"><span class="comment">但你并没有指定输出操作数，也没有列出任何可能被修改的寄存器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">虽然在此例中，你知道 `ECX`, `EAX`, 和 `EDI` 寄存器会被修改，</span></span><br><span class="line"><span class="comment">但在许多情况下，列出clobbered registers是很有必要的，因为它可以帮助编译器更好地优化生成的代码。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以，理论上，你的代码应该像这样：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int count = 1;</span></span><br><span class="line"><span class="comment">int value = 1;</span></span><br><span class="line"><span class="comment">int buf[10];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void main()&#123;</span></span><br><span class="line"><span class="comment">    asm(</span></span><br><span class="line"><span class="comment">        &quot;cld \n\t&quot;</span></span><br><span class="line"><span class="comment">        &quot;rep \n\t&quot;</span></span><br><span class="line"><span class="comment">        &quot;stosl&quot;</span></span><br><span class="line"><span class="comment">        :</span></span><br><span class="line"><span class="comment">        : &quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf)</span></span><br><span class="line"><span class="comment">        : &quot;ecx&quot;, &quot;eax&quot;, &quot;edi&quot;</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这里，`&quot;ecx&quot;, &quot;eax&quot;, &quot;edi&quot;` 是clobber list，告诉编译器这些寄存器的值已经被汇编代码修改了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>3、掌握指针和类型转换相关的Ｃ编程</p><p>实验源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_IG32 0xE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_TG32 0xF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">uint32_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)&#123;\</span></span><br><span class="line"><span class="meta">    (gate).gd_off_15_0 = (uint32_t)(off) &amp; 0xffff;\</span></span><br><span class="line"><span class="meta">    (gate).gd_ss = (sel);\</span></span><br><span class="line"><span class="meta">    (gate).gd_args = 0;\</span></span><br><span class="line"><span class="meta">    (gate).gd_rsv1 = 0;\</span></span><br><span class="line"><span class="meta">    (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;\</span></span><br><span class="line"><span class="meta">    (gate).gd_s = 0;\</span></span><br><span class="line"><span class="meta">    (gate).gd_dpl = (dpl);\</span></span><br><span class="line"><span class="meta">    (gate).gd_p = 1;\</span></span><br><span class="line"><span class="meta">    (gate).gd_off_31_16 = (uint32_t)(off) &gt;&gt; 16;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> gd_off_15_0: <span class="number">16</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_ss: <span class="number">16</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_args: <span class="number">5</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_rsv1: <span class="number">3</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_type: <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_s: <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_dpl: <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_p: <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_off_31_16: <span class="number">16</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> before;</span><br><span class="line">    <span class="type">unsigned</span> intr;</span><br><span class="line">    <span class="type">unsigned</span> after;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> <span class="title">gintr</span>;</span></span><br><span class="line"></span><br><span class="line">    intr = <span class="number">8</span>;</span><br><span class="line">    before = after = <span class="number">0</span>;</span><br><span class="line">    gintr = *((<span class="keyword">struct</span> gatedesc*)&amp;intr);</span><br><span class="line">    SETGATE(gintr, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    intr = *((<span class="type">unsigned</span>*)&amp;(gintr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;intr is 0x%x\n&quot;</span>, intr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gintr is 0x%llx\n&quot;</span>, gintr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己根据输出即可推出来是怎么做的。注意，<code>gintr</code>等于<code>0xee0000010002</code>中，最高16位全部等于0没有展示出来。而%x只能展示32位，所以<code>intr</code>的输出结果为：<code>0x10002</code>。</p><h4 id="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"><a href="#一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？" class="headerlink" title="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"></a>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</h4><p>硬盘主引导扇区（Master Boot Record，MBR）是位于硬盘第一个扇区（通常是逻辑地址0号扇区）的512字节的数据结构，用于引导计算机操作系统。一个符合规范的硬盘主引导扇区应该包含以下几个特征：</p><ol><li><p><strong>引导代码（Boot Code）：</strong> 前446个字节用于存储引导代码，这是引导加载程序（Boot Loader）的代码，负责加载操作系统。这段代码必须是有效的汇编代码，能够启动计算机。</p></li><li><p><strong>分区表（Partition Table）：</strong> 接下来的64字节用于存储分区表，每个分区表项占16字节。一个硬盘可以分为最多4个主分区，每个分区表项描述一个分区的起始位置、大小和分区类型等信息。</p></li><li><p><strong>签名字节（Signature）：</strong> 最后的两个字节（0x55AA）是MBR的签名，标志这个扇区是有效的MBR扇区。这个签名是个小端字节序的16位值，它告诉操作系统这个扇区包含了引导信息，是一个有效的MBR。</p></li></ol><p>总结起来，一个被系统认为是符合规范的硬盘主引导扇区应该包含引导代码、分区表和签名字节。这些特征是为了确保引导加载程序可以正确地读取分区信息，从而启动操作系统。如果这些特征中的任何一个缺失或损坏，可能导致系统无法正确引导。</p><p>引导扇区代码（<code>tools/sign.c</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span> </span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: &lt;input filename&gt; &lt;output filename&gt;\n&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stat(argv[<span class="number">1</span>], &amp;st) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error opening file &#x27;%s&#x27;: %s\n&quot;</span>, argv[<span class="number">1</span>], strerror(errno)); </span><br><span class="line">        <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&#x27;%s&#x27; size: %lld bytes\n&quot;</span>, argv[<span class="number">1</span>], (<span class="type">long</span> <span class="type">long</span>)st.st_size); </span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; <span class="number">510</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%lld &gt;&gt; 510!!\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)st.st_size); </span><br><span class="line">        <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf)); </span><br><span class="line">    FILE*ifp=fopen(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="type">int</span> size = fread(buf, <span class="number">1</span>,st.st_size, ifp); </span><br><span class="line">    <span class="keyword">if</span> (size != st.st_size) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;read &#x27;%s&#x27; error, size is %d.\n&quot;</span>, argv[<span class="number">1</span>], size); </span><br><span class="line">        <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ifp);</span><br><span class="line">    buf[<span class="number">510</span>]= <span class="number">0x55</span>; </span><br><span class="line">    buf[<span class="number">511</span>] =<span class="number">0xAA</span>;</span><br><span class="line">    FILE*ofp = fopen(argv[<span class="number">2</span>], <span class="string">&quot;wb+&quot;</span>);</span><br><span class="line">    size = fwrite(buf, <span class="number">1</span>, <span class="number">512</span>, ofp); </span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">512</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;write &#x27;%s&#x27; error, size is %d.\n&quot;</span>, argv[<span class="number">2</span>], size); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ofp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;build 512 bytes boot sector: &#x27;%s&#x27; success!\n&quot;</span>, argv[<span class="number">2</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">这是一个简单的C程序，用于生成一个包含引导代码的512字节的引导扇区（Boot Sector）。这样的引导扇区通常用于创建可引导的存储介质，例如硬盘、U盘等。以下是程序的主要功能和流程：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 使用 `stat` 函数获取指定输入文件（`argv[1]`）的信息，主要是文件大小。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 打印输入文件的大小。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 检查文件大小是否超过了510字节。如果超过，打印错误信息并退出程序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 读取输入文件的内容（最多510字节），将内容存储在一个大小为512字节的缓冲区中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5. 在缓冲区的倒数第二个字节（第510字节）写入0x55，倒数第一个字节（第511字节）写入0xAA。这是引导扇区的标志，用于告诉计算机系统这是一个有效的引导扇区。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6. 打开输出文件（`argv[2]`），将修改后的缓冲区写入文件。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">7. 打印成功信息并返回0。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这个程序的目的是创建一个符合标准的引导扇区，其中包含引导代码和标志字节。请注意，生成的引导扇区在实际使用时需要按照引导扇区的规范进行进一步配置，以确保它能够正确地引导计算机系统。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以下是程序的一些可能的改进和注意事项：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 添加更多的错误检查，例如检查文件是否成功打开。</span></span><br><span class="line"><span class="comment">- 考虑处理更多的边界情况，例如文件是否为空。</span></span><br><span class="line"><span class="comment">- 考虑使用二进制文件读写模式（&quot;rb&quot; 和 &quot;wb+&quot;）而不是文本模式。</span></span><br><span class="line"><span class="comment">- 考虑使用 `perror` 函数来打印与 `fopen`、`fread`、`fwrite` 相关的错误信息。</span></span><br><span class="line"><span class="comment">- 考虑处理大端和小端字节序的问题，特别是当涉及到二进制文件时。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、操作系统要干啥？哪些操作&amp;#x2F;任务不属于操作系统的管理范畴？&lt;/p&gt;
&lt;p&gt;2、工具使用&lt;/p&gt;
&lt;p&gt;阅读源码工具：&lt;code&gt;understannd&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;源码文档自动生成工具：&lt;code&gt;doxygen&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;虚拟</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://zcl0219.github.io/2023/10/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zcl0219.github.io/2023/10/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-10-06T18:57:06.000Z</published>
    <updated>2023-10-06T18:57:06.148Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器-第八章</title>
    <link href="http://zcl0219.github.io/2023/09/07/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
    <id>http://zcl0219.github.io/2023/09/07/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%AC%AC%E5%85%AB%E7%AB%A0/</id>
    <published>2023-09-07T01:30:19.000Z</published>
    <updated>2023-09-07T01:44:27.621Z</updated>
    
    <content type="html"><![CDATA[<p>这里因为做项目的需要，我先写下8.6节有关有限状态机的内容</p><p>这一节我们介绍逻辑单元内部的一种高效编程方法：有限状态机。有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里因为做项目的需要，我先写下8.6节有关有限状态机的内容&lt;/p&gt;
&lt;p&gt;这一节我们介绍逻辑单元内部的一种高效编程方法：有限状态机。有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CMake</title>
    <link href="http://zcl0219.github.io/2023/08/29/CMake/"/>
    <id>http://zcl0219.github.io/2023/08/29/CMake/</id>
    <published>2023-08-29T14:34:47.000Z</published>
    <updated>2023-09-06T02:00:51.820Z</updated>
    
    <content type="html"><![CDATA[<p>这里画一个图直接直接展示一下CMake和Makefile的使用过程</p><p><img src="png1.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ *.cpp -o app  <span class="comment">//直接编译    </span></span><br></pre></td></tr></table></figure><p>使用#注释</p><p>块注释#[[ ]]</p><p>camke_minimum_required：指定使用的cmake的最低版本</p><p>project：定义工程名称</p><p>add_executable：定义工程会生成一个可执行程序 add_executable(可执行程序名称 源文件名称（空格或者分号隔离源文件)）</p><p>cmake CMakeLists.txt：文件所在路径</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(app, add.cpp div.cpp mult.cpp main.cpp sub.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果CMakeLists.txt文件就在当前目录下，直接执行以下命令</span></span><br><span class="line">cmake .</span><br><span class="line">make</span><br><span class="line"><span class="comment">#就会出现app可执行文件</span></span><br></pre></td></tr></table></figure><p>生成了很多其他文件，我们可以把这些临时文件放在一个文件夹里，一般为build文件夹。创建build文件后，cd进build文件，执行camke ..，则cmake执行后生成的文件都放在了build文件夹里。</p><h3 id="set的使用"><a href="#set的使用" class="headerlink" title="set的使用"></a><code>set</code>的使用</h3><p>set是为了简化add_executable(app, add.cpp div.cpp mult.cpp main.cpp sub.cpp)的编写，要不然这样和直接编译感觉没啥区别。set给一个变量赋值都是字符串类型，这些文件的名字会作为一个字符串存在变量里。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set指令的语法是：</span></span><br><span class="line"><span class="comment"># [] 中的参数为可选项，如不需要可以不写</span></span><br><span class="line"><span class="keyword">set</span>(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># VAR：变量名</span></span><br><span class="line"><span class="comment"># VALUE：变量值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一：各个源文件之间使用空格间隔</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST add.c div.c main.c mult.c sub.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二：各个源文件之间使用;间隔</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST add.c;div.c;main.c;mult.c;sub.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><p>取变量值必须以这种方式。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &quot;$ + &#123;变量名&#125;&quot;</span></span><br><span class="line"><span class="variable">$&#123;SRC_LIST&#125;</span></span><br></pre></td></tr></table></figure><p>还可以通过set设置使用C++的标准（C++11，C++17）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正常编译选定c++标准</span></span><br><span class="line">g++ *.cpp -std=c++11 -o app</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用camke指定c++标准，对应有一个宏叫做DCMAKE_Cxx_STANDARD</span></span><br><span class="line"><span class="comment"># 由两种方式指定C++标准</span></span><br><span class="line"><span class="comment"># 第一种：在CMakeLists.txt中通过set命令指定</span></span><br><span class="line"><span class="keyword">set</span>(CAMKE_CXX_STANDARD <span class="number">11</span>)  <span class="comment"># 等价于增加 -std=c++11</span></span><br><span class="line"><span class="keyword">set</span>(CAMKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="keyword">set</span>(CAMKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种：在执行camke命令的时候制定出这个宏的值</span></span><br><span class="line">camke CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=<span class="number">11</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=<span class="number">14</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=<span class="number">17</span></span><br></pre></td></tr></table></figure><p>set还可以指定输出路径，建议使用绝对路径，如果这个路径中的子目录不存在，会自动生成，无需自己手动创建。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在CMake中指定可执行程序输出的路径，也对应一个宏，叫做EXECUTABLE_OUTPUT_PATH，它的值还是通过set命令设置</span></span><br><span class="line"><span class="keyword">set</span>(HOME /home/zcl/linux/soft)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_UOTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>/bin)</span><br><span class="line"><span class="comment"># 第一行：定义一个变量用于存储一个绝对路径</span></span><br><span class="line"><span class="comment"># 第二行：将拼接好的路径值设置给EXECUTABLE_OUTPUT_PATH宏</span></span><br></pre></td></tr></table></figure><h3 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h3><p>我们可以看到我们上面所讲的使用set并没有解决要将所有源文件名字写出来的本质问题。为了解决这个问题，这里我们讲一下通过搜索某个目录下的文件来引入源文件的方法。CMake给我们提供了两种方法来搜索文件，aux_source_directory命令或者file命令。</p><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>在CMake中使用aux_source_directory命令可以查找某个路径下的所有源文件。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(&lt;dir&gt; &lt;variable&gt;)</span><br><span class="line"><span class="comment"># dir：要搜索的目录</span></span><br><span class="line"><span class="comment"># variable：将从dir目录下搜索到的源文件列表存储到该变量中</span></span><br><span class="line"><span class="comment"># 这里介绍一个宏，PROJECT_SOURCE_DIR宏代表的就是我们在camke命令后携带的那个路径。比如camke ..，PROJECT_SORCE_DIR宏代表的就是`..`</span></span><br><span class="line"><span class="comment"># 再介绍另外一个宏，CMAKE_CURRENT_SOURCE_DIR宏代表的就是当前CMakelists.txt文件所在的路径</span></span><br><span class="line"><span class="comment"># 下面进入实操，比如搜索当前CMakelists.txt文件所在目录下的src目录</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src SRC_LIST)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>通过file命令来搜索出所有需要的源文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line"><span class="keyword">file</span>(GLOB 变量名 要搜索的文件路径和文件类型)</span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</span><br><span class="line"><span class="comment"># GLOB：将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中</span></span><br><span class="line"><span class="comment"># GLOB_RECURSE：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中</span></span><br><span class="line"><span class="comment"># 比如：搜索当前目录的src目录下所有的源文件，并将其存储到变量中</span></span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="variable">$&#123;CAMKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/*.h)</span><br><span class="line"><span class="comment"># 注：关于要搜索的文件路径和类型可以加双引号，也可不加</span></span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="搜索头文件路径"><a href="#搜索头文件路径" class="headerlink" title="搜索头文件路径"></a>搜索头文件路径</h3><p>在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能找到这些头文件。在CMake里搜索头文件的命令也很简单</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(headpath)</span><br><span class="line"><span class="comment"># headpath就是头文件路径，这里建议写绝对路径</span></span><br><span class="line"><span class="comment"># 实操</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><h3 id="通过CMake制作库文件"><a href="#通过CMake制作库文件" class="headerlink" title="通过CMake制作库文件"></a>通过CMake制作库文件</h3><p>有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来讲解在cmake中生成这两类库文件的方法。</p><h4 id="制作静态库"><a href="#制作静态库" class="headerlink" title="制作静态库"></a>制作静态库</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在cmake中，如果要制作静态库，需要使用的命令如下：</span></span><br><span class="line"><span class="keyword">add_library</span>(库名称 STATIC 源文件<span class="number">1</span> [源文件<span class="number">2</span>] ...) </span><br><span class="line"><span class="comment"># 注：在Linux中，静态库名字分为三部分：lib+库名字+.a，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。</span></span><br><span class="line"><span class="comment"># 如果是动态库，最终生成的库的名字就是：libXXX.so(Linux)，libXXX.dll(Windows)；</span></span><br><span class="line"><span class="comment"># 如果是静态库，最终生成的库的名字就是：libXXX.a(Linux)，libXXX.lib(Windows)；</span></span><br><span class="line"><span class="comment"># 下面有一个目录，需要将src目录中的源文件编译成静态库，然后再使用：</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── <span class="keyword">include</span>           <span class="comment"># 头文件目录</span></span><br><span class="line">│   └── head.h</span><br><span class="line">├── main.cpp          <span class="comment"># 用于测试的源文件</span></span><br><span class="line">└── src               <span class="comment"># 源文件目录</span></span><br><span class="line">    ├── add.cpp</span><br><span class="line">    ├── div.cpp</span><br><span class="line">    ├── mult.cpp</span><br><span class="line">    └── sub.cpp</span><br><span class="line"><span class="comment"># 根据上面的目录结构，可以这样编写CMakeLists.txt文件:</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 注：STATIC对应的是静态库，SHARED对应的是动态库</span></span><br></pre></td></tr></table></figure><h4 id="制作动态库"><a href="#制作动态库" class="headerlink" title="制作动态库"></a>制作动态库</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(calc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><h4 id="指定输出路径"><a href="#指定输出路径" class="headerlink" title="指定输出路径"></a>指定输出路径</h4><p>对于生成的库文件来说和可执行程序一样都可以指定输出路径。这里使用LIBRARY_OUTPUT_PATH宏，这个宏对应静态库文件和动态库文件都适用。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="comment"># 设置动态库/静态库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="comment">#add_library(calc SHARED $&#123;SRC_LIST&#125;)</span></span><br><span class="line"><span class="comment"># 生成静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><h3 id="包含库文件"><a href="#包含库文件" class="headerlink" title="包含库文件"></a>包含库文件</h3><p>在编写程序的过程中，可能会用到一些系统提供的动态库或者自己制作出的动态库或者静态库文件，cmake中也为我们提供了相关的加载动态库的命令。</p><h4 id="链接静态库"><a href="#链接静态库" class="headerlink" title="链接静态库"></a>链接静态库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── add.cpp</span><br><span class="line">├── div.cpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── mult.cpp</span><br><span class="line">└── sub.cpp</span><br></pre></td></tr></table></figure><p>现在我们把上面src目录中的add.cpp、div.cpp、mult.cpp、sub.cpp编译成一个静态库文件libcalc.a。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试目录结构</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span> </span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.a     # 制作出的静态库的名字</span><br><span class="line">└── src</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br><span class="line">4 directories, 4 files</span><br></pre></td></tr></table></figure><p>在cmake中，链接静态库的命令如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_libraries</span>(&lt;static lib&gt; [&lt;static lib&gt;...])</span><br><span class="line"><span class="comment"># 参数1：指定出要链接的静态库的名字，可以是全名 libxxx.a，也可以是掐头（lib）去尾（.a）之后的名字 xxx</span></span><br><span class="line"><span class="comment"># 参数2-N：要链接的其它静态库的名字</span></span><br></pre></td></tr></table></figure><p>如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(&lt;lib path&gt;)</span><br></pre></td></tr></table></figure><p>这样，修改之后的CMakeLists.txt文件内容如下:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="comment"># 搜索指定目录下源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="comment"># 包含头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 包含静态库路径 添加了这行代码，就可以根据参数指定的路径找到这个静态库了。</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 链接静态库</span></span><br><span class="line"><span class="keyword">link_libraries</span>(calc)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure><h4 id="链接动态库"><a href="#链接动态库" class="headerlink" title="链接动态库"></a>链接动态库</h4><p>target不知道这个符号是来自它链接的多个库中的哪一个库，它只知道有这么一个库。</p><p>FATAL_ERROR：CMake 错误, 终止所有处理过程（CMake在生成”message to display”这条消息之后就不在执行了，直接中断）</p><p>CMake在底层管理的时候会将子字符串通过分号隔开，但通过message打印变量值的时候，看不到这个分号。这个分号有助于cmake进行字符串删除操作。只能删除组成变量的子串。比如一开始SRC&#x3D;”A123”，后来apeend了“456”, “789”，如果没有分号，你可能可以删除”345”，但有了分号后，就删除不了了，你只能删除组成SRC的完整的子串，比如”A123”, “456”等。</p><p>注意，存储列表长度的output variable依旧是一个字符串类型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里画一个图直接直接展示一下CMake和Makefile的使用过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;png1.png&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://zcl0219.github.io/2023/08/29/MySQL/"/>
    <id>http://zcl0219.github.io/2023/08/29/MySQL/</id>
    <published>2023-08-29T13:56:11.000Z</published>
    <updated>2023-10-09T08:27:20.733Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DAY1"><a href="#DAY1" class="headerlink" title="DAY1"></a><code>DAY1</code></h3><p>使用指令创建数据库：CREATE DATABASE zcl_db01;</p><p>删除数据库指令：DROP DATABASE zcl_db01;</p><p>创建一个使用utf8字符集的zcl_db02数据库：CREATE DATABASE zcl_db02 CHARACTER SET utf8</p><p>创建一个使用utf8字符集，并带校对规则的zcl_db03数据库：CREATE DATABASE zcl_db03 CHARACTER SET utf8 COLLATE utf8_bin<br>utf8_bin区分大小写，utf8_general_ci不区分大小写</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查看当前数据库服务器中的所有数据库</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES</span><br><span class="line"></span><br><span class="line">#查看前面创建的zcl_db01数据库的定义信息</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE `zcl_db01`</span><br><span class="line"></span><br><span class="line">#在创建数据库、表的时候，为了规避关键字，可以使用``解决</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE `<span class="keyword">CREATE</span>`</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#备份数据库</span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p <span class="operator">-</span>B zcl_db03 <span class="operator">&gt;</span> e:\\tmp.sql (文件名)</span><br><span class="line"></span><br><span class="line">#恢复数据库</span><br><span class="line">source e:\\tmp.sql</span><br><span class="line"></span><br><span class="line">#备份数据库的表</span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p zcl_db03 t1 t2 (t1和t2是表名) <span class="operator">&gt;</span> e:\\tmp1.sql</span><br></pre></td></tr></table></figure><h3 id="DAY2"><a href="#DAY2" class="headerlink" title="DAY2"></a><code>DAY2</code></h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 创建表</span><br><span class="line"># create table table_name</span><br><span class="line"># (</span><br><span class="line"># filed1 datatype,</span><br><span class="line">#filed2 datatype,</span><br><span class="line">#filed3 datatype</span><br><span class="line"># )character set 字符集 collate 校对规则 engine 存储引擎</span><br><span class="line">#  filed：指定列名   datatype：指定列类型（字段类型）</span><br><span class="line">#  character set：如不指定则为所在数据库字符集</span><br><span class="line">#  collate：如不指定则为所在数据库校对规则</span><br><span class="line"></span><br><span class="line"># 实操</span><br><span class="line">create table `user`(</span><br><span class="line">id int,</span><br><span class="line">    `name` varchar(255),</span><br><span class="line">    `passward` varchar(255),</span><br><span class="line">    `birthday` date</span><br><span class="line">)character set utf8 collate utf8_general_ci engine innodb; </span><br></pre></td></tr></table></figure><h4 id="Mysql常用数据类型"><a href="#Mysql常用数据类型" class="headerlink" title="Mysql常用数据类型"></a>Mysql常用数据类型</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Mysql列类型就是Mysql的数据类型</span><br><span class="line"># 数值类型：</span><br><span class="line"># 整型：tinyint(1个字节)smallint(2个字节)mediumint(3个字节)int(4个字节)bigint(8个字节)</span><br><span class="line"># 小数类型：float(单精度 4个字节)double(双精度 8个字节)decimal[M,D](大小不确定，M代表长度，D代表小数位数)</span><br><span class="line"></span><br><span class="line"># 文本类型（字符串类型）</span><br><span class="line"># char(0-255)varchar(0~65535)text(0~2^16-1)longtext(0~2^32-1)</span><br><span class="line"></span><br><span class="line"># 二进制数据类型</span><br><span class="line"># blob[0~2^16-1]longblob[0~2^32-1]</span><br><span class="line"></span><br><span class="line"># 日期类型</span><br><span class="line"># date[日期 年月日] time[时间 时分秒]datetime[年月日 时分秒 YYYY-MM-DD HH:MM:SS]timestamp[时间戳]</span><br></pre></td></tr></table></figure><p>在满足需求的情况下，尽量选择占用空间小的类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t3(</span><br><span class="line">id TINYINT</span><br><span class="line">);</span><br><span class="line"># INSERT INTO t3 VALUES(128); 错误：越界了，超过了tinyint范围。 </span><br><span class="line">INSERT INTO t3 VALUES(127);</span><br><span class="line"># 定义无符号的整数 指定unsigned</span><br><span class="line">CREATE TABLE t4(</span><br><span class="line">id TINYINT UNSIGNED</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># BIT(M), M在1-64。显示按照bit。</span><br><span class="line">CREATE TABLE t5(</span><br><span class="line">num BIT(8)</span><br><span class="line">);</span><br><span class="line">INSERT INTO t5 VALUES(255);</span><br><span class="line">SELECT * FROM t5;</span><br><span class="line"># 输出：11111111</span><br><span class="line">SELECT * FROM t5 WHERE num = 255;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># DECIMAL[M, D] </span><br><span class="line"># M是小数位数（精度）的总数，D是小数点（标度）后面的位数。</span><br><span class="line"># 如果D是0，则值没有小数点或分数部分，M最大是65，D最大是30。如果D被省略，则默认是0，如果M被省略，默认是10。</span><br><span class="line">CREATE TABLE t6(</span><br><span class="line">num1 FLOAT,</span><br><span class="line">    num2 DOUBLE,</span><br><span class="line">    num3 DECIMAL(30, 20)</span><br><span class="line">);</span><br><span class="line">INSERT INTO t6 VALUES(88.123456789123456, 88.123456789123456, 88.123456789123456)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># char(4) 这个4表示字符数（最大255），不是字节数，不管是中文还是英文都是放四个，按字符计算，定长，即使你插入&#x27;aa&#x27;，也会占用分配的4个字符的空间</span><br><span class="line"># varchar(4) 这个4表示字符数，是变长，如果你插入&#x27;aa&#x27;，实际占用空间并不是4个字符，而是实际占用的空间。</span><br><span class="line"># utf-8：一个字符占三个字节</span><br><span class="line">CREATE TABLE t11(</span><br><span class="line">&#x27;name&#x27; CHAR(4)</span><br><span class="line">);</span><br><span class="line"># INSERT INTO t11 VALUES(&#x27;ABCDE&#x27;) 报错，太长</span><br><span class="line">INSERT INTO t11 VALUES(&#x27;ABCD&#x27;)</span><br><span class="line">INSERT INTO t11 VALUES(&#x27;你好&#x27;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 日期类型 date datetime timestamp</span><br><span class="line">CREATE TABLE birthday11(</span><br><span class="line">birthday DATE,</span><br><span class="line">    worktime DATETIME,</span><br><span class="line">    login_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</span><br><span class="line">);</span><br><span class="line">INSERT INTO bithday11(birthday, worktime) VALUES(&#x27;2022-11-11&#x27;, &#x27;2022-11-11 10:10:10&#x27;);</span><br></pre></td></tr></table></figure><h4 id="创建表的课堂练习"><a href="#创建表的课堂练习" class="headerlink" title="创建表的课堂练习"></a>创建表的课堂练习</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#x27;emp&#x27;(</span><br><span class="line">id INT,</span><br><span class="line">    &#x27;name&#x27; VARCHAR(32),</span><br><span class="line">    sex CHAR(1),</span><br><span class="line">    birthday DATE,</span><br><span class="line">    entry_date DATETIME,</span><br><span class="line">    job VARCHAR(32),</span><br><span class="line">    saraly DOUBLE,</span><br><span class="line">    &#x27;resume&#x27; TEXT</span><br><span class="line">) CHARSET utf8 COLLATE utf8_bin ENGINE INNODB;</span><br><span class="line">INSERT INTO &#x27;emp&#x27; VALUES(</span><br><span class="line">100, &#x27;小妖怪&#x27;, &#x27;男&#x27;, &#x27;2000-11-11&#x27;, &#x27;巡山的&#x27;, 3000, &#x27;大王叫我来巡山&#x27;</span><br><span class="line">);</span><br><span class="line">SELECT * FROM &#x27;emp&#x27;;</span><br><span class="line"></span><br><span class="line"># 增加列</span><br><span class="line">ALTER TABLE emp ADD image VARCHAR(32) NOT NULL DEFAULT &#x27;&#x27; AFTER RESUME</span><br><span class="line"></span><br><span class="line"># 显示表结构</span><br><span class="line">DESC emp</span><br><span class="line"></span><br><span class="line"># 修改job长度</span><br><span class="line">ALTER TABLE emp MODIFY job VARCHAR(60) NOT NULL DEFAULT &#x27;&#x27;</span><br><span class="line"></span><br><span class="line"># 删除列</span><br><span class="line">ALTER TABLE emp DROP sex</span><br><span class="line"></span><br><span class="line"># 修改表名</span><br><span class="line">RENAME TABLE emp TO employee</span><br><span class="line"></span><br><span class="line"># 修改表的字符集</span><br><span class="line">ALTER TABLE employee CHARACTER SET utf8</span><br><span class="line"></span><br><span class="line"># 修改列名</span><br><span class="line">ALTER TABLE employee CHANGE &#x27;name&#x27; user_name VARCHAR(64) NOT NULL DEFAULT &#x27;&#x27;</span><br></pre></td></tr></table></figure><h4 id="数据库CRUD语句"><a href="#数据库CRUD语句" class="headerlink" title="数据库CRUD语句"></a>数据库CRUD语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 使用INSERT语句向表中插入数据</span><br><span class="line">CREATE TABLE &#x27;goods&#x27;(</span><br><span class="line">id INT,</span><br><span class="line">    goods_name VARCHAR(10),</span><br><span class="line">    price DOUBLE</span><br><span class="line">);</span><br><span class="line">INSERT INTO &#x27;goods&#x27; (id, goods_name, price) VALUES (10, &#x27;华为手机&#x27;, 2000);</span><br><span class="line">INSERT INTO &#x27;goods&#x27; (id, goods_name, price) VALUES (20, &#x27;苹果手机&#x27;, 20000);</span><br><span class="line"></span><br><span class="line"># INSERT语句的细节</span><br><span class="line">-- 插入的数据应与字段的数据类型相同，比如把&#x27;abc&#x27;添加到int类型会错误。</span><br><span class="line">-- 数据的长度应在列的规定范围内，不能将一个长度为80的字符串加入到长度为40的列中。</span><br><span class="line">-- 在VALUES中列出的数据位置必须与被加入的列的排列位置相对应。</span><br><span class="line">-- 字符和日期类型应包含在单引号中</span><br><span class="line">-- 列可以插入空值，前提是该字段允许为空（没有NOT NULL）</span><br><span class="line">-- INSERT INTO TABLE_NAME (列名) VALUES (),(),()，添加多条数据一次性</span><br><span class="line">-- 如果是给表中的所有字段添加数据，(id, goods_name, price)这个可以省略</span><br><span class="line">-- 默认值的使用，当不给某个字段赋值时，如果有默认值就会添加，否则报错。</span><br><span class="line">-- 如果我们希望指定某个列的默认值，可以在创建表时指定。</span><br><span class="line">CREATE TABLE &#x27;goods2&#x27;(</span><br><span class="line">id INT,</span><br><span class="line">    goods_name VARCHAR(10),</span><br><span class="line">    price DOUBLE NOT NULL DEFAULT 100</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 演示update语句</span><br><span class="line">-- employee是表名，salary是列名</span><br><span class="line">-- 将所有员工薪水修改为5000，如果没有带where条件，会修改所有的记录，因此要小心</span><br><span class="line">UPDATE employee SET salary = 5000 </span><br><span class="line">-- 将姓名为小妖怪的员工薪水修改为3000</span><br><span class="line">UPDATE employee SET salary = 3000 WHERE user_name = &#x27;小妖怪&#x27;</span><br><span class="line">-- 将老妖怪的薪水在原有基础上增加1000</span><br><span class="line">INSERT INTO employee VALUES(200, &#x27;老妖怪&#x27;, &#x27;1990-11-11&#x27;, &#x27;2000-11-11 10:10:10&#x27;, &#x27;捶背的&#x27;, 5000,  &#x27;给大王捶背的&#x27;);</span><br><span class="line">UPDATE employee SET salary = salary + 1000 WHERE user_name = &#x27;老妖怪&#x27;</span><br><span class="line">UPDATE employee SET salary = salary + 1000, job = &#x27;出主意的&#x27; WHERE user_name = &#x27;老妖怪&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 演示delete语句</span><br><span class="line">-- 删除表中名称为‘老妖怪’的记录</span><br><span class="line">DELETE FROM employee WHERE user_name = &#x27;老妖怪&#x27;;</span><br><span class="line">-- 删除表中所有记录</span><br><span class="line">DELETE FROM employee</span><br><span class="line">-- DELETE删除不了一列的值，但可以使用UPDATE语句置为null</span><br><span class="line">UPDATE employee SET job = NULL WHERE user_name = &#x27;老妖怪&#x27;;</span><br><span class="line">-- 要删除这个表</span><br><span class="line">DROP TABLE employee</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">-- select指定查询哪些列的数据</span><br><span class="line">-- *代表查询所有列</span><br><span class="line">-- from指定查询哪张表</span><br><span class="line">-- DISTINCT可选，指显示结果时，是否去掉重复数据</span><br><span class="line">CREATE TABLE student(</span><br><span class="line">id INT NOT NULL DEFAULT 1,</span><br><span class="line">    NAME VARCHAR(20) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">    chinese FLOAT NOT NULL DEFAULT 0.0,</span><br><span class="line">    english FLOAT NOT NULL DEFAULT 0.0,</span><br><span class="line">    math FLOAT NOT NULL DEFAULT 0.0</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(1, &#x27;韩顺平&#x27;, 89, 78, 90);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(2, &#x27;张飞&#x27;, 67, 98, 56);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(3, &#x27;宋江&#x27;, 87, 78, 77);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(4, &#x27;关羽&#x27;, 88, 98, 90);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(5, &#x27;赵云&#x27;, 82, 84, 67);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(6, &#x27;欧阳锋&#x27;, 55, 85, 45);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(7, &#x27;黄蓉&#x27;, 75, 65, 30);</span><br><span class="line"></span><br><span class="line">SELECT * FROM student;</span><br><span class="line"></span><br><span class="line">-- 查寻表中所有学生的信息</span><br><span class="line">SELECT * FROM student;</span><br><span class="line"></span><br><span class="line">-- 查询表中所有学生的姓名和对应的英语成绩</span><br><span class="line">SELECT &#x27;NAME&#x27;, english FROM student;</span><br><span class="line"></span><br><span class="line">-- 过滤表中重复数据distinct</span><br><span class="line">-- 要查询的记录每个字段都相同，才会去重</span><br><span class="line">SELECT DISTINCT english FROM student;</span><br><span class="line"></span><br><span class="line">-- 统计每个学生的总分</span><br><span class="line">SELECT &#x27;NAME&#x27;, (chinese + english + math) FROM student;</span><br><span class="line"></span><br><span class="line">-- 在所有学生总分加10分</span><br><span class="line">SELECT &#x27;NAME&#x27;, (chinese + english + math + 10) FROM student;</span><br><span class="line"></span><br><span class="line">-- 使用别名表示学生分数</span><br><span class="line">SELECT &#x27;NAME&#x27;, (chinese + english + math + 10) AS total_score FROM student;</span><br><span class="line">SELECT &#x27;NAME&#x27; AS &#x27;名字&#x27;, (chinese + english + math + 10) AS total_score FROM student;</span><br><span class="line"></span><br><span class="line">-- 查询姓名为赵云的学生成绩</span><br><span class="line">SELECT * FROM student WHERE &#x27;NAME&#x27; = &#x27;赵云&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询英语成绩大于90分的同学</span><br><span class="line">SELECT * FROM student WHERE english &gt; 90;</span><br><span class="line"></span><br><span class="line">-- 查询总分大于200分的所有同学</span><br><span class="line">SELECT * FROM student WHERE (chinese + english + math) &gt; 200;</span><br><span class="line"></span><br><span class="line">-- 查询math大于60并且id大于4的学生成绩</span><br><span class="line">SELECT * FROM student WHERE math &gt; 60 AND id &gt; 4;</span><br><span class="line"></span><br><span class="line">-- 查询英语成绩大于语文成绩的同学</span><br><span class="line">SELECT * FROM student WHERE english &gt; chinese;</span><br><span class="line"></span><br><span class="line">-- 查询总分大于200分并且数学成绩小于语文成绩的姓韩的学生</span><br><span class="line">-- 韩% 表示名字以韩开头的就可以</span><br><span class="line">SELECT * FROM student WHERE (chinese + english + math) &gt; 200 AND </span><br><span class="line">  math &lt; chinese AND &#x27;NAME&#x27; LIKE &#x27;韩%&#x27;;</span><br><span class="line">  </span><br><span class="line">-- 查询英语分数在80-90之间的同学</span><br><span class="line">SELECT * FROM student WHERE english &gt;= 80 AND english &lt;= 90;</span><br><span class="line">SELECT * FROM student WHERE english BETWWWN 80 AND 90; -- BETWEEN AND 是闭区间</span><br><span class="line"></span><br><span class="line">-- 查询数学分数为89，90，91的同学</span><br><span class="line">SELECT * FROM student WHERE math = 89 OR math = 90 OR math = 91;</span><br><span class="line">SELECT * FROM student WHERE math IN (89, 90, 91);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;DAY1&quot;&gt;&lt;a href=&quot;#DAY1&quot; class=&quot;headerlink&quot; title=&quot;DAY1&quot;&gt;&lt;/a&gt;&lt;code&gt;DAY1&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;使用指令创建数据库：CREATE DATABASE zcl_db01;&lt;/p&gt;
&lt;p&gt;删除数据库指</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux 高性能服务器--第五章</title>
    <link href="http://zcl0219.github.io/2023/08/27/Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <id>http://zcl0219.github.io/2023/08/27/Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%AC%AC%E4%BA%94%E7%AB%A0/</id>
    <published>2023-08-27T04:45:48.000Z</published>
    <updated>2023-11-08T18:52:29.127Z</updated>
    
    <content type="html"><![CDATA[<h4 id="5-1-1-判断主机是小端字节序还是大端字节序"><a href="#5-1-1-判断主机是小端字节序还是大端字节序" class="headerlink" title="5.1.1 判断主机是小端字节序还是大端字节序"></a>5.1.1 判断主机是小端字节序还是大端字节序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">byteOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">short</span> value;</span><br><span class="line">        <span class="type">char</span> union_bytes[<span class="built_in">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    &#125;test;</span><br><span class="line">    </span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span>(test.union_bytes[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; test.union_bytes[<span class="number">1</span>] == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端字节序\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(test.union_bytes[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; test.union_bytes[<span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端字节序\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不清楚\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">byteOrder</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1-3专用socket地址"><a href="#5-1-3专用socket地址" class="headerlink" title="5.1.3专用socket地址"></a>5.1.3专用<code>socket</code>地址</h4><p><code>TCP/IP</code>协议族有<code>sockaddr_in</code>和<code>sockaddr_in6</code>两个专用<code>socket</code>地址结构体，他们分别用于<code>IPv4</code>和<code>IPv6</code>，这里我只介绍<code>sockaddr_in</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;  <span class="comment">// 地址族：AF_INET</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin_port;<span class="comment">// 端口号：要用网络字节序表示</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;<span class="comment">// IPv4地址结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span>&#123;</span><br><span class="line">    <span class="type">u_int32_t</span> s_addr;<span class="comment">// 要用网络字节序表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：所有专用<code>socket</code>地址类型的变量在实际使用时都需要转换为通用<code>socket</code>地址类型<code>sockaddr</code>（强制转换即可），因为所有<code>socket</code>编程接口使用的地址参数的类型都是<code>sockaddr</code>。</p><h4 id="5-1-4IP地址转换函数"><a href="#5-1-4IP地址转换函数" class="headerlink" title="5.1.4IP地址转换函数"></a>5.1.4<code>IP</code>地址转换函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span>;<span class="comment">// 用于将字符串表示的IP地址转换为用网络字节序整数表示的IP地址</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> cnt)</span></span>;<span class="comment">// 最后一个参数指定目标存储单元的大小，这两个宏可以帮我们指定</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">inet_pton成功时返回1，失败时返回0并设置errno</span></span><br><span class="line"><span class="comment">inet_ntop成功时返回目标存储单元的地址，失败返回NULL并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET6_ADDRSTRLEN 64</span></span><br></pre></td></tr></table></figure><h4 id="5-2创建socket"><a href="#5-2创建socket" class="headerlink" title="5.2创建socket"></a>5.2创建socket</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">domain一般为PF_INET(IPv4)，或者PF_INET6(IPv6)</span></span></span><br><span class="line"><span class="comment"><span class="function">type参数指定服务类型，主要有SOCK_STREAM和SOCK_UGRAM</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span> </span></span><br></pre></td></tr></table></figure><p>socket系统调用成功时返回一个socket文件描述符，失败返回-1并设置errno</p><h4 id="5-3命名socket"><a href="#5-3命名socket" class="headerlink" title="5.3命名socket"></a>5.3命名socket</h4><p>创建socket时，我们给它指定了地址族，但是并未指定使用该地址族中的哪个具体socket地址。将一个socket与socket地址绑定称为给socket命名。在服务器程序中，我们通常需要命名socket，<strong>因为只有命名后客户端才知道该如何连接它</strong>。客户端通常不需要命名socket，而是采用匿名方式，也就是使用操作系统自动分配的socket地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* my_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bind将my_addr所指的socket地址分配给未命名的socket文件描述符，addrlen参数指出该socket地址的长度</span></span><br><span class="line"><span class="comment">bind成功时返回0，失败时返回-1并设置errno，其中两种常见的errno是：EACCES和EADDRINUSE。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="5-4监听socket"><a href="#5-4监听socket" class="headerlink" title="5.4监听socket"></a>5.4监听socket</h4><p>socket被命名之后，还不能立即接收客户端连接，我们需要使用如下系统调用来创建一个监听队列以存放待处理的客户连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sockfd参数指定被监听的socket，backlog参数提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客户端连接，客户端也将收到ECONNREFUSED错误信息。（实际上最多可以接收backlog + 1个客户端连接）</span></span><br><span class="line"><span class="comment">listen成功时返回0，失败时返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>下面我们编写一个程序测试一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">basename使用示例：</span></span><br><span class="line"><span class="comment">`basename()` 是一个常用于处理文件路径和程序参数的库函数。</span></span><br><span class="line"><span class="comment">它的主要目的是从一个给定的路径中提取基础名（base name），也就是最后一部分的名称，不包含任何前导的目录。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">来自 `&lt;libgen.h&gt;`（或在某些系统中是 `&lt;string.h&gt;` 或 `&lt;strings.h&gt;`），`basename()` 函数的原型如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">char *basename(char *path);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">让我们看一些使用 `basename()` 的例子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 输入 `/home/user/documents/file.txt` 返回 `file.txt`</span></span><br><span class="line"><span class="comment">2. 输入 `/home/user/documents/folder/` 返回 `folder`</span></span><br><span class="line"><span class="comment">3. 输入 `/home/user/documents/` 返回 `documents`</span></span><br><span class="line"><span class="comment">4. 输入 `file.txt` 返回 `file.txt`</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在给出的代码示例中：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">printf(&quot;usage: %s ip_address port_num backlog\n&quot;, basename(argv[0]));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">`argv[0]` 通常是程序的名称，包括它被执行时的完整路径。</span></span><br><span class="line"><span class="comment">使用 `basename()` 函数，你可以仅提取程序的实际名称，而不包括其路径，这在显示帮助或错误消息时特别有用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">举个例子，假设程序的完整路径是 `/home/user/my_program`，那么 `basename(argv[0])` 就会返回 `my_program`。这样，上述的 `printf` 语句将输出：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">usage: my_program ip_address port_num backlog</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">需要注意的是，`basename()` 函数可能会修改其参数，也可能返回一个指向静态存储区的指针。</span></span><br><span class="line"><span class="comment">因此，如果原始路径字符串不应被修改，那么在调用 `basename()` 之前，最好先复制这个字符串。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">term_handler</span><span class="params">(<span class="type">int</span> sig)</span>&#123;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    signal(SIGTERM, term_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_num backlog\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sockfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sign = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    server_addr.sin_family = PF_INET;</span><br><span class="line">    server_addr.sin_port = htons(port);</span><br><span class="line">    inet_pton(PF_INET, ip, &amp;server_addr.sin_addr);</span><br><span class="line"></span><br><span class="line">    sign = bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    assert(sign != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    sign = listen(sockfd, <span class="number">5</span>);</span><br><span class="line">    assert(sign != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果忘记截图了，大家可以自己试一下，具体步骤</span></span><br><span class="line"><span class="comment">./test 172.30.78.145 8000 5</span></span><br><span class="line"><span class="comment">另开终端多次telnet 172.30.78.145 8000</span></span><br><span class="line"><span class="comment">netstat -nt | grep 8000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个命令组合使用了两个命令：<code>netstat</code> 和 <code>grep</code>，并通过管道（<code>|</code>）将第一个命令的输出作为第二个命令的输入。我会为你逐步解释它：</p><ol><li><p><strong><code>netstat -nt</code></strong>:</p><ul><li><code>netstat</code>: 这是一个命令行工具，用于显示网络状态，包括网络连接、路由表、接口统计等。</li><li><code>-n</code>: 表示以数字形式显示地址和端口号，而不是尝试解析它们的名称。</li></ul></li></ol><ul><li><code>-t</code>: 仅显示TCP连接。</li></ul><p>因此，<code>netstat -nt</code> 的输出会列出系统上所有活动的TCP连接，同时显示它们的源和目标IP地址以及端口号，并直接显示数字而不进行名称解析。</p><ol start="2"><li><strong><code>|</code></strong>:</li></ol><ul><li>这是一个管道操作符，用于将前一个命令的输出作为后一个命令的输入。</li></ul><ol start="3"><li><p><strong><code>grep 8000</code></strong>:</p><ul><li><code>grep</code>: 是一个强大的文本搜索工具，用于搜索匹配的字符串。</li><li><code>8000</code>: 是你想在 <code>netstat</code> 的输出中搜索的字符串。</li></ul><p>这个命令会从 <code>netstat</code> 的输出中筛选出所有包含 “8000” 的行，这通常意味着你正在查找与端口 <code>8000</code> 相关的所有活动连接。</p></li></ol><p>综上所述，<code>netstat -nt | grep 8000</code> 会显示所有在端口 <code>8000</code> 上的活动TCP连接。</p><h4 id="5-5接受连接"><a href="#5-5接受连接" class="headerlink" title="5.5接受连接"></a>5.5接受连接</h4><p>代码：接受一个异常的连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libgen.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;运行程序，需输入这三个参数：%s, ip_address, port_num\n&quot;</span>, <span class="built_in">basename</span>(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = <span class="built_in">ntohs</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(sock, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">    <span class="type">socklen_t</span> client_len = <span class="built_in">sizeof</span>(client);</span><br><span class="line">    <span class="type">int</span> connfd = <span class="built_in">accept</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;client_len);</span><br><span class="line">    <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">char</span> remote[INET_ADDRSTRLEN];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>, <span class="built_in">inet_ntop</span>(AF_INET, &amp;client.sin_addr, remote, client_len),</span><br><span class="line">                <span class="built_in">ntohs</span>(client.sin_port));</span><br><span class="line">        <span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、第一次运行报错，<code>undefined reference to main</code>，这种情况一般有三种可能：</p><ul><li>没有定义main函数</li><li>main函数的main拼写错误</li><li>刚写的代码忘记保存了</li></ul><p>2、<code>accept</code>函数是阻塞的，上述代码即服务器端运行的时候，会阻塞在<code>accept</code>处，一旦客户端请求建立连接，服务器立马终止程序。注意<code>accept</code>只是从<code>listen</code>监听队列中取出连接，它不会理会客户端处于什么状态。</p><p>3、一直在思考<code>select/poll/epoll</code>这些有什么用。首先因为listen是有监听队列的，劣势就在于只能一个个处理，并且同时接入的连接数有限。比如队列长度为5，处理完一个，再建立下一个连接，这样如果某一个连接处理很长时间一直阻塞在那里，就导致后面的新请求连接建立超时。很直观的想法是<code>fork</code>新进程或者创建新线程来处理新连接，每来一个连接我就创建一个来跟他对接。这样资源消耗太大。因此就有了<code>select/poll/epoll</code>，先把连接建立起来并放进文件描述符，最后从这里面寻找哪些发生了可读可写事件，也避免了因为读写事件造成的阻塞（没有数据到来就阻塞了）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;5-1-1-判断主机是小端字节序还是大端字节序&quot;&gt;&lt;a href=&quot;#5-1-1-判断主机是小端字节序还是大端字节序&quot; class=&quot;headerlink&quot; title=&quot;5.1.1 判断主机是小端字节序还是大端字节序&quot;&gt;&lt;/a&gt;5.1.1 判断主机是小端字节序还</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++内存管理</title>
    <link href="http://zcl0219.github.io/2023/08/27/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://zcl0219.github.io/2023/08/27/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2023-08-27T03:48:36.000Z</published>
    <updated>2023-08-28T01:05:57.661Z</updated>
    
    <content type="html"><![CDATA[<p>有关C++内存管理问题总结如下</p><h3 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h3><h4 id="C-中堆和栈的区别是什么"><a href="#C-中堆和栈的区别是什么" class="headerlink" title="C++中堆和栈的区别是什么"></a><code>C++</code>中堆和栈的区别是什么</h4><ol><li>栈由系统分配释放，栈上变量的生命周期是确定的，一般与作用域有关。栈的地址由高到低，栈上分配的空间大小在编译时通常已知。</li><li>堆由程序员手动开辟释放，堆上的变量除非被显示释放，否则会持续存在。堆的地址由低到高，堆上几乎可以分配任意大小的内存块，但可能会造成内存碎片。</li><li>这里说一下<code>C++</code>的内存分区：堆区、栈区、<code>data</code>区、<code>bss</code>段、代码段。数据<code>data</code>区存放的是静态变量和初始化的全局变量，<code>bss</code>段存放的是未初始化的全局变量。</li></ol><h4 id="什么是RAII？为什么它在C-中很重要"><a href="#什么是RAII？为什么它在C-中很重要" class="headerlink" title="什么是RAII？为什么它在C++中很重要"></a>什么是<code>RAII</code>？为什么它在<code>C++</code>中很重要</h4><p><code>RAII</code>是一种编程思想和设计模式，核心思想是：将资源的获取与对象的初始化捆绑在一起，将资源的释放与对象的销毁捆绑在一起。这样，资源管理就与对象的生命周期紧密关联。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::fstream fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">File</span>(<span class="type">const</span> std::string&amp; filename) &#123;</span><br><span class="line">        fs.<span class="built_in">open</span>(filename, std::ios::in | std::ios::out);</span><br><span class="line">        <span class="keyword">if</span> (!fs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to open the file&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他与文件相关的操作...</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">File</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (fs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            fs.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">File <span class="title">myFile</span><span class="params">(<span class="string">&quot;sample.txt&quot;</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 进行文件操作...</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当myFile对象离开其作用域时，它的析构函数会自动被调用，从而关闭文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解释new和delete，与malloc和free的区别"><a href="#解释new和delete，与malloc和free的区别" class="headerlink" title="解释new和delete，与malloc和free的区别"></a>解释<code>new</code>和<code>delete</code>，与<code>malloc</code>和<code>free</code>的区别</h4><ul><li><p>属性的区别</p><p><code>new/delete</code>：这两个是<code>C++</code>中的关键字；</p><p><code>malloc/free</code>：这两个是库函数；</p></li><li><p>使用上的区别</p><p><code>malloc</code>：申请空间需要显式填入申请内存的大小；</p><p><code>new</code>：无需显式填入申请内存的大小，<code>new</code>会根据<code>new</code>的类型分配内存；</p></li><li><p>返回类型的区别</p><p><code>new</code>操作符内存分配成功，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，故<code>new</code>是符合类型安全性的操作符。</p><p><code>malloc</code>内存分配成功返回的是<code>void*</code>指针，需要通过强制类型转换，转换成我们需要的类型。</p><p>所以<code>C++</code>中<code>new</code>比<code>malloc</code>安全可靠。</p></li><li><p>分配失败的区别</p><p><code>malloc</code>分配失败会返回<code>NULL</code>，我们可以通过判断返回值是否是<code>NULL</code>得知是否分配成功。</p><p><code>new</code>分配失败会抛出<code>bad_alloc</code>异常。</p></li><li><p>扩张内存的区别</p><p><code>malloc</code>有内存扩张机制（通过<code>realloc</code>实现）。</p><p><code>new</code>没有扩张内存机制。</p></li></ul><h3 id="中级问题"><a href="#中级问题" class="headerlink" title="中级问题"></a>中级问题</h3><h4 id="为什么C-推荐使用智能指针，如shared-ptr和unique-ptr"><a href="#为什么C-推荐使用智能指针，如shared-ptr和unique-ptr" class="headerlink" title="为什么C++推荐使用智能指针，如shared_ptr和unique_ptr"></a>为什么<code>C++</code>推荐使用智能指针，如<code>shared_ptr</code>和<code>unique_ptr</code></h4><ul><li>自动管理内存：对于<code>unique_ptr</code>，当它超出作用域或者被重新分配时，它指向的对象会被删除。对于<code>shared_ptr</code>，当它的引用计数为0时，它指向的对象会被删除。</li><li>异常安全：当函数抛出异常，智能指针确保资源被正确清理，避免资源泄露。</li><li>防止悬挂指针：悬挂指针是指指向已经释放内存的指针。<code>unique_ptr</code>和<code>shared_ptr</code>可以减少悬挂指针的风险，因为他们确保在没有引用的时候释放资源。</li></ul><h4 id="你能解释shared-ptr中的引用计数机制是如何工作的吗"><a href="#你能解释shared-ptr中的引用计数机制是如何工作的吗" class="headerlink" title="你能解释shared_ptr中的引用计数机制是如何工作的吗"></a>你能解释<code>shared_ptr</code>中的引用计数机制是如何工作的吗</h4><ul><li>通过一个指针实现引用计数功能，加锁，保证线程安全</li></ul><h4 id="什么情况下会导致内存泄漏，你如何检测和预防"><a href="#什么情况下会导致内存泄漏，你如何检测和预防" class="headerlink" title="什么情况下会导致内存泄漏，你如何检测和预防"></a>什么情况下会导致内存泄漏，你如何检测和预防</h4><ul><li><p>指针重新赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line"><span class="type">int</span> *np = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line">p = np;</span><br><span class="line"><span class="comment">//p原来的指向的内存无法释放，因为现在没有指针指向这块内存</span></span><br></pre></td></tr></table></figure></li><li><p>错误的内存释放</p><p>假设有一个指针<code>p</code>指向10字节的内存，该内存的第三个字节<code>np</code>又指向某个动态分配的内存， 如果此时你直接<code>delete(p)</code>，则会导致<code>np</code>指向的内存无法释放。</p></li><li><p>返回值的不正确处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于没有对函数f()的返回值做正确接收，将会导致f函数分配的内存无法释放。</span></span><br></pre></td></tr></table></figure></li></ul><p>关于内存泄露可以使用工具：<code>Valgrind</code>。</p><h3 id="高级问题"><a href="#高级问题" class="headerlink" title="高级问题"></a>高级问题</h3><h4 id="描述C-的内存模型是什么？如何保证线程间的数据同步？"><a href="#描述C-的内存模型是什么？如何保证线程间的数据同步？" class="headerlink" title="描述C++的内存模型是什么？如何保证线程间的数据同步？"></a>描述C++的内存模型是什么？如何保证线程间的数据同步？</h4><h4 id="什么是内存屏障-memory-barrier-或内存栅栏？在哪些场景中需要使用它？"><a href="#什么是内存屏障-memory-barrier-或内存栅栏？在哪些场景中需要使用它？" class="headerlink" title="什么是内存屏障(memory barrier)或内存栅栏？在哪些场景中需要使用它？"></a>什么是内存屏障(memory barrier)或内存栅栏？在哪些场景中需要使用它？</h4><h4 id="你有没有用过定制的内存分配器，比如为某些高性能的应用场景？如果有，请描述其工作原理和使用场景。"><a href="#你有没有用过定制的内存分配器，比如为某些高性能的应用场景？如果有，请描述其工作原理和使用场景。" class="headerlink" title="你有没有用过定制的内存分配器，比如为某些高性能的应用场景？如果有，请描述其工作原理和使用场景。"></a>你有没有用过定制的内存分配器，比如为某些高性能的应用场景？如果有，请描述其工作原理和使用场景。</h4><h3 id="实践问题"><a href="#实践问题" class="headerlink" title="实践问题"></a>实践问题</h3><h4 id="描述一个你曾遇到的复杂的内存相关bug，你是如何诊断和解决的？"><a href="#描述一个你曾遇到的复杂的内存相关bug，你是如何诊断和解决的？" class="headerlink" title="描述一个你曾遇到的复杂的内存相关bug，你是如何诊断和解决的？"></a>描述一个你曾遇到的复杂的内存相关bug，你是如何诊断和解决的？</h4><h4 id="你如何评估一个C-程序的内存使用效率？你使用过哪些工具或技术"><a href="#你如何评估一个C-程序的内存使用效率？你使用过哪些工具或技术" class="headerlink" title="你如何评估一个C++程序的内存使用效率？你使用过哪些工具或技术"></a>你如何评估一个C++程序的内存使用效率？你使用过哪些工具或技术</h4><h4 id="请编写一个小程序，其中创建一个有资源泄漏的类，然后展示如何使用工具或方法找到并修复该泄漏。"><a href="#请编写一个小程序，其中创建一个有资源泄漏的类，然后展示如何使用工具或方法找到并修复该泄漏。" class="headerlink" title="请编写一个小程序，其中创建一个有资源泄漏的类，然后展示如何使用工具或方法找到并修复该泄漏。"></a>请编写一个小程序，其中创建一个有资源泄漏的类，然后展示如何使用工具或方法找到并修复该泄漏。</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有关C++内存管理问题总结如下&lt;/p&gt;
&lt;h3 id=&quot;基础问题&quot;&gt;&lt;a href=&quot;#基础问题&quot; class=&quot;headerlink&quot; title=&quot;基础问题&quot;&gt;&lt;/a&gt;基础问题&lt;/h3&gt;&lt;h4 id=&quot;C-中堆和栈的区别是什么&quot;&gt;&lt;a href=&quot;#C-中堆和栈的区别是</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>单例懒汉模式</title>
    <link href="http://zcl0219.github.io/2023/08/25/%E5%8D%95%E4%BE%8B%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zcl0219.github.io/2023/08/25/%E5%8D%95%E4%BE%8B%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-08-25T03:31:52.000Z</published>
    <updated>2023-08-25T03:35:53.069Z</updated>
    
    <content type="html"><![CDATA[<p>话不多说，直接上代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//双重检查锁定模式</span></span><br><span class="line">    <span class="comment">//这样做的目的是，如果实例已经被创建，可以避免每次加锁解锁的操作，提高性能</span></span><br><span class="line">    <span class="comment">//但看文字可能不好理解，这里给出不是双重检查锁定模式就好理解了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    static Singleton&amp; getInstance()&#123;</span></span><br><span class="line"><span class="comment">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</span></span><br><span class="line"><span class="comment">        if(instance_ == nullptr)&#123;</span></span><br><span class="line"><span class="comment">            instance_ = new Singleton();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return *instance_;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    这种写法性能非常低下，因为每次调用instance()都会加锁释放锁，而这个步骤只有在第一次new Singleton()才是有必要的。</span></span><br><span class="line"><span class="comment">    只要p被创建出来了，不管多少线程同时访问，使用if (p == nullptr) 进行判断都是足够的（只是读操作，不需要加锁），没有线程安全问题，</span></span><br><span class="line"><span class="comment">    加了锁之后反而存在性能问题。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance_ == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(instance_ == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                instance_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *instance_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::mutex mutex_;</span><br><span class="line">    <span class="type">static</span> Singleton *instance_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::mutex Singleton::mutex_;</span><br><span class="line">Singleton* Singleton::instance_ = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p><strong>问题</strong></p><p>构造析构为什么要私有</p><p>解答：</p><p>在单例模式中，构造函数和析构函数被设置为私有的原因是为了确保满足单例模式的核心要求：系统中某个类只能存在一个实例。</p><p>通过将构造函数和析构函数设为私有，我们可以确保以下几点：</p><ol><li><p><strong>外部无法实例化</strong>：由于构造函数是私有的，这意味着不能在类的外部直接创建该类的实例。这确保了实例的创建只能通过单例类提供的某些特定方法（如<code>getInstance</code>）来完成，从而控制实例的数量。</p></li><li><p><strong>禁止复制</strong>：单例模式要确保只有一个实例存在，所以我们不希望该类的对象被复制。将构造函数设为私有可以防止复制构造，但为了进一步确保不被复制，我们通常还需要禁止拷贝构造函数和拷贝赋值操作符（通过<code>= delete</code>）。</p></li><li><p><strong>外部无法销毁</strong>：将析构函数设为私有可以确保外部代码无法直接删除单例对象。通常，单例对象在程序结束时自动销毁，或者单例类提供了一个专门的方法来手动销毁它。</p></li><li><p><strong>继承控制</strong>：由于构造函数和析构函数是私有的，这也意味着这个类不能被继承（因为派生类的构造函数需要调用基类的构造函数）。</p></li></ol><p>综上所述，将构造函数和析构函数设为私有是为了确保满足单例模式的设计原则，即系统中该类只有一个实例，并提供对该实例的全局访问点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;话不多说，直接上代码&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>日志模块设计</title>
    <link href="http://zcl0219.github.io/2023/08/25/%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/"/>
    <id>http://zcl0219.github.io/2023/08/25/%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/</id>
    <published>2023-08-25T02:45:23.000Z</published>
    <updated>2023-08-25T02:57:50.778Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本篇文章主要参考如下文章，主要是对代码做一个较为详尽的解释</strong></p><p>参考链接：<a href="https://blog.csdn.net/qq_46495964/article/details/122952567">https://blog.csdn.net/qq_46495964/article/details/122952567</a></p><p><strong>前言：</strong><br>日志系统在程序运行中有着非常大的作用，用于记录程序的运行情况，在程序出错后查看日志，方便地定位出错的大概范围。在设计日志系统之前，先考虑一下日志需要输出什么信息呢？什么信息才是有用的信息，都知道写日志是一种对文件的<code>io</code>操作，所以尽可能避免输出没用的信息。<br><strong>有用的信息：关键变量的值、运行的位置（哪个文件、哪个函数、哪一行）、时间、线程号、进程号等等。</strong></p><h4 id="日志系统的设计"><a href="#日志系统的设计" class="headerlink" title="日志系统的设计"></a>日志系统的设计</h4><ol><li><p>日志的级别</p><p>在测试、调试、交付等场景需要输出不同的级别日志。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见的日志级别</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LOGLEVEL</span></span><br><span class="line">&#123;</span><br><span class="line">LOG_LEVEL_NONE,</span><br><span class="line">LOG_LEVEL_ERROR,     <span class="comment">// error</span></span><br><span class="line">LOG_LEVEL_WARNING,   <span class="comment">// warning</span></span><br><span class="line">LOG_LEVEL_DEBUG,     <span class="comment">// debug</span></span><br><span class="line">LOG_LEVEL_INFO,      <span class="comment">// info</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>日志的输出地</p><p>日志输出的地方可能不同，终端、控制台、UI界面、文件等等都有。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">LOGTARGET</span></span><br><span class="line">&#123;</span><br><span class="line">LOG_TERM      = <span class="number">0x00</span>,</span><br><span class="line">LOG_FILE      = <span class="number">0x01</span>,</span><br><span class="line">LOG_UI        = <span class="number">0x10</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>日志的作用域</p><p>日志做到什么时候都可以输出，可作用于全程序文件，考虑到多线程情况下，必须保证日志的输出需要得到线程安全的保障，所以需要一个<strong>全局且唯一的日志器</strong>。使用设计模式中的<strong>单例模式—–日志器</strong></p></li></ol><h4 id="C-版本的日志系统的实现"><a href="#C-版本的日志系统的实现" class="headerlink" title="C++版本的日志系统的实现"></a>C++版本的日志系统的实现</h4><p><strong>Logger.h</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">这是一个基本的线程安全日志系统的头文件，其目的是为应用程序提供日志功能。以下是对这个头文件的详细解释：</span><br><span class="line"></span><br><span class="line">1. **预处理指令和宏**:</span><br><span class="line">    - `<span class="comment">#ifndef`, `#define`, 和 `#endif` 用于保证头文件只被包含一次，避免重复定义。</span></span><br><span class="line">    - `<span class="comment">#define` 宏定义了三个日志级别：`LogInfo`, `LogWarning`, 和 `LogError`。这些宏都使用了变参（`...`），允许用户为日志提供自定义的格式和参数。这些宏捕获了日志消息的来源（文件、行号和函数）并将其添加到日志队列中。</span></span><br><span class="line"></span><br><span class="line">2. **类定义：Logger**</span><br><span class="line">    - 是一个单例类，这意味着整个程序中只能有一个实例。这通过私有的默认构造函数、删除的复制构造函数和赋值运算符来实现。</span><br><span class="line">    - `GetInstance()` 方法提供了对单例实例的访问。</span><br><span class="line">    - `SetFileName()` 允许设置日志文件的名称。</span><br><span class="line">    - `Start()` 和 `Stop()` 用于启动和停止日志线程。</span><br><span class="line">    - `AddToQueue()` 是用于将新的日志消息添加到日志队列的方法。</span><br><span class="line">    - `threadfunc()` 是日志线程的工作函数，它持续从日志队列中读取消息并写入文件。</span><br><span class="line"></span><br><span class="line">3. **类的私有成员**:</span><br><span class="line">    - `filename_`: 存储日志文件的名称。</span><br><span class="line">    - `fp_`: 用于文件操作的文件指针。请注意，在所给代码中，`FILE` 的声明被注释掉了，你需要包含 `&lt;cstdio&gt;` 或者直接使用 C++ 的文件流类（如 `std::ofstream`）。</span><br><span class="line">    - `spthread_`: 一个智能指针，指向日志线程。</span><br><span class="line">    - `mutex_`: 用于保护日志队列和其他共享资源，确保多线程访问时的线程安全。</span><br><span class="line">    - `cv_`: 条件变量，用于通知日志线程有新的消息到来。</span><br><span class="line">    - `exit_`: 一个标志，指示日志线程何时退出。</span><br><span class="line">    - `queue_`: 存储待处理日志消息的队列。</span><br><span class="line"></span><br><span class="line">4. **注释**: </span><br><span class="line">    - 提供了关于该文件的基本信息，如文件名称和日期。</span><br><span class="line"></span><br><span class="line">总之，这个日志系统设计的思路是：</span><br><span class="line">1. 用户调用预定义的宏添加日志消息。</span><br><span class="line">2. 日志消息被添加到一个线程安全的队列。</span><br><span class="line">3. 一个独立的日志线程从队列中取出消息并写入文件。</span><br><span class="line"></span><br><span class="line">这种设计允许应用程序非阻塞地添加日志消息，而将I/O操作留给专门的线程，从而提高应用程序的性能。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 日志类头文件, Logger.h</span></span><br><span class="line"><span class="comment"> *  2022.02.1</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LOGGER_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LOGGER_H__</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//struct FILE;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LogInfo(...)        Logger::GetInstance().AddToQueue(<span class="string">&quot;INFO&quot;</span>, __FILE__, __LINE__, __PRETTY_FUNCTION__, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LogWarning(...)     Logger::GetInstance().AddToQueue(<span class="string">&quot;WARNING&quot;</span>, __FILE__, __LINE__, __PRETTY_FUNCTION__, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LogError(...)       Logger::GetInstance().AddToQueue(<span class="string">&quot;ERROR&quot;</span>, __FILE__, __LINE__, __PRETTY_FUNCTION__, __VA_ARGS__)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetFileName</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddToQueue</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszLevel, <span class="type">const</span> <span class="type">char</span>* pszFile, <span class="type">int</span> lineNo, <span class="type">const</span> <span class="type">char</span>* pszFuncSig, <span class="type">char</span>* pszFmt, ...)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Logger</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> Logger&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    Logger&amp; <span class="keyword">operator</span> =(Logger&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadfunc</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string                     filename_;</span><br><span class="line">    FILE*                           fp_&#123;&#125;;</span><br><span class="line">    std::shared_ptr&lt;std::thread&gt;    spthread_;</span><br><span class="line">    std::mutex                      mutex_;</span><br><span class="line">    std::condition_variable         cv_;            <span class="comment">//有新的日志到来的标识</span></span><br><span class="line">    <span class="type">bool</span>                            exit_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    std::list&lt;std::string&gt;          queue_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//!__LOGGER_H__</span></span></span><br></pre></td></tr></table></figure><p>Logger.cpp</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">这是日志类的实现文件`Logger.cpp`。它对`Logger.h`中定义的函数进行了具体的实现。我将分步解释这个文件的内容：</span><br><span class="line"></span><br><span class="line">1. **<span class="comment">#include语句**: 引入了所需的头文件，其中`Logger.h`是之前你展示的日志类的头文件，其他的是C和C++标准库中的头文件。</span></span><br><span class="line"></span><br><span class="line">2. **GetInstance方法**: 实现了单例模式的核心功能。通过使用局部静态对象`logger`，它确保只创建一次`Logger`类的实例。</span><br><span class="line"></span><br><span class="line">3. **SetFileName方法**: 允许用户设置日志文件的名称。</span><br><span class="line"></span><br><span class="line">4. **Start方法**: </span><br><span class="line">    - 如果用户没有提供日志文件名，它会生成一个默认的日志文件名，该文件名包含当前的日期和时间。</span><br><span class="line">    - 尝试打开日志文件以写入和读取。</span><br><span class="line">    - 创建一个新线程来处理日志消息。</span><br><span class="line"></span><br><span class="line">5. **Stop方法**: </span><br><span class="line">    - 设置`exit_`标志为`<span class="literal">true</span>`。</span><br><span class="line">    - 通过条件变量通知日志线程。</span><br><span class="line">    - 等待日志线程结束。</span><br><span class="line"></span><br><span class="line">6. **AddToQueue方法**: </span><br><span class="line">    - 使用变长参数列表格式化日志消息。</span><br><span class="line">    - 生成一个包含日期、时间、日志级别、线程ID、源文件名、行号、函数签名和日志消息的完整日志字符串。</span><br><span class="line">    - 使用互斥锁将完整的日志字符串添加到队列。</span><br><span class="line">    - 通过条件变量通知日志线程有新的消息到来。</span><br><span class="line"></span><br><span class="line">7. **threadfunc方法**:</span><br><span class="line">    - 日志线程的核心功能。</span><br><span class="line">    - 检查文件指针是否为空。</span><br><span class="line">    - 在`exit_`为`<span class="literal">false</span>`的情况下，循环处理日志消息。</span><br><span class="line">    - 使用互斥锁和条件变量等待新的消息到来。</span><br><span class="line">    - 当有新的消息时，从队列中取出并写入日志文件。</span><br><span class="line">    - 如果设置了退出标志并且队列为空，线程将退出。</span><br><span class="line"></span><br><span class="line">总体上，这是一个简单但功能完整的日志系统实现。它使用了多线程，互斥锁和条件变量来确保线程安全，并使日志操作与应用程序的其他部分异步进行，从而提高了性能。</span><br><span class="line"></span><br><span class="line">然而，也有一些可以进一步优化或改进的地方：</span><br><span class="line">1. 在`Start()`中，文件是以<span class="string">&quot;wt+&quot;</span>模式打开的，这意味着如果文件已经存在，它会被覆盖。如果希望在现有文件中追加日志，则应使用<span class="string">&quot;at+&quot;</span>。</span><br><span class="line">2. 代码中没有明确的错误处理或异常处理策略。例如，如果`fopen`失败或`std::thread`创建失败时。</span><br><span class="line">3. 在`threadfunc`中，当队列不为空时，每处理一个消息就会刷新文件，这可能影响性能。可以考虑在队列中有多个消息时，一次性写入多个消息，然后再刷新。</span><br><span class="line">4. 可能会考虑添加一个`Rotate`功能，当日志文件大小超过某个限制时，自动将当前日志文件重命名，并创建一个新的日志文件。</span><br><span class="line">5. 为了提高性能，可以考虑使用双缓冲技术，这样可以减少互斥锁的争用。</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 日志类实现文件, Logger.cpp</span></span><br><span class="line"><span class="comment"> *  2022.02.1</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">Logger&amp; <span class="title">Logger::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Logger logger;</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::SetFileName</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    filename_ = filename;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Logger::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (filename_.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">tm</span>* t = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line">        <span class="type">char</span> timestr[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(timestr, <span class="string">&quot;%04d%02d%02d%02d%02d%02d.imserver.log&quot;</span>, t-&gt;tm_year + <span class="number">1900</span>, t-&gt;tm_mon + <span class="number">1</span>, t-&gt;tm_mday, t-&gt;tm_hour, t-&gt;tm_min, t-&gt;tm_sec);</span><br><span class="line">        filename_ = timestr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fp_ = <span class="built_in">fopen</span>(filename_.<span class="built_in">c_str</span>(), <span class="string">&quot;wt+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp_ == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    spthread_.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">thread</span>(std::<span class="built_in">bind</span>(&amp;Logger::threadfunc, <span class="keyword">this</span>)));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::Stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    exit_ = <span class="literal">true</span>;</span><br><span class="line">    cv_.<span class="built_in">notify_one</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//等待时间线程结束</span></span><br><span class="line">    spthread_-&gt;<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::AddToQueue</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszLevel, <span class="type">const</span> <span class="type">char</span>* pszFile, <span class="type">int</span> lineNo, <span class="type">const</span> <span class="type">char</span>* pszFuncSig, <span class="type">char</span>* pszFmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> msg[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    va_list vArgList;                            </span><br><span class="line">    <span class="built_in">va_start</span>(vArgList, pszFmt);</span><br><span class="line">    <span class="built_in">vsnprintf</span>(msg, <span class="number">256</span>, pszFmt, vArgList);</span><br><span class="line">    <span class="built_in">va_end</span>(vArgList);</span><br><span class="line"> </span><br><span class="line">    <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span>* tmstr = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line">    <span class="type">char</span> content[<span class="number">512</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;[%04d-%02d-%02d %02d:%02d:%02d][%s][0x%04x][%s:%d %s]%s\n&quot;</span>,</span><br><span class="line">                tmstr-&gt;tm_year + <span class="number">1900</span>,</span><br><span class="line">                tmstr-&gt;tm_mon + <span class="number">1</span>,</span><br><span class="line">                tmstr-&gt;tm_mday,</span><br><span class="line">                tmstr-&gt;tm_hour,</span><br><span class="line">                tmstr-&gt;tm_min,</span><br><span class="line">                tmstr-&gt;tm_sec,</span><br><span class="line">                pszLevel,</span><br><span class="line">                std::this_thread::<span class="built_in">get_id</span>(),</span><br><span class="line">                pszFile,</span><br><span class="line">                lineNo,</span><br><span class="line">                pszFuncSig,</span><br><span class="line">                msg);</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        queue_.<span class="built_in">emplace_back</span>(content);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::threadfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fp_ == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (!exit_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//写日志</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (queue_.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (exit_)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">            cv_.<span class="built_in">wait</span>(guard);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//写日志</span></span><br><span class="line">        <span class="type">const</span> std::string&amp; str = queue_.<span class="built_in">front</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">fwrite</span>((<span class="type">void</span>*)str.<span class="built_in">c_str</span>(), str.<span class="built_in">length</span>(), <span class="number">1</span>, fp_);</span><br><span class="line">        <span class="built_in">fflush</span>(fp_);</span><br><span class="line">        queue_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ol><li><p>Stop方法: 设置exit_标志为true。 通过条件变量通知日志线程。 等待日志线程结束 </p><p><strong>请问这里为什么需要通知日志线程</strong></p><p>解答：在<code>Logger</code>类的实现中，日志线程的工作是从队列中获取日志消息并将其写入文件。为了实现这个功能，它在队列为空时通过<code>cv_.wait(guard)</code>进入休眠状态，等待新的日志消息的到来。</p><p>当你调用<code>Stop</code>方法时，你希望日志线程能够尽快结束。但有一种情况需要考虑：当<code>Stop</code>被调用时，队列可能仍然是空的，这意味着日志线程可能处于<code>cv_.wait(guard)</code>的休眠状态。</p><p>在这种情况下，即使你设置了<code>exit_</code>标志为<code>true</code>，日志线程仍然不会醒来检查这个标志，因为它正在等待新的日志消息到来。</p><p>为了确保日志线程能够醒来、检查<code>exit_</code>标志并正确地退出，你需要在<code>Stop</code>方法中通过<code>cv_.notify_one()</code>通知日志线程。这样，日志线程将被唤醒，然后它可以检查<code>exit_</code>标志，并根据该标志的值决定是否退出。</p><p>总之，通知日志线程是为了确保它可以从<code>cv_.wait(guard)</code>中醒来，然后检查退出条件并安全地退出。</p></li><li><p>这个程序没有设计线程来将新的日志信息加入队列吗</p><p>从提供的代码来看，日志系统中只设计了一个专门的日志线程（在<code>Logger::Start()</code>方法中启动），其任务是从队列中提取日志消息并将其写入文件。此外，并没有为添加新日志消息到队列专门设计线程。</p><p>当你希望写入日志时，只需在你的主程序或任何其他线程中调用<code>LogInfo()</code>, <code>LogWarning()</code>, 或 <code>LogError()</code>这样的宏。这些宏内部会调用<code>Logger::AddToQueue()</code>，该方法将日志消息格式化并加入到队列中。这种设计的优点是简单且高效，因为它允许多个线程在运行时无缝地向日志系统添加消息，而无需额外的线程。</p><p>但值得注意的是，<code>Logger::AddToQueue()</code>使用了互斥锁<code>mutex_</code>来保证多个线程同时向队列添加消息时的线程安全。这意味着，即使多个线程同时调用日志宏，<code>Logger::AddToQueue()</code>中的代码仍然是线程安全的。</p><p>总的来说，这个日志系统的设计考虑到了多线程环境，允许多个线程同时添加日志消息，但它并没有专门设置一个线程来完成这项任务，而是允许主程序或其他任何线程来直接调用添加日志的宏。</p><p>自己的话：你自己程序在运行的时候是不是有多个线程，这些线程就是负责啥时候要调用<code>LogInfo()</code>, <code>LogWarning()</code>, 或 <code>LogError()</code>这样的宏。所以当然不需要额外的线程来操作加入队列操作，只需要一个带锁函数即可。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;本篇文章主要参考如下文章，主要是对代码做一个较为详尽的解释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;https://blog.csdn.net/qq_46495964/article/details/122952567&quot;&gt;https://</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>webServer</title>
    <link href="http://zcl0219.github.io/2023/08/23/webServer/"/>
    <id>http://zcl0219.github.io/2023/08/23/webServer/</id>
    <published>2023-08-23T13:08:31.000Z</published>
    <updated>2023-09-20T19:17:59.989Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始正式补充完善<code>webServer</code>服务器的内容！想到哪写到哪吧，回头再做整合。</p><h3 id="标准C库IO函数"><a href="#标准C库IO函数" class="headerlink" title="标准C库IO函数"></a>标准C库IO函数</h3><p><img src="PNG1.png"></p><h4 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、如何处理接收到的HTTP请求</span></span><br><span class="line"><span class="comment">2、如何填写HTTP响应</span></span><br><span class="line"><span class="comment">3、如何建立网络连接传输数据</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="HTTP请求处理"><a href="#HTTP请求处理" class="headerlink" title="HTTP请求处理"></a>HTTP请求处理</h4><p>http_conn头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">http_conn</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">http_conn</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">http_conn</span>() &#123;&#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_epollfd;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_user_count;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> so0ckaddr_in &amp;addr)</span></span>;<span class="comment">// 初始化连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close_conn</span><span class="params">(<span class="type">bool</span> real_close = <span class="literal">true</span>)</span></span>;<span class="comment">// 关闭连接，关于需要传入real_close参数的原因，后面会讲到，预留问题</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_sockfd;<span class="comment">// 发起http请求的sockfd</span></span><br><span class="line">    sockaddr_in m_address;<span class="comment">// 发起http请求的socket地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在http_conn类里主要设置五个对外的接口：</p><ul><li><p>初始化新接受的连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> sockaddr_in &amp;addr)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们会把所有事件注册到一张内核事件表上，因此定义一个内核事件就好了。static int m_epollfd;</span></span><br><span class="line"><span class="comment">同时我们会统计当前连接数，同样是使用一个静态变量，所有实例对象共享。static int m_user_count;</span></span><br><span class="line"><span class="comment">每建立一个新连接，m_user_count就会加1；</span></span><br><span class="line"><span class="comment">当我们向内核事件表注册一个事件时，我们需要考虑我们所要监听的事件类型，这里我们考虑：</span></span><br><span class="line"><span class="comment">读事件（EPOLLIN）、边沿触发模式（EPOLLET）、以及EPOLLRDHUP（检测TCP对端连接的关闭或者半关闭状态）</span></span><br><span class="line"><span class="comment">为了配合ET模式和多线程，我们需要做两个操作，第一是将所监听的文件描述符设置为非阻塞的，第二需要设置为EPOLLONESHOT类型</span></span><br><span class="line"><span class="comment">注意：我们对m_epollfd和m_user_count的初始化分别为</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> m_epollfd = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> m_user_count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>设置非阻塞函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例：Linux高性能服务器编程 p113</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> sockfd)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>(sockfd, F_GETFL);  <span class="comment">// 获取文件描述符旧的状态标志</span></span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;<span class="comment">// 设置非阻塞标志</span></span><br><span class="line">    <span class="built_in">fcntl</span>(sockfd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;<span class="comment">// 返回文件描述符旧的状态标志，以便日后恢复该状态标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置感兴趣事件类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们在向内核事件表注册新事件的时候，需要指定自己对这个文件描述符上发生的什么事件感兴趣</span></span><br><span class="line"><span class="comment">// 可读？可写？</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> one_shot)</span></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">if</span>(one_shot)&#123;</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化函数代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::init</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> sockaddr_in &amp;addr)</span></span>&#123;</span><br><span class="line">m_sockfd = sockfd;</span><br><span class="line">    m_address = addr;</span><br><span class="line">    <span class="built_in">addfd</span>(m_epollfd, sockfd, <span class="literal">true</span>);</span><br><span class="line">    m_user_count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关闭连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">close_conn</span><span class="params">(<span class="type">bool</span> real_close)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们可以思考一下有关关闭连接需要涉及到哪些操作。</span></span><br><span class="line"><span class="comment">1、首先，如果一个连接关闭了，我们需要将其从内核事件表上移除</span></span><br><span class="line"><span class="comment">2、当前连接数目也会减一</span></span><br><span class="line"><span class="comment">这里我们准备先实现一个从内核事件表上移除文件描述符的函数（void removefd），在实现关闭连接</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>移除文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removefd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::close_conn</span><span class="params">(<span class="type">bool</span> real_close)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(real_close &amp;&amp; m_sockfd != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">removefd</span>(m_epollfd, m_sockfd);</span><br><span class="line">        m_sockfd = <span class="number">-1</span>;</span><br><span class="line">        m_user_count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>处理客户请求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于如何处理客户连接请求的问题，我们从最原始的地方出发。</span></span><br><span class="line"><span class="comment">首先，你了解一个http请求的基本格式吗？因为我们只有在了解http请求的通用格式后才知道如何对其进行解析</span></span><br><span class="line"><span class="comment">下面，我将展示一个最基本的GET请求格式</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">GET /path/to/resource?param1=value1&amp;param2=value2 HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agnet: Mozilla/5.0 (platform; rv:geckoversion) Gecko/geckotrail Firefox/firefoxversion</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br><span class="line"><span class="comment"># 关于这个GET请求的详细解释我提一个chatgpt的解释在这，可以阅读一下</span></span><br><span class="line">下面是逐行详细解释：</span><br><span class="line">1. `GET /path/to/resource?param1=value1&amp;param2=value2 HTTP/1.1`</span><br><span class="line">   - `GET`: 这是HTTP请求的方法。`GET` 方法用于请求指定的资源。与POST相比，GET请求是只读的，并且用于获取数据而不是发送数据。</span><br><span class="line">   - `/path/to/resource`: 这是请求的资源路径，通常是文件或者其他资源的位置。</span><br><span class="line">   - `?`: 这个符号表示URL的查询部分的开始。</span><br><span class="line">   - `param1=value1&amp;param2=value2`: 这是查询字符串。在此例中，有两个参数，`param1`和`param2`，它们的值分别是`value1`和`value2`。`&amp;`符号用于分隔查询参数。</span><br><span class="line">   - `HTTP/1.1`: 表示使用的HTTP版本，这里是1.1。</span><br><span class="line"></span><br><span class="line">2. `Host: www.example.com`</span><br><span class="line">   - `Host`: 这是HTTP头的名称。它指定了请求的目标主机和域名。</span><br><span class="line">   - `www.example.com`: 请求的目标域名。</span><br><span class="line"></span><br><span class="line">3. `User-Agent: Mozilla/5.0 (platform; rv:geckoversion) Gecko/geckotrail Firefox/firefoxversion`</span><br><span class="line">   - `User-Agent`: 这是HTTP头的名称。它描述了发出请求的用户代理的类型，通常是浏览器。</span><br><span class="line">   - `Mozilla/5.0`: 这是用户代理的一般标记。虽然名为Mozilla，但它并不仅仅代表Mozilla浏览器，大多数浏览器都会以这种方式标识。</span><br><span class="line">   - `(platform; rv:geckoversion)`: 这部分提供了关于用户代理的详细信息，例如它在哪个平台上运行。</span><br><span class="line">   - `Gecko/geckotrail`: 这是Gecko渲染引擎的标识及其版本。</span><br><span class="line">   - `Firefox/firefoxversion`: 表示用户代理是Firefox浏览器，后面跟着其版本。</span><br><span class="line"></span><br><span class="line">4. `Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8`</span><br><span class="line">   - `Accept`: HTTP头名称，表示客户端可以处理的内容类型。</span><br><span class="line">   - 该头的值列出了浏览器接受的MIME类型，按照优先级排序。例如，`text/html` 表示HTML文档，而`q=0.9`表示相对优先级。</span><br><span class="line"></span><br><span class="line">5. `Accept-Language: en-US,en;q=0.5`</span><br><span class="line">   - `Accept-Language`: HTTP头名称，表示用户代理偏好的自然语言。</span><br><span class="line">   - `en-US,en`: 这指示用户代理首先希望接收美国英语的内容，其次是英语。</span><br><span class="line"></span><br><span class="line">6. `Accept-Encoding: gzip, deflate, br`</span><br><span class="line">   - `Accept-Encoding`: HTTP头名称，表示用户代理可以接受的内容编码。</span><br><span class="line">   - `gzip, deflate, br`: 这些是可以接受的编码方法，用于内容压缩。</span><br><span class="line"></span><br><span class="line">7. `Connection: keep-alive`</span><br><span class="line">   - `Connection`: HTTP头名称，表示是否持续连接。</span><br><span class="line">   - `keep-alive`: 表示浏览器希望服务器保持连接，以便于后续的请求可以复用相同的TCP连接。</span><br><span class="line"></span><br><span class="line">这个请求大体上是一个典型的HTTP GET请求，由HTTP方法、资源路径、HTTP版本、多个头字段组成。每个头字段都有其特定的语义和目的。</span><br></pre></td></tr></table></figure><p>现在我们知道了HTTP请求格式了，那么到底如何解析它呢？这里就要引入一种叫做“有限状态机”的方法了，有关这个方法的具体描述与实现，大家可以看我的另一篇文章。</p></li><li><p>非阻塞读操作</p></li><li><p>非阻塞写操作</p></li></ul><p><strong>第一个知识点：<code>iovec</code></strong></p><p>这里先介绍一个<code>iovec</code>结构体，因为我们在写HTTP响应的时候需要用到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>&#123;</span></span><br><span class="line">  <span class="type">ptr_t</span> iov_base;</span><br><span class="line">  <span class="type">size_t</span> iov_len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct iovec结构体，指针成员iov_base指向一个缓冲区，这个缓冲区是存放read_v所接收的数据或者write_v将要发送的数据。成员iov_len在各种情况下分别确定了接收的最大长度和实际写入的长度。</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *<span class="built_in">vector</span>, <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *<span class="built_in">vector</span>, <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure><p>下面给出一个应用实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> part1[] = <span class="string">&quot;This is from writev&quot;</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> part2 = <span class="number">65</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> part3[] = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[3];</span></span><br><span class="line">    </span><br><span class="line">    iov[<span class="number">0</span>].iov_base = part3;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="built_in">strlen</span>(part3);</span><br><span class="line">    </span><br><span class="line">    iov[<span class="number">1</span>].iov_base = part1;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in">strlen</span>(part1);</span><br><span class="line">    </span><br><span class="line">    iov[<span class="number">2</span>].iov_base = &amp;part2;</span><br><span class="line">    iov[<span class="number">2</span>].iov_len = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    </span><br><span class="line">    writev(<span class="number">1</span>, iov, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二个知识点：<code>va_list</code>, <code>vsnprintf</code></strong></p><p>参考链接：<a href="https://blog.csdn.net/dengzhilong_cpp/article/details/54944676">https://blog.csdn.net/dengzhilong_cpp/article/details/54944676</a></p><p>参考链接：<a href="https://blog.csdn.net/luliplus/article/details/124123219">https://blog.csdn.net/luliplus/article/details/124123219</a></p><p>以上是今天要写代码的基础知识，下面开始正式代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*写HTTP响应*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">http_conn::write</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bytes_have_send = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bytes_to_send = m_write_idx;</span><br><span class="line">    <span class="keyword">if</span>(bytes_to_send == <span class="number">0</span>)&#123;</span><br><span class="line">        modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        temp = writev(m_sockfd, m_iv, m_iv_count);</span><br><span class="line">        <span class="keyword">if</span>(temp &lt;= <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EAGAIN)&#123;</span><br><span class="line">                modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unmap();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bytes_to_send -= temp;</span><br><span class="line">        bytes_have_send += temp;</span><br><span class="line">        <span class="keyword">if</span>(bytes_to_send &lt;= bytes_have_send)&#123;</span><br><span class="line">            unmap();</span><br><span class="line">            <span class="keyword">if</span>(m_linger)&#123;</span><br><span class="line">                init();</span><br><span class="line">                modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​                                                                                                                                                           </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天开始正式补充完善&lt;code&gt;webServer&lt;/code&gt;服务器的内容！想到哪写到哪吧，回头再做整合。&lt;/p&gt;
&lt;h3 id=&quot;标准C库IO函数&quot;&gt;&lt;a href=&quot;#标准C库IO函数&quot; class=&quot;headerlink&quot; title=&quot;标准C库IO函数&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>中缀表达式转后缀表达式</title>
    <link href="http://zcl0219.github.io/2023/08/23/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://zcl0219.github.io/2023/08/23/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2023-08-23T09:16:28.000Z</published>
    <updated>2023-10-07T10:31:14.909Z</updated>
    
    <content type="html"><![CDATA[<p>面试时被问到了关于如何将中缀表达式转换为后缀表达式，这里总结一下转换的步骤</p><ol><li>遇到操作数，直接输出</li><li>栈为空时，遇到运算符，入栈</li><li>遇到左括号，将其入栈</li><li>遇到右括号，执行出栈操作，并将出栈的元素输出，直到弹出栈的是左括号，左括号不输出</li><li>遇到其他运算符“+”，“-”，“*”，“&#x2F;”时，弹出所有优先级大于或等于该运算符的栈顶元素，然后将该运算符入栈</li><li>最终将栈中的元素依次出栈，输出</li></ol><p><img src="1.png"></p><p>（啊！先写到这吧，为了弄个图片弄了好久）</p><p>参考链接：<a href="https://blog.csdn.net/y_16041527/article/details/79684188">https://blog.csdn.net/y_16041527/article/details/79684188</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;面试时被问到了关于如何将中缀表达式转换为后缀表达式，这里总结一下转换的步骤&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;遇到操作数，直接输出&lt;/li&gt;
&lt;li&gt;栈为空时，遇到运算符，入栈&lt;/li&gt;
&lt;li&gt;遇到左括号，将其入栈&lt;/li&gt;
&lt;li&gt;遇到右括号，执行出栈操作，并将出栈的元素输出，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>智能指针shared_ptr的实现</title>
    <link href="http://zcl0219.github.io/2023/07/26/shared-ptr/"/>
    <id>http://zcl0219.github.io/2023/07/26/shared-ptr/</id>
    <published>2023-07-26T01:12:27.000Z</published>
    <updated>2023-08-10T15:29:15.120Z</updated>
    
    <content type="html"><![CDATA[<p>我们今天来实现一个简易版的智能指针吧！拖了好久啦，以后会把vector、string的简易版也给补上，<code>gigigi</code></p><p>我们可以先想想<code>shared_ptr</code>最大的特点，就是当他的引用计数为0时，便会自动释放所指对象和析构。所以一个关键点就是这个引用计数怎么设置？static？不可以！static变量同属于一个类的所有对象，这样就会导致不管指的是不是同一个对象，引用计数都相同。所以我们这里决定采用一个指针来进行引用计数。具体实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(T* sPtr = <span class="literal">nullptr</span>)</span>: sPtr_(sPtr)&#123;</span></span><br><span class="line">        <span class="keyword">if</span>(sPtr_)&#123;</span><br><span class="line">            useCount_ = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line">            sMutex_ = <span class="keyword">new</span> std::mutex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>()&#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)&#123;</span><br><span class="line">        useCount_ = sp.useCount_;</span><br><span class="line">        sPtr_ = sp.sPtr_;</span><br><span class="line">        sMutex_ = sp.sMutex_;</span><br><span class="line">        <span class="built_in">addUsecount</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sPtr_ != sp.sPtr_)&#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            sPtr_ = sp.sPtr_;</span><br><span class="line">            useCount_ = sp.useCount_;</span><br><span class="line">            sMutex_ = sp.sMutex_;</span><br><span class="line">            <span class="built_in">addUsecount</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()&#123;</span><br><span class="line">        <span class="keyword">return</span> *sPtr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">        <span class="keyword">return</span> sPtr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">useCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *useCount_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sPtr_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addUsecount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sMutex_-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        ++(*useCount_);</span><br><span class="line">        sMutex_-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">bool</span> deleteFlag = <span class="literal">false</span>;</span><br><span class="line">        sMutex_-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(--(*useCount_) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> useCount_;</span><br><span class="line">            <span class="keyword">delete</span> sPtr_;</span><br><span class="line">            deleteFlag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sMutex_-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span>(deleteFlag)&#123;</span><br><span class="line">            <span class="keyword">delete</span> sMutex_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* useCount_;</span><br><span class="line">    T* sPtr_;</span><br><span class="line">    std::mutex* sMutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;std::string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> std::string(<span class="string">&quot;hello&quot;</span>))</span></span>;</span><br><span class="line">    shared_ptr&lt;std::string&gt; p2 = p1;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; p2.useCount() &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="function">shared_ptr&lt;std::string&gt; <span class="title">p3</span><span class="params">(p2)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; p3.<span class="built_in">useCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p2.<span class="built_in">useCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    p2 = p3;</span><br><span class="line">    std::cout &lt;&lt; p3.<span class="built_in">useCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p2.<span class="built_in">useCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入结果图片有点问题，最近没时间弄，各位自己跑一下验证一下，有错误记得说！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们今天来实现一个简易版的智能指针吧！拖了好久啦，以后会把vector、string的简易版也给补上，&lt;code&gt;gigigi&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们可以先想想&lt;code&gt;shared_ptr&lt;/code&gt;最大的特点，就是当他的引用计数为0时，便会自动释放所指对象</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Cpp高频面经</title>
    <link href="http://zcl0219.github.io/2023/06/29/Cpp%E9%AB%98%E9%A2%91%E9%9D%A2%E7%BB%8F/"/>
    <id>http://zcl0219.github.io/2023/06/29/Cpp%E9%AB%98%E9%A2%91%E9%9D%A2%E7%BB%8F/</id>
    <published>2023-06-28T19:50:53.000Z</published>
    <updated>2023-10-09T08:26:33.676Z</updated>
    
    <content type="html"><![CDATA[<h4 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h4><ul><li><p>属性的区别</p><p>new&#x2F;delete：这两个是C++中的关键字；</p><p>malloc&#x2F;free：这两个是库函数；</p></li><li><p>使用上的区别</p><p>malloc：申请空间需要显式填入申请内存的大小；</p><p>new：无需显式填入申请内存的大小，new会根据new的类型分配内存；</p></li><li><p>返回类型的区别</p><p>new操作符内存分配成功，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，故new是符合类型安全性的操作符。</p><p>malloc内存分配成功返回的是void*指针，需要通过强制类型转换，转换成我们需要的类型。</p><p>所以C++中new比malloc安全可靠。</p></li><li><p>分配失败的区别</p><p>malloc分配失败会返回NULL，我们可以通过判断返回值是否是NULL得知是否分配成功。</p><p>new分配失败会抛出bad_alloc异常。</p></li><li><p>扩张内存的区别</p><p>malloc有内存扩张机制（通过realloc实现）。</p><p>new没有扩张内存机制。</p></li></ul><p><a href="https://zhuanlan.zhihu.com/p/338489910">https://zhuanlan.zhihu.com/p/338489910</a></p><h4 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h4><ul><li>明确动态内存使用范围：在程序中使用动态内存时，需要明确该内存的使用范围，确保在不需要使用该内存时能够及时释放内存。</li><li>使用RAII技术：RAII（Resource Acquisition Is Initialization）是C++中一种常用的资源管理技术，它利用了C++对象的构造函数和析构函数自动调用的特性，在对象的构造函数中申请资源，在对象的析构函数中释放资源，从而避免资源泄漏问题。</li><li>使用智能指针：智能指针可以自动管理动态内存的分配和释放。</li></ul><h4 id="线程池的数量一般怎么设置"><a href="#线程池的数量一般怎么设置" class="headerlink" title="线程池的数量一般怎么设置"></a>线程池的数量一般怎么设置</h4><p>线程池中线程数量的设置主要考虑两个方面：</p><ul><li><p>I&#x2F;O密集型</p></li><li><p>如果说任务是耗时I&#x2F;O型，比如涉及数据库、文件的读写，网络通信等任务，这种任务的特点是不会特别消耗CPU资源，但是我们需要考虑到I&#x2F;O操作耗时较长。这种情况一般会将线程数设置的比较大，达到了CPU核心数的很多倍。因为如果线程数设置的比较少，会造成CPU计算资源的浪费。</p></li><li><p>CPU密集型</p></li><li><p>对于CPU密集型任务，线程数不宜设置的过多，因为过多的线程都会去抢占CPU资源，就会产生不必要的上下文切换，反而会造成整体性能的下降</p></li></ul><p>线程数通用计算公示：线程数 &#x3D; CPU核心数 * (1 + I&#x2F;O耗时 &#x2F; CPU耗时)</p><h4 id="来了一个新任务，线程池是怎么工作的（本答案有待商榷）"><a href="#来了一个新任务，线程池是怎么工作的（本答案有待商榷）" class="headerlink" title="来了一个新任务，线程池是怎么工作的（本答案有待商榷）"></a>来了一个新任务，线程池是怎么工作的（本答案有待商榷）</h4><p>当有一个新任务到来时，线程池会先判断是否有空闲线程，如果有，则将任务分配给空闲线程；</p><p>如果此时线程池里没有空线程，则先将任务放任务任务队列，待有空闲线程之后，再从任务队列中取出任务。</p><h4 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h4><p>在我的理解里，完美转发 &#x3D; std::forward + 万能引用 + 引用折叠。首先引用折叠机制为T&amp;&amp;类型的万能引用中的模板参数T赋予了一个恰到好处的值，而我们用T去指明std::forward的模板参数，从而使得std::forward返回的是正确的类型（这里关于返回的是正确的类型，应该去看std::forward实现的源码，知乎链接如下：<a href="https://zhuanlan.zhihu.com/p/369203981%EF%BC%89">https://zhuanlan.zhihu.com/p/369203981）</a></p><h4 id="去掉std-forward会咋样"><a href="#去掉std-forward会咋样" class="headerlink" title="去掉std::forward会咋样"></a>去掉std::forward会咋样</h4><p>可能会导致在传递参数的时候丢失类型信息，从而导致编译器无法正确推断模板类型或者在模板类型推断中发生错误。</p><h4 id="讲一下C-中的虚继承"><a href="#讲一下C-中的虚继承" class="headerlink" title="讲一下C++中的虚继承"></a>讲一下C++中的虚继承</h4><h4 id="基类的析构函数为什么是虚函数？"><a href="#基类的析构函数为什么是虚函数？" class="headerlink" title="基类的析构函数为什么是虚函数？"></a>基类的析构函数为什么是虚函数？</h4><p>如果基类的虚构函数不是虚函数，当我们定义一个父类指针指向子类对象时，最后子类的析构函数不会调用，导致内存泄漏。</p><h4 id="struct和union的区别（默写）"><a href="#struct和union的区别（默写）" class="headerlink" title="struct和union的区别（默写）"></a>struct和union的区别（默写）</h4><h4 id="C-内存布局-x2F-程序分段（默写）"><a href="#C-内存布局-x2F-程序分段（默写）" class="headerlink" title="C++内存布局&#x2F;程序分段（默写）"></a>C++内存布局&#x2F;程序分段（默写）</h4><h4 id="了解shared-ptr吗？如果让你手写一个shared-ptr，你会怎么设计"><a href="#了解shared-ptr吗？如果让你手写一个shared-ptr，你会怎么设计" class="headerlink" title="了解shared_ptr吗？如果让你手写一个shared_ptr，你会怎么设计"></a>了解shared_ptr吗？如果让你手写一个shared_ptr，你会怎么设计</h4><p>shared_ptr是智能指针里面的共享指针，即多个指针指向同一个内存。每多一个指针指向这片内存，引用计数加1。当对象的引用计数减少为0时，对象会自动析构，对应内存被自动释放。智能指针是模板类，而不是指针。</p><p>设计：将shared_ptr定义为一个模板类，包括两个成员：模板类指针和一个指向引用计数的指针。指向引用计数类型的指针应该包括这些成员函数：增加计数、减少计数、返回现有计数。一个私有成员就是用于计数的变量。共享指针模板类的构造函数接受一个模板类型指针，并且需要声明为explicit，表示必须直接初始化。另外就是拷贝构造函数和移动构造函数。拷贝构造需要注意拷贝的对象的指针是否为nullptr，如果不是nullptr，则需要增加引用计数。移动构造函数需要注意将传入的右值引用对象的指针置空，引用计数清零。析构函数有两个判断条件，第一个最后一个指向对象的指针需要为非nullptr并且此时引用计数减一后为0。然后就是重载*、-&gt;、bool，还有一个函数用于获得指针get()。动态转换（可考虑）。</p><h4 id="介绍一下TCP，TCP粘包如何解决"><a href="#介绍一下TCP，TCP粘包如何解决" class="headerlink" title="介绍一下TCP，TCP粘包如何解决"></a>介绍一下TCP，TCP粘包如何解决</h4><p>解决办法：</p><ul><li>发送端：使用TCP_NODELAY关闭Nagle算法，但是如果不是时延敏感的应用尽量不要关闭</li><li>接收端：没法解决，只能交给应用端解决</li><li>应用层：有三种解决办法<ul><li>只发送固定包长的数据包，但是这个方法基本不用，灵活性太差</li><li>指定标识结尾，比如\r\n之类的</li><li>包头加包体，包头一般是固定长度，并且里面有一个字段可以告知我们接下来的包体有多大</li></ul></li></ul><h4 id="回调函数是什么，回调函数的本质"><a href="#回调函数是什么，回调函数的本质" class="headerlink" title="回调函数是什么，回调函数的本质"></a>回调函数是什么，回调函数的本质</h4><p>回调函数允许我们将一个函数（或函数对象）作为参数传递给另一个函数，并在需要的时候由后者调用执行。回调函数定义了在特定事件或条件满足时应该执行的操作。主调函数是接受回调函数作为参数的函数。</p><h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><ol><li>进程<ul><li>进程拥有独立内存空间和系统资源</li><li>进程之间相互独立，一个进程的崩溃通常不会影响其他进程</li><li>创建、销毁和切换进程开销比较大</li></ul></li><li>线程<ul><li>一个进程可以包含多个线程，所有线程共享相同的地址空间和系统资源</li><li>线程之间可以直接读写进程内的共享数据，执行起来更高效</li><li>线程的创建、销毁和切换开销比较小</li></ul></li></ol><h4 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h4><p>GET用于获取资源，参数通过URL传递，不适合传输敏感信息，幂等，有缓存，传输数据的大小受限于URL的长度。POST用于提交数据，参数通过请求体传递，适合传输敏感信息，不幂等，无缓存，没有数据大小限制。</p><h4 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h4><ol><li>HTTP<ul><li>HTTP是一种应用层协议，用于在Web浏览器和Web服务器之间传输超文本和其他资源</li><li>HTTP是明文传输的协议，意味着数据在传输过程中是未加密的，容易被窃听和篡改</li><li>HTTP默认使用80端口号</li></ul></li><li>HTTPS<ul><li>HTTPS是HTTP协议的安全版本，加强了数据传输的安全性和保密性</li><li>HTTPS使用了SSL&#x2F;TLS协议进行数据加密和身份认证</li><li>HTTPS默认使用443端口通信</li></ul></li></ol><h4 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++ 11新特性"></a>C++ 11新特性</h4><ul><li><p>auto关键字</p></li><li><p>智能指针</p></li><li><p>lambda表达式参考链接（<a href="https://blog.51cto.com/u_15323899/5785594%EF%BC%89">https://blog.51cto.com/u_15323899/5785594）</a></p><p>Lambda表达式是C++11引入的一种新特性，它允许在代码中定义匿名函数。虽然在使用上非常简洁和方便，但lambda表达式背后的实现相对复杂。以下是lambda表达式在底层的工作原理：</p><ol><li><p><strong>转换为类</strong>:</p><ul><li>当你定义一个lambda表达式，编译器会为你生成一个匿名类（也称为闭包类型）。这个类将会覆盖函数调用操作符，使得该对象可以像函数一样被调用。</li><li>如果lambda表达式捕获了外部的局部变量（例如通过值或引用），这些变量将会被添加为该匿名类的成员。</li></ul></li><li><p><strong>成员变量</strong>:</p><ul><li>为了支持捕获，生成的闭包类型可能会包含成员变量。如果使用值捕获，那么这些成员变量将存储捕获的变量的副本；如果使用引用捕获，那么成员变量将存储相应变量的引用。</li></ul></li><li><p><strong>函数调用操作符重载</strong>:</p><ul><li>生成的类会覆盖函数调用操作符<code>operator()</code>. 这个操作符的实现就是lambda表达式的主体。</li></ul></li><li><p><strong>构造函数</strong>:</p><ul><li>该匿名类的构造函数会初始化所有捕获的变量。根据捕获方式（值或引用）来复制或绑定这些变量。</li></ul></li><li><p><strong>生成的类是只移动构造的</strong>:</p><ul><li>这意味着你不能按常规方式复制lambda表达式，但可以移动它。</li></ul></li></ol><p>下面是一个简单的lambda表达式的例子以及一个可能的简化版本的匿名类表示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lambda</span></span><br><span class="line"><span class="keyword">auto</span> lambda = [x](<span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Possible representation by the compiler</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__anonymous</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    __anonymous(<span class="type">int</span> _x) : <span class="built_in">x</span>(_x) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>要注意的是，这只是一个简化的表示。实际编译器生成的代码会比这更复杂，尤其是当涉及到更高级的特性（如泛型、<code>mutable</code>关键字或捕获列表）时。</p><p>最后，虽然从概念上讲，lambda表达式是转换为类的，但这并不意味着性能会受到影响。优化后的编译器通常会内联这些生成的类和函数调用操作符，从而消除由于间接调用导致的任何额外开销。</p></li><li><p>右值引用和移动语义</p></li></ul><h4 id="lambda表达式的使用场景"><a href="#lambda表达式的使用场景" class="headerlink" title="lambda表达式的使用场景"></a>lambda表达式的使用场景</h4><p>lambda表达式提供了一种简洁、方便的方式来创建匿名对象。在一些需要传递简单函数对象的场景下，使用lambda表达式可以避免额外的函数对象类。</p><h4 id="vector迭代器失效的原因"><a href="#vector迭代器失效的原因" class="headerlink" title="vector迭代器失效的原因"></a>vector迭代器失效的原因</h4><p>vector底层的实现是一个动态数组，vector里面存储的元素都是连续的，一旦比如删除一个元素，后面的所有元素都需要移动。我们可以考虑一种极端情况，删除最后一个元素，此时指向原vector数组的最后一个元素的迭代器就没指向任何元素了，如何此时我们访问这个迭代器所指向的元素，就会导致未定义行为，所以就会判定迭代器失效。其实所有改变vector大小的操作，都会导致vector迭代器失效。</p><h4 id="map的底层数据结构"><a href="#map的底层数据结构" class="headerlink" title="map的底层数据结构"></a>map的底层数据结构</h4><p>红黑树参考链接：<a href="https://www.jianshu.com/p/e136ec79235c">https://www.jianshu.com/p/e136ec79235c</a></p><p>map是有序容器，底层数据结构是红黑树，时间复杂度为log(n)。红黑树的前身可以说是二叉搜索树。但是二叉搜索树最坏的情况下树的高度为n，那么就导致时间复杂度为o(n), 所以便衍生出来了平衡二叉树。其实红黑树的五大特性就是为了保持二叉搜索树的平衡。保证时间复杂度稳定在o(logn)。</p><h4 id="unordered-map底层数据结构"><a href="#unordered-map底层数据结构" class="headerlink" title="unordered_map底层数据结构"></a>unordered_map底层数据结构</h4><p>unordered_map是无序容器，底层使用哈希表实现的。</p><h4 id="TCP握手为什么是三次握手，两次握手为什么不行呢"><a href="#TCP握手为什么是三次握手，两次握手为什么不行呢" class="headerlink" title="TCP握手为什么是三次握手，两次握手为什么不行呢"></a>TCP握手为什么是三次握手，两次握手为什么不行呢</h4><p>这里有两个大点，第一个字面意思很好理解，第二点举个例子就通透了，面试时最好全部答上来</p><ul><li><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤</p></li><li><p>防止已失效的连接请求又传送到服务器端，因而产生错误</p><p>只有采用三次握手可以减少服务端的资源浪费。解释如下：<br>例如，客户端向服务端发送请求同步报文A，因为网络阻塞等原因，服务端没有收到同步报文A，所以没有发送同步确认报文。过了一段时间，客户端没有收到服务端的确认报文，重新向服务端发送请求同步报文B，服务端接收到报文B后，向客户端发送同步确认报文，客户端接收到确认报文后，向服务端发送确认报文，建立连接。数据传输完毕后，连接断开。客户端进入close状态，此时服务端收到之前的报文A，向客户端返回同步确认报文。如果使用两次握手，服务端回应后不确认客户端的状态，连接建立成功。服务端会长时间等待客户端发送数据，连接长期保持，会造成资源浪费。当多个客户端产生这种情况，服务器就会等待多个客户端的响应，连接数量过多，之后的客户端请求，服务器无法响应。造成服务器处于瘫痪状态。<br>只有使用三次握手，当服务端收到确认报文后，保证当前时刻，客户端可以发送数据时，才能建立有意义的连接。当客户端一段时间不发送数据时，服务器应自动断开连接，来节省自身连接的客户端数量，减少资源的浪费。</p></li></ul><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p>HTTP状态码是在HTTP协议中用于表示服务器对请求的处理结果的三位数字代码。HTTP状态码的分类如下：</p><ol><li><p>1xx（信息性状态码）：表示服务器已接收请求，需要客户端继续操作。</p></li><li><p>2xx（成功状态码）：表示服务器成功处理了请求。</p></li><li><p>3xx（重定向状态码）：表示请求需要进一步的操作，通常用于重定向。</p></li><li><p>4xx（客户端错误状态码）：表示客户端发出的请求有误。</p></li><li><p>5xx（服务器错误状态码）：表示服务器在处理请求时发生了错误。</p></li></ol><p>以下是一些常见的HTTP状态码示例：</p><ol><li><p>200 OK：请求成功，服务器成功处理了请求。</p></li><li><p>201 Created：请求成功，服务器已成功创建了资源。</p></li><li><p>204 No Content：请求成功，但服务器没有新的信息返回。</p></li><li><p>400 Bad Request：请求错误，服务器不理解或无法处理请求。</p></li><li><p>401 Unauthorized：请求需要用户认证，未提供有效的认证信息。</p></li><li><p>403 Forbidden：请求被服务器拒绝，没有访问权限。</p></li><li><p>404 Not Found：请求的资源不存在。</p></li><li><p>500 Internal Server Error：服务器内部错误，无法完成请求。</p></li><li><p>502 Bad Gateway：服务器作为网关或代理，从上游服务器收到无效的响应。</p></li><li><p>503 Service Unavailable：服务器暂时不可用，通常是由于过载或维护。</p></li></ol><p>这只是HTTP状态码中的一部分，实际中可能还会遇到其他状态码。状态码的具体含义可参考HTTP协议的官方文档或RFC文档。不同的状态码代表了服务器对请求的不同响应结果，客户端根据状态码可以做出相应的处理。</p><h4 id="使用智能指针了，普通指针还能用吗？"><a href="#使用智能指针了，普通指针还能用吗？" class="headerlink" title="使用智能指针了，普通指针还能用吗？"></a>使用智能指针了，普通指针还能用吗？</h4><p>个人觉得使用了智能指针后不推荐使用普通指针。因为使用了智能指针后，再使用普通指针指向相同对象，并不会增加引用计数，等智能指针引用计数变为0的时候，对象被销毁，此时普通指针就变为了野指针。</p><h4 id="什么时候使用智能指针，什么时候使用普通指针-（CHATGPT）"><a href="#什么时候使用智能指针，什么时候使用普通指针-（CHATGPT）" class="headerlink" title="什么时候使用智能指针，什么时候使用普通指针 （CHATGPT）"></a>什么时候使用智能指针，什么时候使用普通指针 （CHATGPT）</h4><p>使用智能指针还是普通指针取决于你的代码需求和内存管理需求。以下是一些指导原则：</p><p>使用智能指针的情况：</p><ol><li><p>动态分配内存：如果你需要动态分配内存，尤其是在使用<code>new</code>关键字时，最好使用智能指针来管理这些资源。智能指针会自动在不再需要时释放内存，避免了内存泄漏的问题。</p></li><li><p>所有权传递：当多个地方共享一个资源并且需要明确的所有权传递时，智能指针特别有用。例如，使用<code>std::shared_ptr</code>来共享资源，并在最后一个引用释放时自动删除资源。</p></li><li><p>异常安全：在使用普通指针的代码中，如果在动态分配资源后发生异常，可能会导致资源泄漏。使用智能指针可以更好地处理异常情况，确保资源在退出作用域时得到正确释放。</p></li><li><p>容器存储：如果要在STL容器中存储指针类型，建议使用智能指针。STL容器在元素添加或删除时可能会复制或移动元素，使用智能指针可以正确管理资源的所有权。</p></li></ol><p>使用普通指针的情况：</p><ol><li><p>接口和传统API：某些接口和传统的C API可能要求使用原始指针，此时你无法使用智能指针。在这种情况下，你应该小心管理内存，确保手动释放资源。</p></li><li><p>与C代码交互：当与C语言库或代码进行交互时，普通指针是常用的方式，因为C语言不支持智能指针。</p></li><li><p>临时指针：对于一些临时指针，其生命周期很短且不需要动态内存管理时，可以使用普通指针。</p></li><li><p>最低开销：在某些性能关键的场景，智能指针可能带来额外的开销，此时使用普通指针可能更合适。但请注意，在性能优化前确保使用智能指针没有影响到代码的正确性和可维护性。</p></li></ol><p>综上所述，智能指针在大多数情况下是推荐的内存管理方式，特别是在现代C++代码中。然而，有些特定的场景可能需要使用普通指针，但在这种情况下你需要格外小心以避免内存泄漏和悬挂指针问题。</p><h4 id="Hash-map原理"><a href="#Hash-map原理" class="headerlink" title="Hash_map原理"></a>Hash_map原理</h4><p>Hash_map基于Hash_map（哈希表）。</p><p>哈希表基本原理：使用一个下标范围较大的数组来储存元素。那我们怎么根据关键字知道它应该放在数组的哪个位置呢？这就通过哈希函数（散列函数）来解决。哈希函数使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应。但是，不能保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这就产生了哈希冲突。因此“直接定址”和“解决冲突”是哈希表的两大特点。</p><p>哈希冲突的解决主要有以下四种方法：开放地址法，再哈希法，链地址法和建立公共溢出区。关于这四种方法的解释见知乎链接 <a href="https://zhuanlan.zhihu.com/p/29520044">https://zhuanlan.zhihu.com/p/29520044</a></p><h4 id="C-多态介绍一下"><a href="#C-多态介绍一下" class="headerlink" title="C++多态介绍一下"></a>C++多态介绍一下</h4><p>C++多态主要包括重载、虚函数、模板。重载包括函数重载和运算符重载，编译期，即编译器在编译阶段就会根据函数调用的上下文来决定使用哪一个重载版本。虚函数是在运行期。重载和模板属于静态多态，虚函数属于动态多态。静态多态与动态多态靠编译期与运行期区分。</p><h4 id="虚函数、纯虚函数原理，虚表什么时候建立的https-zhuanlan-zhihu-com-p-37331092"><a href="#虚函数、纯虚函数原理，虚表什么时候建立的https-zhuanlan-zhihu-com-p-37331092" class="headerlink" title="虚函数、纯虚函数原理，虚表什么时候建立的https://zhuanlan.zhihu.com/p/37331092"></a>虚函数、纯虚函数原理，虚表什么时候建立的<a href="https://zhuanlan.zhihu.com/p/37331092">https://zhuanlan.zhihu.com/p/37331092</a></h4><ul><li>虚函数，在类成员方法的声明（不是定义）语句前加“virtual”，如virtual void func</li><li>纯虚函数，在虚函数后加“&#x3D;0”，如virtual void func &#x3D; 0</li><li>对于虚函数，子类可以（也可以不）重写基类的虚函数，该行为称之为override</li><li>对于纯虚函数，子类必须提供纯虚函数的个性化实现</li></ul><p>在派生子类中对虚函数和纯虚函数的个性化实现，都体现了多态特性，但区别在于：</p><ul><li>子类如果不提供虚函数的实现，将会自动调用基类的缺省虚函数实现</li><li>子类如果不提供纯虚函数的实现，将会编译失败</li></ul><p><strong>当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数则由指针指向的实际类型决定</strong></p><p>实现虚函数表的关键就是虚函数表指针，这个指针指向一张名为虚函数表的表，为表中的数据则为函数指针，存储了虚函数具体实现所对应的位置。另外，当一个类有多个虚函数时，仍然只有一个虚函数指针，而此时的虚函数表里会有多个<strong>函数指针</strong>，因此，虚函数实现的过程是：<strong>通过对象内存中的虚函数指针vptr找到虚函数表vtbl，再通过vtbl中的函数指针找到对应虚函数的实现区域并进行调用。</strong>所以虚函数的调用时由指针所指向内存块的具体类型决定的。</p><h4 id="构造函数和析构函数可以是虚函数吗？"><a href="#构造函数和析构函数可以是虚函数吗？" class="headerlink" title="构造函数和析构函数可以是虚函数吗？"></a>构造函数和析构函数可以是虚函数吗？</h4><p>答案是：构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。</p><p>首先，我们已经知道虚函数的实现则是通过对象内存中的vptr来实现的。而构造函数是用来实例化一个对象的，通俗来讲就是为对象内存中的值做初始化操作。那么在构造函数完成之前，也即还没有进行初始化，此时vptr是没有值的，也就无法通过vptr找到作为构造函数和虚函数所在的代码区，所以构造函数只能以普通函数的形式存放在类所指定的代码区中。</p><p>而对于析构函数，当我们delete(a)的时候，如果析构函数不是虚函数，那么调用的将会是基类base的析构函数。而当继承的时候，通常派生类会在基类的基础上定义自己的成员，此时我们当然希望可以调用派生类的析构函数对新定义的成员也进行析构。</p><h4 id="map为啥用红黑树不用avl树？"><a href="#map为啥用红黑树不用avl树？" class="headerlink" title="map为啥用红黑树不用avl树？"></a>map为啥用红黑树不用avl树？</h4><ul><li>平衡调整次数更少</li><li>内存使用更少：AVL树需要存储额外的平衡因子信息</li><li>更适合于频繁的插入和删除操作</li></ul><h4 id="怎么判断map里key值存不存在"><a href="#怎么判断map里key值存不存在" class="headerlink" title="怎么判断map里key值存不存在"></a>怎么判断map里key值存不存在</h4><p>c.at(k)访问关键字为k的元素，如果k不在c中，返回一个out_of_range异常</p><p>c.find(k)如果存在，返回一个迭代器，指向关键字为k的元素；如果不存在，返回尾后迭代器</p><p>c.count(k)不存在返回0，存在返回k关键字的数量</p><h4 id="多进程通信方式"><a href="#多进程通信方式" class="headerlink" title="多进程通信方式"></a>多进程通信方式</h4><p>管道、命名管道、消息队列、信号量、共享内存、套接字、RPC</p><p>管道：一种最简单的进程间通信方式，通常用于父子进程间通信。管道中数据只能朝一个方向流动，即一方读另一方写。管道通过系统调用pipe()创建。</p><p>命名管道：一种更通用的进程间通信方式，它可以在无关的进程之间进行通信。不同于管道，命名管道通过文件系统中的路径名来标识。命名管道可以通过系统调用 <code>mkfifo()</code> 创建。</p><p>信号量：讲好sem_init(), sem_wait(), sem_post()系统整体运作过程就好了</p><p>套接字：服务器监听一个ip+端口，客户端访问连接</p><h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><table><thead><tr><th align="left"></th><th align="center">TCP</th><th align="center">UDP</th></tr></thead><tbody><tr><td align="left">可靠性</td><td align="center">可靠</td><td align="center">不可靠</td></tr><tr><td align="left">连接</td><td align="center">面向连接</td><td align="center">无连接</td></tr><tr><td align="left">数据传输方式</td><td align="center">字节流</td><td align="center">数据报</td></tr><tr><td align="left">双工性</td><td align="center">全双工</td><td align="center">一对一、一对多、多对一、多对多</td></tr><tr><td align="left">流量控制</td><td align="center">滑动窗口</td><td align="center">无</td></tr><tr><td align="left">拥塞控制</td><td align="center">慢启动、拥塞避免、快速重传、快速回复</td><td align="center">无</td></tr><tr><td align="left">效率</td><td align="center">低</td><td align="center">高</td></tr><tr><td align="left">传输速度</td><td align="center">慢</td><td align="center">快</td></tr></tbody></table><h4 id="TCP-x2F-IP协议组"><a href="#TCP-x2F-IP协议组" class="headerlink" title="TCP&#x2F;IP协议组"></a>TCP&#x2F;IP协议组</h4><p>IP协议、TCP协议、UDP协议、ICMP协议、ARP协议、RARP协议</p><h4 id="OSI七层"><a href="#OSI七层" class="headerlink" title="OSI七层"></a>OSI七层</h4><p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p><h4 id="socket编程recv函数"><a href="#socket编程recv函数" class="headerlink" title="socket编程recv函数"></a>socket编程recv函数</h4><p>返回0：对方关闭连接</p><p>返回相应的接收数据大小</p><p>返回错误码：传输出现错误</p><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>快排思想：选定基准元素，小的放一边，大的放一边，最后分治</p><h4 id="HTTP状态码-1"><a href="#HTTP状态码-1" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><ol><li>1XX - 信息状态码：<ul><li>100 Continue：服务端已经收到了客户端请求，继续发送剩余部分</li></ul></li><li>2XX - 成功状态码：<ul><li>200 OK：请求成功，服务器成功处理了请求</li><li>201 Created：请求成功，并创建了资源</li><li>204 No Content：请求成功，但没有返回内容</li></ul></li><li>3XX - 重定向状态码：<ul><li>301 Moved Permanently：永久重定向，请求的资源被永久移到了新位置</li><li>302 Found：临时重定向，请求的资源被临时移到了新位置</li><li>304 Not Modified：客户端缓存资源仍然有效，未修改</li></ul></li><li>4XX - 客户端错误状态码：<ul><li>400 Bad Request：客户端请求错误，服务器无法理解</li><li>401 Unauthorized：请求要求身份验证，客户端未提供有效的身份信息</li><li>403 Forbidden：服务器拒绝请求，没有访问权限</li><li>404 Not Found：请求的资源不存在</li></ul></li><li>5XX - 服务器错误状态码：<ul><li>500 Internet Server Error：服务器内部错误，无法完成请求</li><li>502 Bad Gateway：作为网关或代理的服务器从上游服务器收到无效响应</li><li>503 Service Unavailable：服务器暂时过载或维护中，无法处理请求</li><li>504 Gateway Timeout：作为网关或代理服务器未及时从上游服务器接收响应</li></ul></li></ol><h4 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h4><p>DNS就是域名解析服务，查询过程依次递增。本地域名解析（操作系统首先会查询本地DNS缓存） —–》本地域名服务器查询 —–》根域名服务器查询 —–》顶级域名服务器查询 —–》权威域名服务器查询 —–》返回结果。DNS查询和应答报文具有相同格式，主要区别在于某些字段的标识。下面讲几个重要的字段。</p><ul><li>16位标识：用于标记一对DNS查询和应答，以此区分一个DNS应答是哪一个DNS查询的回应</li><li>16位标志<ul><li>QR：查询报文（0）&#x2F;应答报文（1）</li><li>opcode：标准查询（0）&#x2F;    反向查询（1）就是是通过域名获取ip地址还是通过ip地址获取域名</li></ul></li></ul><h4 id="TCP为什么需要四次挥手，三次挥手有什么问题"><a href="#TCP为什么需要四次挥手，三次挥手有什么问题" class="headerlink" title="TCP为什么需要四次挥手，三次挥手有什么问题"></a>TCP为什么需要四次挥手，三次挥手有什么问题</h4><ol><li>客户端最后一个ACK可能会丢失，这样服务端就无法正常进入CLOSED状态。于是B会重传请求释放的报文，而此时如果A已经关闭了，那就收不到B的重传请求，就会导致B无法正常释放。而如果A还在等待时间内，就会收到B的重传，然后进行应答，这样B就可以进入CLOSED状态</li><li>如果三次挥手的话，服务端收到来自客户端的FIN请求后，需要同时回复ACK和发送FIN断开连接请求。但是在TCP连接中是有一个半关闭状态的，也就是服务端其实还是可以继续发送数据的，如果三次挥手，就无法做到服务器再发送数据了。</li></ol><h4 id="TCP传输为什么是可靠的"><a href="#TCP传输为什么是可靠的" class="headerlink" title="TCP传输为什么是可靠的"></a>TCP传输为什么是可靠的</h4><ul><li>确认与重传：如果一定时间内未收到ACK，则会重传</li><li>序列号与顺序性：TCP为每一个数据包分配一个序列号，接收端会进行数据包重组</li><li>流量控制</li><li>拥塞控制</li><li>连接管理：三次握手与四次挥手</li><li>超时与重试</li></ul><h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p>新建、就绪、运行、阻塞、等待、终止</p><h4 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h4><p>死锁发生的必要条件，通常被称为死锁的四个条件，分别是：</p><ol><li><strong>互斥条件（Mutual Exclusion）：</strong> 指某个资源在一段时间内只能被一个线程或进程占用，其他线程或进程需要等待资源释放才能继续执行。</li><li><strong>请求与保持条件（Hold and Wait）：</strong> 指线程在保持至少一个资源的同时，还请求其他资源，而这些资源可能被其他线程占用，导致请求阻塞。</li><li><strong>不剥夺条件（No Preemption）：</strong> 指资源只能由占有它的线程显式释放，其他线程不能强行抢占资源。</li><li><strong>循环等待条件（Circular Wait）：</strong> 指多个线程形成一个循环，每个线程都在等待下一个线程所持有的资源，导致一个闭环的等待状态。</li></ol><h4 id="死锁解决方案"><a href="#死锁解决方案" class="headerlink" title="死锁解决方案"></a>死锁解决方案</h4><ul><li>系统重新启动</li><li>撤销进程、剥夺资源</li><li>进程回退策略，即让参与死锁的进程回退到没有发生死锁前某一点处。</li></ul><h4 id="树的知识"><a href="#树的知识" class="headerlink" title="树的知识"></a>树的知识</h4><p><a href="https://oi-wiki.org/ds/bplus-tree/">https://oi-wiki.org/ds/bplus-tree/</a></p><h4 id="Linux-API调用返回值汇总"><a href="#Linux-API调用返回值汇总" class="headerlink" title="Linux API调用返回值汇总"></a>Linux API调用返回值汇总</h4><p>int pthread_create：成功时返回0，失败时返回错误码</p><p>void pthread_exit：不会失败</p><p>int pthread_join ( pthread_t thread, void** retval)：成功时返回0，失败时返回错误码。错误码：EDEADLK：可能引起死锁，比如两个线程互相针对对方调用pthread_join，或者线程对自身调用pthread_join；EINVAL：目标线程是不可回收的，或者已经有其他线程在回收该目标线程；ESRCH：目标线程不存在。</p><p>int sem_init( sem_t* sem, int pshared, unsigned int value )</p><p>int sem_destroy( sem_t* sem )</p><p>int sem_wait( sem_t* sem)</p><p>int sem_trywait( sem_t* sem )</p><p>int sem_post( sem_t* sem )：以上五个成功时返回0， 失败时返回-1并设置errno</p><h4 id="DNS的解析过程"><a href="#DNS的解析过程" class="headerlink" title="DNS的解析过程"></a>DNS的解析过程</h4><p>DNS是实现域名和IP地址相互映射的一个分布式数据库。DNS解析过程主要包括以下步骤</p><ol><li>本地缓存查询：当用户通过浏览器访问某域名时，浏览器会首先在自己的缓存里查询是否有该域名对应的IP地址。</li><li>本地系统查询：查看本计算机系统Host文件DNS缓存是否有对应DNS缓存</li><li>查看路由器缓存</li><li>查询ISP DNS缓存：也称本地域名服务器查询，计算机会向你的ISP（互联网服务提供商）分配的本地域名服务器发出查询请求</li><li>根域名服务器</li><li>顶级域名服务器：根域名服务器并不会直接返回用户IP地址，而是会指向查询请求对应的顶级域名服务器</li><li>权威域名服务器：顶级域名服务器会指向域名的权威域名服务器，这些服务器管理特定的域名的DNS服务。</li></ol><h4 id="TCP传输为什么是可靠的-1"><a href="#TCP传输为什么是可靠的-1" class="headerlink" title="TCP传输为什么是可靠的"></a>TCP传输为什么是可靠的</h4><p>总结下来主要包括三个方面：</p><ul><li>检验和</li><li>确认应答（ACK和序列号一应一答）</li><li>超时重传</li></ul><h4 id="NAT协议和跨域（不了解）"><a href="#NAT协议和跨域（不了解）" class="headerlink" title="NAT协议和跨域（不了解）"></a>NAT协议和跨域（不了解）</h4><h4 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h4><p>最明显的一个区别就是GET请求会把参数放在URL（统一资源定位符）中，POST会把参数放在请求体中。</p><p>数据大小限制：GET请求把参数放在URL中，GET请求数据大小收到URL长度限制。POST请求则不会</p><p>幂等性：GET请求每次相同请求返回的结果都一样，多次重复请求不会对资源产生影响。POST请求则相反</p><p>安全性：POST更安全，参数没有暴露在URL上</p><p>缓存：GET请求可以被浏览器缓存，POST请求不会被浏览器缓存</p><h4 id="写一段死锁的代码"><a href="#写一段死锁的代码" class="headerlink" title="写一段死锁的代码"></a>写一段死锁的代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_a;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">another</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in child thread, get mutex a\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_b);</span><br><span class="line">    b += a;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_b);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_a, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_b, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;id, <span class="literal">NULL</span>, another, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in parent thread, get mutex b\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    ++b;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_a);</span><br><span class="line">    a += b;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pro is end\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除字符串头尾空格代码"><a href="#删除字符串头尾空格代码" class="headerlink" title="删除字符串头尾空格代码"></a>删除字符串头尾空格代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::string tmp;</span><br><span class="line">    <span class="built_in">getline</span>(std::cin, s);   <span class="comment">//这里很重要哦，如果用cin，“hello world”会被截断成hello</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = s.<span class="built_in">substr</span>(i, s.<span class="built_in">size</span>() - i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = s.<span class="built_in">substr</span>(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shared-ptr是线程安全的吗？https-cloud-tencent-com-developer-article-1654442"><a href="#shared-ptr是线程安全的吗？https-cloud-tencent-com-developer-article-1654442" class="headerlink" title="shared_ptr是线程安全的吗？https://cloud.tencent.com/developer/article/1654442"></a>shared_ptr是线程安全的吗？<a href="https://cloud.tencent.com/developer/article/1654442">https://cloud.tencent.com/developer/article/1654442</a></h4><ul><li>多线程同时读一个shared_ptr对象是安全的</li><li>多线程同时对一个shared_ptr对象进行读和写是不安全的，需要加锁</li></ul><p>这里给出一个伪代码的简单例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Foo&gt; g(new Foo1);   // 线程之间共享的shared_ptr</span><br><span class="line">shared_ptr&lt;Foo&gt; x;     // 线程A的局部变量</span><br><span class="line">shared_ptr&lt;Foo&gt; n(new Foo2);   // 线程B的局部变量</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">线程A</span><br><span class="line">x = g;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">线程B</span><br><span class="line">g = n;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">测试场景：</span><br><span class="line"></span><br><span class="line">线程A </span><br><span class="line">  智能指针x 读取Foo1,然后还重置Foo1计数。</span><br><span class="line"></span><br><span class="line">线程 B:</span><br><span class="line"> 销毁了Foo1</span><br><span class="line">线程A</span><br><span class="line">重置计数时，foo1已经被销毁。</span><br></pre></td></tr></table></figure><h4 id="mysql读写锁怎么实现-mysql-读写锁和互斥锁的区别https-blog-51cto-com-u-16099299-7031260"><a href="#mysql读写锁怎么实现-mysql-读写锁和互斥锁的区别https-blog-51cto-com-u-16099299-7031260" class="headerlink" title="mysql读写锁怎么实现 mysql 读写锁和互斥锁的区别https://blog.51cto.com/u_16099299/7031260"></a>mysql读写锁怎么实现 mysql 读写锁和互斥锁的区别<a href="https://blog.51cto.com/u_16099299/7031260">https://blog.51cto.com/u_16099299/7031260</a></h4><ul><li>请你讲述一下互斥锁机制，以及互斥锁和读写锁的区别<ul><li>互斥锁（mutex），用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</li><li>读写锁（rwlock），分为读锁和写锁。处于读操作的时候，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其他获得写锁失败的线程将会进入睡眠状态，直到写锁释放时被唤醒。注意;写锁会阻塞其他读写锁。当有一个线程获得写锁在写时，读锁也不能被其他线程获取；写者优于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。<br>读写锁：区分读者和写者，而互斥锁不区分，互斥锁只允许同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。</li></ul></li><li>Linux中的四种锁机制<ul><li>互斥锁：在同一时间内只允许一个线程访问对象</li><li>读写锁：同一时间内允许多个读者同时读对象，同一时间内只允许一个写者访问对象，且当有一个线程获得写操作的时候，读锁也不能被其他的线程获取，写者优于读者，唤醒时先唤醒写者。</li><li>自旋锁：在任何时刻内自能有一个线程访问资源，但是当获取锁操作失败时，不会进入睡眠状态而是会原地自旋，直到锁被释放，这样减少了线程从睡眠状态到被唤醒状态的资源消耗，在加锁时间短暂的情况下使用会提高效率。但是加锁时间过长会非常浪费CPU</li><li>RCU（read-copy-update）：在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改，然后在将老数据update成新数据。在RCU的时候读者几乎不需要同步开销，即不需要获取锁，也不适用原子指令，不会导致竞争因此不用考虑死锁问题了。但是对于写者的同步开销比较大，他需要复制被修改的数据，还必须使用锁机制同步并行其他写者的改操作，在有大量读操作，少量写操作的时候使用。</li></ul></li></ul><h4 id="delete关键字的作用"><a href="#delete关键字的作用" class="headerlink" title="delete关键字的作用"></a>delete关键字的作用</h4><ol><li><p>删除特殊的成员函数：在C++11中可以使用delete来显示的阻止编译器自动生成某些特殊的成员函数。通过在类的声明中将这些特殊函数标记为delete，可以防止这些函数隐式的生成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() = <span class="keyword">delete</span>; <span class="comment">// 阻止生成默认构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp;) = <span class="keyword">delete</span>; <span class="comment">// 阻止生成拷贝构造函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>删除特定的函数重载：在函数重载时，可以使用delete关键字来标记某个特定的函数重载，防止特定的重载函数被调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">(<span class="type">double</span> x)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// 阻止调用带有 double 参数的函数</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="define和const的区别"><a href="#define和const的区别" class="headerlink" title="define和const的区别"></a>define和const的区别</h4><ul><li>就起作用的阶段而言：#define是在编译的预处理阶段起作用，而const是在编译、运行时起作用；</li><li>就起作用的方式而言：#define只是简单的字符串替换，没有类型检查，而const有类型检查，避免相应的错误；</li><li>就存储方式而言：#define只是进行展开，有多少地方使用，就有多少替换。const定义的只读变量在程序运行过程中只有一份备份；</li></ul><h4 id="写时拷贝（COW）https-www-cnblogs-com-biyeymyhjob-archive-2012-07-20-2601655-html"><a href="#写时拷贝（COW）https-www-cnblogs-com-biyeymyhjob-archive-2012-07-20-2601655-html" class="headerlink" title="写时拷贝（COW）https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html"></a>写时拷贝（COW）<a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html">https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html</a></h4><p>在linux里，fork（）会产生一个子进程，子进程与父进程用的是相同的物理空间，也就是说两者的虚拟空间不同，但对应的物理空间是一个。当父&#x2F;子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。这里的相应段你能理解不？其实就是一个程序一般分为哪些段，主要可以分为四大段：栈、堆、数据段、代码段；再细分的话可以加一个bss段，也就是用于存放程序中未初始化的全局变量的一块内存区域。</p><p>还有一个细节问题就是，fork之后内核会将子进程放在队列的前面，以让子进程先执行，以免父进程执行导致写时复制，造成不必要的复制，导致效率的下降。可以这么理解，可能子进程执行的代码并不需要写，完全可以使用原共享段，而父进程反而会改变（fork之后），如果父进程先执行，则子进程就要COW。</p><h4 id="coredump，gdb怎么定位"><a href="#coredump，gdb怎么定位" class="headerlink" title="coredump，gdb怎么定位"></a>coredump，gdb怎么定位</h4><p>整体流程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g source.cpp -o <span class="built_in">source</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./source</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./source ./core</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where(在gdb下输入)</span><br></pre></td></tr></table></figure><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><code>epoll</code></h4><p>关于<code>epoll</code>问题在这暂且不多写，只需记住内核事件表，<code>select</code>和<code>poll</code>都是轮询，事件复杂度：<code>epoll（o1）</code>，其他<code>（on）</code>。</p><p><code>select</code>和<code>poll</code>必须遍历内核事件表上所有已注册的文件描述符以找到其中的就绪者；<code>epoll</code>仅遍历就绪的文件描述符。</p><h4 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用"></a>static的作用</h4><ol><li><p>在函数体内，被声明为静态的变量在这一函数被调用过程中维持其值不变。</p><p>这句话其实是想说如果在函数内部声明了一个静态变量，那么这个变量在函数调用期间不会被重新初始化。它的生命周期是从程序开始到程序结束，但其作用域仍然限制在该函数内。这里给一段示例代码最好理解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    num++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num is: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">count</span>();<span class="comment">// num = 1</span></span><br><span class="line">    <span class="built_in">count</span>();<span class="comment">// num = 2 正常情况下，如果是非static，num会被重新置0，但这里并没有体现出来。</span></span><br><span class="line">    <span class="built_in">count</span>();<span class="comment">// num = 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其他函数访问。它是一个本地的全局变量。</p><p>这句话就是表面意思，很好理解，这里给一个代码帮助理解</p><p><strong>moduleA.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> secretValue = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSecretValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; secretValue &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifySecretValue</span><span class="params">(<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">    secretValue = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>moudleB.cpp</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">printSecretValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">modifySecretValue</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printSecretValue</span>();</span><br><span class="line">    <span class="built_in">modifySecretValue</span>(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; secretValue &lt;&lt; std::endl; </span></span><br><span class="line">    <span class="comment">// 记住，这句话是会导致编译错误的，模块B不能直接访问模块A的变量。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在模块内，一个被声明为静态的函数只可被本模块内的其他函数调用。也就是，这个函数被限制在声明它的模块的本地范围内使用。</p><p>这里的意思其实就和第二点差不多了，也给一个简单示例代码吧</p><p><strong>moduleA.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个静态函数，只在moduleA.cpp中可见</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">secretFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside secret function of moduleA!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公开的函数，可以被其他模块调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">publicFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside public function of moduleA.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">secretFunction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>moduleB.cpp</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">publicFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">publicFunction</span>();  <span class="comment">// 可以调用这个函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能调用 secretFunction，因为它在moduleA.cpp中是静态的</span></span><br><span class="line">    <span class="comment">// secretFunction();  // 这一行会导致编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，<code>moduleA.cpp</code>定义了一个静态函数<code>secretFunction</code>。在<code>moduleB.cpp</code>中，我们可以调用<code>publicFunction</code>，但当我们尝试调用<code>secretFunction</code>时，会导致编译错误，因为<code>secretFunction</code>只在<code>moduleA.cpp</code>中可见。</p></li></ol><h4 id="有关static的必要补充"><a href="#有关static的必要补充" class="headerlink" title="有关static的必要补充"></a>有关static的必要补充</h4><ul><li><p>修饰成员变量</p><p>用static修饰类的数据成员，使其成为类的全局变量，会被类的所有对象共享，包括派生类对象。<strong>所有对象只维持同一个实例。</strong>因此类的static成员必须进行类外初始化，而不能在构造函数内进行初始化，不过也可以用const修饰static数据成员在类内初始化。因为const修饰的变量无法修改。</p></li><li><p>修饰成员函数</p><p>用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针，因而只能访问static成员变量。<strong>注意</strong>：正是因为static修饰的成员函数不含this指针，而const修饰的成员函数会添加一个隐藏的参数const this*，所以这两种语义是矛盾的，所以在成员函数上不能同时用他们。</p></li><li><p>this指针理解</p><p>对象就是大房子，成员就是房子里的物件，this是一个指着房子的指针，如果要获取对象的成员也就是大房子内的物件，需要使用this指针加-&gt;这个符号。</p></li></ul><h4 id="三种智能指针"><a href="#三种智能指针" class="headerlink" title="三种智能指针"></a>三种智能指针</h4><p>智能指针是在栈中的一个类，用于管理堆上分配的内存。传统的C&#x2F;C++对于堆上内存的开辟释放，需要程序手动管理，而智能指针是一个类，有构造函数和析构函数，在超出作用范围后，程序会自动调用析构函数释放其管理的指针指向的内存，不需要手动释放。</p><ul><li>shared_ptr共享智能指针，多个智能指针可以指向同一个对象，对象的资源在最后一个指针销毁时释放，通过引用计数来判断是否是最后一个智能指针。</li><li>unique_ptr独占智能指针，同一时刻只有一个智能指针可以指向该对象，如果要安全重用该指针，标准库函数std::move()可以将unique_ptr赋值给另一个unique_ptr。</li><li>weak_ptr      弱智能指针，不会增加shared_ptr的引用计数，可以避免两个shared_ptr相互引用的死锁问题。weak_ptr只能用shared_ptr或者另一个weak_ptr构造，通过lock()方法weak_ptr可以转化为shared_ptr。</li></ul><p>下面给出代码示例</p><p><strong>unique_ptr</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string str;</span><br><span class="line">    ~<span class="built_in">test</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;test::~test()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> test())</span></span>;</span><br><span class="line">    p1-&gt;str = <span class="string">&quot;test string&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1-&gt;str: &quot;</span> &lt;&lt; p1-&gt;str &lt;&lt; std::endl;</span><br><span class="line">    std::unique_ptr&lt;test&gt; p2;</span><br><span class="line">    p2 = std::<span class="built_in">move</span>(p1);</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; p1-&gt;str &lt;&lt; std::endl; p1此时已经访问不到资源了</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p2-&gt;str: &quot;</span> &lt;&lt; p2-&gt;str &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// p1-&gt;str: test string</span></span><br><span class="line"><span class="comment">// p2-&gt;str: test string</span></span><br><span class="line"><span class="comment">// test::~test() 析构函数发生了调用，自动释放资源</span></span><br></pre></td></tr></table></figure><p><strong>shared_ptr</strong>造成的死锁问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; a;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;A&gt; b;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::~B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*******前边两个类中相互引用，此时引入weak_ptr解决死锁问题*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    p1-&gt;a = p2;</span><br><span class="line">    p2-&gt;b = p1;<span class="comment">//这种情况发生死锁,两个shared_ptr计数都不会为0，资源不会被释放</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count():&quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count():&quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体解释一下死锁的产生主要原因是引用计数无法降为0。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">首先，来理解下为什么这种情况会导致资源不能被释放：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 当你创建`p1`和`p2`时，它们都有一个引用计数为1。</span></span><br><span class="line"><span class="comment">2. 当执行`p1-&gt;a = p2;`，`p2`的引用计数增加到2，因为现在有两个`shared_ptr`对象（`p1-&gt;a`和`p2`）指向同一个`B`对象。</span></span><br><span class="line"><span class="comment">3. 当执行`p2-&gt;b = p1;`，`p1`的引用计数增加到2，因为现在有两个`shared_ptr`对象（`p2-&gt;b`和`p1`）指向同一个`A`对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">到此，我们得到了一个环状结构：`p1`指向`A`对象，`A`对象内部的`shared_ptr`指向`B`对象，`B`对象内部的`shared_ptr`又指向`A`对象。这就形成了循环引用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当`main`函数返回时，`p1`和`p2`的析构函数将被调用，但是它们的引用计数都不会降为0，因为循环引用。所以，`A`和`B`对象的析构函数永远不会被调用，这就导致了资源泄漏。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">要解决这个问题，可以使用`weak_ptr`来打破循环引用。你可以将其中一个类的`shared_ptr`成员变量替换为`weak_ptr`。这样，`weak_ptr`不会增加引用计数，从而避免了循环引用的问题。当你需要从`weak_ptr`获取一个`shared_ptr`时，可以使用`lock`方法。</span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></figure><p><strong>weak_prt</strong>解决循环引用问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; a;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    weak_ptr&lt;A&gt; b;  <span class="comment">// 将 shared_ptr 替换为 weak_ptr</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::~B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line">    p1-&gt;a = p2;</span><br><span class="line">    p2-&gt;b = p1;  <span class="comment">// 这里不会增加 p1 的引用计数</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 use_count(): &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 输出 1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2 use_count(): &quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 当 main 返回时，p1 和 p2 都会被析构，它们所指向的对象也会被正确地销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="STL内存池机制"><a href="#STL内存池机制" class="headerlink" title="STL内存池机制"></a>STL内存池机制</h4><ul><li><p>第一级配置器</p><p>第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。</p></li><li><p>第二级配置器</p><p>在STL的第二级配置器中多了一些机制，避免太多小区造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。</p><p>如果要分配的区块大于128bytes，则移交给第一级配置器处理。<br>如果要分配的区块小于128bytes，则以 内存池管理（memory pool），又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。</p><p>参考连接：<a href="https://blog.csdn.net/a987073381/article/details/52245795">https://blog.csdn.net/a987073381/article/details/52245795</a></p></li></ul><h4 id="索引选B-树的原因"><a href="#索引选B-树的原因" class="headerlink" title="索引选B+树的原因"></a>索引选B+树的原因</h4><p>个人感觉主要就是探讨B+树和B树之间的区别。<br>参考链接：<a href="https://www.cnblogs.com/JCpeng/p/15231338.html">https://www.cnblogs.com/JCpeng/p/15231338.html</a></p><h4 id="服务端TIME-WAIT过多的危害及解决办法"><a href="#服务端TIME-WAIT过多的危害及解决办法" class="headerlink" title="服务端TIME_WAIT过多的危害及解决办法"></a>服务端TIME_WAIT过多的危害及解决办法</h4><p>危害</p><ul><li>导致大量socket连接端口被占用无法释放，导致系统停转</li><li>处理大量的TIME_WAIT状态的连接会占用更多的CPU时间，导致服务器响应时间增加</li></ul><p>解决办法</p><ul><li>调整系统内核参数</li><li>调整短连接为长连接</li></ul><h4 id="set底层数据结构"><a href="#set底层数据结构" class="headerlink" title="set底层数据结构"></a>set底层数据结构</h4><p>set底层数据结构是红黑树。关于map和set的一些问题列举如下：</p><p><strong>为何map和set的插入删除效率比用其他序列容器高？</strong><br>因为对于关联容器来说，不需要做内存拷贝和内存移动。因为map和set容器内部所有元素都是以节点的方式来存储，父节点和子节点。因此插入和删除的时候都是指针的指向换来换去，并没有内存移动。</p><p><strong>为何每次插入&#x2F;删除后以前保存的迭代器不会失效</strong><br>在这里，迭代器就相当于指向节点的指针，内存没有变，指向内存的指针当然不会失效。不同于map&#x2F;set，vector就会失效，比如需要扩容的时候，需要一块更大的内存，就必须把之前的内存释放，申请更大的内存，复制已有的数据元素到新的内存。</p><p><strong>为何map和set不能像vector一样有个reserve函数来预分配数据</strong><br>不懂！预留本问题</p><p><strong>当数据元素增多时（10000到20000个比较），map和set的插入和搜索速度变化如何？</strong><br>map和set使用的是二分查找，举例来说就是，16个元素查四次，32个元素查5次，10000个也就是14次，20000也就15次。</p><h4 id="mapreduce原理（不懂，预留）"><a href="#mapreduce原理（不懂，预留）" class="headerlink" title="mapreduce原理（不懂，预留）"></a>mapreduce原理（不懂，预留）</h4><h4 id="socket哪些操作会产生阻塞"><a href="#socket哪些操作会产生阻塞" class="headerlink" title="socket哪些操作会产生阻塞"></a>socket哪些操作会产生阻塞</h4><p>accept()：在等待客户端的连接请求时会阻塞。如果没有客户端尝试连接，调用这个函数的进程或者线程会被挂起。</p><p>connect()：当客户端尝试与远程主机建立连接时，此操作会阻塞，知道连接成功或失败</p><p>recv()：当数据从网络到达时，如果没有数据可读，函数调用就会被挂起，阻塞</p><p>send()：当发送缓冲区已满，并且无法接受更多数据发送到网络时，操作阻塞。</p><h4 id="申请一块大内存和一块小内存的效率是一样的吗？"><a href="#申请一块大内存和一块小内存的效率是一样的吗？" class="headerlink" title="申请一块大内存和一块小内存的效率是一样的吗？"></a>申请一块大内存和一块小内存的效率是一样的吗？</h4><p>不一样，申请一块小内存通常是不需要一级配置器，小块内存通常由内存分配器从预先分配的内存池中分配，这些池被称为<code>bins</code>，这种分配通常非常快，因为它只是涉及到从已存在的内存池中返回一个指针。大的内存通常要调用<code>mmap()</code>。</p><h4 id="TCP慢启动和拥塞控制"><a href="#TCP慢启动和拥塞控制" class="headerlink" title="TCP慢启动和拥塞控制"></a>TCP慢启动和拥塞控制</h4><p>TCP连接建立好之后，CWND（congestion window，拥塞窗口）被设置为初始值IW（initial window），其大小为2~4个SMSS（TCP报文段的最大长度，仅指数据部分），新的linux内核加大了这个值。此时发送端最多能发送IW字节的数据，此后发送端每收到一个确认，CWND就按照如下公式增长：<br>$$<br>CWND +&#x3D; min(N, SMSS)<br>$$<br>其中N是此次确认中包含的之前未被确认的字节数。<br>如果不施加其他手段，慢启动必然使得CWND增长的很快，所以TCP拥塞控制中有另外一个非常重要的变量：慢启动门限。当CWND超过慢启动门限值时，TCP将进入拥塞避免阶段。</p><h4 id="发送端判断发生拥塞的依据"><a href="#发送端判断发生拥塞的依据" class="headerlink" title="发送端判断发生拥塞的依据"></a>发送端判断发生拥塞的依据</h4><ul><li>传输超时</li><li>接收到重复的确认报文段</li></ul><h4 id="Linux下的POSIX互斥锁和条件变量"><a href="#Linux下的POSIX互斥锁和条件变量" class="headerlink" title="Linux下的POSIX互斥锁和条件变量"></a>Linux下的POSIX互斥锁和条件变量</h4><p>牢记这几个函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">pthread_mutex_destory(&amp;mutex);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">pthread_mutex_trylock(&amp;mutex);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_init(&amp;cond, NULL);</span><br><span class="line">pthread_cond_destory(&amp;cond);</span><br><span class="line">pthread_cond_broadcast(&amp;cond);</span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);</span><br></pre></td></tr></table></figure><p>条件变量要配合互斥锁使用。这里挂一个讲的比较清晰明了的博客链接（<a href="https://punmy.cn/2018/06/07/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condition%20Variables%EF%BC%89.html%EF%BC%89%EF%BC%8C%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E5%8A%A0%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B">https://punmy.cn/2018/06/07/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condition%20Variables%EF%BC%89.html），下面是使用互斥锁加条件变量实现的生产者-消费者模型</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mutex_;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span> condition_;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_t</span> notifying_thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;condition_, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;condition_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span> *args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">    <span class="keyword">while</span>(value != <span class="number">10</span>)&#123;</span><br><span class="line">        value++;</span><br><span class="line">    &#125;</span><br><span class="line">    notifying_thread = <span class="built_in">pthread_self</span>();</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;condition_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">    <span class="keyword">while</span>(value != <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;condition_, &amp;mutex_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value is 10, the pthread is: %lu\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)notifying_thread);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">consumer</span><span class="params">(<span class="type">void</span> *args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">waitCondition</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> a1;</span><br><span class="line">    <span class="type">pthread_t</span> a2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;a1, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;a2, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(a1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(a2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">destory</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写一个生产者-x2F-消费者模型（采用信号量）"><a href="#写一个生产者-x2F-消费者模型（采用信号量）" class="headerlink" title="写一个生产者&#x2F;消费者模型（采用信号量）"></a>写一个生产者&#x2F;消费者模型（采用信号量）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_BUFFERS = <span class="number">10</span>;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> empty;</span><br><span class="line"><span class="type">sem_t</span> full;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        num = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;empty);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">        buffer.<span class="built_in">push</span>(num);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">comsumer</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;full);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">        num = buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Comsumed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> proThread, comPthread;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;empty, <span class="number">0</span>, MAX_BUFFERS);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;full, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;proThread, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;comPthread, <span class="literal">NULL</span>, comsumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(proThread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(comPthread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;empty);</span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;full);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="基类的析构函数为什么是虚函数"><a href="#基类的析构函数为什么是虚函数" class="headerlink" title="基类的析构函数为什么是虚函数"></a>基类的析构函数为什么是虚函数</h4><p>当基类的析构函数不是虚函数可能会导致派生类对象的析构函数不被调用。从而引发资源泄露或者其他未定义行为。下面给出示例代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base obj is constructed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="comment">// ~Base() &#123; std::cout &lt;&lt; &quot;Base obj is deconstructed&quot; &lt;&lt; std::endl; &#125;</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base obj is deconstructed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()&#123;</span><br><span class="line">        num_ = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived is constructed&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Derived</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived is deconstructed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *num_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base *base = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）"><a href="#为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）" class="headerlink" title="为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）"></a>为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）</h4><p>当一个基类没有虚析构函数，并且通过基类指针删除一个派生类对象时，只有基类的析构函数会被调用。这是因为编译器在编译时期决定了调用哪个析构函数，而不是在运行时期，这种机制被称为“静态绑定”。</p><p>如果基类的析构函数是虚函数，那么编译器会在运行时决定要调用哪个析构函数，这种机制称为“动态绑定”或“多态”。</p><h4 id="拷贝构造函数为什么要用引用"><a href="#拷贝构造函数为什么要用引用" class="headerlink" title="拷贝构造函数为什么要用引用"></a>拷贝构造函数为什么要用引用</h4><p>避免拷贝构造函数无限递归下去！那传引用为什么行呢？回忆一下引用定义，传引用人家根本就不会涉及到构造函数这玩意，形参相当于实参的一个别名。</p><h4 id="左右值的差别"><a href="#左右值的差别" class="headerlink" title="左右值的差别"></a>左右值的差别</h4><h4 id="C-中的虚继承"><a href="#C-中的虚继承" class="headerlink" title="C++中的虚继承"></a>C++中的虚继承</h4><p>c++中的虚继承主要是为了解决多继承情况中存在的二义性问题。比如，现在类A为基类，类B和类C继承自类A，类D继承自类B和类C，假设此时A中有一个名为x的变量且B和C都定义了x，如果此时D直接访问x会产生二义性问题。因为不清楚是A-&gt;B-&gt;D还是A-&gt;C-&gt;D。此时如果让类B和类C虚继承自A，就使得在派生类中只保留有一份成员变量x，解决了二义性问题。<br>参考链接：<br><a href="http://c.biancheng.net/view/2280.html">http://c.biancheng.net/view/2280.html</a><br><a href="https://zhuanlan.zhihu.com/p/41309205%EF%BC%88%E8%99%9A%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E9%83%BD%E8%AE%B2%E4%BA%86%EF%BC%8C%E5%8D%81%E5%88%86%E8%AF%A6%E7%BB%86%EF%BC%89">https://zhuanlan.zhihu.com/p/41309205（虚继承、虚函数都讲了，十分详细）</a></p><h4 id="C-中的forward函数"><a href="#C-中的forward函数" class="headerlink" title="C++中的forward函数"></a>C++中的forward函数</h4><p>左值引用和右值引用的结果都是左值，无法通过引用区分原本变量的左右值，forward可以保持变量的原本的左右值属性，帮助我们区分。</p><h4 id="如何判断TCP断开"><a href="#如何判断TCP断开" class="headerlink" title="如何判断TCP断开"></a>如何判断TCP断开</h4><ol><li>发送心跳消息</li><li>利用recv&#x2F;send函数的返回值<ul><li>recv返回0代表对方关闭了连接</li><li>recv返回-1并且errno&#x3D;&#x3D;EAGAIN或者EWOULDBLOCK时，表示没有数据可读，可以稍后再试。</li><li><strong>send返回非负值</strong>:<ul><li><code>send</code>返回的是实际发送的字节数，这可能会少于你请求发送的字节数（缓冲区已满）。</li><li>如果没有可用的缓冲区空间，那么在非阻塞模式下，<code>send</code>可能会返回<code>EAGAIN</code>或<code>EWOULDBLOCK</code>。</li></ul></li><li><strong>send返回-1</strong>:<ul><li>与<code>recv</code>类似，这表示出现了错误。</li><li>可以使用<code>perror</code>、<code>strerror</code>或检查<code>errno</code>来确定具体的错误原因。</li><li>常见的错误原因包括<code>EPIPE</code>（对端已关闭，本端仍尝试发送数据导致的”Broken pipe”错误）和<code>ECONNRESET</code>（连接被对端重置）。</li></ul></li></ul></li><li>利用tcp自带的keepalive机制</li></ol><h4 id="如何查看系统的最大进程数和线程数"><a href="#如何查看系统的最大进程数和线程数" class="headerlink" title="如何查看系统的最大进程数和线程数"></a>如何查看系统的最大进程数和线程数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/pid_max    # 最大进程数</span><br><span class="line">cat /proc/sys/kernel/threads-max# 最大线程数</span><br></pre></td></tr></table></figure><h4 id="git-rebase和git-merge的区别（https-joyohub-com-2020-04-06-git-rebase-）"><a href="#git-rebase和git-merge的区别（https-joyohub-com-2020-04-06-git-rebase-）" class="headerlink" title="git rebase和git merge的区别（https://joyohub.com/2020/04/06/git-rebase/）"></a>git rebase和git merge的区别（<a href="https://joyohub.com/2020/04/06/git-rebase/%EF%BC%89">https://joyohub.com/2020/04/06/git-rebase/）</a></h4><h4 id="C-calss-和-struct的区别"><a href="#C-calss-和-struct的区别" class="headerlink" title="C++ calss 和 struct的区别"></a>C++ calss 和 struct的区别</h4><p>class默认访问类型是private，struct默认访问类型是public</p><h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><ol><li>指针是一个变量，它保存了另一个变量的内存地址；引用是另一个变量的别名，与原变量共享内存地址。</li><li>指针可以被重新赋值，指向新的对象；引用绑定对象后不能更改。</li><li>指针可以为nullptr；引用必须初始化。</li></ol><h4 id="为什么模板类的声明和实现不能分别写在-h文件和-cpp文件中"><a href="#为什么模板类的声明和实现不能分别写在-h文件和-cpp文件中" class="headerlink" title="为什么模板类的声明和实现不能分别写在.h文件和.cpp文件中"></a>为什么模板类的声明和实现不能分别写在.h文件和.cpp文件中</h4><p>首先，模板不是传统意义上的代码。它更像是编译器的“代码生成工具”。当你使用一个特定的模板类型（例如<code>std::vector&lt;int&gt;</code>)，<strong>编译器会为你生成这种类型的实例代码</strong>。为了做到这一点，编译器需要能够看到模板的完整定义。注意：这就是模板和普通类的最大区别。普通类在编译阶段并没有（并不依赖于）编译时的类型特化，只需要在链接阶段将所有.cpp文件链接在一起就好了。而如果模板分开写，其他使用模板的.cpp文件在编译时找不到定义，导致链接错误。</p><h4 id="动态链接与静态链接"><a href="#动态链接与静态链接" class="headerlink" title="动态链接与静态链接"></a>动态链接与静态链接</h4><p>静态链接（.a&#x2F;.lib）：把要调用的函数或者过程链接到可执行文件中，成为可执行文件的一部分。如果多个程序使用相同的库，那么该库的代码在每个程序中都会被复制，这浪费了磁盘和内存空间。但是所有代码都在可执行文件中，没有运行时链接开销。</p><p>动态链接（.so&#x2F;.ddl）：动态链接所调用的函数代码并没有被拷贝到应用程序的可执行文件中去，而是仅仅在其中加入了所调用函数的描述信息（往往是一些重定位信息）。仅当应用程序被装入内存开始运行时，在Windows的管理下，才在应用程序与相应的DLL之间建立链接关系。当要执行所调用DLL中的函数时，根据链接产生的重定位信息，Windows才转去执行DLL中相应的函数代码。多份代码可以共享同一份库代码。</p><h4 id="pragma-pack编译宏"><a href="#pragma-pack编译宏" class="headerlink" title="pragma pack编译宏"></a>pragma pack编译宏</h4><p>pragma pack用于指定内存对齐值。</p><h4 id="vector底层实现原理"><a href="#vector底层实现原理" class="headerlink" title="vector底层实现原理"></a>vector底层实现原理</h4><p>理解vector的实现主要考虑四个东西就好了：三个指针加动态内存申请。</p><p>三个指针：</p><ul><li>first_：指向vector容器对象起始地址的位置</li><li>last_：指向vector容器对象中当前最后一个元素的末尾字节</li><li>end_：指向vector容器所占内存空间的最后一个字节</li></ul><p><img src="png1.gif"></p><p>动态内存申请：</p><p>当 vector 的大小和容量相等（size&#x3D;&#x3D;capacity）也就是满载时，如果再向其添加元素，那么 vector 就需要扩容。vector 容器扩容的过程需要经历以下 3 步：</p><ol><li>完全弃用现有的内存空间，重新申请更大的内存空间；</li><li>将旧内存空间中的数据，按原有顺序移动到新的内存空间中；</li><li>最后将旧的内存空间释放。</li></ol><h4 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h4><p>常量指针：记忆方法（常量的指针），指针指向的对象是一个常量，只能读取指针指向的内容，不能修改指针指向的内容。</p><p>指针常量：指针本身是一个常量，不能修改指针指向的地址，可以修改指针指向地址的内容。</p><h4 id="C-中一些特别的关键字（default，override、final、volatile）"><a href="#C-中一些特别的关键字（default，override、final、volatile）" class="headerlink" title="C++中一些特别的关键字（default，override、final、volatile）"></a>C++中一些特别的关键字（default，override、final、volatile）</h4><p>参考链接：<a href="https://blog.csdn.net/u011947630/article/details/103062773">https://blog.csdn.net/u011947630/article/details/103062773</a></p><h4 id="字节算法题：小于N的最大数"><a href="#字节算法题：小于N的最大数" class="headerlink" title="字节算法题：小于N的最大数"></a>字节算法题：小于N的最大数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> value = <span class="number">14132</span>;</span><br><span class="line">string valueStr = <span class="built_in">to_string</span>(value);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index, <span class="type">bool</span> judge, <span class="type">int</span> temp)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(index == valueStr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ans = temp;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(judge) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">true</span>, temp * <span class="number">10</span> + (nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>]));    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> val = valueStr[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val == nums[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">false</span>, temp * <span class="number">10</span> + nums[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; nums[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">true</span>, temp * <span class="number">10</span> + nums[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最终结果为空</span></span><br><span class="line">        <span class="keyword">if</span>(index != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//少了一位，显然小了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">true</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如果同时有大量客户并发建立连接，服务器端有什么机制进行处理"><a href="#如果同时有大量客户并发建立连接，服务器端有什么机制进行处理" class="headerlink" title="如果同时有大量客户并发建立连接，服务器端有什么机制进行处理"></a>如果同时有大量客户并发建立连接，服务器端有什么机制进行处理</h4><ol><li>多进程和多线程</li><li>连接池</li><li>异步I&#x2F;O</li><li>负载均衡</li><li>限流</li><li>短连接与长连接</li></ol><h4 id="HTTP和TCP之间的关系"><a href="#HTTP和TCP之间的关系" class="headerlink" title="HTTP和TCP之间的关系"></a>HTTP和TCP之间的关系</h4><ol><li><p>HTTP是一个应用层协议，TCP是一个传输层协议</p></li><li><p>HTTP依赖于TCP来进行数据的传输。比如，当你使用浏览器访问一个网页时，背后发生的是HTTP请求和响应的交换，而这些HTTP数据包是通过TCP连接发送的。</p></li><li><p>HTTP&#x2F;1.0对于每一个请求-响应都会新建一个TCP连接，使用完之后就关闭</p><p>HTPP&#x2F;1.1引入了keep-alive机制，允许在单个TCP连接上发送多个HTTP请求和响应</p><p>HTTP&#x2F;2进一步扩展了这种机制，允许在单个TCP连接上同时多路复用多个HTTP请求和响应</p></li></ol><h4 id="HTTP从请求到得到结果的过程"><a href="#HTTP从请求到得到结果的过程" class="headerlink" title="HTTP从请求到得到结果的过程"></a>HTTP从请求到得到结果的过程</h4><ol><li><p><strong>域名解析</strong>：</p><ul><li>客户端（通常是浏览器）首先检查URL是否包含域名（例如 <code>www.example.com</code>）。</li><li>如果包含，客户端首先会查找其DNS缓存是否已经有该域名的IP地址。</li><li>如果没有，客户端会发起一个DNS查询到配置的DNS服务器，以获取对应的IP地址。</li></ul></li><li><p><strong>建立TCP连接</strong>：</p><ul><li>使用从DNS查询得到的IP地址，客户端尝试与服务器的80端口（HTTP）或443端口（HTTPS）建立一个TCP连接。</li><li>这涉及到TCP三次握手过程。</li></ul></li><li><p><strong>（HTTPS的情况）SSL&#x2F;TLS握手</strong>：</p><ul><li>如果是HTTPS请求，一旦TCP连接建立，客户端和服务器会进行SSL&#x2F;TLS握手来建立加密的通信通道。</li></ul></li><li><p><strong>发送HTTP请求</strong>：</p><ul><li>连接建立后，客户端会发送HTTP请求报文。这包括请求行（例如 <code>GET /path HTTP/1.1</code>）、请求头和（对于某些请求如POST）请求体。</li></ul></li><li><p><strong>服务器处理请求</strong>：</p><ul><li>服务器接收到请求后，由其HTTP服务软件（如Apache、Nginx等）处理。</li><li>服务器可能会根据请求路径查询文件、与数据库交互或调用其他服务，以生成响应。</li></ul></li><li><p><strong>服务器发送响应</strong>：</p><ul><li>服务器生成响应后，它将响应报文发送回客户端。响应通常包括状态行（例如 <code>HTTP/1.1 200 OK</code>）、响应头和响应体。</li><li>对于动态内容，如由PHP、Python或Node.js等后端语言生成的页面，服务器可能会进行一些额外的处理来生成响应内容。</li></ul></li><li><p><strong>客户端处理响应</strong>：</p><ul><li>客户端（如浏览器）接收响应，并基于响应内容采取相应的行动。</li><li>如果响应是一个HTML页面，浏览器会开始解析HTML，并可能发起其他请求来获取页面上的资源，如图片、CSS、JavaScript文件等。</li></ul></li><li><p><strong>关闭连接</strong>：</p><ul><li>一旦数据交换完成，通常会关闭TCP连接。然而，在HTTP&#x2F;1.1中，默认使用<code>keep-alive</code>，意味着连接可以被复用，从而减少后续请求的延迟。</li></ul></li></ol><h4 id="https和http的区别是什么，https具体是怎么做的"><a href="#https和http的区别是什么，https具体是怎么做的" class="headerlink" title="https和http的区别是什么，https具体是怎么做的"></a>https和http的区别是什么，https具体是怎么做的</h4><p>HTTPS和HTTP唯一的区别就是HTTPS使用TLS&#x2F;SSL来加密普通的HTTP请求和响应。</p><p>关于https具体是如何做的，这里有一个参考博文链接，写的超好（参考链接：<a href="https://www.runoob.com/w3cnote/http-vs-https.html%EF%BC%89">https://www.runoob.com/w3cnote/http-vs-https.html）</a></p><h4 id="gdb中，如何查看每个线程相关的信息"><a href="#gdb中，如何查看每个线程相关的信息" class="headerlink" title="gdb中，如何查看每个线程相关的信息"></a>gdb中，如何查看每个线程相关的信息</h4><p>在 gdb 中，可以使用 <code>info threads</code> 命令查看当前进程中的所有线程信息。这个命令会列出每个线程的编号、状态（如运行、挂起等）以及当前所在的函数名称。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info threads</span><br><span class="line">  Id   Target Id         Frame </span><br><span class="line">  2    Thread 0x7ffff7fc8700 (LWP 13627) <span class="string">&quot;main&quot;</span> __libc_start_main (argc=1, argv=0x7fffffffe4c8, <span class="built_in">env</span>=0x7fffffffe4d8,</span><br><span class="line">      auxvec=0x7fffffffe4d8, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffe4c8) at ../csu/libc-start.c:310</span><br><span class="line">  3    Thread 0x7ffff77c7700 (LWP 13628) <span class="string">&quot;main&quot;</span> foo () at test.c:6</span><br><span class="line">  4    Thread 0x7ffff6fc6700 (LWP 13629) <span class="string">&quot;main&quot;</span> bar () at test.c:11</span><br></pre></td></tr></table></figure><p>你还可以使用 <code>thread &lt;thread-id&gt;</code> 命令来切换到指定的线程，然后使用其他 gdb 命令来查看线程的信息或调试线程。</p><p>例如，你可以输入 <code>thread 3</code> 命令切换到编号为 3 的线程，然后输入 <code>bt</code> 命令来查看线程的调用堆栈：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) thread 3</span><br><span class="line">[Switching to thread 3 (Thread 0x7ffff77c7700 (LWP 13628))]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  foo () at test.c:6</span></span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  foo () at test.c:6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00007ffff7bbb830 <span class="keyword">in</span> start_thread (arg=&lt;optimized out&gt;) at pthread_create.c:486</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007ffff78f95fd <span class="keyword">in</span> <span class="built_in">clone</span> () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span></span><br></pre></td></tr></table></figure><h4 id="构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因"><a href="#构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因" class="headerlink" title="构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因"></a>构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因</h4><p>构造函数从语法上调用虚函数没有任何问题，但这样做可能并不会达到预期的结果。因为在构造函数执行期间，对象的虚表仍在被设置，因此调用的虚函数版本可能并不是我们想要的版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base construct\n&quot;</span>;</span><br><span class="line">        <span class="built_in">call</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base call\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived construct\n&quot;</span>;</span><br><span class="line">        <span class="built_in">call</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived call\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面这段程序，可能我们期望得到的结果是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Derived call</span><br><span class="line">Derived constructor</span><br><span class="line">Derived call</span><br></pre></td></tr></table></figure><p>但我们实际得到的结果是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Base call</span><br><span class="line">Derived constructor</span><br><span class="line">Derived call</span><br></pre></td></tr></table></figure><p>原因是在Base构造函数执行时，Derived部分的对象还没有完全构造出来，因此，此时vtable仍然指向Base类的vtable。因此，当在Base构造函数中调用call虚函数时，他会调用Base版本，而不是Derived版本。</p><p><strong>这里延伸一下不要在析构函数中调用虚函数的原因</strong>：析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经“销毁”，这个时再调用子类的虚函数已经没有意义了。</p><h4 id="迭代器的实现"><a href="#迭代器的实现" class="headerlink" title="迭代器的实现"></a>迭代器的实现</h4><p>参考链接：<a href="https://www.cnblogs.com/wengle520/p/12492708.html">https://www.cnblogs.com/wengle520/p/12492708.html</a></p><h4 id="epoll红黑树的作用"><a href="#epoll红黑树的作用" class="headerlink" title="epoll红黑树的作用"></a>epoll红黑树的作用</h4><p>简单点讲就是在内核事件表上快速注册&#x2F;删除所需连接文件描述符。下面两篇文章基本阐述了这个问题，好好看！</p><p><a href="https://cloud.tencent.com/developer/article/1862671">https://cloud.tencent.com/developer/article/1862671</a></p><p><a href="https://zhuanlan.zhihu.com/p/366955699">https://zhuanlan.zhihu.com/p/366955699</a></p><h4 id="用户态和内核态分别会做什么，怎么切换的"><a href="#用户态和内核态分别会做什么，怎么切换的" class="headerlink" title="用户态和内核态分别会做什么，怎么切换的"></a>用户态和内核态分别会做什么，怎么切换的</h4><p>内核空间主要负责操作系统内核线程以及用户程序系统调用。</p><p>用户空间主要负责用户程序的非系统调用。</p><p>从用户态切换到内核态主要有三种方式：</p><ol><li>系统调用：系统调用本身就是中断，但是<strong>软件中断</strong>，跟硬中断不同。系统调用机制是使用了操作系统为用户特别开放的一个中断来实现，如 Linux 的 int 80h 中断。</li><li>异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，会触发由当前运行进程切换到处理此异常的内核相关进程中</li><li>外围设备中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序。</li></ol><p>有一个面试问题：I&#x2F;O频繁发生内核态和用户态切换，怎么解决？</p><p>答案：使用用户进程缓冲区。</p><p>用户进程缓冲区</p><p>你看一些程序在读取文件时，会先申请一块内存数组，称为buffer，然后每次调用read，读取设定字节长度的数据，写入buffer。之后的程序都是从buffer中获取数据，当buffer使用完后，在进行下一次调用，填充buffer。所以说：用户缓冲区的目的就是是为了减少系统调用次数，从而降低操作系统在用户态与核心态切换所耗费的时间。除了在进程中设计缓冲区，内核也有自己的缓冲区。</p><p>内核缓存区</p><p>当一个用户进程要从磁盘读取数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程缓冲区中。但若是内核缓冲区中没有数据，内核会把对数据块的请求，加入到请求队列，然后把进程挂起，为其它进程提供服务。等到数据已经读取到内核缓冲区时，把内核缓冲区中的数据读取到用户进程中，才会通知进程，当然不同的IO模型，在调度和使用内核缓冲区的方式上有所不同。</p><p>参考链接：</p><p><a href="https://blog.csdn.net/qq_42052956/article/details/111562280">https://blog.csdn.net/qq_42052956/article/details/111562280</a></p><p><a href="https://cloud.tencent.com/developer/article/2131401">https://cloud.tencent.com/developer/article/2131401</a></p><h4 id="进程的创建需要系统分配什么资源"><a href="#进程的创建需要系统分配什么资源" class="headerlink" title="进程的创建需要系统分配什么资源"></a>进程的创建需要系统分配什么资源</h4><p>根据其他博客里写的底层源码来看，分配给一个进程的东西太多啦，我们挑几个记一下：内存、CPU处理时间、输入输出设备、存储空间。</p><p>参考链接：</p><p><a href="https://blog.csdn.net/lvyibin890/article/details/82193900">https://blog.csdn.net/lvyibin890/article/details/82193900</a></p><p><a href="https://juejin.cn/s/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%99%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E4%BB%80%E4%B9%88%E8%B5%84%E6%BA%90">https://juejin.cn/s/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%99%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E4%BB%80%E4%B9%88%E8%B5%84%E6%BA%90</a></p><h4 id="HTTPS加密方式：对称加密、非对称加密"><a href="#HTTPS加密方式：对称加密、非对称加密" class="headerlink" title="HTTPS加密方式：对称加密、非对称加密"></a>HTTPS加密方式：对称加密、非对称加密</h4><p>对称加密：密钥只有一个，加密解密为同一个密码。利用这种加密方式时必须把密钥也发送给对方，密钥在传输过程中被窃取，也就失去了加密的意义。</p><p>非对称加密：密钥成对出现，公钥加密需要私钥解密，私钥加密需要公钥解密。</p><p>参考链接：</p><p><a href="https://www.runoob.com/w3cnote/http-vs-https.html">https://www.runoob.com/w3cnote/http-vs-https.html</a></p><p><a href="https://www.itwork.club/2022/05/27/why-did-https-use-mixed-encryption-algorithm/">https://www.itwork.club/2022/05/27/why-did-https-use-mixed-encryption-algorithm/</a></p><h4 id="线程的三种状态"><a href="#线程的三种状态" class="headerlink" title="线程的三种状态"></a>线程的三种状态</h4><p>就绪态、运行态、阻塞态</p><h4 id="析构函数里能不能抛异常-为什么？"><a href="#析构函数里能不能抛异常-为什么？" class="headerlink" title="析构函数里能不能抛异常?为什么？"></a>析构函数里能不能抛异常?为什么？</h4><p>析构函数从语法上是可以抛出异常的，但是这样做很危险，请尽量不要这要做。原因在《More Effective C++》中提到两个： </p><p>（1）如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。 </p><p>（2）通常异常发生时，c++的异常处理机制在异常的传播过程中会进行栈展开（stack-unwinding），因发生异常而逐步退出复合语句和函数定义的过程，被称为栈展开。在栈展开的过程中就会调用已经在栈构造好的对象的析构函数来释放资源，此时若其他析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃。</p><h4 id="两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？"><a href="#两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？" class="headerlink" title="两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？"></a>两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？</h4><p>有虚函数的大，因为有虚函数的类的会包含一个虚函数指针。注意不同操作系统指针大小不一样。</p><p>参考链接：<a href="https://blog.csdn.net/luolaihua2018/article/details/110736211">https://blog.csdn.net/luolaihua2018/article/details/110736211</a></p><h4 id="数据报和数据流的区别？"><a href="#数据报和数据流的区别？" class="headerlink" title="数据报和数据流的区别？"></a>数据报和数据流的区别？</h4><p>可以这么简单理解：</p><p>假设现在有100字节数据，面向数据流和面向数据报的连接可以分别怎么样处理呢？</p><ul><li>数据流是发送端可以调用10次write，每次10字节。接收端调用一次read。也可以是发送端调用一次write，接收端调用10次read。数据流是没有边界的</li><li>数据报则是一次write就需要一次read，是有边界的。</li></ul><h4 id="在分布式系统中，如果某个节点宕机了咋办？"><a href="#在分布式系统中，如果某个节点宕机了咋办？" class="headerlink" title="在分布式系统中，如果某个节点宕机了咋办？"></a>在分布式系统中，如果某个节点宕机了咋办？</h4><p>做一个数据副本策略，把每一台机器上的数据做几个副本的冗余，放在别的机器上。万一说某一台机器宕机，没事啊，因为其他机器上还有他的副本。</p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>所谓自旋锁就是通过while循环实现的，让拿到锁的线程进入临界区执行代码，让没有拿到锁的线程一直进行while死循环，这其实就是线程自己“旋”在while循环了，因而这种锁就叫做自旋锁。</p><p>自旋锁实现参考链接：<a href="https://blog.csdn.net/jeffasd/article/details/80661804">https://blog.csdn.net/jeffasd/article/details/80661804</a></p><h4 id="线程同步的方式有哪些"><a href="#线程同步的方式有哪些" class="headerlink" title="线程同步的方式有哪些"></a>线程同步的方式有哪些</h4><p>互斥锁、信号量、条件变量、自旋锁、读写锁、屏障</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;new和malloc的区别&quot;&gt;&lt;a href=&quot;#new和malloc的区别&quot; class=&quot;headerlink&quot; title=&quot;new和malloc的区别&quot;&gt;&lt;/a&gt;new和malloc的区别&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;属性的区别&lt;/p&gt;
&lt;p&gt;new&amp;</summary>
      
    
    
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++内存管理</title>
    <url>/2023/08/27/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>有关C++内存管理问题总结如下</p>
<h3 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h3><h4 id="C-中堆和栈的区别是什么"><a href="#C-中堆和栈的区别是什么" class="headerlink" title="C++中堆和栈的区别是什么"></a><code>C++</code>中堆和栈的区别是什么</h4><ol>
<li>栈由系统分配释放，栈上变量的生命周期是确定的，一般与作用域有关。栈的地址由高到低，栈上分配的空间大小在编译时通常已知。</li>
<li>堆由程序员手动开辟释放，堆上的变量除非被显示释放，否则会持续存在。堆的地址由低到高，堆上几乎可以分配任意大小的内存块，但可能会造成内存碎片。</li>
<li>这里说一下<code>C++</code>的内存分区：堆区、栈区、<code>data</code>区、<code>bss</code>段、代码段。数据<code>data</code>区存放的是静态变量和初始化的全局变量，<code>bss</code>段存放的是未初始化的全局变量。</li>
</ol>
<h4 id="什么是RAII？为什么它在C-中很重要"><a href="#什么是RAII？为什么它在C-中很重要" class="headerlink" title="什么是RAII？为什么它在C++中很重要"></a>什么是<code>RAII</code>？为什么它在<code>C++</code>中很重要</h4><p><code>RAII</code>是一种编程思想和设计模式，核心思想是：将资源的获取与对象的初始化捆绑在一起，将资源的释放与对象的销毁捆绑在一起。这样，资源管理就与对象的生命周期紧密关联。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::fstream fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">File</span>(<span class="type">const</span> std::string&amp; filename) &#123;</span><br><span class="line">        fs.<span class="built_in">open</span>(filename, std::ios::in | std::ios::out);</span><br><span class="line">        <span class="keyword">if</span> (!fs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to open the file&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他与文件相关的操作...</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">File</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (fs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            fs.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">File <span class="title">myFile</span><span class="params">(<span class="string">&quot;sample.txt&quot;</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 进行文件操作...</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当myFile对象离开其作用域时，它的析构函数会自动被调用，从而关闭文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="解释new和delete，与malloc和free的区别"><a href="#解释new和delete，与malloc和free的区别" class="headerlink" title="解释new和delete，与malloc和free的区别"></a>解释<code>new</code>和<code>delete</code>，与<code>malloc</code>和<code>free</code>的区别</h4><ul>
<li><p>属性的区别</p>
<p><code>new/delete</code>：这两个是<code>C++</code>中的关键字；</p>
<p><code>malloc/free</code>：这两个是库函数；</p>
</li>
<li><p>使用上的区别</p>
<p><code>malloc</code>：申请空间需要显式填入申请内存的大小；</p>
<p><code>new</code>：无需显式填入申请内存的大小，<code>new</code>会根据<code>new</code>的类型分配内存；</p>
</li>
<li><p>返回类型的区别</p>
<p><code>new</code>操作符内存分配成功，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，故<code>new</code>是符合类型安全性的操作符。</p>
<p><code>malloc</code>内存分配成功返回的是<code>void*</code>指针，需要通过强制类型转换，转换成我们需要的类型。</p>
<p>所以<code>C++</code>中<code>new</code>比<code>malloc</code>安全可靠。</p>
</li>
<li><p>分配失败的区别</p>
<p><code>malloc</code>分配失败会返回<code>NULL</code>，我们可以通过判断返回值是否是<code>NULL</code>得知是否分配成功。</p>
<p><code>new</code>分配失败会抛出<code>bad_alloc</code>异常。</p>
</li>
<li><p>扩张内存的区别</p>
<p><code>malloc</code>有内存扩张机制（通过<code>realloc</code>实现）。</p>
<p><code>new</code>没有扩张内存机制。</p>
</li>
</ul>
<h3 id="中级问题"><a href="#中级问题" class="headerlink" title="中级问题"></a>中级问题</h3><h4 id="为什么C-推荐使用智能指针，如shared-ptr和unique-ptr"><a href="#为什么C-推荐使用智能指针，如shared-ptr和unique-ptr" class="headerlink" title="为什么C++推荐使用智能指针，如shared_ptr和unique_ptr"></a>为什么<code>C++</code>推荐使用智能指针，如<code>shared_ptr</code>和<code>unique_ptr</code></h4><ul>
<li>自动管理内存：对于<code>unique_ptr</code>，当它超出作用域或者被重新分配时，它指向的对象会被删除。对于<code>shared_ptr</code>，当它的引用计数为0时，它指向的对象会被删除。</li>
<li>异常安全：当函数抛出异常，智能指针确保资源被正确清理，避免资源泄露。</li>
<li>防止悬挂指针：悬挂指针是指指向已经释放内存的指针。<code>unique_ptr</code>和<code>shared_ptr</code>可以减少悬挂指针的风险，因为他们确保在没有引用的时候释放资源。</li>
</ul>
<h4 id="你能解释shared-ptr中的引用计数机制是如何工作的吗"><a href="#你能解释shared-ptr中的引用计数机制是如何工作的吗" class="headerlink" title="你能解释shared_ptr中的引用计数机制是如何工作的吗"></a>你能解释<code>shared_ptr</code>中的引用计数机制是如何工作的吗</h4><ul>
<li>通过一个指针实现引用计数功能，加锁，保证线程安全</li>
</ul>
<h4 id="什么情况下会导致内存泄漏，你如何检测和预防"><a href="#什么情况下会导致内存泄漏，你如何检测和预防" class="headerlink" title="什么情况下会导致内存泄漏，你如何检测和预防"></a>什么情况下会导致内存泄漏，你如何检测和预防</h4><ul>
<li><p>指针重新赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line"><span class="type">int</span> *np = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line">p = np;</span><br><span class="line"><span class="comment">//p原来的指向的内存无法释放，因为现在没有指针指向这块内存</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>错误的内存释放</p>
<p>假设有一个指针<code>p</code>指向10字节的内存，该内存的第三个字节<code>np</code>又指向某个动态分配的内存， 如果此时你直接<code>delete(p)</code>，则会导致<code>np</code>指向的内存无法释放。</p>
</li>
<li><p>返回值的不正确处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于没有对函数f()的返回值做正确接收，将会导致f函数分配的内存无法释放。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>关于内存泄露可以使用工具：<code>Valgrind</code>。</p>
<h3 id="高级问题"><a href="#高级问题" class="headerlink" title="高级问题"></a>高级问题</h3><h4 id="描述C-的内存模型是什么？如何保证线程间的数据同步？"><a href="#描述C-的内存模型是什么？如何保证线程间的数据同步？" class="headerlink" title="描述C++的内存模型是什么？如何保证线程间的数据同步？"></a>描述C++的内存模型是什么？如何保证线程间的数据同步？</h4><h4 id="什么是内存屏障-memory-barrier-或内存栅栏？在哪些场景中需要使用它？"><a href="#什么是内存屏障-memory-barrier-或内存栅栏？在哪些场景中需要使用它？" class="headerlink" title="什么是内存屏障(memory barrier)或内存栅栏？在哪些场景中需要使用它？"></a>什么是内存屏障(memory barrier)或内存栅栏？在哪些场景中需要使用它？</h4><h4 id="你有没有用过定制的内存分配器，比如为某些高性能的应用场景？如果有，请描述其工作原理和使用场景。"><a href="#你有没有用过定制的内存分配器，比如为某些高性能的应用场景？如果有，请描述其工作原理和使用场景。" class="headerlink" title="你有没有用过定制的内存分配器，比如为某些高性能的应用场景？如果有，请描述其工作原理和使用场景。"></a>你有没有用过定制的内存分配器，比如为某些高性能的应用场景？如果有，请描述其工作原理和使用场景。</h4><h3 id="实践问题"><a href="#实践问题" class="headerlink" title="实践问题"></a>实践问题</h3><h4 id="描述一个你曾遇到的复杂的内存相关bug，你是如何诊断和解决的？"><a href="#描述一个你曾遇到的复杂的内存相关bug，你是如何诊断和解决的？" class="headerlink" title="描述一个你曾遇到的复杂的内存相关bug，你是如何诊断和解决的？"></a>描述一个你曾遇到的复杂的内存相关bug，你是如何诊断和解决的？</h4><h4 id="你如何评估一个C-程序的内存使用效率？你使用过哪些工具或技术"><a href="#你如何评估一个C-程序的内存使用效率？你使用过哪些工具或技术" class="headerlink" title="你如何评估一个C++程序的内存使用效率？你使用过哪些工具或技术"></a>你如何评估一个C++程序的内存使用效率？你使用过哪些工具或技术</h4><h4 id="请编写一个小程序，其中创建一个有资源泄漏的类，然后展示如何使用工具或方法找到并修复该泄漏。"><a href="#请编写一个小程序，其中创建一个有资源泄漏的类，然后展示如何使用工具或方法找到并修复该泄漏。" class="headerlink" title="请编写一个小程序，其中创建一个有资源泄漏的类，然后展示如何使用工具或方法找到并修复该泄漏。"></a>请编写一个小程序，其中创建一个有资源泄漏的类，然后展示如何使用工具或方法找到并修复该泄漏。</h4>]]></content>
  </entry>
  <entry>
    <title>CMake</title>
    <url>/2023/08/29/CMake/</url>
    <content><![CDATA[<p>这里画一个图直接直接展示一下CMake和Makefile的使用过程</p>
<p><img src="png1.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g++ *.cpp -o app  <span class="comment">//直接编译    </span></span><br></pre></td></tr></table></figure>

<p>使用#注释</p>
<p>块注释#[[ ]]</p>
<p>camke_minimum_required：指定使用的cmake的最低版本</p>
<p>project：定义工程名称</p>
<p>add_executable：定义工程会生成一个可执行程序 add_executable(可执行程序名称 源文件名称（空格或者分号隔离源文件)）</p>
<p>cmake CMakeLists.txt：文件所在路径</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(app, add.cpp div.cpp mult.cpp main.cpp sub.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果CMakeLists.txt文件就在当前目录下，直接执行以下命令</span></span><br><span class="line">cmake .</span><br><span class="line">make</span><br><span class="line"><span class="comment">#就会出现app可执行文件</span></span><br></pre></td></tr></table></figure>

<p>生成了很多其他文件，我们可以把这些临时文件放在一个文件夹里，一般为build文件夹。创建build文件后，cd进build文件，执行camke ..，则cmake执行后生成的文件都放在了build文件夹里。</p>
<h3 id="set的使用"><a href="#set的使用" class="headerlink" title="set的使用"></a><code>set</code>的使用</h3><p>set是为了简化add_executable(app, add.cpp div.cpp mult.cpp main.cpp sub.cpp)的编写，要不然这样和直接编译感觉没啥区别。set给一个变量赋值都是字符串类型，这些文件的名字会作为一个字符串存在变量里。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set指令的语法是：</span></span><br><span class="line"><span class="comment"># [] 中的参数为可选项，如不需要可以不写</span></span><br><span class="line"><span class="keyword">set</span>(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># VAR：变量名</span></span><br><span class="line"><span class="comment"># VALUE：变量值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一：各个源文件之间使用空格间隔</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST add.c div.c main.c mult.c sub.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二：各个源文件之间使用;间隔</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST add.c;div.c;main.c;mult.c;sub.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>取变量值必须以这种方式。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &quot;$ + &#123;变量名&#125;&quot;</span></span><br><span class="line"><span class="variable">$&#123;SRC_LIST&#125;</span></span><br></pre></td></tr></table></figure>

<p>还可以通过set设置使用C++的标准（C++11，C++17）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正常编译选定c++标准</span></span><br><span class="line">g++ *.cpp -std=c++11 -o app</span><br></pre></td></tr></table></figure>

<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用camke指定c++标准，对应有一个宏叫做DCMAKE_Cxx_STANDARD</span></span><br><span class="line"><span class="comment"># 由两种方式指定C++标准</span></span><br><span class="line"><span class="comment"># 第一种：在CMakeLists.txt中通过set命令指定</span></span><br><span class="line"><span class="keyword">set</span>(CAMKE_CXX_STANDARD <span class="number">11</span>)  <span class="comment"># 等价于增加 -std=c++11</span></span><br><span class="line"><span class="keyword">set</span>(CAMKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="keyword">set</span>(CAMKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种：在执行camke命令的时候制定出这个宏的值</span></span><br><span class="line">camke CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=<span class="number">11</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=<span class="number">14</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=<span class="number">17</span></span><br></pre></td></tr></table></figure>

<p>set还可以指定输出路径，建议使用绝对路径，如果这个路径中的子目录不存在，会自动生成，无需自己手动创建。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在CMake中指定可执行程序输出的路径，也对应一个宏，叫做EXECUTABLE_OUTPUT_PATH，它的值还是通过set命令设置</span></span><br><span class="line"><span class="keyword">set</span>(HOME /home/zcl/linux/soft)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_UOTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>/bin)</span><br><span class="line"><span class="comment"># 第一行：定义一个变量用于存储一个绝对路径</span></span><br><span class="line"><span class="comment"># 第二行：将拼接好的路径值设置给EXECUTABLE_OUTPUT_PATH宏</span></span><br></pre></td></tr></table></figure>



<h3 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h3><p>我们可以看到我们上面所讲的使用set并没有解决要将所有源文件名字写出来的本质问题。为了解决这个问题，这里我们讲一下通过搜索某个目录下的文件来引入源文件的方法。CMake给我们提供了两种方法来搜索文件，aux_source_directory命令或者file命令。</p>
<h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>在CMake中使用aux_source_directory命令可以查找某个路径下的所有源文件。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(&lt;dir&gt; &lt;variable&gt;)</span><br><span class="line"><span class="comment"># dir：要搜索的目录</span></span><br><span class="line"><span class="comment"># variable：将从dir目录下搜索到的源文件列表存储到该变量中</span></span><br><span class="line"><span class="comment"># 这里介绍一个宏，PROJECT_SOURCE_DIR宏代表的就是我们在camke命令后携带的那个路径。比如camke ..，PROJECT_SORCE_DIR宏代表的就是`..`</span></span><br><span class="line"><span class="comment"># 再介绍另外一个宏，CMAKE_CURRENT_SOURCE_DIR宏代表的就是当前CMakelists.txt文件所在的路径</span></span><br><span class="line"><span class="comment"># 下面进入实操，比如搜索当前CMakelists.txt文件所在目录下的src目录</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src SRC_LIST)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>通过file命令来搜索出所有需要的源文件</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line"><span class="keyword">file</span>(GLOB 变量名 要搜索的文件路径和文件类型)</span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</span><br><span class="line"><span class="comment"># GLOB：将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中</span></span><br><span class="line"><span class="comment"># GLOB_RECURSE：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中</span></span><br><span class="line"><span class="comment"># 比如：搜索当前目录的src目录下所有的源文件，并将其存储到变量中</span></span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="variable">$&#123;CAMKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/*.h)</span><br><span class="line"><span class="comment"># 注：关于要搜索的文件路径和类型可以加双引号，也可不加</span></span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="搜索头文件路径"><a href="#搜索头文件路径" class="headerlink" title="搜索头文件路径"></a>搜索头文件路径</h3><p>在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能找到这些头文件。在CMake里搜索头文件的命令也很简单</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(headpath)</span><br><span class="line"><span class="comment"># headpath就是头文件路径，这里建议写绝对路径</span></span><br><span class="line"><span class="comment"># 实操</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>



<h3 id="通过CMake制作库文件"><a href="#通过CMake制作库文件" class="headerlink" title="通过CMake制作库文件"></a>通过CMake制作库文件</h3><p>有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来讲解在cmake中生成这两类库文件的方法。</p>
<h4 id="制作静态库"><a href="#制作静态库" class="headerlink" title="制作静态库"></a>制作静态库</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在cmake中，如果要制作静态库，需要使用的命令如下：</span></span><br><span class="line"><span class="keyword">add_library</span>(库名称 STATIC 源文件<span class="number">1</span> [源文件<span class="number">2</span>] ...) </span><br><span class="line"><span class="comment"># 注：在Linux中，静态库名字分为三部分：lib+库名字+.a，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。</span></span><br><span class="line"><span class="comment"># 如果是动态库，最终生成的库的名字就是：libXXX.so(Linux)，libXXX.dll(Windows)；</span></span><br><span class="line"><span class="comment"># 如果是静态库，最终生成的库的名字就是：libXXX.a(Linux)，libXXX.lib(Windows)；</span></span><br><span class="line"><span class="comment"># 下面有一个目录，需要将src目录中的源文件编译成静态库，然后再使用：</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── <span class="keyword">include</span>           <span class="comment"># 头文件目录</span></span><br><span class="line">│   └── head.h</span><br><span class="line">├── main.cpp          <span class="comment"># 用于测试的源文件</span></span><br><span class="line">└── src               <span class="comment"># 源文件目录</span></span><br><span class="line">    ├── add.cpp</span><br><span class="line">    ├── div.cpp</span><br><span class="line">    ├── mult.cpp</span><br><span class="line">    └── sub.cpp</span><br><span class="line"><span class="comment"># 根据上面的目录结构，可以这样编写CMakeLists.txt文件:</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 注：STATIC对应的是静态库，SHARED对应的是动态库</span></span><br></pre></td></tr></table></figure>

<h4 id="制作动态库"><a href="#制作动态库" class="headerlink" title="制作动态库"></a>制作动态库</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(calc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="指定输出路径"><a href="#指定输出路径" class="headerlink" title="指定输出路径"></a>指定输出路径</h4><p>对于生成的库文件来说和可执行程序一样都可以指定输出路径。这里使用LIBRARY_OUTPUT_PATH宏，这个宏对应静态库文件和动态库文件都适用。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="comment"># 设置动态库/静态库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="comment">#add_library(calc SHARED $&#123;SRC_LIST&#125;)</span></span><br><span class="line"><span class="comment"># 生成静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="包含库文件"><a href="#包含库文件" class="headerlink" title="包含库文件"></a>包含库文件</h3><p>在编写程序的过程中，可能会用到一些系统提供的动态库或者自己制作出的动态库或者静态库文件，cmake中也为我们提供了相关的加载动态库的命令。</p>
<h4 id="链接静态库"><a href="#链接静态库" class="headerlink" title="链接静态库"></a>链接静态库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">├── add.cpp</span><br><span class="line">├── div.cpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── mult.cpp</span><br><span class="line">└── sub.cpp</span><br></pre></td></tr></table></figure>

<p>现在我们把上面src目录中的add.cpp、div.cpp、mult.cpp、sub.cpp编译成一个静态库文件libcalc.a。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试目录结构</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span> </span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.a     # 制作出的静态库的名字</span><br><span class="line">└── src</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br><span class="line">4 directories, 4 files</span><br></pre></td></tr></table></figure>

<p>在cmake中，链接静态库的命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">link_libraries</span>(&lt;static lib&gt; [&lt;static lib&gt;...])</span><br><span class="line"><span class="comment"># 参数1：指定出要链接的静态库的名字，可以是全名 libxxx.a，也可以是掐头（lib）去尾（.a）之后的名字 xxx</span></span><br><span class="line"><span class="comment"># 参数2-N：要链接的其它静态库的名字</span></span><br></pre></td></tr></table></figure>

<p>如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(&lt;lib path&gt;)</span><br></pre></td></tr></table></figure>

<p>这样，修改之后的CMakeLists.txt文件内容如下:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="comment"># 搜索指定目录下源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="comment"># 包含头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 包含静态库路径 添加了这行代码，就可以根据参数指定的路径找到这个静态库了。</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 链接静态库</span></span><br><span class="line"><span class="keyword">link_libraries</span>(calc)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="链接动态库"><a href="#链接动态库" class="headerlink" title="链接动态库"></a>链接动态库</h4><p>target不知道这个符号是来自它链接的多个库中的哪一个库，它只知道有这么一个库。</p>
<p>FATAL_ERROR：CMake 错误, 终止所有处理过程（CMake在生成”message to display”这条消息之后就不在执行了，直接中断）</p>
<p>CMake在底层管理的时候会将子字符串通过分号隔开，但通过message打印变量值的时候，看不到这个分号。这个分号有助于cmake进行字符串删除操作。只能删除组成变量的子串。比如一开始SRC&#x3D;”A123”，后来apeend了“456”, “789”，如果没有分号，你可能可以删除”345”，但有了分号后，就删除不了了，你只能删除组成SRC的完整的子串，比如”A123”, “456”等。</p>
<p>注意，存储列表长度的output variable依旧是一个字符串类型。</p>
]]></content>
  </entry>
  <entry>
    <title>Linux 高性能服务器--第五章</title>
    <url>/2023/08/27/Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
    <content><![CDATA[<h4 id="5-1-1-判断主机是小端字节序还是大端字节序"><a href="#5-1-1-判断主机是小端字节序还是大端字节序" class="headerlink" title="5.1.1 判断主机是小端字节序还是大端字节序"></a>5.1.1 判断主机是小端字节序还是大端字节序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">byteOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">short</span> value;</span><br><span class="line">        <span class="type">char</span> union_bytes[<span class="built_in">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    &#125;test;</span><br><span class="line">    </span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span>(test.union_bytes[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; test.union_bytes[<span class="number">1</span>] == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端字节序\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(test.union_bytes[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; test.union_bytes[<span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端字节序\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不清楚\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">byteOrder</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-1-3专用socket地址"><a href="#5-1-3专用socket地址" class="headerlink" title="5.1.3专用socket地址"></a>5.1.3专用<code>socket</code>地址</h4><p><code>TCP/IP</code>协议族有<code>sockaddr_in</code>和<code>sockaddr_in6</code>两个专用<code>socket</code>地址结构体，他们分别用于<code>IPv4</code>和<code>IPv6</code>，这里我只介绍<code>sockaddr_in</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;  <span class="comment">// 地址族：AF_INET</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin_port;	<span class="comment">// 端口号：要用网络字节序表示</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;	<span class="comment">// IPv4地址结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span>&#123;</span><br><span class="line">    <span class="type">u_int32_t</span> s_addr;	<span class="comment">// 要用网络字节序表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：所有专用<code>socket</code>地址类型的变量在实际使用时都需要转换为通用<code>socket</code>地址类型<code>sockaddr</code>（强制转换即可），因为所有<code>socket</code>编程接口使用的地址参数的类型都是<code>sockaddr</code>。</p>
<h4 id="5-1-4IP地址转换函数"><a href="#5-1-4IP地址转换函数" class="headerlink" title="5.1.4IP地址转换函数"></a>5.1.4<code>IP</code>地址转换函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span>;	<span class="comment">// 用于将字符串表示的IP地址转换为用网络字节序整数表示的IP地址</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> cnt)</span></span>;	<span class="comment">// 最后一个参数指定目标存储单元的大小，这两个宏可以帮我们指定</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">inet_pton成功时返回1，失败时返回0并设置errno</span></span><br><span class="line"><span class="comment">inet_ntop成功时返回目标存储单元的地址，失败返回NULL并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET6_ADDRSTRLEN 64</span></span><br></pre></td></tr></table></figure>



<h4 id="5-2创建socket"><a href="#5-2创建socket" class="headerlink" title="5.2创建socket"></a>5.2创建socket</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">domain一般为PF_INET(IPv4)，或者PF_INET6(IPv6)</span></span></span><br><span class="line"><span class="comment"><span class="function">type参数指定服务类型，主要有SOCK_STREAM和SOCK_UGRAM</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span> </span></span><br></pre></td></tr></table></figure>

<p>socket系统调用成功时返回一个socket文件描述符，失败返回-1并设置errno</p>
<h4 id="5-3命名socket"><a href="#5-3命名socket" class="headerlink" title="5.3命名socket"></a>5.3命名socket</h4><p>创建socket时，我们给它指定了地址族，但是并未指定使用该地址族中的哪个具体socket地址。将一个socket与socket地址绑定称为给socket命名。在服务器程序中，我们通常需要命名socket，<strong>因为只有命名后客户端才知道该如何连接它</strong>。客户端通常不需要命名socket，而是采用匿名方式，也就是使用操作系统自动分配的socket地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* my_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bind将my_addr所指的socket地址分配给未命名的socket文件描述符，addrlen参数指出该socket地址的长度</span></span><br><span class="line"><span class="comment">bind成功时返回0，失败时返回-1并设置errno，其中两种常见的errno是：EACCES和EADDRINUSE。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="5-4监听socket"><a href="#5-4监听socket" class="headerlink" title="5.4监听socket"></a>5.4监听socket</h4><p>socket被命名之后，还不能立即接收客户端连接，我们需要使用如下系统调用来创建一个监听队列以存放待处理的客户连接</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sockfd参数指定被监听的socket，backlog参数提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客户端连接，客户端也将收到ECONNREFUSED错误信息。（实际上最多可以接收backlog + 1个客户端连接）</span></span><br><span class="line"><span class="comment">listen成功时返回0，失败时返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>下面我们编写一个程序测试一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">basename使用示例：</span></span><br><span class="line"><span class="comment">`basename()` 是一个常用于处理文件路径和程序参数的库函数。</span></span><br><span class="line"><span class="comment">它的主要目的是从一个给定的路径中提取基础名（base name），也就是最后一部分的名称，不包含任何前导的目录。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">来自 `&lt;libgen.h&gt;`（或在某些系统中是 `&lt;string.h&gt;` 或 `&lt;strings.h&gt;`），`basename()` 函数的原型如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">char *basename(char *path);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">让我们看一些使用 `basename()` 的例子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 输入 `/home/user/documents/file.txt` 返回 `file.txt`</span></span><br><span class="line"><span class="comment">2. 输入 `/home/user/documents/folder/` 返回 `folder`</span></span><br><span class="line"><span class="comment">3. 输入 `/home/user/documents/` 返回 `documents`</span></span><br><span class="line"><span class="comment">4. 输入 `file.txt` 返回 `file.txt`</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在给出的代码示例中：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">printf(&quot;usage: %s ip_address port_num backlog\n&quot;, basename(argv[0]));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">`argv[0]` 通常是程序的名称，包括它被执行时的完整路径。</span></span><br><span class="line"><span class="comment">使用 `basename()` 函数，你可以仅提取程序的实际名称，而不包括其路径，这在显示帮助或错误消息时特别有用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">举个例子，假设程序的完整路径是 `/home/user/my_program`，那么 `basename(argv[0])` 就会返回 `my_program`。这样，上述的 `printf` 语句将输出：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">usage: my_program ip_address port_num backlog</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">需要注意的是，`basename()` 函数可能会修改其参数，也可能返回一个指向静态存储区的指针。</span></span><br><span class="line"><span class="comment">因此，如果原始路径字符串不应被修改，那么在调用 `basename()` 之前，最好先复制这个字符串。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">term_handler</span><span class="params">(<span class="type">int</span> sig)</span>&#123;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    signal(SIGTERM, term_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_num backlog\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sockfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sign = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    server_addr.sin_family = PF_INET;</span><br><span class="line">    server_addr.sin_port = htons(port);</span><br><span class="line">    inet_pton(PF_INET, ip, &amp;server_addr.sin_addr);</span><br><span class="line"></span><br><span class="line">    sign = bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    assert(sign != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    sign = listen(sockfd, <span class="number">5</span>);</span><br><span class="line">    assert(sign != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果忘记截图了，大家可以自己试一下，具体步骤</span></span><br><span class="line"><span class="comment">./test 172.30.78.145 8000 5</span></span><br><span class="line"><span class="comment">另开终端多次	telnet 172.30.78.145 8000</span></span><br><span class="line"><span class="comment">netstat -nt | grep 8000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这个命令组合使用了两个命令：<code>netstat</code> 和 <code>grep</code>，并通过管道（<code>|</code>）将第一个命令的输出作为第二个命令的输入。我会为你逐步解释它：</p>
<ol>
<li><p><strong><code>netstat -nt</code></strong>:</p>
<ul>
<li><code>netstat</code>: 这是一个命令行工具，用于显示网络状态，包括网络连接、路由表、接口统计等。</li>
<li><code>-n</code>: 表示以数字形式显示地址和端口号，而不是尝试解析它们的名称。</li>
</ul>
</li>
</ol>
<ul>
<li><code>-t</code>: 仅显示TCP连接。</li>
</ul>
<p>因此，<code>netstat -nt</code> 的输出会列出系统上所有活动的TCP连接，同时显示它们的源和目标IP地址以及端口号，并直接显示数字而不进行名称解析。</p>
<ol start="2">
<li><strong><code>|</code></strong>:</li>
</ol>
<ul>
<li>这是一个管道操作符，用于将前一个命令的输出作为后一个命令的输入。</li>
</ul>
<ol start="3">
<li><p><strong><code>grep 8000</code></strong>:</p>
<ul>
<li><code>grep</code>: 是一个强大的文本搜索工具，用于搜索匹配的字符串。</li>
<li><code>8000</code>: 是你想在 <code>netstat</code> 的输出中搜索的字符串。</li>
</ul>
<p>这个命令会从 <code>netstat</code> 的输出中筛选出所有包含 “8000” 的行，这通常意味着你正在查找与端口 <code>8000</code> 相关的所有活动连接。</p>
</li>
</ol>
<p>综上所述，<code>netstat -nt | grep 8000</code> 会显示所有在端口 <code>8000</code> 上的活动TCP连接。</p>
<h4 id="5-5接受连接"><a href="#5-5接受连接" class="headerlink" title="5.5接受连接"></a>5.5接受连接</h4><p>代码：接受一个异常的连接</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libgen.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;运行程序，需输入这三个参数：%s, ip_address, port_num\n&quot;</span>, <span class="built_in">basename</span>(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = <span class="built_in">ntohs</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(sock, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">    <span class="type">socklen_t</span> client_len = <span class="built_in">sizeof</span>(client);</span><br><span class="line">    <span class="type">int</span> connfd = <span class="built_in">accept</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;client_len);</span><br><span class="line">    <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">char</span> remote[INET_ADDRSTRLEN];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>, <span class="built_in">inet_ntop</span>(AF_INET, &amp;client.sin_addr, remote, client_len),</span><br><span class="line">                <span class="built_in">ntohs</span>(client.sin_port));</span><br><span class="line">        <span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、第一次运行报错，<code>undefined reference to main</code>，这种情况一般有三种可能：</p>
<ul>
<li>没有定义main函数</li>
<li>main函数的main拼写错误</li>
<li>刚写的代码忘记保存了</li>
</ul>
<p>2、<code>accept</code>函数是阻塞的，上述代码即服务器端运行的时候，会阻塞在<code>accept</code>处，一旦客户端请求建立连接，服务器立马终止程序。注意<code>accept</code>只是从<code>listen</code>监听队列中取出连接，它不会理会客户端处于什么状态。</p>
<p>3、一直在思考<code>select/poll/epoll</code>这些有什么用。首先因为listen是有监听队列的，劣势就在于只能一个个处理，并且同时接入的连接数有限。比如队列长度为5，处理完一个，再建立下一个连接，这样如果某一个连接处理很长时间一直阻塞在那里，就导致后面的新请求连接建立超时。很直观的想法是<code>fork</code>新进程或者创建新线程来处理新连接，每来一个连接我就创建一个来跟他对接。这样资源消耗太大。因此就有了<code>select/poll/epoll</code>，先把连接建立起来并放进文件描述符，最后从这里面寻找哪些发生了可读可写事件，也避免了因为读写事件造成的阻塞（没有数据到来就阻塞了）。</p>
]]></content>
  </entry>
  <entry>
    <title>Linux高性能服务器-第八章</title>
    <url>/2023/09/07/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%AC%AC%E5%85%AB%E7%AB%A0/</url>
    <content><![CDATA[<p>这里因为做项目的需要，我先写下8.6节有关有限状态机的内容</p>
<p>这一节我们介绍逻辑单元内部的一种高效编程方法：有限状态机。有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。</p>
]]></content>
  </entry>
  <entry>
    <title>Cpp高频面经</title>
    <url>/2023/06/29/Cpp%E9%AB%98%E9%A2%91%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h4 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h4><ul>
<li><p>属性的区别</p>
<p>new&#x2F;delete：这两个是C++中的关键字；</p>
<p>malloc&#x2F;free：这两个是库函数；</p>
</li>
<li><p>使用上的区别</p>
<p>malloc：申请空间需要显式填入申请内存的大小；</p>
<p>new：无需显式填入申请内存的大小，new会根据new的类型分配内存；</p>
</li>
<li><p>返回类型的区别</p>
<p>new操作符内存分配成功，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，故new是符合类型安全性的操作符。</p>
<p>malloc内存分配成功返回的是void*指针，需要通过强制类型转换，转换成我们需要的类型。</p>
<p>所以C++中new比malloc安全可靠。</p>
</li>
<li><p>分配失败的区别</p>
<p>malloc分配失败会返回NULL，我们可以通过判断返回值是否是NULL得知是否分配成功。</p>
<p>new分配失败会抛出bad_alloc异常。</p>
</li>
<li><p>扩张内存的区别</p>
<p>malloc有内存扩张机制（通过realloc实现）。</p>
<p>new没有扩张内存机制。</p>
</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/338489910">https://zhuanlan.zhihu.com/p/338489910</a></p>
<h4 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h4><ul>
<li>明确动态内存使用范围：在程序中使用动态内存时，需要明确该内存的使用范围，确保在不需要使用该内存时能够及时释放内存。</li>
<li>使用RAII技术：RAII（Resource Acquisition Is Initialization）是C++中一种常用的资源管理技术，它利用了C++对象的构造函数和析构函数自动调用的特性，在对象的构造函数中申请资源，在对象的析构函数中释放资源，从而避免资源泄漏问题。</li>
<li>使用智能指针：智能指针可以自动管理动态内存的分配和释放。</li>
</ul>
<h4 id="线程池的数量一般怎么设置"><a href="#线程池的数量一般怎么设置" class="headerlink" title="线程池的数量一般怎么设置"></a>线程池的数量一般怎么设置</h4><p>线程池中线程数量的设置主要考虑两个方面：</p>
<ul>
<li><p>I&#x2F;O密集型</p>
</li>
<li><p>如果说任务是耗时I&#x2F;O型，比如涉及数据库、文件的读写，网络通信等任务，这种任务的特点是不会特别消耗CPU资源，但是我们需要考虑到I&#x2F;O操作耗时较长。这种情况一般会将线程数设置的比较大，达到了CPU核心数的很多倍。因为如果线程数设置的比较少，会造成CPU计算资源的浪费。</p>
</li>
<li><p>CPU密集型</p>
</li>
<li><p>对于CPU密集型任务，线程数不宜设置的过多，因为过多的线程都会去抢占CPU资源，就会产生不必要的上下文切换，反而会造成整体性能的下降</p>
</li>
</ul>
<p>线程数通用计算公示：线程数 &#x3D; CPU核心数 * (1 + I&#x2F;O耗时 &#x2F; CPU耗时)</p>
<h4 id="来了一个新任务，线程池是怎么工作的（本答案有待商榷）"><a href="#来了一个新任务，线程池是怎么工作的（本答案有待商榷）" class="headerlink" title="来了一个新任务，线程池是怎么工作的（本答案有待商榷）"></a>来了一个新任务，线程池是怎么工作的（本答案有待商榷）</h4><p>当有一个新任务到来时，线程池会先判断是否有空闲线程，如果有，则将任务分配给空闲线程；</p>
<p>如果此时线程池里没有空线程，则先将任务放任务任务队列，待有空闲线程之后，再从任务队列中取出任务。</p>
<h4 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h4><p>在我的理解里，完美转发 &#x3D; std::forward + 万能引用 + 引用折叠。首先引用折叠机制为T&amp;&amp;类型的万能引用中的模板参数T赋予了一个恰到好处的值，而我们用T去指明std::forward的模板参数，从而使得std::forward返回的是正确的类型（这里关于返回的是正确的类型，应该去看std::forward实现的源码，知乎链接如下：<a href="https://zhuanlan.zhihu.com/p/369203981%EF%BC%89">https://zhuanlan.zhihu.com/p/369203981）</a></p>
<h4 id="去掉std-forward会咋样"><a href="#去掉std-forward会咋样" class="headerlink" title="去掉std::forward会咋样"></a>去掉std::forward会咋样</h4><p>可能会导致在传递参数的时候丢失类型信息，从而导致编译器无法正确推断模板类型或者在模板类型推断中发生错误。</p>
<h4 id="讲一下C-中的虚继承"><a href="#讲一下C-中的虚继承" class="headerlink" title="讲一下C++中的虚继承"></a>讲一下C++中的虚继承</h4><h4 id="基类的析构函数为什么是虚函数？"><a href="#基类的析构函数为什么是虚函数？" class="headerlink" title="基类的析构函数为什么是虚函数？"></a>基类的析构函数为什么是虚函数？</h4><p>如果基类的虚构函数不是虚函数，当我们定义一个父类指针指向子类对象时，最后子类的析构函数不会调用，导致内存泄漏。</p>
<h4 id="struct和union的区别（默写）"><a href="#struct和union的区别（默写）" class="headerlink" title="struct和union的区别（默写）"></a>struct和union的区别（默写）</h4><h4 id="C-内存布局-x2F-程序分段（默写）"><a href="#C-内存布局-x2F-程序分段（默写）" class="headerlink" title="C++内存布局&#x2F;程序分段（默写）"></a>C++内存布局&#x2F;程序分段（默写）</h4><h4 id="了解shared-ptr吗？如果让你手写一个shared-ptr，你会怎么设计"><a href="#了解shared-ptr吗？如果让你手写一个shared-ptr，你会怎么设计" class="headerlink" title="了解shared_ptr吗？如果让你手写一个shared_ptr，你会怎么设计"></a>了解shared_ptr吗？如果让你手写一个shared_ptr，你会怎么设计</h4><p>shared_ptr是智能指针里面的共享指针，即多个指针指向同一个内存。每多一个指针指向这片内存，引用计数加1。当对象的引用计数减少为0时，对象会自动析构，对应内存被自动释放。智能指针是模板类，而不是指针。</p>
<p>设计：将shared_ptr定义为一个模板类，包括两个成员：模板类指针和一个指向引用计数的指针。指向引用计数类型的指针应该包括这些成员函数：增加计数、减少计数、返回现有计数。一个私有成员就是用于计数的变量。共享指针模板类的构造函数接受一个模板类型指针，并且需要声明为explicit，表示必须直接初始化。另外就是拷贝构造函数和移动构造函数。拷贝构造需要注意拷贝的对象的指针是否为nullptr，如果不是nullptr，则需要增加引用计数。移动构造函数需要注意将传入的右值引用对象的指针置空，引用计数清零。析构函数有两个判断条件，第一个最后一个指向对象的指针需要为非nullptr并且此时引用计数减一后为0。然后就是重载*、-&gt;、bool，还有一个函数用于获得指针get()。动态转换（可考虑）。</p>
<h4 id="介绍一下TCP，TCP粘包如何解决"><a href="#介绍一下TCP，TCP粘包如何解决" class="headerlink" title="介绍一下TCP，TCP粘包如何解决"></a>介绍一下TCP，TCP粘包如何解决</h4><p>解决办法：</p>
<ul>
<li>发送端：使用TCP_NODELAY关闭Nagle算法，但是如果不是时延敏感的应用尽量不要关闭</li>
<li>接收端：没法解决，只能交给应用端解决</li>
<li>应用层：有三种解决办法<ul>
<li>只发送固定包长的数据包，但是这个方法基本不用，灵活性太差</li>
<li>指定标识结尾，比如\r\n之类的</li>
<li>包头加包体，包头一般是固定长度，并且里面有一个字段可以告知我们接下来的包体有多大</li>
</ul>
</li>
</ul>
<h4 id="回调函数是什么，回调函数的本质"><a href="#回调函数是什么，回调函数的本质" class="headerlink" title="回调函数是什么，回调函数的本质"></a>回调函数是什么，回调函数的本质</h4><p>回调函数允许我们将一个函数（或函数对象）作为参数传递给另一个函数，并在需要的时候由后者调用执行。回调函数定义了在特定事件或条件满足时应该执行的操作。主调函数是接受回调函数作为参数的函数。</p>
<h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><ol>
<li>进程<ul>
<li>进程拥有独立内存空间和系统资源</li>
<li>进程之间相互独立，一个进程的崩溃通常不会影响其他进程</li>
<li>创建、销毁和切换进程开销比较大</li>
</ul>
</li>
<li>线程<ul>
<li>一个进程可以包含多个线程，所有线程共享相同的地址空间和系统资源</li>
<li>线程之间可以直接读写进程内的共享数据，执行起来更高效</li>
<li>线程的创建、销毁和切换开销比较小</li>
</ul>
</li>
</ol>
<h4 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h4><p>GET用于获取资源，参数通过URL传递，不适合传输敏感信息，幂等，有缓存，传输数据的大小受限于URL的长度。POST用于提交数据，参数通过请求体传递，适合传输敏感信息，不幂等，无缓存，没有数据大小限制。</p>
<h4 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h4><ol>
<li>HTTP<ul>
<li>HTTP是一种应用层协议，用于在Web浏览器和Web服务器之间传输超文本和其他资源</li>
<li>HTTP是明文传输的协议，意味着数据在传输过程中是未加密的，容易被窃听和篡改</li>
<li>HTTP默认使用80端口号</li>
</ul>
</li>
<li>HTTPS<ul>
<li>HTTPS是HTTP协议的安全版本，加强了数据传输的安全性和保密性</li>
<li>HTTPS使用了SSL&#x2F;TLS协议进行数据加密和身份认证</li>
<li>HTTPS默认使用443端口通信</li>
</ul>
</li>
</ol>
<h4 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++ 11新特性"></a>C++ 11新特性</h4><ul>
<li><p>auto关键字</p>
</li>
<li><p>智能指针</p>
</li>
<li><p>lambda表达式	参考链接（<a href="https://blog.51cto.com/u_15323899/5785594%EF%BC%89">https://blog.51cto.com/u_15323899/5785594）</a></p>
<p>Lambda表达式是C++11引入的一种新特性，它允许在代码中定义匿名函数。虽然在使用上非常简洁和方便，但lambda表达式背后的实现相对复杂。以下是lambda表达式在底层的工作原理：</p>
<ol>
<li><p><strong>转换为类</strong>:</p>
<ul>
<li>当你定义一个lambda表达式，编译器会为你生成一个匿名类（也称为闭包类型）。这个类将会覆盖函数调用操作符，使得该对象可以像函数一样被调用。</li>
<li>如果lambda表达式捕获了外部的局部变量（例如通过值或引用），这些变量将会被添加为该匿名类的成员。</li>
</ul>
</li>
<li><p><strong>成员变量</strong>:</p>
<ul>
<li>为了支持捕获，生成的闭包类型可能会包含成员变量。如果使用值捕获，那么这些成员变量将存储捕获的变量的副本；如果使用引用捕获，那么成员变量将存储相应变量的引用。</li>
</ul>
</li>
<li><p><strong>函数调用操作符重载</strong>:</p>
<ul>
<li>生成的类会覆盖函数调用操作符<code>operator()</code>. 这个操作符的实现就是lambda表达式的主体。</li>
</ul>
</li>
<li><p><strong>构造函数</strong>:</p>
<ul>
<li>该匿名类的构造函数会初始化所有捕获的变量。根据捕获方式（值或引用）来复制或绑定这些变量。</li>
</ul>
</li>
<li><p><strong>生成的类是只移动构造的</strong>:</p>
<ul>
<li>这意味着你不能按常规方式复制lambda表达式，但可以移动它。</li>
</ul>
</li>
</ol>
<p>下面是一个简单的lambda表达式的例子以及一个可能的简化版本的匿名类表示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lambda</span></span><br><span class="line"><span class="keyword">auto</span> lambda = [x](<span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Possible representation by the compiler</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__anonymous</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    __anonymous(<span class="type">int</span> _x) : <span class="built_in">x</span>(_x) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要注意的是，这只是一个简化的表示。实际编译器生成的代码会比这更复杂，尤其是当涉及到更高级的特性（如泛型、<code>mutable</code>关键字或捕获列表）时。</p>
<p>最后，虽然从概念上讲，lambda表达式是转换为类的，但这并不意味着性能会受到影响。优化后的编译器通常会内联这些生成的类和函数调用操作符，从而消除由于间接调用导致的任何额外开销。</p>
</li>
<li><p>右值引用和移动语义</p>
</li>
</ul>
<h4 id="lambda表达式的使用场景"><a href="#lambda表达式的使用场景" class="headerlink" title="lambda表达式的使用场景"></a>lambda表达式的使用场景</h4><p>lambda表达式提供了一种简洁、方便的方式来创建匿名对象。在一些需要传递简单函数对象的场景下，使用lambda表达式可以避免额外的函数对象类。</p>
<h4 id="vector迭代器失效的原因"><a href="#vector迭代器失效的原因" class="headerlink" title="vector迭代器失效的原因"></a>vector迭代器失效的原因</h4><p>vector底层的实现是一个动态数组，vector里面存储的元素都是连续的，一旦比如删除一个元素，后面的所有元素都需要移动。我们可以考虑一种极端情况，删除最后一个元素，此时指向原vector数组的最后一个元素的迭代器就没指向任何元素了，如何此时我们访问这个迭代器所指向的元素，就会导致未定义行为，所以就会判定迭代器失效。其实所有改变vector大小的操作，都会导致vector迭代器失效。</p>
<h4 id="map的底层数据结构"><a href="#map的底层数据结构" class="headerlink" title="map的底层数据结构"></a>map的底层数据结构</h4><p>红黑树参考链接：<a href="https://www.jianshu.com/p/e136ec79235c">https://www.jianshu.com/p/e136ec79235c</a></p>
<p>map是有序容器，底层数据结构是红黑树，时间复杂度为log(n)。红黑树的前身可以说是二叉搜索树。但是二叉搜索树最坏的情况下树的高度为n，那么就导致时间复杂度为o(n), 所以便衍生出来了平衡二叉树。其实红黑树的五大特性就是为了保持二叉搜索树的平衡。保证时间复杂度稳定在o(logn)。</p>
<h4 id="unordered-map底层数据结构"><a href="#unordered-map底层数据结构" class="headerlink" title="unordered_map底层数据结构"></a>unordered_map底层数据结构</h4><p>unordered_map是无序容器，底层使用哈希表实现的。</p>
<h4 id="TCP握手为什么是三次握手，两次握手为什么不行呢"><a href="#TCP握手为什么是三次握手，两次握手为什么不行呢" class="headerlink" title="TCP握手为什么是三次握手，两次握手为什么不行呢"></a>TCP握手为什么是三次握手，两次握手为什么不行呢</h4><p>这里有两个大点，第一个字面意思很好理解，第二点举个例子就通透了，面试时最好全部答上来</p>
<ul>
<li><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤</p>
</li>
<li><p>防止已失效的连接请求又传送到服务器端，因而产生错误</p>
<p>只有采用三次握手可以减少服务端的资源浪费。解释如下：<br>例如，客户端向服务端发送请求同步报文A，因为网络阻塞等原因，服务端没有收到同步报文A，所以没有发送同步确认报文。过了一段时间，客户端没有收到服务端的确认报文，重新向服务端发送请求同步报文B，服务端接收到报文B后，向客户端发送同步确认报文，客户端接收到确认报文后，向服务端发送确认报文，建立连接。数据传输完毕后，连接断开。客户端进入close状态，此时服务端收到之前的报文A，向客户端返回同步确认报文。如果使用两次握手，服务端回应后不确认客户端的状态，连接建立成功。服务端会长时间等待客户端发送数据，连接长期保持，会造成资源浪费。当多个客户端产生这种情况，服务器就会等待多个客户端的响应，连接数量过多，之后的客户端请求，服务器无法响应。造成服务器处于瘫痪状态。<br>只有使用三次握手，当服务端收到确认报文后，保证当前时刻，客户端可以发送数据时，才能建立有意义的连接。当客户端一段时间不发送数据时，服务器应自动断开连接，来节省自身连接的客户端数量，减少资源的浪费。</p>
</li>
</ul>
<h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p>HTTP状态码是在HTTP协议中用于表示服务器对请求的处理结果的三位数字代码。HTTP状态码的分类如下：</p>
<ol>
<li><p>1xx（信息性状态码）：表示服务器已接收请求，需要客户端继续操作。</p>
</li>
<li><p>2xx（成功状态码）：表示服务器成功处理了请求。</p>
</li>
<li><p>3xx（重定向状态码）：表示请求需要进一步的操作，通常用于重定向。</p>
</li>
<li><p>4xx（客户端错误状态码）：表示客户端发出的请求有误。</p>
</li>
<li><p>5xx（服务器错误状态码）：表示服务器在处理请求时发生了错误。</p>
</li>
</ol>
<p>以下是一些常见的HTTP状态码示例：</p>
<ol>
<li><p>200 OK：请求成功，服务器成功处理了请求。</p>
</li>
<li><p>201 Created：请求成功，服务器已成功创建了资源。</p>
</li>
<li><p>204 No Content：请求成功，但服务器没有新的信息返回。</p>
</li>
<li><p>400 Bad Request：请求错误，服务器不理解或无法处理请求。</p>
</li>
<li><p>401 Unauthorized：请求需要用户认证，未提供有效的认证信息。</p>
</li>
<li><p>403 Forbidden：请求被服务器拒绝，没有访问权限。</p>
</li>
<li><p>404 Not Found：请求的资源不存在。</p>
</li>
<li><p>500 Internal Server Error：服务器内部错误，无法完成请求。</p>
</li>
<li><p>502 Bad Gateway：服务器作为网关或代理，从上游服务器收到无效的响应。</p>
</li>
<li><p>503 Service Unavailable：服务器暂时不可用，通常是由于过载或维护。</p>
</li>
</ol>
<p>这只是HTTP状态码中的一部分，实际中可能还会遇到其他状态码。状态码的具体含义可参考HTTP协议的官方文档或RFC文档。不同的状态码代表了服务器对请求的不同响应结果，客户端根据状态码可以做出相应的处理。</p>
<h4 id="使用智能指针了，普通指针还能用吗？"><a href="#使用智能指针了，普通指针还能用吗？" class="headerlink" title="使用智能指针了，普通指针还能用吗？"></a>使用智能指针了，普通指针还能用吗？</h4><p>个人觉得使用了智能指针后不推荐使用普通指针。因为使用了智能指针后，再使用普通指针指向相同对象，并不会增加引用计数，等智能指针引用计数变为0的时候，对象被销毁，此时普通指针就变为了野指针。</p>
<h4 id="什么时候使用智能指针，什么时候使用普通指针-（CHATGPT）"><a href="#什么时候使用智能指针，什么时候使用普通指针-（CHATGPT）" class="headerlink" title="什么时候使用智能指针，什么时候使用普通指针 （CHATGPT）"></a>什么时候使用智能指针，什么时候使用普通指针 （CHATGPT）</h4><p>使用智能指针还是普通指针取决于你的代码需求和内存管理需求。以下是一些指导原则：</p>
<p>使用智能指针的情况：</p>
<ol>
<li><p>动态分配内存：如果你需要动态分配内存，尤其是在使用<code>new</code>关键字时，最好使用智能指针来管理这些资源。智能指针会自动在不再需要时释放内存，避免了内存泄漏的问题。</p>
</li>
<li><p>所有权传递：当多个地方共享一个资源并且需要明确的所有权传递时，智能指针特别有用。例如，使用<code>std::shared_ptr</code>来共享资源，并在最后一个引用释放时自动删除资源。</p>
</li>
<li><p>异常安全：在使用普通指针的代码中，如果在动态分配资源后发生异常，可能会导致资源泄漏。使用智能指针可以更好地处理异常情况，确保资源在退出作用域时得到正确释放。</p>
</li>
<li><p>容器存储：如果要在STL容器中存储指针类型，建议使用智能指针。STL容器在元素添加或删除时可能会复制或移动元素，使用智能指针可以正确管理资源的所有权。</p>
</li>
</ol>
<p>使用普通指针的情况：</p>
<ol>
<li><p>接口和传统API：某些接口和传统的C API可能要求使用原始指针，此时你无法使用智能指针。在这种情况下，你应该小心管理内存，确保手动释放资源。</p>
</li>
<li><p>与C代码交互：当与C语言库或代码进行交互时，普通指针是常用的方式，因为C语言不支持智能指针。</p>
</li>
<li><p>临时指针：对于一些临时指针，其生命周期很短且不需要动态内存管理时，可以使用普通指针。</p>
</li>
<li><p>最低开销：在某些性能关键的场景，智能指针可能带来额外的开销，此时使用普通指针可能更合适。但请注意，在性能优化前确保使用智能指针没有影响到代码的正确性和可维护性。</p>
</li>
</ol>
<p>综上所述，智能指针在大多数情况下是推荐的内存管理方式，特别是在现代C++代码中。然而，有些特定的场景可能需要使用普通指针，但在这种情况下你需要格外小心以避免内存泄漏和悬挂指针问题。</p>
<h4 id="Hash-map原理"><a href="#Hash-map原理" class="headerlink" title="Hash_map原理"></a>Hash_map原理</h4><p>Hash_map基于Hash_map（哈希表）。</p>
<p>哈希表基本原理：使用一个下标范围较大的数组来储存元素。那我们怎么根据关键字知道它应该放在数组的哪个位置呢？这就通过哈希函数（散列函数）来解决。哈希函数使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应。但是，不能保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这就产生了哈希冲突。因此“直接定址”和“解决冲突”是哈希表的两大特点。</p>
<p>哈希冲突的解决主要有以下四种方法：开放地址法，再哈希法，链地址法和建立公共溢出区。关于这四种方法的解释见知乎链接 <a href="https://zhuanlan.zhihu.com/p/29520044">https://zhuanlan.zhihu.com/p/29520044</a></p>
<h4 id="C-多态介绍一下"><a href="#C-多态介绍一下" class="headerlink" title="C++多态介绍一下"></a>C++多态介绍一下</h4><p>C++多态主要包括重载、虚函数、模板。重载包括函数重载和运算符重载，编译期，即编译器在编译阶段就会根据函数调用的上下文来决定使用哪一个重载版本。虚函数是在运行期。重载和模板属于静态多态，虚函数属于动态多态。静态多态与动态多态靠编译期与运行期区分。</p>
<h4 id="虚函数、纯虚函数原理，虚表什么时候建立的https-zhuanlan-zhihu-com-p-37331092"><a href="#虚函数、纯虚函数原理，虚表什么时候建立的https-zhuanlan-zhihu-com-p-37331092" class="headerlink" title="虚函数、纯虚函数原理，虚表什么时候建立的	https://zhuanlan.zhihu.com/p/37331092"></a>虚函数、纯虚函数原理，虚表什么时候建立的	<a href="https://zhuanlan.zhihu.com/p/37331092">https://zhuanlan.zhihu.com/p/37331092</a></h4><ul>
<li>虚函数，在类成员方法的声明（不是定义）语句前加“virtual”，如virtual void func</li>
<li>纯虚函数，在虚函数后加“&#x3D;0”，如virtual void func &#x3D; 0</li>
<li>对于虚函数，子类可以（也可以不）重写基类的虚函数，该行为称之为override</li>
<li>对于纯虚函数，子类必须提供纯虚函数的个性化实现</li>
</ul>
<p>在派生子类中对虚函数和纯虚函数的个性化实现，都体现了多态特性，但区别在于：</p>
<ul>
<li>子类如果不提供虚函数的实现，将会自动调用基类的缺省虚函数实现</li>
<li>子类如果不提供纯虚函数的实现，将会编译失败</li>
</ul>
<p><strong>当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数则由指针指向的实际类型决定</strong></p>
<p>实现虚函数表的关键就是虚函数表指针，这个指针指向一张名为虚函数表的表，为表中的数据则为函数指针，存储了虚函数具体实现所对应的位置。另外，当一个类有多个虚函数时，仍然只有一个虚函数指针，而此时的虚函数表里会有多个<strong>函数指针</strong>，因此，虚函数实现的过程是：<strong>通过对象内存中的虚函数指针vptr找到虚函数表vtbl，再通过vtbl中的函数指针找到对应虚函数的实现区域并进行调用。</strong>所以虚函数的调用时由指针所指向内存块的具体类型决定的。</p>
<h4 id="构造函数和析构函数可以是虚函数吗？"><a href="#构造函数和析构函数可以是虚函数吗？" class="headerlink" title="构造函数和析构函数可以是虚函数吗？"></a>构造函数和析构函数可以是虚函数吗？</h4><p>答案是：构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。</p>
<p>首先，我们已经知道虚函数的实现则是通过对象内存中的vptr来实现的。而构造函数是用来实例化一个对象的，通俗来讲就是为对象内存中的值做初始化操作。那么在构造函数完成之前，也即还没有进行初始化，此时vptr是没有值的，也就无法通过vptr找到作为构造函数和虚函数所在的代码区，所以构造函数只能以普通函数的形式存放在类所指定的代码区中。</p>
<p>而对于析构函数，当我们delete(a)的时候，如果析构函数不是虚函数，那么调用的将会是基类base的析构函数。而当继承的时候，通常派生类会在基类的基础上定义自己的成员，此时我们当然希望可以调用派生类的析构函数对新定义的成员也进行析构。</p>
<h4 id="map为啥用红黑树不用avl树？"><a href="#map为啥用红黑树不用avl树？" class="headerlink" title="map为啥用红黑树不用avl树？"></a>map为啥用红黑树不用avl树？</h4><ul>
<li>平衡调整次数更少</li>
<li>内存使用更少：AVL树需要存储额外的平衡因子信息</li>
<li>更适合于频繁的插入和删除操作</li>
</ul>
<h4 id="怎么判断map里key值存不存在"><a href="#怎么判断map里key值存不存在" class="headerlink" title="怎么判断map里key值存不存在"></a>怎么判断map里key值存不存在</h4><p>c.at(k)	访问关键字为k的元素，如果k不在c中，返回一个out_of_range异常</p>
<p>c.find(k)	如果存在，返回一个迭代器，指向关键字为k的元素；如果不存在，返回尾后迭代器</p>
<p>c.count(k)	不存在返回0，存在返回k关键字的数量</p>
<h4 id="多进程通信方式"><a href="#多进程通信方式" class="headerlink" title="多进程通信方式"></a>多进程通信方式</h4><p>管道、命名管道、消息队列、信号量、共享内存、套接字、RPC</p>
<p>管道：一种最简单的进程间通信方式，通常用于父子进程间通信。管道中数据只能朝一个方向流动，即一方读另一方写。管道通过系统调用pipe()创建。</p>
<p>命名管道：一种更通用的进程间通信方式，它可以在无关的进程之间进行通信。不同于管道，命名管道通过文件系统中的路径名来标识。命名管道可以通过系统调用 <code>mkfifo()</code> 创建。</p>
<p>信号量：讲好sem_init(), sem_wait(), sem_post()系统整体运作过程就好了</p>
<p>套接字：服务器监听一个ip+端口，客户端访问连接</p>
<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><table>
<thead>
<tr>
<th align="left"></th>
<th align="center">TCP</th>
<th align="center">UDP</th>
</tr>
</thead>
<tbody><tr>
<td align="left">可靠性</td>
<td align="center">可靠</td>
<td align="center">不可靠</td>
</tr>
<tr>
<td align="left">连接</td>
<td align="center">面向连接</td>
<td align="center">无连接</td>
</tr>
<tr>
<td align="left">数据传输方式</td>
<td align="center">字节流</td>
<td align="center">数据报</td>
</tr>
<tr>
<td align="left">双工性</td>
<td align="center">全双工</td>
<td align="center">一对一、一对多、多对一、多对多</td>
</tr>
<tr>
<td align="left">流量控制</td>
<td align="center">滑动窗口</td>
<td align="center">无</td>
</tr>
<tr>
<td align="left">拥塞控制</td>
<td align="center">慢启动、拥塞避免、快速重传、快速回复</td>
<td align="center">无</td>
</tr>
<tr>
<td align="left">效率</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
<tr>
<td align="left">传输速度</td>
<td align="center">慢</td>
<td align="center">快</td>
</tr>
</tbody></table>
<h4 id="TCP-x2F-IP协议组"><a href="#TCP-x2F-IP协议组" class="headerlink" title="TCP&#x2F;IP协议组"></a>TCP&#x2F;IP协议组</h4><p>IP协议、TCP协议、UDP协议、ICMP协议、ARP协议、RARP协议</p>
<h4 id="OSI七层"><a href="#OSI七层" class="headerlink" title="OSI七层"></a>OSI七层</h4><p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<h4 id="socket编程recv函数"><a href="#socket编程recv函数" class="headerlink" title="socket编程recv函数"></a>socket编程recv函数</h4><p>返回0：对方关闭连接</p>
<p>返回相应的接收数据大小</p>
<p>返回错误码：传输出现错误</p>
<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>快排思想：选定基准元素，小的放一边，大的放一边，最后分治</p>
<h4 id="HTTP状态码-1"><a href="#HTTP状态码-1" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><ol>
<li>1XX - 信息状态码：<ul>
<li>100 Continue：服务端已经收到了客户端请求，继续发送剩余部分</li>
</ul>
</li>
<li>2XX - 成功状态码：<ul>
<li>200 OK：请求成功，服务器成功处理了请求</li>
<li>201 Created：请求成功，并创建了资源</li>
<li>204 No Content：请求成功，但没有返回内容</li>
</ul>
</li>
<li>3XX - 重定向状态码：<ul>
<li>301 Moved Permanently：永久重定向，请求的资源被永久移到了新位置</li>
<li>302 Found：临时重定向，请求的资源被临时移到了新位置</li>
<li>304 Not Modified：客户端缓存资源仍然有效，未修改</li>
</ul>
</li>
<li>4XX - 客户端错误状态码：<ul>
<li>400 Bad Request：客户端请求错误，服务器无法理解</li>
<li>401 Unauthorized：请求要求身份验证，客户端未提供有效的身份信息</li>
<li>403 Forbidden：服务器拒绝请求，没有访问权限</li>
<li>404 Not Found：请求的资源不存在</li>
</ul>
</li>
<li>5XX - 服务器错误状态码：<ul>
<li>500 Internet Server Error：服务器内部错误，无法完成请求</li>
<li>502 Bad Gateway：作为网关或代理的服务器从上游服务器收到无效响应</li>
<li>503 Service Unavailable：服务器暂时过载或维护中，无法处理请求</li>
<li>504 Gateway Timeout：作为网关或代理服务器未及时从上游服务器接收响应</li>
</ul>
</li>
</ol>
<h4 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h4><p>DNS就是域名解析服务，查询过程依次递增。本地域名解析（操作系统首先会查询本地DNS缓存） —–》本地域名服务器查询 —–》根域名服务器查询 —–》顶级域名服务器查询 —–》权威域名服务器查询 —–》返回结果。DNS查询和应答报文具有相同格式，主要区别在于某些字段的标识。下面讲几个重要的字段。</p>
<ul>
<li>16位标识：用于标记一对DNS查询和应答，以此区分一个DNS应答是哪一个DNS查询的回应</li>
<li>16位标志<ul>
<li>QR：查询报文（0）&#x2F;	应答报文（1）</li>
<li>opcode：标准查询（0）&#x2F;    反向查询（1）就是是通过域名获取ip地址还是通过ip地址获取域名</li>
</ul>
</li>
</ul>
<h4 id="TCP为什么需要四次挥手，三次挥手有什么问题"><a href="#TCP为什么需要四次挥手，三次挥手有什么问题" class="headerlink" title="TCP为什么需要四次挥手，三次挥手有什么问题"></a>TCP为什么需要四次挥手，三次挥手有什么问题</h4><ol>
<li>客户端最后一个ACK可能会丢失，这样服务端就无法正常进入CLOSED状态。于是B会重传请求释放的报文，而此时如果A已经关闭了，那就收不到B的重传请求，就会导致B无法正常释放。而如果A还在等待时间内，就会收到B的重传，然后进行应答，这样B就可以进入CLOSED状态</li>
<li>如果三次挥手的话，服务端收到来自客户端的FIN请求后，需要同时回复ACK和发送FIN断开连接请求。但是在TCP连接中是有一个半关闭状态的，也就是服务端其实还是可以继续发送数据的，如果三次挥手，就无法做到服务器再发送数据了。</li>
</ol>
<h4 id="TCP传输为什么是可靠的"><a href="#TCP传输为什么是可靠的" class="headerlink" title="TCP传输为什么是可靠的"></a>TCP传输为什么是可靠的</h4><ul>
<li>确认与重传：如果一定时间内未收到ACK，则会重传</li>
<li>序列号与顺序性：TCP为每一个数据包分配一个序列号，接收端会进行数据包重组</li>
<li>流量控制</li>
<li>拥塞控制</li>
<li>连接管理：三次握手与四次挥手</li>
<li>超时与重试</li>
</ul>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p>新建、就绪、运行、阻塞、等待、终止</p>
<h4 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h4><p>死锁发生的必要条件，通常被称为死锁的四个条件，分别是：</p>
<ol>
<li><strong>互斥条件（Mutual Exclusion）：</strong> 指某个资源在一段时间内只能被一个线程或进程占用，其他线程或进程需要等待资源释放才能继续执行。</li>
<li><strong>请求与保持条件（Hold and Wait）：</strong> 指线程在保持至少一个资源的同时，还请求其他资源，而这些资源可能被其他线程占用，导致请求阻塞。</li>
<li><strong>不剥夺条件（No Preemption）：</strong> 指资源只能由占有它的线程显式释放，其他线程不能强行抢占资源。</li>
<li><strong>循环等待条件（Circular Wait）：</strong> 指多个线程形成一个循环，每个线程都在等待下一个线程所持有的资源，导致一个闭环的等待状态。</li>
</ol>
<h4 id="死锁解决方案"><a href="#死锁解决方案" class="headerlink" title="死锁解决方案"></a>死锁解决方案</h4><ul>
<li>系统重新启动</li>
<li>撤销进程、剥夺资源</li>
<li>进程回退策略，即让参与死锁的进程回退到没有发生死锁前某一点处。</li>
</ul>
<h4 id="树的知识"><a href="#树的知识" class="headerlink" title="树的知识"></a>树的知识</h4><p><a href="https://oi-wiki.org/ds/bplus-tree/">https://oi-wiki.org/ds/bplus-tree/</a></p>
<h4 id="Linux-API调用返回值汇总"><a href="#Linux-API调用返回值汇总" class="headerlink" title="Linux API调用返回值汇总"></a>Linux API调用返回值汇总</h4><p>int pthread_create：成功时返回0，失败时返回错误码</p>
<p>void pthread_exit：不会失败</p>
<p>int pthread_join ( pthread_t thread, void** retval)：成功时返回0，失败时返回错误码。错误码：EDEADLK：可能引起死锁，比如两个线程互相针对对方调用pthread_join，或者线程对自身调用pthread_join；EINVAL：目标线程是不可回收的，或者已经有其他线程在回收该目标线程；ESRCH：目标线程不存在。</p>
<p>int sem_init( sem_t* sem, int pshared, unsigned int value )</p>
<p>int sem_destroy( sem_t* sem )</p>
<p>int sem_wait( sem_t* sem)</p>
<p>int sem_trywait( sem_t* sem )</p>
<p>int sem_post( sem_t* sem )：以上五个成功时返回0， 失败时返回-1并设置errno</p>
<h4 id="DNS的解析过程"><a href="#DNS的解析过程" class="headerlink" title="DNS的解析过程"></a>DNS的解析过程</h4><p>DNS是实现域名和IP地址相互映射的一个分布式数据库。DNS解析过程主要包括以下步骤</p>
<ol>
<li>本地缓存查询：当用户通过浏览器访问某域名时，浏览器会首先在自己的缓存里查询是否有该域名对应的IP地址。</li>
<li>本地系统查询：查看本计算机系统Host文件DNS缓存是否有对应DNS缓存</li>
<li>查看路由器缓存</li>
<li>查询ISP DNS缓存：也称本地域名服务器查询，计算机会向你的ISP（互联网服务提供商）分配的本地域名服务器发出查询请求</li>
<li>根域名服务器</li>
<li>顶级域名服务器：根域名服务器并不会直接返回用户IP地址，而是会指向查询请求对应的顶级域名服务器</li>
<li>权威域名服务器：顶级域名服务器会指向域名的权威域名服务器，这些服务器管理特定的域名的DNS服务。</li>
</ol>
<h4 id="TCP传输为什么是可靠的-1"><a href="#TCP传输为什么是可靠的-1" class="headerlink" title="TCP传输为什么是可靠的"></a>TCP传输为什么是可靠的</h4><p>总结下来主要包括三个方面：</p>
<ul>
<li>检验和</li>
<li>确认应答（ACK和序列号一应一答）</li>
<li>超时重传</li>
</ul>
<h4 id="NAT协议和跨域（不了解）"><a href="#NAT协议和跨域（不了解）" class="headerlink" title="NAT协议和跨域（不了解）"></a>NAT协议和跨域（不了解）</h4><h4 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h4><p>最明显的一个区别就是GET请求会把参数放在URL（统一资源定位符）中，POST会把参数放在请求体中。</p>
<p>数据大小限制：GET请求把参数放在URL中，GET请求数据大小收到URL长度限制。POST请求则不会</p>
<p>幂等性：GET请求每次相同请求返回的结果都一样，多次重复请求不会对资源产生影响。POST请求则相反</p>
<p>安全性：POST更安全，参数没有暴露在URL上</p>
<p>缓存：GET请求可以被浏览器缓存，POST请求不会被浏览器缓存</p>
<h4 id="写一段死锁的代码"><a href="#写一段死锁的代码" class="headerlink" title="写一段死锁的代码"></a>写一段死锁的代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_a;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">another</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in child thread, get mutex a\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_b);</span><br><span class="line">    b += a;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_b);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_a, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_b, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;id, <span class="literal">NULL</span>, another, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in parent thread, get mutex b\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    ++b;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_a);</span><br><span class="line">    a += b;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pro is end\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="删除字符串头尾空格代码"><a href="#删除字符串头尾空格代码" class="headerlink" title="删除字符串头尾空格代码"></a>删除字符串头尾空格代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::string tmp;</span><br><span class="line">    <span class="built_in">getline</span>(std::cin, s);   <span class="comment">//这里很重要哦，如果用cin，“hello world”会被截断成hello</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = s.<span class="built_in">substr</span>(i, s.<span class="built_in">size</span>() - i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = s.<span class="built_in">substr</span>(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="shared-ptr是线程安全的吗？https-cloud-tencent-com-developer-article-1654442"><a href="#shared-ptr是线程安全的吗？https-cloud-tencent-com-developer-article-1654442" class="headerlink" title="shared_ptr是线程安全的吗？https://cloud.tencent.com/developer/article/1654442"></a>shared_ptr是线程安全的吗？<a href="https://cloud.tencent.com/developer/article/1654442">https://cloud.tencent.com/developer/article/1654442</a></h4><ul>
<li>多线程同时读一个shared_ptr对象是安全的</li>
<li>多线程同时对一个shared_ptr对象进行读和写是不安全的，需要加锁</li>
</ul>
<p>这里给出一个伪代码的简单例子</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;Foo&gt; g(new Foo1);   // 线程之间共享的shared_ptr</span><br><span class="line">shared_ptr&lt;Foo&gt; x;   		  // 线程A的局部变量</span><br><span class="line">shared_ptr&lt;Foo&gt; n(new Foo2);   // 线程B的局部变量</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">线程A</span><br><span class="line">x = g;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">线程B</span><br><span class="line">g = n;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">测试场景：</span><br><span class="line"></span><br><span class="line">线程A </span><br><span class="line">  智能指针x 读取Foo1,然后还重置Foo1计数。</span><br><span class="line"></span><br><span class="line">线程 B:</span><br><span class="line"> 销毁了Foo1</span><br><span class="line">线程A</span><br><span class="line">重置计数时，foo1已经被销毁。</span><br></pre></td></tr></table></figure>



<h4 id="mysql读写锁怎么实现-mysql-读写锁和互斥锁的区别https-blog-51cto-com-u-16099299-7031260"><a href="#mysql读写锁怎么实现-mysql-读写锁和互斥锁的区别https-blog-51cto-com-u-16099299-7031260" class="headerlink" title="mysql读写锁怎么实现 mysql 读写锁和互斥锁的区别	https://blog.51cto.com/u_16099299/7031260"></a>mysql读写锁怎么实现 mysql 读写锁和互斥锁的区别	<a href="https://blog.51cto.com/u_16099299/7031260">https://blog.51cto.com/u_16099299/7031260</a></h4><ul>
<li>请你讲述一下互斥锁机制，以及互斥锁和读写锁的区别<ul>
<li>互斥锁（mutex），用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</li>
<li>读写锁（rwlock），分为读锁和写锁。处于读操作的时候，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其他获得写锁失败的线程将会进入睡眠状态，直到写锁释放时被唤醒。注意;写锁会阻塞其他读写锁。当有一个线程获得写锁在写时，读锁也不能被其他线程获取；写者优于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。<br>读写锁：区分读者和写者，而互斥锁不区分，互斥锁只允许同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。</li>
</ul>
</li>
<li>Linux中的四种锁机制<ul>
<li>互斥锁：在同一时间内只允许一个线程访问对象</li>
<li>读写锁：同一时间内允许多个读者同时读对象，同一时间内只允许一个写者访问对象，且当有一个线程获得写操作的时候，读锁也不能被其他的线程获取，写者优于读者，唤醒时先唤醒写者。</li>
<li>自旋锁：在任何时刻内自能有一个线程访问资源，但是当获取锁操作失败时，不会进入睡眠状态而是会原地自旋，直到锁被释放，这样减少了线程从睡眠状态到被唤醒状态的资源消耗，在加锁时间短暂的情况下使用会提高效率。但是加锁时间过长会非常浪费CPU</li>
<li>RCU（read-copy-update）：在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改，然后在将老数据update成新数据。在RCU的时候读者几乎不需要同步开销，即不需要获取锁，也不适用原子指令，不会导致竞争因此不用考虑死锁问题了。但是对于写者的同步开销比较大，他需要复制被修改的数据，还必须使用锁机制同步并行其他写者的改操作，在有大量读操作，少量写操作的时候使用。</li>
</ul>
</li>
</ul>
<h4 id="delete关键字的作用"><a href="#delete关键字的作用" class="headerlink" title="delete关键字的作用"></a>delete关键字的作用</h4><ol>
<li><p>删除特殊的成员函数：在C++11中可以使用delete来显示的阻止编译器自动生成某些特殊的成员函数。通过在类的声明中将这些特殊函数标记为delete，可以防止这些函数隐式的生成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() = <span class="keyword">delete</span>; <span class="comment">// 阻止生成默认构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp;) = <span class="keyword">delete</span>; <span class="comment">// 阻止生成拷贝构造函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除特定的函数重载：在函数重载时，可以使用delete关键字来标记某个特定的函数重载，防止特定的重载函数被调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">(<span class="type">double</span> x)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// 阻止调用带有 double 参数的函数</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="define和const的区别"><a href="#define和const的区别" class="headerlink" title="define和const的区别"></a>define和const的区别</h4><ul>
<li>就起作用的阶段而言：#define是在编译的预处理阶段起作用，而const是在编译、运行时起作用；</li>
<li>就起作用的方式而言：#define只是简单的字符串替换，没有类型检查，而const有类型检查，避免相应的错误；</li>
<li>就存储方式而言：#define只是进行展开，有多少地方使用，就有多少替换。const定义的只读变量在程序运行过程中只有一份备份；</li>
</ul>
<h4 id="写时拷贝（COW）https-www-cnblogs-com-biyeymyhjob-archive-2012-07-20-2601655-html"><a href="#写时拷贝（COW）https-www-cnblogs-com-biyeymyhjob-archive-2012-07-20-2601655-html" class="headerlink" title="写时拷贝（COW）	https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html"></a>写时拷贝（COW）	<a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html">https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html</a></h4><p>在linux里，fork（）会产生一个子进程，子进程与父进程用的是相同的物理空间，也就是说两者的虚拟空间不同，但对应的物理空间是一个。当父&#x2F;子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。这里的相应段你能理解不？其实就是一个程序一般分为哪些段，主要可以分为四大段：栈、堆、数据段、代码段；再细分的话可以加一个bss段，也就是用于存放程序中未初始化的全局变量的一块内存区域。</p>
<p>还有一个细节问题就是，fork之后内核会将子进程放在队列的前面，以让子进程先执行，以免父进程执行导致写时复制，造成不必要的复制，导致效率的下降。可以这么理解，可能子进程执行的代码并不需要写，完全可以使用原共享段，而父进程反而会改变（fork之后），如果父进程先执行，则子进程就要COW。</p>
<h4 id="coredump，gdb怎么定位"><a href="#coredump，gdb怎么定位" class="headerlink" title="coredump，gdb怎么定位"></a>coredump，gdb怎么定位</h4><p>整体流程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -g source.cpp -o <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./source</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb ./source ./core</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">where(在gdb下输入)</span><br></pre></td></tr></table></figure>



<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><code>epoll</code></h4><p>关于<code>epoll</code>问题在这暂且不多写，只需记住内核事件表，<code>select</code>和<code>poll</code>都是轮询，事件复杂度：<code>epoll（o1）</code>，其他<code>（on）</code>。</p>
<p><code>select</code>和<code>poll</code>必须遍历内核事件表上所有已注册的文件描述符以找到其中的就绪者；<code>epoll</code>仅遍历就绪的文件描述符。</p>
<h4 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用"></a>static的作用</h4><ol>
<li><p>在函数体内，被声明为静态的变量在这一函数被调用过程中维持其值不变。</p>
<p>这句话其实是想说如果在函数内部声明了一个静态变量，那么这个变量在函数调用期间不会被重新初始化。它的生命周期是从程序开始到程序结束，但其作用域仍然限制在该函数内。这里给一段示例代码最好理解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    num++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num is: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">count</span>();	<span class="comment">// num = 1</span></span><br><span class="line">    <span class="built_in">count</span>();	<span class="comment">// num = 2 正常情况下，如果是非static，num会被重新置0，但这里并没有体现出来。</span></span><br><span class="line">    <span class="built_in">count</span>();	<span class="comment">// num = 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其他函数访问。它是一个本地的全局变量。</p>
<p>这句话就是表面意思，很好理解，这里给一个代码帮助理解</p>
<p><strong>moduleA.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> secretValue = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSecretValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; secretValue &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifySecretValue</span><span class="params">(<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">    secretValue = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>moudleB.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">printSecretValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">modifySecretValue</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printSecretValue</span>();</span><br><span class="line">    <span class="built_in">modifySecretValue</span>(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; secretValue &lt;&lt; std::endl; </span></span><br><span class="line">    <span class="comment">// 记住，这句话是会导致编译错误的，模块B不能直接访问模块A的变量。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在模块内，一个被声明为静态的函数只可被本模块内的其他函数调用。也就是，这个函数被限制在声明它的模块的本地范围内使用。</p>
<p>这里的意思其实就和第二点差不多了，也给一个简单示例代码吧</p>
<p><strong>moduleA.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个静态函数，只在moduleA.cpp中可见</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">secretFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside secret function of moduleA!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公开的函数，可以被其他模块调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">publicFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside public function of moduleA.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">secretFunction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>moduleB.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">publicFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">publicFunction</span>();  <span class="comment">// 可以调用这个函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能调用 secretFunction，因为它在moduleA.cpp中是静态的</span></span><br><span class="line">    <span class="comment">// secretFunction();  // 这一行会导致编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>moduleA.cpp</code>定义了一个静态函数<code>secretFunction</code>。在<code>moduleB.cpp</code>中，我们可以调用<code>publicFunction</code>，但当我们尝试调用<code>secretFunction</code>时，会导致编译错误，因为<code>secretFunction</code>只在<code>moduleA.cpp</code>中可见。</p>
</li>
</ol>
<h4 id="有关static的必要补充"><a href="#有关static的必要补充" class="headerlink" title="有关static的必要补充"></a>有关static的必要补充</h4><ul>
<li><p>修饰成员变量</p>
<p>用static修饰类的数据成员，使其成为类的全局变量，会被类的所有对象共享，包括派生类对象。<strong>所有对象只维持同一个实例。</strong>因此类的static成员必须进行类外初始化，而不能在构造函数内进行初始化，不过也可以用const修饰static数据成员在类内初始化。因为const修饰的变量无法修改。</p>
</li>
<li><p>修饰成员函数</p>
<p>用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针，因而只能访问static成员变量。<strong>注意</strong>：正是因为static修饰的成员函数不含this指针，而const修饰的成员函数会添加一个隐藏的参数const this*，所以这两种语义是矛盾的，所以在成员函数上不能同时用他们。</p>
</li>
<li><p>this指针理解</p>
<p>对象就是大房子，成员就是房子里的物件，this是一个指着房子的指针，如果要获取对象的成员也就是大房子内的物件，需要使用this指针加-&gt;这个符号。</p>
</li>
</ul>
<h4 id="三种智能指针"><a href="#三种智能指针" class="headerlink" title="三种智能指针"></a>三种智能指针</h4><p>智能指针是在栈中的一个类，用于管理堆上分配的内存。传统的C&#x2F;C++对于堆上内存的开辟释放，需要程序手动管理，而智能指针是一个类，有构造函数和析构函数，在超出作用范围后，程序会自动调用析构函数释放其管理的指针指向的内存，不需要手动释放。</p>
<ul>
<li>shared_ptr	共享智能指针，多个智能指针可以指向同一个对象，对象的资源在最后一个指针销毁时释放，通过引用计数来判断是否是最后一个智能指针。</li>
<li>unique_ptr	独占智能指针，同一时刻只有一个智能指针可以指向该对象，如果要安全重用该指针，标准库函数std::move()可以将unique_ptr赋值给另一个unique_ptr。</li>
<li>weak_ptr      弱智能指针，不会增加shared_ptr的引用计数，可以避免两个shared_ptr相互引用的死锁问题。weak_ptr只能用shared_ptr或者另一个weak_ptr构造，通过lock()方法weak_ptr可以转化为shared_ptr。</li>
</ul>
<p>下面给出代码示例</p>
<p><strong>unique_ptr</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string str;</span><br><span class="line">    ~<span class="built_in">test</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;test::~test()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> test())</span></span>;</span><br><span class="line">    p1-&gt;str = <span class="string">&quot;test string&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1-&gt;str: &quot;</span> &lt;&lt; p1-&gt;str &lt;&lt; std::endl;</span><br><span class="line">    std::unique_ptr&lt;test&gt; p2;</span><br><span class="line">    p2 = std::<span class="built_in">move</span>(p1);</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; p1-&gt;str &lt;&lt; std::endl; p1此时已经访问不到资源了</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p2-&gt;str: &quot;</span> &lt;&lt; p2-&gt;str &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// p1-&gt;str: test string</span></span><br><span class="line"><span class="comment">// p2-&gt;str: test string</span></span><br><span class="line"><span class="comment">// test::~test() 析构函数发生了调用，自动释放资源</span></span><br></pre></td></tr></table></figure>

<p><strong>shared_ptr</strong>造成的死锁问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; a;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;A&gt; b;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::~B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*******前边两个类中相互引用，此时引入weak_ptr解决死锁问题*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    p1-&gt;a = p2;</span><br><span class="line">    p2-&gt;b = p1;<span class="comment">//这种情况发生死锁,两个shared_ptr计数都不会为0，资源不会被释放</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count():&quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count():&quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体解释一下死锁的产生主要原因是引用计数无法降为0。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">首先，来理解下为什么这种情况会导致资源不能被释放：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 当你创建`p1`和`p2`时，它们都有一个引用计数为1。</span></span><br><span class="line"><span class="comment">2. 当执行`p1-&gt;a = p2;`，`p2`的引用计数增加到2，因为现在有两个`shared_ptr`对象（`p1-&gt;a`和`p2`）指向同一个`B`对象。</span></span><br><span class="line"><span class="comment">3. 当执行`p2-&gt;b = p1;`，`p1`的引用计数增加到2，因为现在有两个`shared_ptr`对象（`p2-&gt;b`和`p1`）指向同一个`A`对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">到此，我们得到了一个环状结构：`p1`指向`A`对象，`A`对象内部的`shared_ptr`指向`B`对象，`B`对象内部的`shared_ptr`又指向`A`对象。这就形成了循环引用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当`main`函数返回时，`p1`和`p2`的析构函数将被调用，但是它们的引用计数都不会降为0，因为循环引用。所以，`A`和`B`对象的析构函数永远不会被调用，这就导致了资源泄漏。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">要解决这个问题，可以使用`weak_ptr`来打破循环引用。你可以将其中一个类的`shared_ptr`成员变量替换为`weak_ptr`。这样，`weak_ptr`不会增加引用计数，从而避免了循环引用的问题。当你需要从`weak_ptr`获取一个`shared_ptr`时，可以使用`lock`方法。</span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></figure>

<p><strong>weak_prt</strong>解决循环引用问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; a;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    weak_ptr&lt;A&gt; b;  <span class="comment">// 将 shared_ptr 替换为 weak_ptr</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::~B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line">    p1-&gt;a = p2;</span><br><span class="line">    p2-&gt;b = p1;  <span class="comment">// 这里不会增加 p1 的引用计数</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 use_count(): &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 输出 1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2 use_count(): &quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 当 main 返回时，p1 和 p2 都会被析构，它们所指向的对象也会被正确地销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="STL内存池机制"><a href="#STL内存池机制" class="headerlink" title="STL内存池机制"></a>STL内存池机制</h4><ul>
<li><p>第一级配置器</p>
<p>第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。</p>
</li>
<li><p>第二级配置器</p>
<p>在STL的第二级配置器中多了一些机制，避免太多小区造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。</p>
<p>如果要分配的区块大于128bytes，则移交给第一级配置器处理。<br>如果要分配的区块小于128bytes，则以 内存池管理（memory pool），又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。</p>
<p>参考连接：<a href="https://blog.csdn.net/a987073381/article/details/52245795">https://blog.csdn.net/a987073381/article/details/52245795</a></p>
</li>
</ul>
<h4 id="索引选B-树的原因"><a href="#索引选B-树的原因" class="headerlink" title="索引选B+树的原因"></a>索引选B+树的原因</h4><p>个人感觉主要就是探讨B+树和B树之间的区别。<br>参考链接：<a href="https://www.cnblogs.com/JCpeng/p/15231338.html">https://www.cnblogs.com/JCpeng/p/15231338.html</a></p>
<h4 id="服务端TIME-WAIT过多的危害及解决办法"><a href="#服务端TIME-WAIT过多的危害及解决办法" class="headerlink" title="服务端TIME_WAIT过多的危害及解决办法"></a>服务端TIME_WAIT过多的危害及解决办法</h4><p>危害</p>
<ul>
<li>导致大量socket连接端口被占用无法释放，导致系统停转</li>
<li>处理大量的TIME_WAIT状态的连接会占用更多的CPU时间，导致服务器响应时间增加</li>
</ul>
<p>解决办法</p>
<ul>
<li>调整系统内核参数</li>
<li>调整短连接为长连接</li>
</ul>
<h4 id="set底层数据结构"><a href="#set底层数据结构" class="headerlink" title="set底层数据结构"></a>set底层数据结构</h4><p>set底层数据结构是红黑树。关于map和set的一些问题列举如下：</p>
<p><strong>为何map和set的插入删除效率比用其他序列容器高？</strong><br>因为对于关联容器来说，不需要做内存拷贝和内存移动。因为map和set容器内部所有元素都是以节点的方式来存储，父节点和子节点。因此插入和删除的时候都是指针的指向换来换去，并没有内存移动。</p>
<p><strong>为何每次插入&#x2F;删除后以前保存的迭代器不会失效</strong><br>在这里，迭代器就相当于指向节点的指针，内存没有变，指向内存的指针当然不会失效。不同于map&#x2F;set，vector就会失效，比如需要扩容的时候，需要一块更大的内存，就必须把之前的内存释放，申请更大的内存，复制已有的数据元素到新的内存。</p>
<p><strong>为何map和set不能像vector一样有个reserve函数来预分配数据</strong><br>不懂！预留本问题</p>
<p><strong>当数据元素增多时（10000到20000个比较），map和set的插入和搜索速度变化如何？</strong><br>map和set使用的是二分查找，举例来说就是，16个元素查四次，32个元素查5次，10000个也就是14次，20000也就15次。</p>
<h4 id="mapreduce原理（不懂，预留）"><a href="#mapreduce原理（不懂，预留）" class="headerlink" title="mapreduce原理（不懂，预留）"></a>mapreduce原理（不懂，预留）</h4><h4 id="socket哪些操作会产生阻塞"><a href="#socket哪些操作会产生阻塞" class="headerlink" title="socket哪些操作会产生阻塞"></a>socket哪些操作会产生阻塞</h4><p>accept()：在等待客户端的连接请求时会阻塞。如果没有客户端尝试连接，调用这个函数的进程或者线程会被挂起。</p>
<p>connect()：当客户端尝试与远程主机建立连接时，此操作会阻塞，知道连接成功或失败</p>
<p>recv()：当数据从网络到达时，如果没有数据可读，函数调用就会被挂起，阻塞</p>
<p>send()：当发送缓冲区已满，并且无法接受更多数据发送到网络时，操作阻塞。</p>
<h4 id="申请一块大内存和一块小内存的效率是一样的吗？"><a href="#申请一块大内存和一块小内存的效率是一样的吗？" class="headerlink" title="申请一块大内存和一块小内存的效率是一样的吗？"></a>申请一块大内存和一块小内存的效率是一样的吗？</h4><p>不一样，申请一块小内存通常是不需要一级配置器，小块内存通常由内存分配器从预先分配的内存池中分配，这些池被称为<code>bins</code>，这种分配通常非常快，因为它只是涉及到从已存在的内存池中返回一个指针。大的内存通常要调用<code>mmap()</code>。</p>
<h4 id="TCP慢启动和拥塞控制"><a href="#TCP慢启动和拥塞控制" class="headerlink" title="TCP慢启动和拥塞控制"></a>TCP慢启动和拥塞控制</h4><p>TCP连接建立好之后，CWND（congestion window，拥塞窗口）被设置为初始值IW（initial window），其大小为2~4个SMSS（TCP报文段的最大长度，仅指数据部分），新的linux内核加大了这个值。此时发送端最多能发送IW字节的数据，此后发送端每收到一个确认，CWND就按照如下公式增长：<br>$$<br>CWND +&#x3D; min(N, SMSS)<br>$$<br>其中N是此次确认中包含的之前未被确认的字节数。<br>如果不施加其他手段，慢启动必然使得CWND增长的很快，所以TCP拥塞控制中有另外一个非常重要的变量：慢启动门限。当CWND超过慢启动门限值时，TCP将进入拥塞避免阶段。</p>
<h4 id="发送端判断发生拥塞的依据"><a href="#发送端判断发生拥塞的依据" class="headerlink" title="发送端判断发生拥塞的依据"></a>发送端判断发生拥塞的依据</h4><ul>
<li>传输超时</li>
<li>接收到重复的确认报文段</li>
</ul>
<h4 id="Linux下的POSIX互斥锁和条件变量"><a href="#Linux下的POSIX互斥锁和条件变量" class="headerlink" title="Linux下的POSIX互斥锁和条件变量"></a>Linux下的POSIX互斥锁和条件变量</h4><p>牢记这几个函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">pthread_mutex_destory(&amp;mutex);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">pthread_mutex_trylock(&amp;mutex);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pthread_cond_init(&amp;cond, NULL);</span><br><span class="line">pthread_cond_destory(&amp;cond);</span><br><span class="line">pthread_cond_broadcast(&amp;cond);</span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);</span><br></pre></td></tr></table></figure>

<p>条件变量要配合互斥锁使用。这里挂一个讲的比较清晰明了的博客链接（<a href="https://punmy.cn/2018/06/07/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condition%20Variables%EF%BC%89.html%EF%BC%89%EF%BC%8C%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E5%8A%A0%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B">https://punmy.cn/2018/06/07/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condition%20Variables%EF%BC%89.html），下面是使用互斥锁加条件变量实现的生产者-消费者模型</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mutex_;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span> condition_;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_t</span> notifying_thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;condition_, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;condition_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span> *args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">    <span class="keyword">while</span>(value != <span class="number">10</span>)&#123;</span><br><span class="line">        value++;</span><br><span class="line">    &#125;</span><br><span class="line">    notifying_thread = <span class="built_in">pthread_self</span>();</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;condition_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">    <span class="keyword">while</span>(value != <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;condition_, &amp;mutex_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value is 10, the pthread is: %lu\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)notifying_thread);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">consumer</span><span class="params">(<span class="type">void</span> *args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">waitCondition</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> a1;</span><br><span class="line">    <span class="type">pthread_t</span> a2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;a1, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;a2, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(a1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(a2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">destory</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="写一个生产者-x2F-消费者模型（采用信号量）"><a href="#写一个生产者-x2F-消费者模型（采用信号量）" class="headerlink" title="写一个生产者&#x2F;消费者模型（采用信号量）"></a>写一个生产者&#x2F;消费者模型（采用信号量）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_BUFFERS = <span class="number">10</span>;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> empty;</span><br><span class="line"><span class="type">sem_t</span> full;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        num = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;empty);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">        buffer.<span class="built_in">push</span>(num);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">comsumer</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;full);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">        num = buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Comsumed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> proThread, comPthread;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;empty, <span class="number">0</span>, MAX_BUFFERS);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;full, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;proThread, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;comPthread, <span class="literal">NULL</span>, comsumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(proThread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(comPthread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;empty);</span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;full);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="基类的析构函数为什么是虚函数"><a href="#基类的析构函数为什么是虚函数" class="headerlink" title="基类的析构函数为什么是虚函数"></a>基类的析构函数为什么是虚函数</h4><p>当基类的析构函数不是虚函数可能会导致派生类对象的析构函数不被调用。从而引发资源泄露或者其他未定义行为。下面给出示例代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base obj is constructed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="comment">// ~Base() &#123; std::cout &lt;&lt; &quot;Base obj is deconstructed&quot; &lt;&lt; std::endl; &#125;</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base obj is deconstructed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()&#123;</span><br><span class="line">        num_ = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived is constructed&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Derived</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived is deconstructed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *num_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base *base = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）"><a href="#为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）" class="headerlink" title="为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）"></a>为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）</h4><p>当一个基类没有虚析构函数，并且通过基类指针删除一个派生类对象时，只有基类的析构函数会被调用。这是因为编译器在编译时期决定了调用哪个析构函数，而不是在运行时期，这种机制被称为“静态绑定”。</p>
<p>如果基类的析构函数是虚函数，那么编译器会在运行时决定要调用哪个析构函数，这种机制称为“动态绑定”或“多态”。</p>
<h4 id="拷贝构造函数为什么要用引用"><a href="#拷贝构造函数为什么要用引用" class="headerlink" title="拷贝构造函数为什么要用引用"></a>拷贝构造函数为什么要用引用</h4><p>避免拷贝构造函数无限递归下去！那传引用为什么行呢？回忆一下引用定义，传引用人家根本就不会涉及到构造函数这玩意，形参相当于实参的一个别名。</p>
<h4 id="左右值的差别"><a href="#左右值的差别" class="headerlink" title="左右值的差别"></a>左右值的差别</h4><h4 id="C-中的虚继承"><a href="#C-中的虚继承" class="headerlink" title="C++中的虚继承"></a>C++中的虚继承</h4><p>c++中的虚继承主要是为了解决多继承情况中存在的二义性问题。比如，现在类A为基类，类B和类C继承自类A，类D继承自类B和类C，假设此时A中有一个名为x的变量且B和C都定义了x，如果此时D直接访问x会产生二义性问题。因为不清楚是A-&gt;B-&gt;D还是A-&gt;C-&gt;D。此时如果让类B和类C虚继承自A，就使得在派生类中只保留有一份成员变量x，解决了二义性问题。<br>参考链接：<br><a href="http://c.biancheng.net/view/2280.html">http://c.biancheng.net/view/2280.html</a><br><a href="https://zhuanlan.zhihu.com/p/41309205%EF%BC%88%E8%99%9A%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E9%83%BD%E8%AE%B2%E4%BA%86%EF%BC%8C%E5%8D%81%E5%88%86%E8%AF%A6%E7%BB%86%EF%BC%89">https://zhuanlan.zhihu.com/p/41309205（虚继承、虚函数都讲了，十分详细）</a></p>
<h4 id="C-中的forward函数"><a href="#C-中的forward函数" class="headerlink" title="C++中的forward函数"></a>C++中的forward函数</h4><p>左值引用和右值引用的结果都是左值，无法通过引用区分原本变量的左右值，forward可以保持变量的原本的左右值属性，帮助我们区分。</p>
<h4 id="如何判断TCP断开"><a href="#如何判断TCP断开" class="headerlink" title="如何判断TCP断开"></a>如何判断TCP断开</h4><ol>
<li>发送心跳消息</li>
<li>利用recv&#x2F;send函数的返回值<ul>
<li>recv返回0代表对方关闭了连接</li>
<li>recv返回-1并且errno&#x3D;&#x3D;EAGAIN或者EWOULDBLOCK时，表示没有数据可读，可以稍后再试。</li>
<li><strong>send返回非负值</strong>:<ul>
<li><code>send</code>返回的是实际发送的字节数，这可能会少于你请求发送的字节数（缓冲区已满）。</li>
<li>如果没有可用的缓冲区空间，那么在非阻塞模式下，<code>send</code>可能会返回<code>EAGAIN</code>或<code>EWOULDBLOCK</code>。</li>
</ul>
</li>
<li><strong>send返回-1</strong>:<ul>
<li>与<code>recv</code>类似，这表示出现了错误。</li>
<li>可以使用<code>perror</code>、<code>strerror</code>或检查<code>errno</code>来确定具体的错误原因。</li>
<li>常见的错误原因包括<code>EPIPE</code>（对端已关闭，本端仍尝试发送数据导致的”Broken pipe”错误）和<code>ECONNRESET</code>（连接被对端重置）。</li>
</ul>
</li>
</ul>
</li>
<li>利用tcp自带的keepalive机制</li>
</ol>
<h4 id="如何查看系统的最大进程数和线程数"><a href="#如何查看系统的最大进程数和线程数" class="headerlink" title="如何查看系统的最大进程数和线程数"></a>如何查看系统的最大进程数和线程数</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/kernel/pid_max    # 最大进程数</span><br><span class="line">cat /proc/sys/kernel/threads-max	# 最大线程数</span><br></pre></td></tr></table></figure>



<h4 id="git-rebase和git-merge的区别（https-joyohub-com-2020-04-06-git-rebase-）"><a href="#git-rebase和git-merge的区别（https-joyohub-com-2020-04-06-git-rebase-）" class="headerlink" title="git rebase和git merge的区别（https://joyohub.com/2020/04/06/git-rebase/）"></a>git rebase和git merge的区别（<a href="https://joyohub.com/2020/04/06/git-rebase/%EF%BC%89">https://joyohub.com/2020/04/06/git-rebase/）</a></h4><h4 id="C-calss-和-struct的区别"><a href="#C-calss-和-struct的区别" class="headerlink" title="C++ calss 和 struct的区别"></a>C++ calss 和 struct的区别</h4><p>class默认访问类型是private，struct默认访问类型是public</p>
<h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><ol>
<li>指针是一个变量，它保存了另一个变量的内存地址；引用是另一个变量的别名，与原变量共享内存地址。</li>
<li>指针可以被重新赋值，指向新的对象；引用绑定对象后不能更改。</li>
<li>指针可以为nullptr；引用必须初始化。</li>
</ol>
<h4 id="为什么模板类的声明和实现不能分别写在-h文件和-cpp文件中"><a href="#为什么模板类的声明和实现不能分别写在-h文件和-cpp文件中" class="headerlink" title="为什么模板类的声明和实现不能分别写在.h文件和.cpp文件中"></a>为什么模板类的声明和实现不能分别写在.h文件和.cpp文件中</h4><p>首先，模板不是传统意义上的代码。它更像是编译器的“代码生成工具”。当你使用一个特定的模板类型（例如<code>std::vector&lt;int&gt;</code>)，<strong>编译器会为你生成这种类型的实例代码</strong>。为了做到这一点，编译器需要能够看到模板的完整定义。注意：这就是模板和普通类的最大区别。普通类在编译阶段并没有（并不依赖于）编译时的类型特化，只需要在链接阶段将所有.cpp文件链接在一起就好了。而如果模板分开写，其他使用模板的.cpp文件在编译时找不到定义，导致链接错误。</p>
<h4 id="动态链接与静态链接"><a href="#动态链接与静态链接" class="headerlink" title="动态链接与静态链接"></a>动态链接与静态链接</h4><p>静态链接（.a&#x2F;.lib）：把要调用的函数或者过程链接到可执行文件中，成为可执行文件的一部分。如果多个程序使用相同的库，那么该库的代码在每个程序中都会被复制，这浪费了磁盘和内存空间。但是所有代码都在可执行文件中，没有运行时链接开销。</p>
<p>动态链接（.so&#x2F;.ddl）：动态链接所调用的函数代码并没有被拷贝到应用程序的可执行文件中去，而是仅仅在其中加入了所调用函数的描述信息（往往是一些重定位信息）。仅当应用程序被装入内存开始运行时，在Windows的管理下，才在应用程序与相应的DLL之间建立链接关系。当要执行所调用DLL中的函数时，根据链接产生的重定位信息，Windows才转去执行DLL中相应的函数代码。多份代码可以共享同一份库代码。</p>
<h4 id="pragma-pack编译宏"><a href="#pragma-pack编译宏" class="headerlink" title="pragma pack编译宏"></a>pragma pack编译宏</h4><p>pragma pack用于指定内存对齐值。</p>
<h4 id="vector底层实现原理"><a href="#vector底层实现原理" class="headerlink" title="vector底层实现原理"></a>vector底层实现原理</h4><p>理解vector的实现主要考虑四个东西就好了：三个指针加动态内存申请。</p>
<p>三个指针：</p>
<ul>
<li>first_：指向vector容器对象起始地址的位置</li>
<li>last_：指向vector容器对象中当前最后一个元素的末尾字节</li>
<li>end_：指向vector容器所占内存空间的最后一个字节</li>
</ul>
<p><img src="png1.gif"></p>
<p>动态内存申请：</p>
<p>当 vector 的大小和容量相等（size&#x3D;&#x3D;capacity）也就是满载时，如果再向其添加元素，那么 vector 就需要扩容。vector 容器扩容的过程需要经历以下 3 步：</p>
<ol>
<li>完全弃用现有的内存空间，重新申请更大的内存空间；</li>
<li>将旧内存空间中的数据，按原有顺序移动到新的内存空间中；</li>
<li>最后将旧的内存空间释放。</li>
</ol>
<h4 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h4><p>常量指针：记忆方法（常量的指针），指针指向的对象是一个常量，只能读取指针指向的内容，不能修改指针指向的内容。</p>
<p>指针常量：指针本身是一个常量，不能修改指针指向的地址，可以修改指针指向地址的内容。</p>
<h4 id="C-中一些特别的关键字（default，override、final、volatile）"><a href="#C-中一些特别的关键字（default，override、final、volatile）" class="headerlink" title="C++中一些特别的关键字（default，override、final、volatile）"></a>C++中一些特别的关键字（default，override、final、volatile）</h4><p>参考链接：<a href="https://blog.csdn.net/u011947630/article/details/103062773">https://blog.csdn.net/u011947630/article/details/103062773</a></p>
<h4 id="字节算法题：小于N的最大数"><a href="#字节算法题：小于N的最大数" class="headerlink" title="字节算法题：小于N的最大数"></a>字节算法题：小于N的最大数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> value = <span class="number">14132</span>;</span><br><span class="line">string valueStr = <span class="built_in">to_string</span>(value);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index, <span class="type">bool</span> judge, <span class="type">int</span> temp)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(index == valueStr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ans = temp;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(judge) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">true</span>, temp * <span class="number">10</span> + (nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>]));    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> val = valueStr[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val == nums[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">false</span>, temp * <span class="number">10</span> + nums[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; nums[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">true</span>, temp * <span class="number">10</span> + nums[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最终结果为空</span></span><br><span class="line">        <span class="keyword">if</span>(index != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//少了一位，显然小了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">true</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="如果同时有大量客户并发建立连接，服务器端有什么机制进行处理"><a href="#如果同时有大量客户并发建立连接，服务器端有什么机制进行处理" class="headerlink" title="如果同时有大量客户并发建立连接，服务器端有什么机制进行处理"></a>如果同时有大量客户并发建立连接，服务器端有什么机制进行处理</h4><ol>
<li>多进程和多线程</li>
<li>连接池</li>
<li>异步I&#x2F;O</li>
<li>负载均衡</li>
<li>限流</li>
<li>短连接与长连接</li>
</ol>
<h4 id="HTTP和TCP之间的关系"><a href="#HTTP和TCP之间的关系" class="headerlink" title="HTTP和TCP之间的关系"></a>HTTP和TCP之间的关系</h4><ol>
<li><p>HTTP是一个应用层协议，TCP是一个传输层协议</p>
</li>
<li><p>HTTP依赖于TCP来进行数据的传输。比如，当你使用浏览器访问一个网页时，背后发生的是HTTP请求和响应的交换，而这些HTTP数据包是通过TCP连接发送的。</p>
</li>
<li><p>HTTP&#x2F;1.0对于每一个请求-响应都会新建一个TCP连接，使用完之后就关闭</p>
<p>HTPP&#x2F;1.1引入了keep-alive机制，允许在单个TCP连接上发送多个HTTP请求和响应</p>
<p>HTTP&#x2F;2进一步扩展了这种机制，允许在单个TCP连接上同时多路复用多个HTTP请求和响应</p>
</li>
</ol>
<h4 id="HTTP从请求到得到结果的过程"><a href="#HTTP从请求到得到结果的过程" class="headerlink" title="HTTP从请求到得到结果的过程"></a>HTTP从请求到得到结果的过程</h4><ol>
<li><p><strong>域名解析</strong>：</p>
<ul>
<li>客户端（通常是浏览器）首先检查URL是否包含域名（例如 <code>www.example.com</code>）。</li>
<li>如果包含，客户端首先会查找其DNS缓存是否已经有该域名的IP地址。</li>
<li>如果没有，客户端会发起一个DNS查询到配置的DNS服务器，以获取对应的IP地址。</li>
</ul>
</li>
<li><p><strong>建立TCP连接</strong>：</p>
<ul>
<li>使用从DNS查询得到的IP地址，客户端尝试与服务器的80端口（HTTP）或443端口（HTTPS）建立一个TCP连接。</li>
<li>这涉及到TCP三次握手过程。</li>
</ul>
</li>
<li><p><strong>（HTTPS的情况）SSL&#x2F;TLS握手</strong>：</p>
<ul>
<li>如果是HTTPS请求，一旦TCP连接建立，客户端和服务器会进行SSL&#x2F;TLS握手来建立加密的通信通道。</li>
</ul>
</li>
<li><p><strong>发送HTTP请求</strong>：</p>
<ul>
<li>连接建立后，客户端会发送HTTP请求报文。这包括请求行（例如 <code>GET /path HTTP/1.1</code>）、请求头和（对于某些请求如POST）请求体。</li>
</ul>
</li>
<li><p><strong>服务器处理请求</strong>：</p>
<ul>
<li>服务器接收到请求后，由其HTTP服务软件（如Apache、Nginx等）处理。</li>
<li>服务器可能会根据请求路径查询文件、与数据库交互或调用其他服务，以生成响应。</li>
</ul>
</li>
<li><p><strong>服务器发送响应</strong>：</p>
<ul>
<li>服务器生成响应后，它将响应报文发送回客户端。响应通常包括状态行（例如 <code>HTTP/1.1 200 OK</code>）、响应头和响应体。</li>
<li>对于动态内容，如由PHP、Python或Node.js等后端语言生成的页面，服务器可能会进行一些额外的处理来生成响应内容。</li>
</ul>
</li>
<li><p><strong>客户端处理响应</strong>：</p>
<ul>
<li>客户端（如浏览器）接收响应，并基于响应内容采取相应的行动。</li>
<li>如果响应是一个HTML页面，浏览器会开始解析HTML，并可能发起其他请求来获取页面上的资源，如图片、CSS、JavaScript文件等。</li>
</ul>
</li>
<li><p><strong>关闭连接</strong>：</p>
<ul>
<li>一旦数据交换完成，通常会关闭TCP连接。然而，在HTTP&#x2F;1.1中，默认使用<code>keep-alive</code>，意味着连接可以被复用，从而减少后续请求的延迟。</li>
</ul>
</li>
</ol>
<h4 id="https和http的区别是什么，https具体是怎么做的"><a href="#https和http的区别是什么，https具体是怎么做的" class="headerlink" title="https和http的区别是什么，https具体是怎么做的"></a>https和http的区别是什么，https具体是怎么做的</h4><p>HTTPS和HTTP唯一的区别就是HTTPS使用TLS&#x2F;SSL来加密普通的HTTP请求和响应。</p>
<p>关于https具体是如何做的，这里有一个参考博文链接，写的超好（参考链接：<a href="https://www.runoob.com/w3cnote/http-vs-https.html%EF%BC%89">https://www.runoob.com/w3cnote/http-vs-https.html）</a></p>
<h4 id="gdb中，如何查看每个线程相关的信息"><a href="#gdb中，如何查看每个线程相关的信息" class="headerlink" title="gdb中，如何查看每个线程相关的信息"></a>gdb中，如何查看每个线程相关的信息</h4><p>在 gdb 中，可以使用 <code>info threads</code> 命令查看当前进程中的所有线程信息。这个命令会列出每个线程的编号、状态（如运行、挂起等）以及当前所在的函数名称。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) info threads</span><br><span class="line">  Id   Target Id         Frame </span><br><span class="line">  2    Thread 0x7ffff7fc8700 (LWP 13627) <span class="string">&quot;main&quot;</span> __libc_start_main (argc=1, argv=0x7fffffffe4c8, <span class="built_in">env</span>=0x7fffffffe4d8,</span><br><span class="line">      auxvec=0x7fffffffe4d8, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffe4c8) at ../csu/libc-start.c:310</span><br><span class="line">  3    Thread 0x7ffff77c7700 (LWP 13628) <span class="string">&quot;main&quot;</span> foo () at test.c:6</span><br><span class="line">  4    Thread 0x7ffff6fc6700 (LWP 13629) <span class="string">&quot;main&quot;</span> bar () at test.c:11</span><br></pre></td></tr></table></figure>

<p>你还可以使用 <code>thread &lt;thread-id&gt;</code> 命令来切换到指定的线程，然后使用其他 gdb 命令来查看线程的信息或调试线程。</p>
<p>例如，你可以输入 <code>thread 3</code> 命令切换到编号为 3 的线程，然后输入 <code>bt</code> 命令来查看线程的调用堆栈：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) thread 3</span><br><span class="line">[Switching to thread 3 (Thread 0x7ffff77c7700 (LWP 13628))]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  foo () at test.c:6</span></span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  foo () at test.c:6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00007ffff7bbb830 <span class="keyword">in</span> start_thread (arg=&lt;optimized out&gt;) at pthread_create.c:486</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007ffff78f95fd <span class="keyword">in</span> <span class="built_in">clone</span> () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span></span><br></pre></td></tr></table></figure>



<h4 id="构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因"><a href="#构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因" class="headerlink" title="构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因"></a>构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因</h4><p>构造函数从语法上调用虚函数没有任何问题，但这样做可能并不会达到预期的结果。因为在构造函数执行期间，对象的虚表仍在被设置，因此调用的虚函数版本可能并不是我们想要的版本。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base construct\n&quot;</span>;</span><br><span class="line">        <span class="built_in">call</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base call\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived construct\n&quot;</span>;</span><br><span class="line">        <span class="built_in">call</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived call\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这段程序，可能我们期望得到的结果是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Derived call</span><br><span class="line">Derived constructor</span><br><span class="line">Derived call</span><br></pre></td></tr></table></figure>

<p>但我们实际得到的结果是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Base call</span><br><span class="line">Derived constructor</span><br><span class="line">Derived call</span><br></pre></td></tr></table></figure>

<p>原因是在Base构造函数执行时，Derived部分的对象还没有完全构造出来，因此，此时vtable仍然指向Base类的vtable。因此，当在Base构造函数中调用call虚函数时，他会调用Base版本，而不是Derived版本。</p>
<p><strong>这里延伸一下不要在析构函数中调用虚函数的原因</strong>：析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经“销毁”，这个时再调用子类的虚函数已经没有意义了。</p>
<h4 id="迭代器的实现"><a href="#迭代器的实现" class="headerlink" title="迭代器的实现"></a>迭代器的实现</h4><p>参考链接：<a href="https://www.cnblogs.com/wengle520/p/12492708.html">https://www.cnblogs.com/wengle520/p/12492708.html</a></p>
<h4 id="epoll红黑树的作用"><a href="#epoll红黑树的作用" class="headerlink" title="epoll红黑树的作用"></a>epoll红黑树的作用</h4><p>简单点讲就是在内核事件表上快速注册&#x2F;删除所需连接文件描述符。下面两篇文章基本阐述了这个问题，好好看！</p>
<p><a href="https://cloud.tencent.com/developer/article/1862671">https://cloud.tencent.com/developer/article/1862671</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/366955699">https://zhuanlan.zhihu.com/p/366955699</a></p>
<h4 id="用户态和内核态分别会做什么，怎么切换的"><a href="#用户态和内核态分别会做什么，怎么切换的" class="headerlink" title="用户态和内核态分别会做什么，怎么切换的"></a>用户态和内核态分别会做什么，怎么切换的</h4><p>内核空间主要负责操作系统内核线程以及用户程序系统调用。</p>
<p>用户空间主要负责用户程序的非系统调用。</p>
<p>从用户态切换到内核态主要有三种方式：</p>
<ol>
<li>系统调用：系统调用本身就是中断，但是<strong>软件中断</strong>，跟硬中断不同。系统调用机制是使用了操作系统为用户特别开放的一个中断来实现，如 Linux 的 int 80h 中断。</li>
<li>异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，会触发由当前运行进程切换到处理此异常的内核相关进程中</li>
<li>外围设备中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序。</li>
</ol>
<p>有一个面试问题：I&#x2F;O频繁发生内核态和用户态切换，怎么解决？</p>
<p>答案：使用用户进程缓冲区。</p>
<p>用户进程缓冲区</p>
<p>你看一些程序在读取文件时，会先申请一块内存数组，称为buffer，然后每次调用read，读取设定字节长度的数据，写入buffer。之后的程序都是从buffer中获取数据，当buffer使用完后，在进行下一次调用，填充buffer。所以说：用户缓冲区的目的就是是为了减少系统调用次数，从而降低操作系统在用户态与核心态切换所耗费的时间。除了在进程中设计缓冲区，内核也有自己的缓冲区。</p>
<p>内核缓存区</p>
<p>当一个用户进程要从磁盘读取数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程缓冲区中。但若是内核缓冲区中没有数据，内核会把对数据块的请求，加入到请求队列，然后把进程挂起，为其它进程提供服务。等到数据已经读取到内核缓冲区时，把内核缓冲区中的数据读取到用户进程中，才会通知进程，当然不同的IO模型，在调度和使用内核缓冲区的方式上有所不同。</p>
<p>参考链接：</p>
<p><a href="https://blog.csdn.net/qq_42052956/article/details/111562280">https://blog.csdn.net/qq_42052956/article/details/111562280</a></p>
<p><a href="https://cloud.tencent.com/developer/article/2131401">https://cloud.tencent.com/developer/article/2131401</a></p>
<h4 id="进程的创建需要系统分配什么资源"><a href="#进程的创建需要系统分配什么资源" class="headerlink" title="进程的创建需要系统分配什么资源"></a>进程的创建需要系统分配什么资源</h4><p>根据其他博客里写的底层源码来看，分配给一个进程的东西太多啦，我们挑几个记一下：内存、CPU处理时间、输入输出设备、存储空间。</p>
<p>参考链接：</p>
<p><a href="https://blog.csdn.net/lvyibin890/article/details/82193900">https://blog.csdn.net/lvyibin890/article/details/82193900</a></p>
<p><a href="https://juejin.cn/s/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%99%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E4%BB%80%E4%B9%88%E8%B5%84%E6%BA%90">https://juejin.cn/s/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%99%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E4%BB%80%E4%B9%88%E8%B5%84%E6%BA%90</a></p>
<h4 id="HTTPS加密方式：对称加密、非对称加密"><a href="#HTTPS加密方式：对称加密、非对称加密" class="headerlink" title="HTTPS加密方式：对称加密、非对称加密"></a>HTTPS加密方式：对称加密、非对称加密</h4><p>对称加密：密钥只有一个，加密解密为同一个密码。利用这种加密方式时必须把密钥也发送给对方，密钥在传输过程中被窃取，也就失去了加密的意义。</p>
<p>非对称加密：密钥成对出现，公钥加密需要私钥解密，私钥加密需要公钥解密。</p>
<p>参考链接：</p>
<p><a href="https://www.runoob.com/w3cnote/http-vs-https.html">https://www.runoob.com/w3cnote/http-vs-https.html</a></p>
<p><a href="https://www.itwork.club/2022/05/27/why-did-https-use-mixed-encryption-algorithm/">https://www.itwork.club/2022/05/27/why-did-https-use-mixed-encryption-algorithm/</a></p>
<h4 id="线程的三种状态"><a href="#线程的三种状态" class="headerlink" title="线程的三种状态"></a>线程的三种状态</h4><p>就绪态、运行态、阻塞态</p>
<h4 id="析构函数里能不能抛异常-为什么？"><a href="#析构函数里能不能抛异常-为什么？" class="headerlink" title="析构函数里能不能抛异常?为什么？"></a>析构函数里能不能抛异常?为什么？</h4><p>析构函数从语法上是可以抛出异常的，但是这样做很危险，请尽量不要这要做。原因在《More Effective C++》中提到两个： </p>
<p>（1）如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。 </p>
<p>（2）通常异常发生时，c++的异常处理机制在异常的传播过程中会进行栈展开（stack-unwinding），因发生异常而逐步退出复合语句和函数定义的过程，被称为栈展开。在栈展开的过程中就会调用已经在栈构造好的对象的析构函数来释放资源，此时若其他析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃。</p>
<h4 id="两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？"><a href="#两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？" class="headerlink" title="两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？"></a>两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？</h4><p>有虚函数的大，因为有虚函数的类的会包含一个虚函数指针。注意不同操作系统指针大小不一样。</p>
<p>参考链接：<a href="https://blog.csdn.net/luolaihua2018/article/details/110736211">https://blog.csdn.net/luolaihua2018/article/details/110736211</a></p>
<h4 id="数据报和数据流的区别？"><a href="#数据报和数据流的区别？" class="headerlink" title="数据报和数据流的区别？"></a>数据报和数据流的区别？</h4><p>可以这么简单理解：</p>
<p>假设现在有100字节数据，面向数据流和面向数据报的连接可以分别怎么样处理呢？</p>
<ul>
<li>数据流是发送端可以调用10次write，每次10字节。接收端调用一次read。也可以是发送端调用一次write，接收端调用10次read。数据流是没有边界的</li>
<li>数据报则是一次write就需要一次read，是有边界的。</li>
</ul>
<h4 id="在分布式系统中，如果某个节点宕机了咋办？"><a href="#在分布式系统中，如果某个节点宕机了咋办？" class="headerlink" title="在分布式系统中，如果某个节点宕机了咋办？"></a>在分布式系统中，如果某个节点宕机了咋办？</h4><p>做一个数据副本策略，把每一台机器上的数据做几个副本的冗余，放在别的机器上。万一说某一台机器宕机，没事啊，因为其他机器上还有他的副本。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>所谓自旋锁就是通过while循环实现的，让拿到锁的线程进入临界区执行代码，让没有拿到锁的线程一直进行while死循环，这其实就是线程自己“旋”在while循环了，因而这种锁就叫做自旋锁。</p>
<p>自旋锁实现参考链接：<a href="https://blog.csdn.net/jeffasd/article/details/80661804">https://blog.csdn.net/jeffasd/article/details/80661804</a></p>
<h4 id="线程同步的方式有哪些"><a href="#线程同步的方式有哪些" class="headerlink" title="线程同步的方式有哪些"></a>线程同步的方式有哪些</h4><p>互斥锁、信号量、条件变量、自旋锁、读写锁、屏障</p>
]]></content>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2023/08/29/MySQL/</url>
    <content><![CDATA[<h3 id="DAY1"><a href="#DAY1" class="headerlink" title="DAY1"></a><code>DAY1</code></h3><p>使用指令创建数据库：CREATE DATABASE zcl_db01;</p>
<p>删除数据库指令：DROP DATABASE zcl_db01;</p>
<p>创建一个使用utf8字符集的zcl_db02数据库：CREATE DATABASE zcl_db02 CHARACTER SET utf8</p>
<p>创建一个使用utf8字符集，并带校对规则的zcl_db03数据库：CREATE DATABASE zcl_db03 CHARACTER SET utf8 COLLATE utf8_bin<br>utf8_bin区分大小写，utf8_general_ci不区分大小写</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看当前数据库服务器中的所有数据库</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES</span><br><span class="line"></span><br><span class="line">#查看前面创建的zcl_db01数据库的定义信息</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE `zcl_db01`</span><br><span class="line"></span><br><span class="line">#在创建数据库、表的时候，为了规避关键字，可以使用``解决</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE `<span class="keyword">CREATE</span>`</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#备份数据库</span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p <span class="operator">-</span>B zcl_db03 <span class="operator">&gt;</span> e:\\tmp.sql (文件名)</span><br><span class="line"></span><br><span class="line">#恢复数据库</span><br><span class="line">source e:\\tmp.sql</span><br><span class="line"></span><br><span class="line">#备份数据库的表</span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p zcl_db03 t1 t2 (t1和t2是表名) <span class="operator">&gt;</span> e:\\tmp1.sql</span><br></pre></td></tr></table></figure>



<h3 id="DAY2"><a href="#DAY2" class="headerlink" title="DAY2"></a><code>DAY2</code></h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建表</span><br><span class="line"># create table table_name</span><br><span class="line"># (</span><br><span class="line"># 	filed1 datatype,</span><br><span class="line">#	filed2 datatype,</span><br><span class="line">#	filed3 datatype</span><br><span class="line"># )character set 字符集 collate 校对规则 engine 存储引擎</span><br><span class="line">#  filed：指定列名	   datatype：指定列类型（字段类型）</span><br><span class="line">#  character set：如不指定则为所在数据库字符集</span><br><span class="line">#  collate：如不指定则为所在数据库校对规则</span><br><span class="line"></span><br><span class="line"># 实操</span><br><span class="line">create table `user`(</span><br><span class="line">	id int,</span><br><span class="line">    `name` varchar(255),</span><br><span class="line">    `passward` varchar(255),</span><br><span class="line">    `birthday` date</span><br><span class="line">)character set utf8 collate utf8_general_ci engine innodb; </span><br></pre></td></tr></table></figure>



<h4 id="Mysql常用数据类型"><a href="#Mysql常用数据类型" class="headerlink" title="Mysql常用数据类型"></a>Mysql常用数据类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Mysql列类型就是Mysql的数据类型</span><br><span class="line"># 数值类型：</span><br><span class="line"># 整型：tinyint(1个字节)	smallint(2个字节)	mediumint(3个字节)	int(4个字节)	bigint(8个字节)</span><br><span class="line"># 小数类型：float(单精度 4个字节)	double(双精度 8个字节)	decimal[M,D](大小不确定，M代表长度，D代表小数位数)</span><br><span class="line"></span><br><span class="line"># 文本类型（字符串类型）</span><br><span class="line"># char(0-255)	varchar(0~65535)	text(0~2^16-1)	longtext(0~2^32-1)</span><br><span class="line"></span><br><span class="line"># 二进制数据类型</span><br><span class="line"># blob[0~2^16-1]	longblob[0~2^32-1]</span><br><span class="line"></span><br><span class="line"># 日期类型</span><br><span class="line"># date[日期 年月日] time[时间 时分秒]	datetime[年月日 时分秒 YYYY-MM-DD HH:MM:SS]	timestamp[时间戳]</span><br></pre></td></tr></table></figure>

<p>在满足需求的情况下，尽量选择占用空间小的类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t3(</span><br><span class="line">	id TINYINT</span><br><span class="line">);</span><br><span class="line"># INSERT INTO t3 VALUES(128); 错误：越界了，超过了tinyint范围。 </span><br><span class="line">INSERT INTO t3 VALUES(127);</span><br><span class="line"># 定义无符号的整数 指定unsigned</span><br><span class="line">CREATE TABLE t4(</span><br><span class="line">	id TINYINT UNSIGNED</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># BIT(M), M在1-64。显示按照bit。</span><br><span class="line">CREATE TABLE t5(</span><br><span class="line">	num BIT(8)</span><br><span class="line">);</span><br><span class="line">INSERT INTO t5 VALUES(255);</span><br><span class="line">SELECT * FROM t5;</span><br><span class="line"># 输出：11111111</span><br><span class="line">SELECT * FROM t5 WHERE num = 255;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># DECIMAL[M, D] </span><br><span class="line"># M是小数位数（精度）的总数，D是小数点（标度）后面的位数。</span><br><span class="line"># 如果D是0，则值没有小数点或分数部分，M最大是65，D最大是30。如果D被省略，则默认是0，如果M被省略，默认是10。</span><br><span class="line">CREATE TABLE t6(</span><br><span class="line">	num1 FLOAT,</span><br><span class="line">    num2 DOUBLE,</span><br><span class="line">    num3 DECIMAL(30, 20)</span><br><span class="line">);</span><br><span class="line">INSERT INTO t6 VALUES(88.123456789123456, 88.123456789123456, 88.123456789123456)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># char(4) 这个4表示字符数（最大255），不是字节数，不管是中文还是英文都是放四个，按字符计算，定长，即使你插入&#x27;aa&#x27;，也会占用分配的4个字符的空间</span><br><span class="line"># varchar(4) 这个4表示字符数，是变长，如果你插入&#x27;aa&#x27;，实际占用空间并不是4个字符，而是实际占用的空间。</span><br><span class="line"># utf-8：一个字符占三个字节</span><br><span class="line">CREATE TABLE t11(</span><br><span class="line">	&#x27;name&#x27; CHAR(4)</span><br><span class="line">);</span><br><span class="line"># INSERT INTO t11 VALUES(&#x27;ABCDE&#x27;) 报错，太长</span><br><span class="line">INSERT INTO t11 VALUES(&#x27;ABCD&#x27;)</span><br><span class="line">INSERT INTO t11 VALUES(&#x27;你好&#x27;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 日期类型 date datetime timestamp</span><br><span class="line">CREATE TABLE birthday11(</span><br><span class="line">	birthday DATE,</span><br><span class="line">    worktime DATETIME,</span><br><span class="line">    login_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</span><br><span class="line">);</span><br><span class="line">INSERT INTO bithday11(birthday, worktime) VALUES(&#x27;2022-11-11&#x27;, &#x27;2022-11-11 10:10:10&#x27;);</span><br></pre></td></tr></table></figure>



<h4 id="创建表的课堂练习"><a href="#创建表的课堂练习" class="headerlink" title="创建表的课堂练习"></a>创建表的课堂练习</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#x27;emp&#x27;(</span><br><span class="line">	id INT,</span><br><span class="line">    &#x27;name&#x27; VARCHAR(32),</span><br><span class="line">    sex CHAR(1),</span><br><span class="line">    birthday DATE,</span><br><span class="line">    entry_date DATETIME,</span><br><span class="line">    job VARCHAR(32),</span><br><span class="line">    saraly DOUBLE,</span><br><span class="line">    &#x27;resume&#x27; TEXT</span><br><span class="line">) CHARSET utf8 COLLATE utf8_bin ENGINE INNODB;</span><br><span class="line">INSERT INTO &#x27;emp&#x27; VALUES(</span><br><span class="line">	100, &#x27;小妖怪&#x27;, &#x27;男&#x27;, &#x27;2000-11-11&#x27;, &#x27;巡山的&#x27;, 3000, &#x27;大王叫我来巡山&#x27;</span><br><span class="line">);</span><br><span class="line">SELECT * FROM &#x27;emp&#x27;;</span><br><span class="line"></span><br><span class="line"># 增加列</span><br><span class="line">ALTER TABLE emp ADD image VARCHAR(32) NOT NULL DEFAULT &#x27;&#x27; AFTER RESUME</span><br><span class="line"></span><br><span class="line"># 显示表结构</span><br><span class="line">DESC emp</span><br><span class="line"></span><br><span class="line"># 修改job长度</span><br><span class="line">ALTER TABLE emp MODIFY job VARCHAR(60) NOT NULL DEFAULT &#x27;&#x27;</span><br><span class="line"></span><br><span class="line"># 删除列</span><br><span class="line">ALTER TABLE emp DROP sex</span><br><span class="line"></span><br><span class="line"># 修改表名</span><br><span class="line">RENAME TABLE emp TO employee</span><br><span class="line"></span><br><span class="line"># 修改表的字符集</span><br><span class="line">ALTER TABLE employee CHARACTER SET utf8</span><br><span class="line"></span><br><span class="line"># 修改列名</span><br><span class="line">ALTER TABLE employee CHANGE &#x27;name&#x27; user_name VARCHAR(64) NOT NULL DEFAULT &#x27;&#x27;</span><br></pre></td></tr></table></figure>



<h4 id="数据库CRUD语句"><a href="#数据库CRUD语句" class="headerlink" title="数据库CRUD语句"></a>数据库CRUD语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用INSERT语句向表中插入数据</span><br><span class="line">CREATE TABLE &#x27;goods&#x27;(</span><br><span class="line">	id INT,</span><br><span class="line">    goods_name VARCHAR(10),</span><br><span class="line">    price DOUBLE</span><br><span class="line">);</span><br><span class="line">INSERT INTO &#x27;goods&#x27; (id, goods_name, price) VALUES (10, &#x27;华为手机&#x27;, 2000);</span><br><span class="line">INSERT INTO &#x27;goods&#x27; (id, goods_name, price) VALUES (20, &#x27;苹果手机&#x27;, 20000);</span><br><span class="line"></span><br><span class="line"># INSERT语句的细节</span><br><span class="line">-- 插入的数据应与字段的数据类型相同，比如把&#x27;abc&#x27;添加到int类型会错误。</span><br><span class="line">-- 数据的长度应在列的规定范围内，不能将一个长度为80的字符串加入到长度为40的列中。</span><br><span class="line">-- 在VALUES中列出的数据位置必须与被加入的列的排列位置相对应。</span><br><span class="line">-- 字符和日期类型应包含在单引号中</span><br><span class="line">-- 列可以插入空值，前提是该字段允许为空（没有NOT NULL）</span><br><span class="line">-- INSERT INTO TABLE_NAME (列名) VALUES (),(),()，添加多条数据一次性</span><br><span class="line">-- 如果是给表中的所有字段添加数据，(id, goods_name, price)这个可以省略</span><br><span class="line">-- 默认值的使用，当不给某个字段赋值时，如果有默认值就会添加，否则报错。</span><br><span class="line">-- 如果我们希望指定某个列的默认值，可以在创建表时指定。</span><br><span class="line">CREATE TABLE &#x27;goods2&#x27;(</span><br><span class="line">	id INT,</span><br><span class="line">    goods_name VARCHAR(10),</span><br><span class="line">    price DOUBLE NOT NULL DEFAULT 100</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 演示update语句</span><br><span class="line">-- employee是表名，salary是列名</span><br><span class="line">-- 将所有员工薪水修改为5000，如果没有带where条件，会修改所有的记录，因此要小心</span><br><span class="line">UPDATE employee SET salary = 5000 </span><br><span class="line">-- 将姓名为小妖怪的员工薪水修改为3000</span><br><span class="line">UPDATE employee SET salary = 3000 WHERE user_name = &#x27;小妖怪&#x27;</span><br><span class="line">-- 将老妖怪的薪水在原有基础上增加1000</span><br><span class="line">INSERT INTO employee VALUES(200, &#x27;老妖怪&#x27;, &#x27;1990-11-11&#x27;, &#x27;2000-11-11 10:10:10&#x27;, &#x27;捶背的&#x27;, 5000,  &#x27;给大王捶背的&#x27;);</span><br><span class="line">UPDATE employee SET salary = salary + 1000 WHERE user_name = &#x27;老妖怪&#x27;</span><br><span class="line">UPDATE employee SET salary = salary + 1000, job = &#x27;出主意的&#x27; WHERE user_name = &#x27;老妖怪&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 演示delete语句</span><br><span class="line">-- 删除表中名称为‘老妖怪’的记录</span><br><span class="line">DELETE FROM employee WHERE user_name = &#x27;老妖怪&#x27;;</span><br><span class="line">-- 删除表中所有记录</span><br><span class="line">DELETE FROM employee</span><br><span class="line">-- DELETE删除不了一列的值，但可以使用UPDATE语句置为null</span><br><span class="line">UPDATE employee SET job = NULL WHERE user_name = &#x27;老妖怪&#x27;;</span><br><span class="line">-- 要删除这个表</span><br><span class="line">DROP TABLE employee</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- select指定查询哪些列的数据</span><br><span class="line">-- *代表查询所有列</span><br><span class="line">-- from指定查询哪张表</span><br><span class="line">-- DISTINCT可选，指显示结果时，是否去掉重复数据</span><br><span class="line">CREATE TABLE student(</span><br><span class="line">	id INT NOT NULL DEFAULT 1,</span><br><span class="line">    NAME VARCHAR(20) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">    chinese FLOAT NOT NULL DEFAULT 0.0,</span><br><span class="line">    english FLOAT NOT NULL DEFAULT 0.0,</span><br><span class="line">    math FLOAT NOT NULL DEFAULT 0.0</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(1, &#x27;韩顺平&#x27;, 89, 78, 90);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(2, &#x27;张飞&#x27;, 67, 98, 56);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(3, &#x27;宋江&#x27;, 87, 78, 77);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(4, &#x27;关羽&#x27;, 88, 98, 90);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(5, &#x27;赵云&#x27;, 82, 84, 67);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(6, &#x27;欧阳锋&#x27;, 55, 85, 45);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(7, &#x27;黄蓉&#x27;, 75, 65, 30);</span><br><span class="line"></span><br><span class="line">SELECT * FROM student;</span><br><span class="line"></span><br><span class="line">-- 查寻表中所有学生的信息</span><br><span class="line">SELECT * FROM student;</span><br><span class="line"></span><br><span class="line">-- 查询表中所有学生的姓名和对应的英语成绩</span><br><span class="line">SELECT &#x27;NAME&#x27;, english FROM student;</span><br><span class="line"></span><br><span class="line">-- 过滤表中重复数据distinct</span><br><span class="line">-- 要查询的记录每个字段都相同，才会去重</span><br><span class="line">SELECT DISTINCT english FROM student;</span><br><span class="line"></span><br><span class="line">-- 统计每个学生的总分</span><br><span class="line">SELECT &#x27;NAME&#x27;, (chinese + english + math) FROM student;</span><br><span class="line"></span><br><span class="line">-- 在所有学生总分加10分</span><br><span class="line">SELECT &#x27;NAME&#x27;, (chinese + english + math + 10) FROM student;</span><br><span class="line"></span><br><span class="line">-- 使用别名表示学生分数</span><br><span class="line">SELECT &#x27;NAME&#x27;, (chinese + english + math + 10) AS total_score FROM student;</span><br><span class="line">SELECT &#x27;NAME&#x27; AS &#x27;名字&#x27;, (chinese + english + math + 10) AS total_score FROM student;</span><br><span class="line"></span><br><span class="line">-- 查询姓名为赵云的学生成绩</span><br><span class="line">SELECT * FROM student WHERE &#x27;NAME&#x27; = &#x27;赵云&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询英语成绩大于90分的同学</span><br><span class="line">SELECT * FROM student WHERE english &gt; 90;</span><br><span class="line"></span><br><span class="line">-- 查询总分大于200分的所有同学</span><br><span class="line">SELECT * FROM student WHERE (chinese + english + math) &gt; 200;</span><br><span class="line"></span><br><span class="line">-- 查询math大于60并且id大于4的学生成绩</span><br><span class="line">SELECT * FROM student WHERE math &gt; 60 AND id &gt; 4;</span><br><span class="line"></span><br><span class="line">-- 查询英语成绩大于语文成绩的同学</span><br><span class="line">SELECT * FROM student WHERE english &gt; chinese;</span><br><span class="line"></span><br><span class="line">-- 查询总分大于200分并且数学成绩小于语文成绩的姓韩的学生</span><br><span class="line">-- 韩% 表示名字以韩开头的就可以</span><br><span class="line">SELECT * FROM student WHERE (chinese + english + math) &gt; 200 AND </span><br><span class="line">						  math &lt; chinese AND &#x27;NAME&#x27; LIKE &#x27;韩%&#x27;;</span><br><span class="line">						  </span><br><span class="line">-- 查询英语分数在80-90之间的同学</span><br><span class="line">SELECT * FROM student WHERE english &gt;= 80 AND english &lt;= 90;</span><br><span class="line">SELECT * FROM student WHERE english BETWWWN 80 AND 90; -- BETWEEN AND 是闭区间</span><br><span class="line"></span><br><span class="line">-- 查询数学分数为89，90，91的同学</span><br><span class="line">SELECT * FROM student WHERE math = 89 OR math = 90 OR math = 91;</span><br><span class="line">SELECT * FROM student WHERE math IN (89, 90, 91);</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>OS_ucore</title>
    <url>/2023/10/18/OS-ucore/</url>
    <content><![CDATA[<p>1、操作系统要干啥？哪些操作&#x2F;任务不属于操作系统的管理范畴？</p>
<p>2、工具使用</p>
<p>阅读源码工具：<code>understannd</code></p>
<p>源码文档自动生成工具：<code>doxygen</code></p>
<p>虚拟运行环境：<code>qemu</code></p>
<p><code>Lab0</code></p>
<p>1、了解汇编</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;cld \n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;rep \n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;stosl&quot;</span></span><br><span class="line">        :</span><br><span class="line">        : <span class="string">&quot;c&quot;</span> (count), <span class="string">&quot;a&quot;</span>(value), <span class="string">&quot;D&quot;</span> (buf[<span class="number">0</span>])</span><br><span class="line">        :</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这段 C 代码给出了一个简单的函数，其中包括了一段内联汇编。</span></span><br><span class="line"><span class="comment">该代码试图展示如何使用 `rep stos` 指令来填充一个缓冲区，但存在一些问题和错误。</span></span><br><span class="line"><span class="comment">我会逐步解释代码，然后提出建议的更正。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 变量定义:</span></span><br><span class="line"><span class="comment">    ```c</span></span><br><span class="line"><span class="comment">    int count = 1;</span></span><br><span class="line"><span class="comment">    int value = 1;</span></span><br><span class="line"><span class="comment">    int buf[10];</span></span><br><span class="line"><span class="comment">    ```</span></span><br><span class="line"><span class="comment">    你定义了三个变量：一个 `count` 用于记录要重复的次数，</span></span><br><span class="line"><span class="comment">                    一个 `value` 用于指定要存储的值，</span></span><br><span class="line"><span class="comment">                    以及一个 `buf` 数组用于存储数据。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 主函数和内联汇编:</span></span><br><span class="line"><span class="comment">    ```c</span></span><br><span class="line"><span class="comment">    void main()&#123;</span></span><br><span class="line"><span class="comment">        asm(</span></span><br><span class="line"><span class="comment">            &quot;cld \n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;rep \n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;stsol&quot;</span></span><br><span class="line"><span class="comment">            :</span></span><br><span class="line"><span class="comment">            : &quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf[0])</span></span><br><span class="line"><span class="comment">        );</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    ```</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    - `cld`: 清除方向标志（Direction Flag）。这确保了字符串操作（如 `stos`）从低地址向高地址操作。</span></span><br><span class="line"><span class="comment">    - `rep stos`: 这应该是一个组合的指令，意思是&quot;重复存储&quot;。</span></span><br><span class="line"><span class="comment">      你试图使用这个指令将 `value` 的内容存储到 `buf` 指定的内存位置，</span></span><br><span class="line"><span class="comment">      并根据 `count` 的值重复该操作。但这里有个小错误: 你写的是 `&quot;stsol&quot;`，它是不正确的。应该是 `&quot;stosl&quot;`。</span></span><br><span class="line"><span class="comment">    - 输出约束（Output operands）: 这里没有列出输出操作数，所以你只有一个冒号。</span></span><br><span class="line"><span class="comment">    - 输入约束（Input operands）: `&quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf[0])`，这里:</span></span><br><span class="line"><span class="comment">        * `&quot;c&quot; (count)`：把 `count` 放入 `ECX` 寄存器（这是 `rep` 指令使用的计数寄存器）。</span></span><br><span class="line"><span class="comment">        * `&quot;a&quot;(value)`：把 `value` 放入 `EAX` 寄存器（这是 `stosl` 指令使用的源数据寄存器）。</span></span><br><span class="line"><span class="comment">        * `&quot;D&quot; (buf[0])`：把 `buf` 的首地址放入 `EDI` 寄存器（这是 `stosl` 指令使用的目标地址寄存器）。</span></span><br><span class="line"><span class="comment">          但这样写是不准确的，应该是 `&quot;D&quot; (buf)`。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">修正后的代码如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">```c</span></span><br><span class="line"><span class="comment">int count = 1;</span></span><br><span class="line"><span class="comment">int value = 1;</span></span><br><span class="line"><span class="comment">int buf[10];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void main()&#123;</span></span><br><span class="line"><span class="comment">    asm(</span></span><br><span class="line"><span class="comment">        &quot;cld \n\t&quot;</span></span><br><span class="line"><span class="comment">        &quot;rep \n\t&quot;</span></span><br><span class="line"><span class="comment">        &quot;stosl&quot;</span></span><br><span class="line"><span class="comment">        :</span></span><br><span class="line"><span class="comment">        : &quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf)</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">```</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：使用内联汇编通常是平台和编译器特定的。</span></span><br><span class="line"><span class="comment">上述代码假定你正在使用 GCC 或其它支持 GNU 汇编语法的编译器，并且在一个 x86 架构的机器上运行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在 GCC 的内联汇编中，第三个冒号后面的部分是用于指定被汇编代码修改的寄存器列表的，也叫做“Clobber List”。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以下是 `asm` 的基本格式：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">asm ( assembly code </span></span><br><span class="line"><span class="comment">     : output operands                  // optional</span></span><br><span class="line"><span class="comment">     : input operands                   // optional</span></span><br><span class="line"><span class="comment">     : list of clobbered registers      // optional</span></span><br><span class="line"><span class="comment">     );</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. Assembly Code: 包含汇编指令的字符串。</span></span><br><span class="line"><span class="comment">2. Output Operands: 输出操作数列表。</span></span><br><span class="line"><span class="comment">3. Input Operands: 输入操作数列表。</span></span><br><span class="line"><span class="comment">4. Clobber List: 表示汇编指令可能会更改的寄存器列表，</span></span><br><span class="line"><span class="comment">   这告诉编译器这些寄存器的值可能会被修改，所以不要依赖它们的原始值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在你的例子中，你使用了 `&quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf[0])` 为汇编指令提供输入操作数，</span></span><br><span class="line"><span class="comment">但你并没有指定输出操作数，也没有列出任何可能被修改的寄存器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">虽然在此例中，你知道 `ECX`, `EAX`, 和 `EDI` 寄存器会被修改，</span></span><br><span class="line"><span class="comment">但在许多情况下，列出clobbered registers是很有必要的，因为它可以帮助编译器更好地优化生成的代码。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以，理论上，你的代码应该像这样：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int count = 1;</span></span><br><span class="line"><span class="comment">int value = 1;</span></span><br><span class="line"><span class="comment">int buf[10];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void main()&#123;</span></span><br><span class="line"><span class="comment">    asm(</span></span><br><span class="line"><span class="comment">        &quot;cld \n\t&quot;</span></span><br><span class="line"><span class="comment">        &quot;rep \n\t&quot;</span></span><br><span class="line"><span class="comment">        &quot;stosl&quot;</span></span><br><span class="line"><span class="comment">        :</span></span><br><span class="line"><span class="comment">        : &quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf)</span></span><br><span class="line"><span class="comment">        : &quot;ecx&quot;, &quot;eax&quot;, &quot;edi&quot;</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这里，`&quot;ecx&quot;, &quot;eax&quot;, &quot;edi&quot;` 是clobber list，告诉编译器这些寄存器的值已经被汇编代码修改了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>3、掌握指针和类型转换相关的Ｃ编程</p>
<p>实验源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_IG32 0xE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_TG32 0xF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">uint32_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)&#123;\</span></span><br><span class="line"><span class="meta">    (gate).gd_off_15_0 = (uint32_t)(off) &amp; 0xffff;\</span></span><br><span class="line"><span class="meta">    (gate).gd_ss = (sel);\</span></span><br><span class="line"><span class="meta">    (gate).gd_args = 0;\</span></span><br><span class="line"><span class="meta">    (gate).gd_rsv1 = 0;\</span></span><br><span class="line"><span class="meta">    (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;\</span></span><br><span class="line"><span class="meta">    (gate).gd_s = 0;\</span></span><br><span class="line"><span class="meta">    (gate).gd_dpl = (dpl);\</span></span><br><span class="line"><span class="meta">    (gate).gd_p = 1;\</span></span><br><span class="line"><span class="meta">    (gate).gd_off_31_16 = (uint32_t)(off) &gt;&gt; 16;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> gd_off_15_0: <span class="number">16</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_ss: <span class="number">16</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_args: <span class="number">5</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_rsv1: <span class="number">3</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_type: <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_s: <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_dpl: <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_p: <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_off_31_16: <span class="number">16</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> before;</span><br><span class="line">    <span class="type">unsigned</span> intr;</span><br><span class="line">    <span class="type">unsigned</span> after;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> <span class="title">gintr</span>;</span></span><br><span class="line"></span><br><span class="line">    intr = <span class="number">8</span>;</span><br><span class="line">    before = after = <span class="number">0</span>;</span><br><span class="line">    gintr = *((<span class="keyword">struct</span> gatedesc*)&amp;intr);</span><br><span class="line">    SETGATE(gintr, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    intr = *((<span class="type">unsigned</span>*)&amp;(gintr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;intr is 0x%x\n&quot;</span>, intr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gintr is 0x%llx\n&quot;</span>, gintr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自己根据输出即可推出来是怎么做的。注意，<code>gintr</code>等于<code>0xee0000010002</code>中，最高16位全部等于0没有展示出来。而%x只能展示32位，所以<code>intr</code>的输出结果为：<code>0x10002</code>。</p>
<h4 id="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"><a href="#一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？" class="headerlink" title="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"></a>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</h4><p>硬盘主引导扇区（Master Boot Record，MBR）是位于硬盘第一个扇区（通常是逻辑地址0号扇区）的512字节的数据结构，用于引导计算机操作系统。一个符合规范的硬盘主引导扇区应该包含以下几个特征：</p>
<ol>
<li><p><strong>引导代码（Boot Code）：</strong> 前446个字节用于存储引导代码，这是引导加载程序（Boot Loader）的代码，负责加载操作系统。这段代码必须是有效的汇编代码，能够启动计算机。</p>
</li>
<li><p><strong>分区表（Partition Table）：</strong> 接下来的64字节用于存储分区表，每个分区表项占16字节。一个硬盘可以分为最多4个主分区，每个分区表项描述一个分区的起始位置、大小和分区类型等信息。</p>
</li>
<li><p><strong>签名字节（Signature）：</strong> 最后的两个字节（0x55AA）是MBR的签名，标志这个扇区是有效的MBR扇区。这个签名是个小端字节序的16位值，它告诉操作系统这个扇区包含了引导信息，是一个有效的MBR。</p>
</li>
</ol>
<p>总结起来，一个被系统认为是符合规范的硬盘主引导扇区应该包含引导代码、分区表和签名字节。这些特征是为了确保引导加载程序可以正确地读取分区信息，从而启动操作系统。如果这些特征中的任何一个缺失或损坏，可能导致系统无法正确引导。</p>
<p>引导扇区代码（<code>tools/sign.c</code>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span> </span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: &lt;input filename&gt; &lt;output filename&gt;\n&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stat(argv[<span class="number">1</span>], &amp;st) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error opening file &#x27;%s&#x27;: %s\n&quot;</span>, argv[<span class="number">1</span>], strerror(errno)); </span><br><span class="line">        <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&#x27;%s&#x27; size: %lld bytes\n&quot;</span>, argv[<span class="number">1</span>], (<span class="type">long</span> <span class="type">long</span>)st.st_size); </span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; <span class="number">510</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%lld &gt;&gt; 510!!\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)st.st_size); </span><br><span class="line">        <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf)); </span><br><span class="line">    FILE*ifp=fopen(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="type">int</span> size = fread(buf, <span class="number">1</span>,st.st_size, ifp); </span><br><span class="line">    <span class="keyword">if</span> (size != st.st_size) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;read &#x27;%s&#x27; error, size is %d.\n&quot;</span>, argv[<span class="number">1</span>], size); </span><br><span class="line">        <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ifp);</span><br><span class="line">    buf[<span class="number">510</span>]= <span class="number">0x55</span>; </span><br><span class="line">    buf[<span class="number">511</span>] =<span class="number">0xAA</span>;</span><br><span class="line">    FILE*ofp = fopen(argv[<span class="number">2</span>], <span class="string">&quot;wb+&quot;</span>);</span><br><span class="line">    size = fwrite(buf, <span class="number">1</span>, <span class="number">512</span>, ofp); </span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">512</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;write &#x27;%s&#x27; error, size is %d.\n&quot;</span>, argv[<span class="number">2</span>], size); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ofp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;build 512 bytes boot sector: &#x27;%s&#x27; success!\n&quot;</span>, argv[<span class="number">2</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">这是一个简单的C程序，用于生成一个包含引导代码的512字节的引导扇区（Boot Sector）。这样的引导扇区通常用于创建可引导的存储介质，例如硬盘、U盘等。以下是程序的主要功能和流程：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 使用 `stat` 函数获取指定输入文件（`argv[1]`）的信息，主要是文件大小。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 打印输入文件的大小。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 检查文件大小是否超过了510字节。如果超过，打印错误信息并退出程序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 读取输入文件的内容（最多510字节），将内容存储在一个大小为512字节的缓冲区中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5. 在缓冲区的倒数第二个字节（第510字节）写入0x55，倒数第一个字节（第511字节）写入0xAA。这是引导扇区的标志，用于告诉计算机系统这是一个有效的引导扇区。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6. 打开输出文件（`argv[2]`），将修改后的缓冲区写入文件。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">7. 打印成功信息并返回0。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这个程序的目的是创建一个符合标准的引导扇区，其中包含引导代码和标志字节。请注意，生成的引导扇区在实际使用时需要按照引导扇区的规范进行进一步配置，以确保它能够正确地引导计算机系统。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以下是程序的一些可能的改进和注意事项：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 添加更多的错误检查，例如检查文件是否成功打开。</span></span><br><span class="line"><span class="comment">- 考虑处理更多的边界情况，例如文件是否为空。</span></span><br><span class="line"><span class="comment">- 考虑使用二进制文件读写模式（&quot;rb&quot; 和 &quot;wb+&quot;）而不是文本模式。</span></span><br><span class="line"><span class="comment">- 考虑使用 `perror` 函数来打印与 `fopen`、`fread`、`fwrite` 相关的错误信息。</span></span><br><span class="line"><span class="comment">- 考虑处理大端和小端字节序的问题，特别是当涉及到二进制文件时。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>UNIX环境高级编程第一章</title>
    <url>/2023/06/08/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>RPC</title>
    <url>/2023/06/28/RPC/</url>
    <content><![CDATA[<h3 id="开始补上MPRPC项目的代码实现，从头开始———-day1"><a href="#开始补上MPRPC项目的代码实现，从头开始———-day1" class="headerlink" title="开始补上MPRPC项目的代码实现，从头开始———-day1"></a><strong>开始补上<code>MPRPC</code>项目的代码实现，从头开始———-<code>day1</code></strong></h3><p>简介：项目基于muduo高性能网络库 + protobuf开发，所以命名为mprpc。</p>
<p>技术栈</p>
<ul>
<li>集群和分布式概念及原理</li>
<li>RPC远程过程调用原理及实现</li>
<li>Protobuf数据序列化和反序列化协议</li>
<li>Zookeeper分布式一致性协调服务应用及编程（服务注册中心，方便寻找哪个服务在哪台服务器上）</li>
<li>muduo网络库编程</li>
<li>conf配置文件读取</li>
<li>CMake构建项目集成编译环境</li>
</ul>
<h4 id="集群和分布式（搞懂为什么要分布式）"><a href="#集群和分布式（搞懂为什么要分布式）" class="headerlink" title="集群和分布式（搞懂为什么要分布式）"></a><strong>集群和分布式（搞懂为什么要分布式）</strong></h4><p><strong>集群</strong>：每一台服务器独立运行一个工程的所有模块</p>
<p><strong>分布式</strong>：一个工程拆分了很多模块，每一个模块独立部署运行在一个服务器主机上，所有服务器协同工作共同提供服务，每一台服务器称作分布式的一个节点，根据节点的并发要求，对一个节点可以再做节点模块集群部署。</p>
<p><img src="png1.PNG"></p>
<p>如图中<code>server</code>所示，一个聊天系统包括不同模块：用户管理、好友管理、群组管理、消息管理以及后台管理五个模块。每个模块有自己的特定业务，举个例子，用户管理模块包括用户注册、用户登录、用户注销等。</p>
<p>现在让你提出一些单机聊天服务器的缺陷，你能想到哪些？</p>
<ol>
<li>受限于硬件资源，聊天服务器所能承受的用户的并发量，比如端口用光了。</li>
<li>假设这个单机聊天服务器体系很庞大，项目编译需要两个小时！如果现在消息管理模块有一个小<code>bug</code>，需要改动几行，然后导致需要重新编译、部署整个项代码。</li>
<li>系统中，有些模块是属于<code>CPU</code>密集型，有些模块是<code>I/O</code>密集型的，造成各模块对于硬件资源的需求是不一样的。既然受限于硬件资源，我们就多部署几台服务器，横向增加服务器数量。但并未解决问题2和3。</li>
</ol>
<p>集群的优缺点如下，优点：用户的并发量提升了。缺点：项目代码还是需要整体重新编译，而且需要进行多次部署。</p>
<p><img src="png2.png"></p>
<p>现在我们看红色圈，我们把不同模块分类部署在不同服务器上。所有服务器共同构成一个聊天系统，这就是分布式。现在我们将不同服务器分别视为不同分布式节点。比如用户管理模块和消息管理模块对并发要求高，我们可以进行扩容，再部署几台服务器用于用户管理和消息管理（根据节点的并发要求，对一个节点可以再做节点模块集群部署）。分布式系统针对问题2，每个模块独立部署独立运行，哪个模块有<code>bug</code>，我只需要重新编译部署那个模块，其他模块还能正常运行。问题3就很明显了，视不同要求配置不同服务器。</p>
<p>那分布式就全是优点吗？下面我们说说关于分布式设计的难点。</p>
<ol>
<li>大系统的软件模块该怎么划分。</li>
<li>各模块之间怎么访问？集群服务器所有模块运行在一个进程里，不同模块之间访问简便。而分布式各模块都运行在不同的进程里，那服务器1的模块怎么调用服务器2上的模块的一个业务方法呢？我们这个项目所做的就是封装这种远程调用过程，方便用户调用，也就是程序员方便使用我们写的项目（<code>MPRPC</code>）。</li>
</ol>
<h3 id="RPC通信原理———-day2"><a href="#RPC通信原理———-day2" class="headerlink" title="RPC通信原理———-day2"></a><strong><code>RPC</code>通信原理———-<code>day2</code></strong></h3><p><img src="png3.png"></p>
<p>通过上图我们可以看到，我们设计的框架主要由以下部分和流程组成：</p>
<ul>
<li>发起调用端（caller）：调用方需要将调用的函数名、参数打包（序列化），并通过网络发送出去。这里打算采用muduo网络库。</li>
<li>接收端（callee）：接收方接收到包后，将包里的内容反序列化，就能知道调用哪一个函数、传入的参数是啥，然后返回值依旧是序列化之后通过网络发送回去，发送端接收到后反序列化，得到具体的返回值。</li>
<li>我们的框架主要是实现图中的黄绿部分。<ol>
<li>黄色部分是rpc方法参数的打包和解析，也就是数据的序列化与反序列化，通过protobuf完成。</li>
<li>在图中，有一些东西没画进去，比如我们将黄色块分别取名为client-stub和server-stub。这两个stub都是执行数据的序列化与反序列化。</li>
<li>如果远程调用过程中函数执行出错，我们可以返回一些错误码，防止接收端读取错误的返回值。</li>
<li>绿色部分：网络部分，包括寻找rpc服务主机，发起rpc调用请求和响应rpc调用结果，使用muduo网络库和Zookeeper服务配置中心（专门做服务发现）。</li>
</ol>
</li>
</ul>
<p>protobuf相对于json的好处：</p>
<p>1、protobuf是二进制存储；xml和json都是文本存储</p>
<p>2、protobuf不需要存储额外的信息；json通过key-value存储数据</p>
<ul>
<li><p>json：name: “zhang san”, pwd: “123456”</p>
</li>
<li><p>protobuf: “zhangsan” “123456”</p>
</li>
</ul>
<h3 id="项目环境搭建"><a href="#项目环境搭建" class="headerlink" title="项目环境搭建"></a><strong>项目环境搭建</strong></h3><h4 id="文件组成"><a href="#文件组成" class="headerlink" title="文件组成"></a>文件组成</h4><ul>
<li>bin：可执行文件</li>
<li>build：项目编译文件</li>
<li>lib：项目库文件</li>
<li>src：源文件</li>
<li>test：测试代码</li>
<li>example：框架代码使用范例</li>
<li>CMakeLists.txt：顶层的</li>
<li>cmake文件</li>
<li>README.md：项目自述文件</li>
<li>autonbuild.sh：一键编译脚本</li>
</ul>
<h4 id="Ubuntu-protobuf环境搭建"><a href="#Ubuntu-protobuf环境搭建" class="headerlink" title="Ubuntu protobuf环境搭建"></a>Ubuntu protobuf环境搭建</h4><p>首先在GitHub下载源代码，源码包中src&#x2F;README.md有详细的安装说明，也可以按照如下步骤安装：</p>
<ol>
<li>解压压缩包：unzip protobuf-master.zip</li>
<li>进入解压后的文件夹：cd protobuf-master</li>
<li>安装所需工具：sudo apt-get install autoconf automake libtool curl make g++ unzip</li>
<li>自动生成configure配置文件：.&#x2F;autogen.sh</li>
<li>配置环境：.&#x2F;configure</li>
<li>编译源代码（时间比较长）：make</li>
<li>安装：sudo make install</li>
<li>刷新动态库：sudo ldconfig</li>
<li>测试：看能否正常执行protoc命令（直接去终端执行）</li>
</ol>
<p>源码下载地址：<a href="https://github.com/protocolbuffers/protobuf">https://github.com/protocolbuffers/protobuf</a></p>
<h4 id="muduo库安装"><a href="#muduo库安装" class="headerlink" title="muduo库安装"></a>muduo库安装</h4><p>关于muduo库安装，强烈推荐按照施老师的步骤来（参考链接：<a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/89023980%EF%BC%89%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%B8%8D%E7%94%A8%E7%9C%8B%E6%88%91%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4%EF%BC%8C%E4%B8%8D%E5%AE%8C%E6%95%B4%EF%BC%81%EF%BC%81%EF%BC%81">https://blog.csdn.net/QIANGWEIYUAN/article/details/89023980），可以不用看我下面的安装步骤，不完整！！！</a></p>
<ol>
<li>安装依赖：sudo apt-get install libbost-dev libbost-test-dev sudo apt-get install libcurl4-openssl-dev libc-ares-dev</li>
<li>拉文件：git clone <a href="https://github.com/chenshuo/muduo.git">https://github.com/chenshuo/muduo.git</a></li>
<li>.&#x2F;build.sh</li>
</ol>
<p>muduo库是否安装成功的测试：muduo_test.cpp实现了一个简单的echo server</p>
<p>编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -std=c++11 muduo_test.cpp -lmuduo_net -lmuduo_base -lpthread -o muduo_test</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<p>一个shell终端执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./muduo_test </span><br></pre></td></tr></table></figure>

<p>另一个shell终端执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">telnet 127.0.0.1 8032</span><br></pre></td></tr></table></figure>

<p>如下图所示则安装成功</p>
<p><img src="png4.png"></p>
<h4 id="创建文件（循序渐进，现在需要哪些文件夹就创建哪些）"><a href="#创建文件（循序渐进，现在需要哪些文件夹就创建哪些）" class="headerlink" title="创建文件（循序渐进，现在需要哪些文件夹就创建哪些）"></a>创建文件（循序渐进，现在需要哪些文件夹就创建哪些）</h4><p>首先，我们可以以自己的名字缩写作为后缀创建一个mprpc文件夹，比如我创建的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir mprpc_zcl</span><br></pre></td></tr></table></figure>

<p>接下来我们需要在mprpc_zcl文件夹里创建以下这些文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd mprpc_zcl</span><br><span class="line">mkdir bin</span><br><span class="line">mkdir build</span><br><span class="line">mkdir example</span><br><span class="line">mkdir lib</span><br><span class="line">mkdir src</span><br><span class="line">mkdir test</span><br><span class="line">touch autobuild.sh</span><br><span class="line">touch CMakeLists.txt</span><br></pre></td></tr></table></figure>

<p>好啦，第一件该做的事我们已经完成啦！</p>
<h4 id="protobuf实践讲解（一）"><a href="#protobuf实践讲解（一）" class="headerlink" title="protobuf实践讲解（一）"></a>protobuf实践讲解（一）</h4><p>首先我们写一个protobuf测试文件来了解一下protobuf的基本使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在<span class="built_in">test</span>文件夹下创建protobuf文件夹，在protobuf文件夹里创建test.proto文件和main.cpp文件</span></span><br><span class="line">cd test/</span><br><span class="line">mkdir protobuf</span><br><span class="line">cd protobuf/</span><br><span class="line">touch main.cpp test.proto</span><br></pre></td></tr></table></figure>

<p>首先编写test.proto文件，必要的注释我会放在代码块里。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 声明protobuf版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug; <span class="comment">// 声明了代码所在的包（对于C++来说就是namespace）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">message就是消息类型，protobuf就是将我们封装好的数据类型进行序列化与反序列化。</span></span><br><span class="line"><span class="comment">定义登录消息类型：名字 + 密码</span></span><br><span class="line"><span class="comment">string name = 1; 1 代表第一个字段</span></span><br><span class="line"><span class="comment">注意，你的name等变量需要使用什么类型，string要指明。</span></span><br><span class="line"><span class="comment">这里的string是protobuf里的string类型，不是c++里的string类型</span></span><br><span class="line"><span class="comment">我们编译protobuf文件的时候需要使用这样的命令编译：protoc test.proto --cpp_out=./ （=后面是编译生成文件的输出路径）</span></span><br><span class="line"><span class="comment">编译后会生成一个LoginRequest类（这里仅拿LoginRequest举例），类有两个成员：string name 和 string pwd。</span></span><br><span class="line"><span class="comment">如果序列化成功，就把序列化的结果放在了send_str里面了，serializeToString是protobuf编译后人家已经帮我们写好的方法，我们直接用就好了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义登录请求消息类型 name pwd</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定于登录响应消息类型 错误码：errcode，错误消息：errmsg， 成功与否：success</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> errmsg = <span class="number">2</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，编写main.cpp进行测试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// using namespace fixbug</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">protobuf是一个动态库，需要链接，所以整个编译命令为：g++ main.cpp test.pb.cc -lprotobuf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装了login请求对象的数据</span></span><br><span class="line">    fixbug::LoginRequest req;</span><br><span class="line">    req.<span class="built_in">set_name</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    req.<span class="built_in">set_pwd</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象数据序列化</span></span><br><span class="line">    std::string send_str;</span><br><span class="line">    <span class="keyword">if</span>(req.<span class="built_in">SerializeToString</span>(&amp;send_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; send_str.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从send_str反序列化一个login请求对象</span></span><br><span class="line">    fixbug::LoginRequest reqB;</span><br><span class="line">    <span class="keyword">if</span>(reqB.<span class="built_in">ParseFromString</span>(send_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; reqB.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; reqB.<span class="built_in">pwd</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="protobuf实践讲解（二）"><a href="#protobuf实践讲解（二）" class="headerlink" title="protobuf实践讲解（二）"></a>protobuf实践讲解（二）</h4><p>这一小节我们主要引入了两个新知识：</p>
<ul>
<li>在一个消息类型中定义另外一个消息类型</li>
<li>列表</li>
</ul>
<p>必要的注释我已经放在代码块里了，大家可以看看，有不对的地方请谅解并麻烦指出来。</p>
<p>首先是test.proto文件的更新版</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 声明protobuf版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug; <span class="comment">// 声明了代码所在的包（对于C++来说就是namespace）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">message就是消息类型，protobuf就是将我们封装好的数据类型进行序列化与反序列化。</span></span><br><span class="line"><span class="comment">定义登录消息类型：名字 + 密码</span></span><br><span class="line"><span class="comment">string name = 1; 1 代表第一个字段</span></span><br><span class="line"><span class="comment">注意，你的name等变量需要使用什么类型，string要指明。</span></span><br><span class="line"><span class="comment">这里的string是protobuf里的string类型，不是c++里的string类型</span></span><br><span class="line"><span class="comment">我们编译protobuf文件的时候需要使用这样的命令编译：protoc test.proto --cpp_out=./ （=后面是编译生成文件的输出路径）</span></span><br><span class="line"><span class="comment">编译后会生成一个LoginRequest类（这里仅拿LoginRequest举例），类有两个成员：string name 和 string pwd。</span></span><br><span class="line"><span class="comment">如果序列化成功，就把序列化的结果放在了send_str里面了，serializeToString是protobuf编译后人家已经帮我们写好的方法，我们直接用就好了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> errmsg = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义登录请求消息类型 name pwd</span></span><br><span class="line"><span class="comment">// 这里有一个点可以注意一下，一般把string定义成bytes，string也没错，但bytes效率更高</span></span><br><span class="line"><span class="comment">// 因为你定义成string，protobuf还是要转换成bytes</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定于登录响应消息类型 错误码：errcode，错误消息：errmsg， 成功与否：success</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：对于protobuf的消息类型里面定义的成员变量本身又是另外一个消息类型的话，</span></span><br><span class="line"><span class="comment">他都会提供一个mutable用于改变其成员</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在protobuf里还有一个常用的叫列表</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetFriendListsRequest</span>&#123;</span><br><span class="line">    <span class="type">uint32</span> userid = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32</span> age = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">enum </span><span class="title class_">Sex</span>&#123;</span><br><span class="line">        MAN = <span class="number">0</span>;</span><br><span class="line">        WOMAN = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Sex sex = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetFriendListsReponse</span>&#123;</span><br><span class="line">    <span class="comment">// 这里我们注意到，我们每次定义响应的时候好像都会定义errcode和errmsg字段</span></span><br><span class="line">    <span class="comment">// 所以我们决定将其封装起来（ResultCode），便于使用</span></span><br><span class="line">    <span class="comment">// int32 errcode = 1;</span></span><br><span class="line">    <span class="comment">// bytes errmsg = 2;</span></span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的肯定是一个列表，如何表示呢？</span></span><br><span class="line">    <span class="keyword">repeated</span> User friend_list = <span class="number">2</span>; <span class="comment">// 定义了一个列表类型</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>main.cpp更新版</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// using namespace fixbug</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">protobuf是一个动态库，需要链接，所以整个编译命令为：g++ main.cpp test.pb.cc -lprotobuf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装了login请求对象的数据</span></span><br><span class="line">    fixbug::LoginRequest req;</span><br><span class="line">    req.<span class="built_in">set_name</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    req.<span class="built_in">set_pwd</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象数据序列化</span></span><br><span class="line">    std::string send_str;</span><br><span class="line">    <span class="keyword">if</span>(req.<span class="built_in">SerializeToString</span>(&amp;send_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; send_str.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从send_str反序列化一个login请求对象</span></span><br><span class="line">    fixbug::LoginRequest reqB;</span><br><span class="line">    <span class="keyword">if</span>(reqB.<span class="built_in">ParseFromString</span>(send_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; reqB.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; reqB.<span class="built_in">pwd</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixbug::LoginResponse rsp;</span><br><span class="line">    fixbug::ResultCode *rc = rsp.<span class="built_in">mutable_result</span>();</span><br><span class="line">    rc-&gt;<span class="built_in">set_errcode</span>(<span class="number">1</span>);</span><br><span class="line">    rc-&gt;<span class="built_in">set_errmsg</span>(<span class="string">&quot;登陆处理失败了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::string recv_str;</span><br><span class="line">    <span class="keyword">if</span>(rsp.<span class="built_in">SerializeToString</span>(&amp;recv_str))&#123;</span><br><span class="line">        <span class="comment">// 好像设置的errcode并没有输出，暂时不知道为啥</span></span><br><span class="line">        std::cout &lt;&lt; recv_str.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixbug::GetFriendListsReponse rsp2;</span><br><span class="line">    fixbug::ResultCode *rc2 = rsp2.<span class="built_in">mutable_result</span>();</span><br><span class="line">    rc2-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fixbug::User *user1 = rsp2.<span class="built_in">add_friend_list</span>();</span><br><span class="line">    user1-&gt;<span class="built_in">set_name</span>(<span class="string">&quot;zhang san&quot;</span>);</span><br><span class="line">    user1-&gt;<span class="built_in">set_age</span>(<span class="number">20</span>);</span><br><span class="line">    user1-&gt;<span class="built_in">set_sex</span>(fixbug::User::MAN);</span><br><span class="line"></span><br><span class="line">    fixbug::User *user2 = rsp2.<span class="built_in">add_friend_list</span>();</span><br><span class="line">    user2-&gt;<span class="built_in">set_name</span>(<span class="string">&quot;li si&quot;</span>);</span><br><span class="line">    user2-&gt;<span class="built_in">set_age</span>(<span class="number">18</span>);</span><br><span class="line">    user2-&gt;<span class="built_in">set_sex</span>(fixbug::User::MAN);</span><br><span class="line"></span><br><span class="line">    std::string recv_str2;</span><br><span class="line">    <span class="keyword">if</span>(rsp2.<span class="built_in">SerializeToString</span>(&amp;recv_str2))&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; recv_str2.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string user_str;</span><br><span class="line">    <span class="keyword">if</span>(user1-&gt;<span class="built_in">SerializeToString</span>(&amp;user_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; user_str.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; rsp2.<span class="built_in">friend_list_size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="protobuf实践讲解（三）"><a href="#protobuf实践讲解（三）" class="headerlink" title="protobuf实践讲解（三）"></a>protobuf实践讲解（三）</h4><p>这一节我们主要讲了如何引入函数名。因为我们只传输参数给远程rpc服务器是肯定不够的，远程rpc服务器还需要知道我们需要调用哪种方法，因此我们需要使用service在远程rpc服务器上注册函数？（不知道这个理解对不对）同时，方便之后函数调用方传输函数名，里面有一个ServiceDescriptor类型的指针，用于访问方法的各个属性。代码更新如下，主要更新了test.proto文件，main文件没有更新。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 声明protobuf版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug; <span class="comment">// 声明了代码所在的包（对于C++来说就是namespace）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">message就是消息类型，protobuf就是将我们封装好的数据类型进行序列化与反序列化。</span></span><br><span class="line"><span class="comment">定义登录消息类型：名字 + 密码</span></span><br><span class="line"><span class="comment">string name = 1; 1 代表第一个字段</span></span><br><span class="line"><span class="comment">注意，你的name等变量需要使用什么类型，string要指明。</span></span><br><span class="line"><span class="comment">这里的string是protobuf里的string类型，不是c++里的string类型</span></span><br><span class="line"><span class="comment">我们编译protobuf文件的时候需要使用这样的命令编译：protoc test.proto --cpp_out=./ （=后面是编译生成文件的输出路径）</span></span><br><span class="line"><span class="comment">编译后会生成一个LoginRequest类（这里仅拿LoginRequest举例），类有两个成员：string name 和 string pwd。</span></span><br><span class="line"><span class="comment">如果序列化成功，就把序列化的结果放在了send_str里面了，serializeToString是protobuf编译后人家已经帮我们写好的方法，我们直接用就好了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> errmsg = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义登录请求消息类型 name pwd</span></span><br><span class="line"><span class="comment">// 这里有一个点可以注意一下，一般把string定义成bytes，string也没错，但bytes效率更高</span></span><br><span class="line"><span class="comment">// 因为你定义成string，protobuf还是要转换成bytes</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定于登录响应消息类型 错误码：errcode，错误消息：errmsg， 成功与否：success</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：对于protobuf的消息类型里面定义的成员变量本身又是另外一个消息类型的话，</span></span><br><span class="line"><span class="comment">他都会提供一个mutable用于改变其成员</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在protobuf里还有一个常用的叫列表</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetFriendListsRequest</span>&#123;</span><br><span class="line">    <span class="type">uint32</span> userid = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32</span> age = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">enum </span><span class="title class_">Sex</span>&#123;</span><br><span class="line">        MAN = <span class="number">0</span>;</span><br><span class="line">        WOMAN = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Sex sex = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetFriendListsReponse</span>&#123;</span><br><span class="line">    <span class="comment">// 这里我们注意到，我们每次定义响应的时候好像都会定义errcode和errmsg字段</span></span><br><span class="line">    <span class="comment">// 所以我们决定将其封装起来（ResultCode），便于使用</span></span><br><span class="line">    <span class="comment">// int32 errcode = 1;</span></span><br><span class="line">    <span class="comment">// bytes errmsg = 2;</span></span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的肯定是一个列表，如何表示呢？</span></span><br><span class="line">    <span class="keyword">repeated</span> User friend_list = <span class="number">2</span>; <span class="comment">// 定义了一个列表类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">我们在上面已经完成了参数和反回值传输，但我们仅将函数参数传过去，远程服务器并不知道我们要调用哪种方法啊！</span></span><br><span class="line"><span class="comment">protobuf没有rpc通信功能，只进行序列化与反序列化。但我们依旧要在protobuf里完成rpc方法类型的定义描述。</span></span><br><span class="line"><span class="comment">这就需要使用protobuf的service功能，注意此时需要加入option选项， option cc_generic_services = true; 表示生成service服务类和rpc方法描述</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 不管是message还是service，最后都会生成class类。注意message只生成一个，service会生成两个，一个class UserServiceRpc，一个class UserServiceRpc_stub</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserServiceRpc</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Login(LoginRequest) <span class="keyword">returns</span>(LoginResponse)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> GetFriendLists(GetFriendListsRequest) <span class="keyword">returns</span>(GetFriendListsReponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="本地服务如何发布成RPC服务（一）"><a href="#本地服务如何发布成RPC服务（一）" class="headerlink" title="本地服务如何发布成RPC服务（一）"></a>本地服务如何发布成RPC服务（一）</h4><p>这一块算是正式跨入项目第一步，我们通过业务出发，如果要实现我们所需要的具体需求应该怎么办，直接给出更新后的代码，必要的注释都在代码里</p>
<p>这里先给大家看一个本节之后的文件组成情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── autobuild.sh</span><br><span class="line">├── bin</span><br><span class="line">├── build</span><br><span class="line">├── example</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── callee</span><br><span class="line">│   │   ├── CMakeLists.txt</span><br><span class="line">│   │   └── userservice.cpp</span><br><span class="line">│   ├── caller</span><br><span class="line">│   ├── user.pb.cc</span><br><span class="line">│   ├── user.pb.h</span><br><span class="line">│   └── user.proto</span><br><span class="line">├── lib</span><br><span class="line">├── src</span><br><span class="line">└── test</span><br><span class="line">    └── protobuf</span><br><span class="line">        ├── a.out</span><br><span class="line">        ├── main.cpp</span><br><span class="line">        ├── test.pb.cc</span><br><span class="line">        ├── test.pb.h</span><br><span class="line">        └── test.proto</span><br><span class="line"></span><br><span class="line">9 directories, 13 files</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最上面的小点代表根目录：mprpc_zcl</span></span><br></pre></td></tr></table></figure>

<p>更新后的mprpc_zcl&#x2F;CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置cmake的最低版本和项目名称</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(mprpc_zcl)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目可执行文件输出的路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目库文件输出路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目编译头文件搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/example)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目库文件搜索路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># src里面放的是框架代码</span></span><br><span class="line"><span class="comment"># add_subdirectory(src)  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># example里面放的是rpc服务的使用者和消费者，业务代码</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(example)</span><br></pre></td></tr></table></figure>

<p>更新后的mprpc_zcl&#x2F;example&#x2F;user.proto</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> errmsg = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserServiceRpc</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Login_rpc(LoginRequest) <span class="keyword">returns</span>(LoginResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，编写完之后直接使用protoc user.proto --cpp_out=./编译</span></span><br></pre></td></tr></table></figure>

<p>更新后的mprpc_zcl&#x2F;example&#x2F;CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(callee)</span><br></pre></td></tr></table></figure>

<p>更新后的mprpc_zcl&#x2F;example&#x2F;callee&#x2F;userservice.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我个人觉得这个项目应该从这里开始讲解，我们现在本地有一个用户登录Login_Local方法（隶属于UserService类）。</span></span><br><span class="line"><span class="comment">我们自己在本地调用那肯定很方便，创建一个UserService类对象，直接调用Login_Local方法即可</span></span><br><span class="line"><span class="comment">可是，如果现在有另外一个进程或者另外一台机器想调用我们这个方法怎么办呢？所以我们就要结合谷歌protobuf提供给我们的工具了</span></span><br><span class="line"><span class="comment">这个文件写的就是rpc服务提供者文件，我们在别人想要调用这个本地方法之前需要做哪些基础工作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1、proto文件经过protobuf编译后生成了UserServiceRpc类</span></span><br><span class="line"><span class="comment">2、我们需要在userservice.cpp文件里对这个类里的方法进行重写</span></span><br><span class="line"><span class="comment">3、注意：message会变为类的成员，service会生成一个类，service里的内容会生成方法</span></span><br><span class="line"><span class="comment">4、现在的问题就是：我们重写过后，远方是怎么调用的呢？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Userservice</span> : <span class="keyword">public</span> fixbug::UserServiceRpc   <span class="comment">// 使用在rpc服务发布端（rpc服务提供者）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Login_local</span><span class="params">(std::string name, std::string pwd)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doing local service: Login&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; pwd:&quot;</span> &lt;&lt; pwd;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，作用过程是这样的，当远端将请求发送过来，先会被我们的rpc框架接受，我们rpc框架根据接收到的参数，函数名等数据</span></span><br><span class="line">    <span class="comment">// 匹配到了我们重写的这个函数，然后调用了这个函数。</span></span><br><span class="line">    <span class="comment">// 所以这一块不属于框架的代码，是我们要使用这个框架必须自己写的代码，实现自己需要的功能。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Login_rpc</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> ::fixbug::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::fixbug::LoginResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::google::protobuf::Closure* done)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 暂时还没写完</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新后的mprpc_zcl&#x2F;example&#x2F;callee&#x2F;CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(SRC_LIST userservice.cpp ../user.pb.cc)</span><br><span class="line"><span class="keyword">add_executable</span>(provider <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="本地服务如何发布成RPC服务（二）"><a href="#本地服务如何发布成RPC服务（二）" class="headerlink" title="本地服务如何发布成RPC服务（二）"></a>本地服务如何发布成RPC服务（二）</h4><p>这一节必要的注释我都放在了代码里，以及思考的过程，这一节只对userservice.cpp进行了更新</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我个人觉得这个项目应该从这里开始讲解，我们现在本地有一个用户登录Login_Local方法（隶属于UserService类）。</span></span><br><span class="line"><span class="comment">我们自己在本地调用那肯定很方便，创建一个UserService类对象，直接调用Login_Local方法即可</span></span><br><span class="line"><span class="comment">可是，如果现在有另外一个进程或者另外一台机器想调用我们这个方法怎么办呢？所以我们就要结合谷歌protobuf提供给我们的工具了</span></span><br><span class="line"><span class="comment">这个文件写的就是rpc服务提供者文件，我们在别人想要调用这个本地方法之前需要做哪些基础工作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1、proto文件经过protobuf编译后生成了UserServiceRpc类</span></span><br><span class="line"><span class="comment">2、我们需要在userservice.cpp文件里对这个类里的方法进行重写</span></span><br><span class="line"><span class="comment">3、注意：message会变为类的成员，service会生成一个类，service里的内容会生成方法</span></span><br><span class="line"><span class="comment">4、现在的问题就是：我们重写过后，远方是怎么调用的呢？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Userservice</span> : <span class="keyword">public</span> fixbug::UserServiceRpc   <span class="comment">// 使用在rpc服务发布端（rpc服务提供者）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Login_local</span><span class="params">(std::string name, std::string pwd)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doing local service: Login&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; pwd:&quot;</span> &lt;&lt; pwd;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，作用过程是这样的，当远端将请求发送过来，先会被我们的rpc框架接受，我们rpc框架根据接收到的参数，函数名等数据</span></span><br><span class="line">    <span class="comment">// 匹配到了我们重写的这个函数，然后调用了这个函数。</span></span><br><span class="line">    <span class="comment">// 所以这一块不属于框架的代码，是我们要使用这个框架必须自己写的代码，实现自己需要的功能。</span></span><br><span class="line">    <span class="comment">// 现在的问题是，我callee端收到了参数和函数名，怎么匹配的呢？</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Login_rpc</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> ::fixbug::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::fixbug::LoginResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::google::protobuf::Closure* done)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 框架给业务上报了请求参数LoginRequest，应用获取相应数据做本地业务</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string pwd = request-&gt;<span class="built_in">pwd</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做本地业务</span></span><br><span class="line">        <span class="type">bool</span> login_result = <span class="built_in">Login_local</span>(name, pwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把响应写入，包括错误码、错误消息、返回值。我们不需要管序列化与反序列化，这个是框架来做的</span></span><br><span class="line">        fixbug::ResultCode *code = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        code-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        code-&gt;<span class="built_in">set_errmsg</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(login_result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，我们可以跳进::google::protobuf::Closure类去看看，里面的run是纯虚函数，需要我们进行重新写，那么run应该实现什么功能呢？</span></span><br><span class="line">        <span class="comment">// 其实就是执行响应对象数据的序列化与网络发送</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    总结一下，初始准备步骤：</span></span><br><span class="line"><span class="comment">    写proto文件 ------》继承生成的类，重写类里的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Mprpc框架基础类设计"><a href="#Mprpc框架基础类设计" class="headerlink" title="Mprpc框架基础类设计"></a>Mprpc框架基础类设计</h4><p>这一节我们从服务发布方的需求出发，比如我需要发布一个rpc服务，我需要做什么？我们考虑思路是这样的：假设现在框架写好了，当远端将请求发送过来，先会被我们的rpc框架接受，我们rpc框架根据接收到的参数，函数名等数据。匹配到了我们重写的这个函数，然后调用了这个函数。所以这一块不属于框架的代码，是我们要使用这个框架必须自己写的代码，实现自己需要的功能。<strong>现在的问题是，我callee端收到了参数和函数名，怎么匹配的呢？</strong></p>
<p>我们现在做好了服务发布方的基础工作，我们现在需要思考一个问题：我怎么能让别人想用我们写的rpc框架呢？答案只有一个，就是越简单越好。</p>
<ol>
<li>先进行框架初始化操作</li>
<li>框架里提供了用于发布服务的类</li>
</ol>
<p>这一节更新的文件如下</p>
<p>新加入src&#x2F;include&#x2F;mprpcapplication.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责框架的初始化操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MprpcApplication</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> MprpcApplication &amp;<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">MprpcApplication</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>(<span class="type">const</span> MprpcApplication&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>(MprpcApplication&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新加入src&#x2F;include&#x2F;mprpcprovider.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架提供的专门服务发布rpc服务的网络对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个是框架提供给外部使用的，可以发布rpc方法的函数接口 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新加入src&#x2F;mprpcapplication.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcApplication::Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MprpcApplication &amp;<span class="title">MprpcApplication::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> MprpcApplication app;</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新加入src&#x2F;mprpcprovider.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新了example&#x2F;callee&#x2F;userservice.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我个人觉得这个项目应该从这里开始讲解，我们现在本地有一个用户登录Login_Local方法（隶属于UserService类）。</span></span><br><span class="line"><span class="comment">我们自己在本地调用那肯定很方便，创建一个UserService类对象，直接调用Login_Local方法即可</span></span><br><span class="line"><span class="comment">可是，如果现在有另外一个进程或者另外一台机器想调用我们这个方法怎么办呢？所以我们就要结合谷歌protobuf提供给我们的工具了</span></span><br><span class="line"><span class="comment">这个文件写的就是rpc服务提供者文件，我们在别人想要调用这个本地方法之前需要做哪些基础工作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1、proto文件经过protobuf编译后生成了UserServiceRpc类</span></span><br><span class="line"><span class="comment">2、我们需要在userservice.cpp文件里对这个类里的方法进行重写</span></span><br><span class="line"><span class="comment">3、注意：message会变为类的成员，service会生成一个类，service里的内容会生成方法</span></span><br><span class="line"><span class="comment">4、现在的问题就是：我们重写过后，远方是怎么调用的呢？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;/home/zcl/mprpc_zcl/src/include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;/home/zcl/mprpc_zcl/src/include/mprpcprovider.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> : <span class="keyword">public</span> fixbug::UserServiceRpc   <span class="comment">// 使用在rpc服务发布端（rpc服务提供者）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Login_local</span><span class="params">(std::string name, std::string pwd)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doing local service: Login&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; pwd:&quot;</span> &lt;&lt; pwd;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，作用过程是这样的，当远端将请求发送过来，先会被我们的rpc框架接受，我们rpc框架根据接收到的参数，函数名等数据</span></span><br><span class="line">    <span class="comment">// 匹配到了我们重写的这个函数，然后调用了这个函数。</span></span><br><span class="line">    <span class="comment">// 所以这一块不属于框架的代码，是我们要使用这个框架必须自己写的代码，实现自己需要的功能。</span></span><br><span class="line">    <span class="comment">// 现在的问题是，我callee端收到了参数和函数名，怎么匹配的呢？</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Login_rpc</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> ::fixbug::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::fixbug::LoginResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::google::protobuf::Closure* done)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 框架给业务上报了请求参数LoginRequest，应用获取相应数据做本地业务</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string pwd = request-&gt;<span class="built_in">pwd</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做本地业务</span></span><br><span class="line">        <span class="type">bool</span> login_result = <span class="built_in">Login_local</span>(name, pwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把响应写入，包括错误码、错误消息、返回值。我们不需要管序列化与反序列化，这个是框架来做的</span></span><br><span class="line">        fixbug::ResultCode *code = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        code-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        code-&gt;<span class="built_in">set_errmsg</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(login_result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，我们可以跳进::google::protobuf::Closure类去看看，里面的run是纯虚函数，需要我们进行重新写，那么run应该实现什么功能呢？</span></span><br><span class="line">        <span class="comment">// 其实就是执行响应对象数据的序列化与网络发送</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    总结一下，初始准备步骤：</span></span><br><span class="line"><span class="comment">    写proto文件 ------》继承生成的类，重写类里的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们现在做好了服务发布方的基础工作，我们现在需要思考一个问题：我怎么能让别人想用我们写的rpc框架呢？答案只有一个，就是越简单越好。</span></span><br><span class="line"><span class="comment">1、先进行框架初始化操作</span></span><br><span class="line"><span class="comment">2、框架里提供了用于发布服务的类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="comment">// argc和argv是写ip地址和端口号配置文件这些的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用框架的初始化操作</span></span><br><span class="line">    MprpcApplication::<span class="built_in">Init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// provider是一个rpc网络服务对象。把UserService对象发布到rpc节点上</span></span><br><span class="line">    <span class="comment">// 可能会有很多用户同时使用Rpcprovider，所以这一块必须做到高并发，使用muduo网络库</span></span><br><span class="line">    RpcProvider provider;</span><br><span class="line">    provider.<span class="built_in">NotifyService</span>(<span class="keyword">new</span> <span class="built_in">UserService</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个rpc服务发布节点, Run以后，进程进入阻塞状态，等待远程的rpc调用请求</span></span><br><span class="line">    provider.<span class="built_in">Run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Mprpc框架项目动态库编译"><a href="#Mprpc框架项目动态库编译" class="headerlink" title="Mprpc框架项目动态库编译"></a>Mprpc框架项目动态库编译</h4><p>在init的时候，我们希望用户的输入是这样的：.&#x2F;provider -i config.conf（config.conf是配置文件，自动读取网络服务器和配置中心的ip地址和端口号）。</p>
<p>这节涉及到一个函数：int getopt(int argc, char * const argv[], const char *optstring); 我先给出这个函数的详细解释，方便解读下面的代码</p>
<p>首先，让我们看看<code>getopt</code>函数：</p>
<p><code>getopt</code>函数用于解析命令行参数。其原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getopt</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[], <span class="type">const</span> <span class="type">char</span> *optstring)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>argc</code>和<code>argv</code>是从<code>main</code>函数传递过来的命令行参数数量和参数值。</li>
<li><code>optstring</code>是一个字符串，表示我们期望的选项。例如，如果我们期望一个<code>-i</code>选项，那么<code>optstring</code>就会是<code>&quot;i:&quot;</code>。冒号表示<code>-i</code>后面必须跟一个参数值。</li>
</ul>
<p>函数每次调用都会返回一个字符，这个字符表示被解析到的选项。如果选项后面跟有参数值（如<code>-i value</code>），那么这个值可以通过<code>optarg</code>全局变量获得。当所有选项都被解析完毕后，<code>getopt</code>返回-1。</p>
<p>现在，让我们回到你的代码片段：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;i:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>while</code>循环的目的是持续解析命令行参数，直到所有选项都被解析完毕。</p>
<ul>
<li><p><code>c = getopt(argc, argv, &quot;i:&quot;)</code>：这里，<code>getopt</code>被调用，并返回值赋给<code>c</code>。如果有<code>-i</code>选项，<code>c</code>会等于字符<code>&#39;i&#39;</code>。</p>
</li>
<li><p><code>c != -1</code>：这个条件检查<code>c</code>是否不等于-1。如果<code>c</code>等于-1，那么说明所有选项都已经被解析完毕，<code>while</code>循环结束。</p>
</li>
</ul>
<p>在<code>while</code>循环的内部，你可能会基于<code>c</code>的值做一些操作，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">        <span class="comment">// do something with optarg, which contains the value after -i</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// possibly handle other options</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">        <span class="comment">// handle unknown option</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简而言之，这个代码片段用<code>getopt</code>函数在命令行参数中寻找<code>-i</code>选项，并将找到的值存储在<code>optarg</code>中。</p>
<p>在使用 <code>getopt</code> 函数来解析命令行参数时，你可能会遇到几种特定的返回值。当你在 <code>optstring</code> 中指定了一个选项后跟冒号（如 “i:”），这意味着该选项需要一个参数。</p>
<p>对于 <code>getopt</code> 的返回值：</p>
<ul>
<li>如果一个选项被发现，并且它有一个关联的参数（例如 <code>-i &lt;value&gt;</code>），那么 <code>getopt</code> 返回该选项字符。</li>
<li>如果一个选项被发现，但它缺少一个关联的参数（例如仅仅 <code>-i</code> 而没有后续值），并且在 <code>optstring</code> 中该选项后面有一个冒号，那么 <code>getopt</code> 返回 <code>&#39;:&#39;</code>。</li>
<li>如果找到一个不在 <code>optstring</code> 中的选项，或者找到一个不应有参数但却有参数的选项，那么 <code>getopt</code> 返回 <code>&#39;?&#39;</code>。</li>
</ul>
<p>所以，<code>case &#39;:&#39;</code> 在 <code>switch</code> 语句中处理的是缺少参数的选项情况。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;i:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">            <span class="comment">// handle the -i option with its argument in optarg</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:  <span class="comment">// Missing option argument</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Option -%c requires an argument.\n&quot;</span>, optopt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:  <span class="comment">// Unknown option</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unknown option: -%c\n&quot;</span>, optopt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，如果用户只输入 <code>-i</code> 而没有提供参数，程序将输出 “Option -i requires an argument.”。</p>
<p>新加入src&#x2F;CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="keyword">add_library</span>(mprpc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)  <span class="comment"># 创建一个动态库，方便用户调用</span></span><br></pre></td></tr></table></figure>

<p>更新example&#x2F;callee&#x2F;CMakeLists</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(SRC_LIST userservice.cpp ../user.pb.cc)</span><br><span class="line"><span class="keyword">add_executable</span>(provider <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(provider mprpc protobuf)	<span class="comment"># 链接我们上面创建的mprpc动态库和protobuf库</span></span><br></pre></td></tr></table></figure>

<p>更新mprpcapplication.cpp文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showArgHelp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;format: command -i &lt;configfile&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcApplication::Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">showArgHelp</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    std::string config_file;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;i:&quot;</span>)) != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">                config_file = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;invalid args!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">showArgHelp</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);	<span class="comment">// 配置文件都没加载进来就不要break啦，直接退出运行吧</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;need config_file&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">showArgHelp</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始加载配置文件了 rpcserver_ip=  rpcserver_port=    zookeeper_ip=   zookeeper_port=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MprpcApplication &amp;<span class="title">MprpcApplication::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> MprpcApplication app;</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Mprpc配置文件的加载（一）"><a href="#Mprpc配置文件的加载（一）" class="headerlink" title="Mprpc配置文件的加载（一）"></a>Mprpc配置文件的加载（一）</h4><p>这一节我们主要讲的是如何加载配置文件，换句话说就是解析配置文件。首先我们规定了配置文件的标准格式，如下所示：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rpc节点的ip地址</span></span><br><span class="line">rpcserverip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># rpc节点的port端口号</span></span><br><span class="line">rpcserverport = <span class="number">8000</span></span><br><span class="line"><span class="comment"># zk的IP地址</span></span><br><span class="line">zookeeperip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># zk的port端口号</span></span><br><span class="line">zookeeperport = <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p>这一节引入了MprpcConfig类，我们考虑两部分：解析配置文件 + 查询配置信息。一个自然而然要思考的问题就是如何查询配置信息呢？我们这里考虑的是通过一个map映射即通过键找值。具体如何操作看代码就能了解了。</p>
<p>新加入配置文件&#x2F;bin&#x2F;test.conf</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rpc节点的ip地址</span></span><br><span class="line">rpcserverip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># rpc节点的port端口号</span></span><br><span class="line">rpcserverport = <span class="number">8000</span></span><br><span class="line"><span class="comment"># zk的IP地址</span></span><br><span class="line">zookeeperip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># zk的port端口号</span></span><br><span class="line">zookeeperport = <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p>新加入&#x2F;src&#x2F;include&#x2F;mprpcconfig.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MprpcConfig</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 负责解析加载配置文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *config_file)</span></span>;</span><br><span class="line">    <span class="comment">// 查询配置项信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 每解析到一组ip---port，就insert进m_configMap</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; m_configMap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新加入&#x2F;src&#x2F;mprpcconfig.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcconfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责解析加载配置文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcConfig::loadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *config_file)</span></span>&#123;</span><br><span class="line">    FILE *pf = <span class="built_in">fopen</span>(config_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(pf == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; config_file &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、注释 2、正确的配置项通过=判断 3、去掉开头多余的空格</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">feof</span>(pf))&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">fgets</span>(buf, <span class="number">512</span>, pf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串前面的空格</span></span><br><span class="line">        <span class="comment">// 转换成字符串便于后续操作，因为字符串里有很多函数</span></span><br><span class="line">        <span class="function">std::string <span class="title">src_buf</span><span class="params">(buf)</span></span>;</span><br><span class="line">        <span class="type">int</span> idx = src_buf.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// 说明字符串前面有空格</span></span><br><span class="line">            src_buf = src_buf.<span class="built_in">substr</span>(idx, src_buf.<span class="built_in">size</span>() - idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉字符串后面多余的空格</span></span><br><span class="line">        idx = src_buf.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx != <span class="number">-1</span>)&#123;</span><br><span class="line">            src_buf = src_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断#的注释</span></span><br><span class="line">        <span class="keyword">if</span>(src_buf[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || src_buf.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析配置项</span></span><br><span class="line">        idx = src_buf.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// 配置项不合法</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::string key;</span><br><span class="line">        std::string value;</span><br><span class="line">        key = src_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        value = src_buf.<span class="built_in">substr</span>(idx + <span class="number">1</span>, src_buf.<span class="built_in">size</span>() - idx);</span><br><span class="line">        m_configMap.<span class="built_in">insert</span>(&#123;key, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询配置项信息</span></span><br><span class="line"><span class="function">std::string <span class="title">MprpcConfig::load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_configMap.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(it == m_configMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新&#x2F;src&#x2F;include&#x2F;mprpcapplication.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责框架的初始化操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcconfig.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MprpcApplication</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> MprpcApplication &amp;<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> MprpcConfig m_config;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>(<span class="type">const</span> MprpcApplication&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>(MprpcApplication&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更新&#x2F;src&#x2F;mprpcapplication.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MprpcConfig MprpcApplication::m_config;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showArgHelp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;format: command -i &lt;configfile&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcApplication::Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">showArgHelp</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    std::string config_file;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;i:&quot;</span>)) != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">                config_file = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                <span class="built_in">showArgHelp</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">                <span class="built_in">showArgHelp</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始加载配置文件了 rpcserver_ip=  rpcserver_port=    zookeeper_ip=   zookeeper_port=</span></span><br><span class="line">    <span class="comment">// 这是我们规定的配置文件的标准格式，因为我们后面解析的配置文件也是这个格式</span></span><br><span class="line">    m_config.<span class="built_in">loadConfigFile</span>(config_file.<span class="built_in">c_str</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rpcserverip:&quot;</span> &lt;&lt; m_config.<span class="built_in">load</span>(<span class="string">&quot;reserverip&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rpcserverport:&quot;</span> &lt;&lt; m_config.<span class="built_in">load</span>(<span class="string">&quot;reserverport&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;zookeeperip:&quot;</span> &lt;&lt; m_config.<span class="built_in">load</span>(<span class="string">&quot;zookeeperip&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;zookeeperport:&quot;</span> &lt;&lt; m_config.<span class="built_in">load</span>(<span class="string">&quot;zookeeperport&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MprpcApplication &amp;<span class="title">MprpcApplication::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> MprpcApplication app;</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Mprpc配置文件的加载（二）"><a href="#Mprpc配置文件的加载（二）" class="headerlink" title="Mprpc配置文件的加载（二）"></a>Mprpc配置文件的加载（二）</h4><p>在上一节中好像忘记告诉大家如何编译测试代码了。不知道大家还记不记得我们的可执行文件都是放在bin目录里的，所以我们需要先进入bin目录，即cd bin&#x2F;。</p>
<p>然后为了我们就可以在终端执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./provider -i test.conf</span><br></pre></td></tr></table></figure>

<p>从这个编译命令就可以看出来我们为什么要把test.conf文件和provider都放在bin目录下，这样方便我们编译。然后你们可以测试一下上一节的代码，是有bug的！然后我们需要进行gdb调试，进行gdb调试的话，我们需要在最外层的CMakeLists.txt文件加一行这个代码</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE <span class="string">&quot;Debug&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>bug出现在了mprpcconfig.cpp文件里，你们自己调试一下哈，我下面给出更新后的本节所有代码</p>
<p>更新后的CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置cmake的最低版本和项目名称</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(mprpc_zcl)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb调试选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE <span class="string">&quot;Debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目可执行文件输出的路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目库文件输出路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目编译头文件搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/example)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目库文件搜索路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># src里面放的是框架代码</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># example里面放的是rpc服务的使用者和消费者，业务代码</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(example)</span><br></pre></td></tr></table></figure>

<p>更新后的&#x2F;src&#x2F;include&#x2F;mprpcconfig.h文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MprpcConfig</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 负责解析加载配置文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *config_file)</span></span>;</span><br><span class="line">    <span class="comment">// 查询配置项信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; m_configMap;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 去掉字符串前后的空格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Trim</span><span class="params">(std::string &amp;src_buf)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更新后的mprpcconfig.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcconfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责解析加载配置文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcConfig::loadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *config_file)</span></span>&#123;</span><br><span class="line">    FILE *pf = <span class="built_in">fopen</span>(config_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(pf == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; config_file &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、注释 2、正确的配置项通过=判断 3、去掉开头多余的空格</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">feof</span>(pf))&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">fgets</span>(buf, <span class="number">512</span>, pf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串前面的空格</span></span><br><span class="line">        <span class="comment">// 转换成字符串便于后续操作，因为字符串里有很多函数</span></span><br><span class="line">        <span class="function">std::string <span class="title">read_buf</span><span class="params">(buf)</span></span>;</span><br><span class="line">        <span class="built_in">Trim</span>(read_buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断#的注释</span></span><br><span class="line">        <span class="keyword">if</span>(read_buf[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || read_buf.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析配置项</span></span><br><span class="line">        <span class="type">int</span> idx = read_buf.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// 配置项不合法</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::string key;</span><br><span class="line">        std::string value;</span><br><span class="line">        key = read_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        <span class="built_in">Trim</span>(key);</span><br><span class="line">        <span class="type">int</span> endidx = read_buf.<span class="built_in">find</span>(<span class="string">&#x27;\n&#x27;</span>, idx);</span><br><span class="line">        value = read_buf.<span class="built_in">substr</span>(idx + <span class="number">1</span>, endidx - idx - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Trim</span>(value);</span><br><span class="line">        m_configMap.<span class="built_in">insert</span>(&#123;key, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询配置项信息</span></span><br><span class="line"><span class="function">std::string <span class="title">MprpcConfig::load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_configMap.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(it == m_configMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉字符串前后的空格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcConfig::Trim</span><span class="params">(std::string &amp;src_buf)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = src_buf.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(idx != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 说明字符串前面有空格</span></span><br><span class="line">        src_buf = src_buf.<span class="built_in">substr</span>(idx, src_buf.<span class="built_in">size</span>() - idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去掉字符串后面多余的空格</span></span><br><span class="line">    idx = src_buf.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(idx != <span class="number">-1</span>)&#123;</span><br><span class="line">        src_buf = src_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="开发RpcProvider的网络服务"><a href="#开发RpcProvider的网络服务" class="headerlink" title="开发RpcProvider的网络服务"></a>开发RpcProvider的网络服务</h4><p>是这样的，我们现在已经能够读取到配置文件里的信息了，包括哪些信息呢？还记得吗？来一起回顾一下：rpc服务的ip地址和port端口号，zookeeper的ip地址和port端口号。我们现在回到这个配置文件这里，我们从这个角度出发，我们读取配置文件就是为了获取rpc服务发布节点的ip地址和port端口号，我们是为了什么读取呢？是为了让客户端能够接入，能够调用我们发布的这个rpc服务方法。我们之前在mprpcapplication里说过，为了简便用户的操作，我们提供了一个RpcProvoder类来发布服务节点。所以，这节我们要做的就是通过muduo网络库让配置文件里的rpc服务节点运行起来，可以接收客户端的连接请求。Let‘s go！</p>
<p>新加入mprpcprovider.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架提供的专门服务发布rpc服务的网络对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个是框架提供给外部使用的，可以发布rpc方法的函数接口 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 组合了EventLoop</span></span><br><span class="line">    muduo::net::EventLoop m_eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的socket连接回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已建立连接用户的读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新加入mprpcprovider.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 你启动一个rpc网络服务节点，总要获取ip地址和port端口号吧</span></span><br><span class="line">    <span class="comment">// 所以这里是获取ip地址和port端口号</span></span><br><span class="line">    std::string ip = MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;m_eventLoop, address, <span class="string">&quot;RpcProvider&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 绑定连接回调和消息读写回调方法 分离了网络代码和业务代码</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">// 设置muduo库线程数量，自动分配I/O线程和工作线程</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    m_eventLoop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="RpcProvider发布服务方法（一）"><a href="#RpcProvider发布服务方法（一）" class="headerlink" title="RpcProvider发布服务方法（一）"></a>RpcProvider发布服务方法（一）</h4><p>我们想一下，我们发布的rpc服务节点运行起来阻塞着等待客户的请求连接。假设现在有一个客户端将函数及其参数全部传递过来了，框架应该怎么做匹配呢？框架怎么就能做到这个函数名就匹配这个函数呢？对，有人应该想到了，使用map。我现在的想法也是map。我们将服务与函数对应起来（回忆一下：proto文件里服务生成类，函数就是类成员函数），所以要先限定服务，在限定函数。所以我们使用map将服务函数对应起来就好了。</p>
<p>更新mprpcprovider.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架提供的专门服务发布rpc服务的网络对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个是框架提供给外部使用的，可以发布rpc方法的函数接口 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 组合了EventLoop</span></span><br><span class="line">    muduo::net::EventLoop m_eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// service服务类型信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ServiceInfo</span>&#123;</span><br><span class="line">        google::protobuf::Service *m_service; <span class="comment">// 保存服务对象</span></span><br><span class="line">        std::unordered_map&lt;std::string, <span class="type">const</span> google::protobuf::MethodDescriptor*&gt; m_methodMap; <span class="comment">// 保存服务方法</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::unordered_map&lt;std::string, ServiceInfo&gt; m_serviceMap;  <span class="comment">// 可不止一个服务类型哦，所以也要建立一个映射到不同服务的表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的socket连接回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已建立连接用户的读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更新mprpcprovider.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是框架提供给外部使用的，可以发布rpc方法的函数接口</span></span><br><span class="line"><span class="comment">这里有一个很重要的指针（protobuf提供给我们获取服务及函数的）：google::protobuf::ServiceDescriptor *pserviceDesc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line">    ServiceInfo service_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务对象的描述信息</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::ServiceDescriptor *pserviceDesc = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line">    <span class="comment">// 获取服务的名字</span></span><br><span class="line">    std::string service_name = pserviceDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">    <span class="comment">// 获取服务对象service的方法的数量</span></span><br><span class="line">    <span class="type">int</span> methodCnt = pserviceDesc-&gt;<span class="built_in">method_count</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;service_name: &quot;</span> &lt;&lt; service_name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; methodCnt; ++i)&#123;</span><br><span class="line">        <span class="comment">// 获取了服务对象指定下标的服务方法的描述（抽象描述）</span></span><br><span class="line">        <span class="type">const</span> google::protobuf::MethodDescriptor *pmethodDesc = pserviceDesc-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        std::string method_name = pmethodDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">        service_info.m_methodMap.<span class="built_in">insert</span>(&#123;method_name, pmethodDesc&#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    service_info.m_service = service;</span><br><span class="line">    m_serviceMap.<span class="built_in">insert</span>(&#123;service_name, service_info&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 你启动一个rpc网络服务节点，总要获取ip地址和port端口号吧</span></span><br><span class="line">    <span class="comment">// 所以这里是获取ip地址和port端口号</span></span><br><span class="line">    std::string ip = MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;m_eventLoop, address, <span class="string">&quot;RpcProvider&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 绑定连接回调和消息读写回调方法 分离了网络代码和业务代码</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">// 设置muduo库线程数量，自动分配I/O线程和工作线程</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    m_eventLoop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是要处理当rpc服务节点接收到来自客户端的已经序列化的请求该如何处理。首先，我们框架内部RpcProvider和RpcConsumer协商好之间通信用的protobuf数据类型，这样才方便序列化与反序列化。我们考虑将服务名+方法名作为头部字段，同时，为了防止后面的参数与下一次请求产生粘包问题，我们需要在头部字段里声明参数的大小。另外还有一个问题就是，我们如何分离出头部字段和参数字段呢？一个方法就是指明头部字段有多长。所以，我们的代码更新如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcheader.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是框架提供给外部使用的，可以发布rpc方法的函数接口</span></span><br><span class="line"><span class="comment">这里有一个很重要的指针（protobuf提供给我们获取服务及函数的）：google::protobuf::ServiceDescriptor *pserviceDesc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line">    ServiceInfo service_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务对象的描述信息</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::ServiceDescriptor *pserviceDesc = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line">    <span class="comment">// 获取服务的名字</span></span><br><span class="line">    std::string service_name = pserviceDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">    <span class="comment">// 获取服务对象service的方法的数量</span></span><br><span class="line">    <span class="type">int</span> methodCnt = pserviceDesc-&gt;<span class="built_in">method_count</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;service_name: &quot;</span> &lt;&lt; service_name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; methodCnt; ++i)&#123;</span><br><span class="line">        <span class="comment">// 获取了服务对象指定下标的服务方法的描述（抽象描述）</span></span><br><span class="line">        <span class="comment">// 注意，这里建立map表都是依据proto文件建立的！！！思考一下哦！</span></span><br><span class="line">        <span class="type">const</span> google::protobuf::MethodDescriptor *pmethodDesc = pserviceDesc-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        std::string method_name = pmethodDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">        service_info.m_methodMap.<span class="built_in">insert</span>(&#123;method_name, pmethodDesc&#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    service_info.m_service = service;</span><br><span class="line">    m_serviceMap.<span class="built_in">insert</span>(&#123;service_name, service_info&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 你启动一个rpc网络服务节点，总要获取ip地址和port端口号吧</span></span><br><span class="line">    <span class="comment">// 所以这里是获取ip地址和port端口号</span></span><br><span class="line">    std::string ip = MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;m_eventLoop, address, <span class="string">&quot;RpcProvider&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 绑定连接回调和消息读写回调方法 分离了网络代码和业务代码</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">// 设置muduo库线程数量，自动分配I/O线程和工作线程</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    m_eventLoop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!conn-&gt;<span class="built_in">connected</span>())&#123;</span><br><span class="line">        <span class="comment">// 和rpc client的连接断开了</span></span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在框架内部，RpcProvider和RpcConsumer协商好之间通信用的protobuf数据类型</span></span><br><span class="line"><span class="comment">service_name method_name args   定义proto的message类型，进行数据头的序列化与反序列化</span></span><br><span class="line"><span class="comment">                                service_name method_name args_size（args_size是为了防止粘包问题，指定参数长度）</span></span><br><span class="line"><span class="comment">16UserServiceLogin_rpc16zhang san123456</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">header_size + header_str + args_size + args_str</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr &amp;conn, muduo::net::Buffer *buffer, muduo::Timestamp)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 接收到来自客户端的请求</span></span><br><span class="line">    std::string recv_buf = buffer-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字符流中读取前四个字节的内容</span></span><br><span class="line">    <span class="type">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    recv_buf.<span class="built_in">copy</span>((<span class="type">char</span>*)&amp;header_size, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据header_size读取数据头的原始字符流，反序列化数据，得到rpc请求的详细信息</span></span><br><span class="line">    std::string rpc_header_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span>, header_size);</span><br><span class="line">    mprpc::RpcHeader rpcHeader;</span><br><span class="line">    std::string servcie_name;</span><br><span class="line">    std::string method_name;</span><br><span class="line">    <span class="type">uint32_t</span> args_size;</span><br><span class="line">    <span class="keyword">if</span>(rpcHeader.<span class="built_in">ParseFromString</span>(rpc_header_str))&#123;</span><br><span class="line">        servcie_name = rpcHeader.<span class="built_in">service_name</span>();</span><br><span class="line">        method_name = rpcHeader.<span class="built_in">method_name</span>();</span><br><span class="line">        args_size = rpcHeader.<span class="built_in">args_size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;rpc_header_str:&quot;</span> &lt;&lt; rpc_header_str &lt;&lt; <span class="string">&quot; parse error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取rpc方法参数的字符流数据</span></span><br><span class="line">    std::string args_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span> + header_size, args_size);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;header_size: &quot;</span> &lt;&lt; header_size &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rpc_header_str: &quot;</span> &lt;&lt; rpc_header_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;servcie_name: &quot;</span> &lt;&lt; servcie_name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;args_str: &quot;</span> &lt;&lt; args_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="RpcProvider响应回调实现"><a href="#RpcProvider响应回调实现" class="headerlink" title="RpcProvider响应回调实现"></a>RpcProvider响应回调实现</h4><p>回忆一下provider应该做的事，调用方法并返回response。所以这一节做的就是这个事情。注意request和response都是继承自google::protobuf::Message。</p>
<p>更新mprpcprovider.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架提供的专门服务发布rpc服务的网络对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个是框架提供给外部使用的，可以发布rpc方法的函数接口 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 组合了EventLoop</span></span><br><span class="line">    muduo::net::EventLoop m_eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// service服务类型信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ServiceInfo</span>&#123;</span><br><span class="line">        google::protobuf::Service *m_service; <span class="comment">// 保存服务对象</span></span><br><span class="line">        std::unordered_map&lt;std::string, <span class="type">const</span> google::protobuf::MethodDescriptor*&gt; m_methodMap; <span class="comment">// 保存服务方法</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::unordered_map&lt;std::string, ServiceInfo&gt; m_serviceMap;  <span class="comment">// 可不止一个服务类型哦，所以也要建立一个映射到不同服务的表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的socket连接回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已建立连接用户的读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Closure的回调操作，用于序列化rpc的响应和网络发送</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendRpcResponse</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, google::protobuf::Message*)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更新mprpcprovider.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcheader.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是框架提供给外部使用的，可以发布rpc方法的函数接口</span></span><br><span class="line"><span class="comment">这里有一个很重要的指针（protobuf提供给我们获取服务及函数的）：google::protobuf::ServiceDescriptor *pserviceDesc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line">    ServiceInfo service_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务对象的描述信息</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::ServiceDescriptor *pserviceDesc = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line">    <span class="comment">// 获取服务的名字</span></span><br><span class="line">    std::string service_name = pserviceDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">    <span class="comment">// 获取服务对象service的方法的数量</span></span><br><span class="line">    <span class="type">int</span> methodCnt = pserviceDesc-&gt;<span class="built_in">method_count</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;service_name: &quot;</span> &lt;&lt; service_name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; methodCnt; ++i)&#123;</span><br><span class="line">        <span class="comment">// 获取了服务对象指定下标的服务方法的描述（抽象描述）</span></span><br><span class="line">        <span class="comment">// 注意，这里建立map表都是依据proto文件建立的！！！思考一下哦！</span></span><br><span class="line">        <span class="type">const</span> google::protobuf::MethodDescriptor *pmethodDesc = pserviceDesc-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        std::string method_name = pmethodDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">        service_info.m_methodMap.<span class="built_in">insert</span>(&#123;method_name, pmethodDesc&#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    service_info.m_service = service;</span><br><span class="line">    m_serviceMap.<span class="built_in">insert</span>(&#123;service_name, service_info&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 你启动一个rpc网络服务节点，总要获取ip地址和port端口号吧</span></span><br><span class="line">    <span class="comment">// 所以这里是获取ip地址和port端口号</span></span><br><span class="line">    std::string ip = MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;m_eventLoop, address, <span class="string">&quot;RpcProvider&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 绑定连接回调和消息读写回调方法 分离了网络代码和业务代码</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">// 设置muduo库线程数量，自动分配I/O线程和工作线程</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    m_eventLoop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!conn-&gt;<span class="built_in">connected</span>())&#123;</span><br><span class="line">        <span class="comment">// 和rpc client的连接断开了</span></span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在框架内部，RpcProvider和RpcConsumer协商好之间通信用的protobuf数据类型</span></span><br><span class="line"><span class="comment">service_name method_name args   定义proto的message类型，进行数据头的序列化与反序列化</span></span><br><span class="line"><span class="comment">                                service_name method_name args_size（args_size是为了防止粘包问题，指定参数长度）</span></span><br><span class="line"><span class="comment">16UserServiceLogin_rpc16zhang san123456</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">header_size + header_str + args_size + args_str</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr &amp;conn, muduo::net::Buffer *buffer, muduo::Timestamp)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 接收到来自客户端的请求</span></span><br><span class="line">    std::string recv_buf = buffer-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字符流中读取前四个字节的内容</span></span><br><span class="line">    <span class="type">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    recv_buf.<span class="built_in">copy</span>((<span class="type">char</span>*)&amp;header_size, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据header_size读取数据头的原始字符流，反序列化数据，得到rpc请求的详细信息</span></span><br><span class="line">    std::string rpc_header_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span>, header_size);</span><br><span class="line">    mprpc::RpcHeader rpcHeader;</span><br><span class="line">    std::string servcie_name;</span><br><span class="line">    std::string method_name;</span><br><span class="line">    <span class="type">uint32_t</span> args_size;</span><br><span class="line">    <span class="keyword">if</span>(rpcHeader.<span class="built_in">ParseFromString</span>(rpc_header_str))&#123;</span><br><span class="line">        servcie_name = rpcHeader.<span class="built_in">service_name</span>();</span><br><span class="line">        method_name = rpcHeader.<span class="built_in">method_name</span>();</span><br><span class="line">        args_size = rpcHeader.<span class="built_in">args_size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;rpc_header_str:&quot;</span> &lt;&lt; rpc_header_str &lt;&lt; <span class="string">&quot; parse error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取rpc方法参数的字符流数据</span></span><br><span class="line">    std::string args_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span> + header_size, args_size);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;header_size: &quot;</span> &lt;&lt; header_size &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rpc_header_str: &quot;</span> &lt;&lt; rpc_header_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;servcie_name: &quot;</span> &lt;&lt; servcie_name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;args_str: &quot;</span> &lt;&lt; args_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取servcie对象和method对象</span></span><br><span class="line">    <span class="keyword">auto</span> it = m_serviceMap.<span class="built_in">find</span>(servcie_name);</span><br><span class="line">    <span class="keyword">if</span>(it == m_serviceMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; servcie_name &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> mit = it-&gt;second.m_methodMap.<span class="built_in">find</span>(method_name);</span><br><span class="line">    <span class="keyword">if</span>(mit == it-&gt;second.m_methodMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; servcie_name &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; method_name &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    google::protobuf::Service *service = it-&gt;second.m_service;  <span class="comment">// 获取seivice对象</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::MethodDescriptor *method = mit-&gt;second; <span class="comment">// 获取method对像</span></span><br><span class="line"></span><br><span class="line">    google::protobuf::Message *request = service-&gt;<span class="built_in">GetRequestPrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line">    <span class="keyword">if</span>(!request-&gt;<span class="built_in">ParseFromString</span>(args_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;request parse error, content:&quot;</span> &lt;&lt; args_str &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    google::protobuf::Message *response = service-&gt;<span class="built_in">GetResponsePrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给下面的method方法的调用，绑定一个Closure的回调函数</span></span><br><span class="line">    google::protobuf::Closure *done = google::protobuf::<span class="built_in">NewCallback</span>&lt;RpcProvider, <span class="type">const</span> muduo::net::TcpConnectionPtr &amp;, google::protobuf::Message *&gt;(<span class="keyword">this</span>, &amp;RpcProvider::SendRpcResponse, conn, response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在框架上根据远端rpc请求，调用当前rpc节点上发布的方法</span></span><br><span class="line">    service-&gt;<span class="built_in">CallMethod</span>(method, <span class="literal">nullptr</span>, request, response, done);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Closure的回调操作，用于序列化rpc的响应和网络发送</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::SendRpcResponse</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr &amp;conn, google::protobuf::Message *response)</span></span>&#123;</span><br><span class="line">    std::string response_str;</span><br><span class="line">    <span class="keyword">if</span>(response-&gt;<span class="built_in">SerializeToString</span>(&amp;response_str))&#123; <span class="comment">// response进行序列化</span></span><br><span class="line">        <span class="comment">// 序列化成功后，通过网络把rpc方法执行的结果发送回rpc的调用方</span></span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response_str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;serialize response_str error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    conn-&gt;<span class="built_in">shutdown</span>(); <span class="comment">// 模拟http的短连接服务，由provider主动断开连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="RpcController"><a href="#RpcController" class="headerlink" title="RpcController"></a>RpcController</h4><p>为什么需要这个呢？这里我们需要注意到一个问题，举个例子，在我们的callfriendservice.cpp文件中，当我们使用完stub调用函数GetFriendlist之后，就直接开始读取response了。但你有没有想过，如果在序列化、网络发送、反序列化、函数执行等过程中产生错误了呢？那我们根本就拿不到response或者说拿到的response是错误的。RpcController可以帮助我们记录一些rpc调用过程中的状态信息。</p>
]]></content>
  </entry>
  <entry>
    <title>Zookeeper</title>
    <url>/2023/10/22/Zookeeper/</url>
    <content><![CDATA[<p>一、Zookeeper特点</p>
<ol>
<li>Zookeeper:一个领导者(Leader)，多个跟随者(Follower)组成的集群。<br>2)集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器。<br>3)全局数据一致:每个Server保存一份相同的数据副本， Client无论连接到哪个Server，数据都是一致的。<br>4)更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行。<br>5)数据更新原子性，一次数据更新要么成功，要么失败。<br>6)实时性，在一定时间范围内，Client能读到最新数据。</li>
</ol>
<p>二、数据结构<br>ZooKeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一棵树，每个节点称做一个ZNode。每一个ZNode默认能够存储1MB 的数据，每个ZNode都可以通过其路径唯一标识。</p>
<p>三、应用场景</p>
<p>提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。</p>
<p>四、配置参数</p>
<p>tickTime &#x3D; 2000：通信心跳时间，Zookeeper服务器与客户端心跳时间，单位毫秒</p>
<p>initLimit &#x3D; 10：LF初始通信时限，10次心跳，也就是20s，Leader和Follower初始链接时限</p>
<p>syncLimit &#x3D; 5：LF同步通信时限，两者之间的通信时间（5s）</p>
<p>dataDir：保存Zookeeper中的数据，可以修改</p>
<p>clientPort &#x3D; 2181：客户端连接端口，通常不做修改</p>
]]></content>
  </entry>
  <entry>
    <title>echo服务器问题</title>
    <url>/2023/05/11/echo%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 5000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_IP <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_nonblocking</span><span class="params">(<span class="type">int</span> sockfd)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(sockfd, F_GETFL);</span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(sockfd, F_SETFL, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> listen_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(listen_fd &gt;= <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;address, <span class="number">0</span>, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, SERVER_IP, &amp;address.sin_addr);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(listen_fd, (<span class="keyword">struct</span> sockaddr*)(&amp;address), <span class="built_in">sizeof</span>(address));</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> ret1 = <span class="built_in">listen</span>(listen_fd, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ret1 != <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">set_nonblocking</span>(listen_fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> epoll_fd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(epoll_fd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">    ev.data.fd = listen_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, listen_fd, &amp;ev) == <span class="number">-1</span>)&#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to add file descriptor to epoll&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(epoll_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[MAX_EVENTS];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> nfds = <span class="built_in">epoll_wait</span>(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(events[i].data.fd == listen_fd)&#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">                <span class="type">socklen_t</span> client_len = <span class="built_in">sizeof</span>(client);</span><br><span class="line">                <span class="type">int</span> sock_fd = <span class="built_in">accept</span>(listen_fd, (<span class="keyword">struct</span> sockaddr*)(&amp;client), &amp;client_len);</span><br><span class="line">                <span class="built_in">set_nonblocking</span>(sock_fd);</span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                ev.data.fd = sock_fd;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, sock_fd, &amp;ev) == <span class="number">-1</span>)&#123;</span><br><span class="line">                    std::cerr &lt;&lt; <span class="string">&quot;Failed to add client socket file descriptor to epoll&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> client_fd = events[i].data.fd;</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> recv_size;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>((recv_size = <span class="built_in">recv</span>(client_fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;服务端接收到的消息为：&quot;</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">                    <span class="built_in">send</span>(client_fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(recv_size == <span class="number">0</span> || (recv_size == <span class="number">-1</span> &amp;&amp; errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_DEL, client_fd, &amp;ev) == <span class="number">-1</span>)&#123;</span><br><span class="line">                        std::cerr &lt;&lt; <span class="string">&quot;Failed delete the client_fd&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">close</span>(client_fd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(listen_fd);</span><br><span class="line">    <span class="built_in">close</span>(epoll_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 5000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_IP <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 5</span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client_thread_function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> client_sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, SERVER_IP, &amp;serv_addr.sin_addr);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(client_sockfd, (<span class="keyword">struct</span> sockaddr*)(&amp;serv_addr), <span class="built_in">sizeof</span>(serv_addr)))&#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Connection failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(client_sockfd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="type">int</span> send_size = <span class="built_in">send</span>(client_sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(send_size &lt; <span class="number">0</span>) std::cerr &lt;&lt; <span class="string">&quot;Error sending data: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> recv_size = <span class="built_in">recv</span>(client_sockfd, buf, send_size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(recv_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error recving data: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(mtx);</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;客户端&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;接收信息为：&quot;</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(client_sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> thread_num = <span class="number">5</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; client_threads;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_num; ++i)&#123;</span><br><span class="line">        client_threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(client_thread_function));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t : client_threads)&#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="运行时问题及结果截图"><a href="#运行时问题及结果截图" class="headerlink" title="运行时问题及结果截图"></a>运行时问题及结果截图</h2><p>在服务端与客户端均运行起来时，会发现程序并不能完整运行完，可能运行三条&#x2F;一条&#x2F;直接卡住，一条没有等情况，截图如下：</p>
<p><img src="%E4%B8%80%E6%9D%A1echo.png" alt="0条echo，直接卡住不动"></p>
<p>如上图所示，就显示一条echo回声消息，服务端跟客户端就都卡在这不动了。</p>
<p><img src="%E4%B8%A4%E6%9D%A1echo.png" alt="0条echo，直接卡住不动"></p>
<h2 id="解决方案（我并不清楚怎么就解决了！）"><a href="#解决方案（我并不清楚怎么就解决了！）" class="headerlink" title="解决方案（我并不清楚怎么就解决了！）"></a>解决方案（我并不清楚怎么就解决了！）</h2><p>将ET边缘触发模式改为LT水平触发模式就OK了，但从ET结果来看，程序貌似阻塞住了，但哪里会产生阻塞呢？十分不理解？还是其他问题呢（并非阻塞）？</p>
]]></content>
  </entry>
  <entry>
    <title>智能指针shared_ptr的实现</title>
    <url>/2023/07/26/shared-ptr/</url>
    <content><![CDATA[<p>我们今天来实现一个简易版的智能指针吧！拖了好久啦，以后会把vector、string的简易版也给补上，<code>gigigi</code></p>
<p>我们可以先想想<code>shared_ptr</code>最大的特点，就是当他的引用计数为0时，便会自动释放所指对象和析构。所以一个关键点就是这个引用计数怎么设置？static？不可以！static变量同属于一个类的所有对象，这样就会导致不管指的是不是同一个对象，引用计数都相同。所以我们这里决定采用一个指针来进行引用计数。具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(T* sPtr = <span class="literal">nullptr</span>)</span>: sPtr_(sPtr)&#123;</span></span><br><span class="line">        <span class="keyword">if</span>(sPtr_)&#123;</span><br><span class="line">            useCount_ = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line">            sMutex_ = <span class="keyword">new</span> std::mutex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>()&#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)&#123;</span><br><span class="line">        useCount_ = sp.useCount_;</span><br><span class="line">        sPtr_ = sp.sPtr_;</span><br><span class="line">        sMutex_ = sp.sMutex_;</span><br><span class="line">        <span class="built_in">addUsecount</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sPtr_ != sp.sPtr_)&#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            sPtr_ = sp.sPtr_;</span><br><span class="line">            useCount_ = sp.useCount_;</span><br><span class="line">            sMutex_ = sp.sMutex_;</span><br><span class="line">            <span class="built_in">addUsecount</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()&#123;</span><br><span class="line">        <span class="keyword">return</span> *sPtr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">        <span class="keyword">return</span> sPtr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">useCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *useCount_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sPtr_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addUsecount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sMutex_-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        ++(*useCount_);</span><br><span class="line">        sMutex_-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">bool</span> deleteFlag = <span class="literal">false</span>;</span><br><span class="line">        sMutex_-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(--(*useCount_) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> useCount_;</span><br><span class="line">            <span class="keyword">delete</span> sPtr_;</span><br><span class="line">            deleteFlag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sMutex_-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span>(deleteFlag)&#123;</span><br><span class="line">            <span class="keyword">delete</span> sMutex_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* useCount_;</span><br><span class="line">    T* sPtr_;</span><br><span class="line">    std::mutex* sMutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;std::string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> std::string(<span class="string">&quot;hello&quot;</span>))</span></span>;</span><br><span class="line">    shared_ptr&lt;std::string&gt; p2 = p1;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; p2.useCount() &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="function">shared_ptr&lt;std::string&gt; <span class="title">p3</span><span class="params">(p2)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; p3.<span class="built_in">useCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p2.<span class="built_in">useCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    p2 = p3;</span><br><span class="line">    std::cout &lt;&lt; p3.<span class="built_in">useCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p2.<span class="built_in">useCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入结果图片有点问题，最近没时间弄，各位自己跑一下验证一下，有错误记得说！！！</p>
]]></content>
  </entry>
  <entry>
    <title>webServer</title>
    <url>/2023/08/23/webServer/</url>
    <content><![CDATA[<p>今天开始正式补充完善<code>webServer</code>服务器的内容！想到哪写到哪吧，回头再做整合。</p>
<h3 id="标准C库IO函数"><a href="#标准C库IO函数" class="headerlink" title="标准C库IO函数"></a>标准C库IO函数</h3><p><img src="PNG1.png"></p>
<h4 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、如何处理接收到的HTTP请求</span></span><br><span class="line"><span class="comment">2、如何填写HTTP响应</span></span><br><span class="line"><span class="comment">3、如何建立网络连接传输数据</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="HTTP请求处理"><a href="#HTTP请求处理" class="headerlink" title="HTTP请求处理"></a>HTTP请求处理</h4><p>http_conn头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">http_conn</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">http_conn</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">http_conn</span>() &#123;&#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_epollfd;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_user_count;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> so0ckaddr_in &amp;addr)</span></span>;	<span class="comment">// 初始化连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close_conn</span><span class="params">(<span class="type">bool</span> real_close = <span class="literal">true</span>)</span></span>;	<span class="comment">// 关闭连接，关于需要传入real_close参数的原因，后面会讲到，预留问题</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_sockfd;	<span class="comment">// 发起http请求的sockfd</span></span><br><span class="line">    sockaddr_in m_address;	<span class="comment">// 发起http请求的socket地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在http_conn类里主要设置五个对外的接口：</p>
<ul>
<li><p>初始化新接受的连接</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> sockaddr_in &amp;addr)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们会把所有事件注册到一张内核事件表上，因此定义一个内核事件就好了。static int m_epollfd;</span></span><br><span class="line"><span class="comment">同时我们会统计当前连接数，同样是使用一个静态变量，所有实例对象共享。static int m_user_count;</span></span><br><span class="line"><span class="comment">每建立一个新连接，m_user_count就会加1；</span></span><br><span class="line"><span class="comment">当我们向内核事件表注册一个事件时，我们需要考虑我们所要监听的事件类型，这里我们考虑：</span></span><br><span class="line"><span class="comment">读事件（EPOLLIN）、边沿触发模式（EPOLLET）、以及EPOLLRDHUP（检测TCP对端连接的关闭或者半关闭状态）</span></span><br><span class="line"><span class="comment">为了配合ET模式和多线程，我们需要做两个操作，第一是将所监听的文件描述符设置为非阻塞的，第二需要设置为EPOLLONESHOT类型</span></span><br><span class="line"><span class="comment">注意：我们对m_epollfd和m_user_count的初始化分别为</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> m_epollfd = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> m_user_count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>设置非阻塞函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码示例：Linux高性能服务器编程 p113</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> sockfd)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>(sockfd, F_GETFL);  <span class="comment">// 获取文件描述符旧的状态标志</span></span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;	<span class="comment">// 设置非阻塞标志</span></span><br><span class="line">    <span class="built_in">fcntl</span>(sockfd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;	<span class="comment">// 返回文件描述符旧的状态标志，以便日后恢复该状态标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置感兴趣事件类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们在向内核事件表注册新事件的时候，需要指定自己对这个文件描述符上发生的什么事件感兴趣</span></span><br><span class="line"><span class="comment">// 可读？可写？</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> one_shot)</span></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">if</span>(one_shot)&#123;</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化函数代码实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::init</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> sockaddr_in &amp;addr)</span></span>&#123;</span><br><span class="line">	m_sockfd = sockfd;</span><br><span class="line">    m_address = addr;</span><br><span class="line">    <span class="built_in">addfd</span>(m_epollfd, sockfd, <span class="literal">true</span>);</span><br><span class="line">    m_user_count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>关闭连接</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">close_conn</span><span class="params">(<span class="type">bool</span> real_close)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们可以思考一下有关关闭连接需要涉及到哪些操作。</span></span><br><span class="line"><span class="comment">1、首先，如果一个连接关闭了，我们需要将其从内核事件表上移除</span></span><br><span class="line"><span class="comment">2、当前连接数目也会减一</span></span><br><span class="line"><span class="comment">这里我们准备先实现一个从内核事件表上移除文件描述符的函数（void removefd），在实现关闭连接</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>移除文件描述符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removefd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭连接</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::close_conn</span><span class="params">(<span class="type">bool</span> real_close)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(real_close &amp;&amp; m_sockfd != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">removefd</span>(m_epollfd, m_sockfd);</span><br><span class="line">        m_sockfd = <span class="number">-1</span>;</span><br><span class="line">        m_user_count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>处理客户请求</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于如何处理客户连接请求的问题，我们从最原始的地方出发。</span></span><br><span class="line"><span class="comment">首先，你了解一个http请求的基本格式吗？因为我们只有在了解http请求的通用格式后才知道如何对其进行解析</span></span><br><span class="line"><span class="comment">下面，我将展示一个最基本的GET请求格式</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /path/to/resource?param1=value1&amp;param2=value2 HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agnet: Mozilla/5.0 (platform; rv:geckoversion) Gecko/geckotrail Firefox/firefoxversion</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br><span class="line"><span class="comment"># 关于这个GET请求的详细解释我提一个chatgpt的解释在这，可以阅读一下</span></span><br><span class="line">下面是逐行详细解释：</span><br><span class="line">1. `GET /path/to/resource?param1=value1&amp;param2=value2 HTTP/1.1`</span><br><span class="line">   - `GET`: 这是HTTP请求的方法。`GET` 方法用于请求指定的资源。与POST相比，GET请求是只读的，并且用于获取数据而不是发送数据。</span><br><span class="line">   - `/path/to/resource`: 这是请求的资源路径，通常是文件或者其他资源的位置。</span><br><span class="line">   - `?`: 这个符号表示URL的查询部分的开始。</span><br><span class="line">   - `param1=value1&amp;param2=value2`: 这是查询字符串。在此例中，有两个参数，`param1`和`param2`，它们的值分别是`value1`和`value2`。`&amp;`符号用于分隔查询参数。</span><br><span class="line">   - `HTTP/1.1`: 表示使用的HTTP版本，这里是1.1。</span><br><span class="line"></span><br><span class="line">2. `Host: www.example.com`</span><br><span class="line">   - `Host`: 这是HTTP头的名称。它指定了请求的目标主机和域名。</span><br><span class="line">   - `www.example.com`: 请求的目标域名。</span><br><span class="line"></span><br><span class="line">3. `User-Agent: Mozilla/5.0 (platform; rv:geckoversion) Gecko/geckotrail Firefox/firefoxversion`</span><br><span class="line">   - `User-Agent`: 这是HTTP头的名称。它描述了发出请求的用户代理的类型，通常是浏览器。</span><br><span class="line">   - `Mozilla/5.0`: 这是用户代理的一般标记。虽然名为Mozilla，但它并不仅仅代表Mozilla浏览器，大多数浏览器都会以这种方式标识。</span><br><span class="line">   - `(platform; rv:geckoversion)`: 这部分提供了关于用户代理的详细信息，例如它在哪个平台上运行。</span><br><span class="line">   - `Gecko/geckotrail`: 这是Gecko渲染引擎的标识及其版本。</span><br><span class="line">   - `Firefox/firefoxversion`: 表示用户代理是Firefox浏览器，后面跟着其版本。</span><br><span class="line"></span><br><span class="line">4. `Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8`</span><br><span class="line">   - `Accept`: HTTP头名称，表示客户端可以处理的内容类型。</span><br><span class="line">   - 该头的值列出了浏览器接受的MIME类型，按照优先级排序。例如，`text/html` 表示HTML文档，而`q=0.9`表示相对优先级。</span><br><span class="line"></span><br><span class="line">5. `Accept-Language: en-US,en;q=0.5`</span><br><span class="line">   - `Accept-Language`: HTTP头名称，表示用户代理偏好的自然语言。</span><br><span class="line">   - `en-US,en`: 这指示用户代理首先希望接收美国英语的内容，其次是英语。</span><br><span class="line"></span><br><span class="line">6. `Accept-Encoding: gzip, deflate, br`</span><br><span class="line">   - `Accept-Encoding`: HTTP头名称，表示用户代理可以接受的内容编码。</span><br><span class="line">   - `gzip, deflate, br`: 这些是可以接受的编码方法，用于内容压缩。</span><br><span class="line"></span><br><span class="line">7. `Connection: keep-alive`</span><br><span class="line">   - `Connection`: HTTP头名称，表示是否持续连接。</span><br><span class="line">   - `keep-alive`: 表示浏览器希望服务器保持连接，以便于后续的请求可以复用相同的TCP连接。</span><br><span class="line"></span><br><span class="line">这个请求大体上是一个典型的HTTP GET请求，由HTTP方法、资源路径、HTTP版本、多个头字段组成。每个头字段都有其特定的语义和目的。</span><br></pre></td></tr></table></figure>

<p>现在我们知道了HTTP请求格式了，那么到底如何解析它呢？这里就要引入一种叫做“有限状态机”的方法了，有关这个方法的具体描述与实现，大家可以看我的另一篇文章。</p>
</li>
<li><p>非阻塞读操作</p>
</li>
<li><p>非阻塞写操作</p>
</li>
</ul>
<p><strong>第一个知识点：<code>iovec</code></strong></p>
<p>这里先介绍一个<code>iovec</code>结构体，因为我们在写HTTP响应的时候需要用到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>&#123;</span></span><br><span class="line">  <span class="type">ptr_t</span> iov_base;</span><br><span class="line">  <span class="type">size_t</span> iov_len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct iovec结构体，指针成员iov_base指向一个缓冲区，这个缓冲区是存放read_v所接收的数据或者write_v将要发送的数据。成员iov_len在各种情况下分别确定了接收的最大长度和实际写入的长度。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *<span class="built_in">vector</span>, <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *<span class="built_in">vector</span>, <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>下面给出一个应用实例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> part1[] = <span class="string">&quot;This is from writev&quot;</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> part2 = <span class="number">65</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> part3[] = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[3];</span></span><br><span class="line">    </span><br><span class="line">    iov[<span class="number">0</span>].iov_base = part3;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="built_in">strlen</span>(part3);</span><br><span class="line">    </span><br><span class="line">    iov[<span class="number">1</span>].iov_base = part1;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in">strlen</span>(part1);</span><br><span class="line">    </span><br><span class="line">    iov[<span class="number">2</span>].iov_base = &amp;part2;</span><br><span class="line">    iov[<span class="number">2</span>].iov_len = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    </span><br><span class="line">    writev(<span class="number">1</span>, iov, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二个知识点：<code>va_list</code>, <code>vsnprintf</code></strong></p>
<p>参考链接：<a href="https://blog.csdn.net/dengzhilong_cpp/article/details/54944676">https://blog.csdn.net/dengzhilong_cpp/article/details/54944676</a></p>
<p>参考链接：<a href="https://blog.csdn.net/luliplus/article/details/124123219">https://blog.csdn.net/luliplus/article/details/124123219</a></p>
<p>以上是今天要写代码的基础知识，下面开始正式代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*写HTTP响应*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">http_conn::write</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bytes_have_send = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bytes_to_send = m_write_idx;</span><br><span class="line">    <span class="keyword">if</span>(bytes_to_send == <span class="number">0</span>)&#123;</span><br><span class="line">        modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        temp = writev(m_sockfd, m_iv, m_iv_count);</span><br><span class="line">        <span class="keyword">if</span>(temp &lt;= <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EAGAIN)&#123;</span><br><span class="line">                modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unmap();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bytes_to_send -= temp;</span><br><span class="line">        bytes_have_send += temp;</span><br><span class="line">        <span class="keyword">if</span>(bytes_to_send &lt;= bytes_have_send)&#123;</span><br><span class="line">            unmap();</span><br><span class="line">            <span class="keyword">if</span>(m_linger)&#123;</span><br><span class="line">                init();</span><br><span class="line">                modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                                                                                                                                                           </p>
]]></content>
  </entry>
  <entry>
    <title>中缀表达式转后缀表达式</title>
    <url>/2023/08/23/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>面试时被问到了关于如何将中缀表达式转换为后缀表达式，这里总结一下转换的步骤</p>
<ol>
<li>遇到操作数，直接输出</li>
<li>栈为空时，遇到运算符，入栈</li>
<li>遇到左括号，将其入栈</li>
<li>遇到右括号，执行出栈操作，并将出栈的元素输出，直到弹出栈的是左括号，左括号不输出</li>
<li>遇到其他运算符“+”，“-”，“*”，“&#x2F;”时，弹出所有优先级大于或等于该运算符的栈顶元素，然后将该运算符入栈</li>
<li>最终将栈中的元素依次出栈，输出</li>
</ol>
<p><img src="1.png"></p>
<p>（啊！先写到这吧，为了弄个图片弄了好久）</p>
<p>参考链接：<a href="https://blog.csdn.net/y_16041527/article/details/79684188">https://blog.csdn.net/y_16041527/article/details/79684188</a></p>
]]></content>
  </entry>
  <entry>
    <title>八股文C++</title>
    <url>/2023/05/12/%E5%85%AB%E8%82%A1%E6%96%87C/</url>
    <content><![CDATA[<h5 id="你知道c-三大特性吗？那你又是否清楚他们的特点呢？"><a href="#你知道c-三大特性吗？那你又是否清楚他们的特点呢？" class="headerlink" title="你知道c++三大特性吗？那你又是否清楚他们的特点呢？"></a>你知道c++三大特性吗？那你又是否清楚他们的特点呢？</h5><p>c++三大特性分别为：封装、继承和多态</p>
<p>封装：<br>1、三个特点</p>
<p>结合性，即将属性（数据成员）和行为（成员函数）相结合</p>
<p>信息隐蔽性，利用接口机制隐蔽内部实现细节，只留下接口给外界调用</p>
<p>实现代码重用，在此举个例子解释所谓的实现代码重用：</p>
<p>例如，如果你需要在程序的多个地方进行文件读写操作，你可以创建一个名为<code>FileHandler</code>的类，将文件的打开、关闭、读取和写入等操作封装在该类中的成员函数中。然后，你可以在程序的各个地方实例化<code>FileHandler</code>对象，并调用其成员函数来执行文件操作，而不需要每次都编写打开、关闭、读取和写入的代码。</p>
<p>这种方式可以大大简化程序的编写和维护，并且当你需要对文件操作的逻辑进行修改时，只需要修改<code>FileHandler</code>类中的代码，而不需要修改所有调用该类的地方。</p>
<p>继承：</p>
<p>类的派生就是指从已有类产生新类的过程，原有类称为基类或父类，产生的新类称为子类或派生类，子类继承基类后，可以创建子类对象调用基类的函数和变量等。</p>
<p>多态：</p>
<p>多态（Polymorphism）是面向对象编程中的一个重要概念，它允许使用基类类型的指针或引用来调用派生类对象的特定方法。C++中的多态性是通过虚函数（virtual function）和动态绑定（dynamic binding）实现的。</p>
<p>在C++中，要实现多态，需要满足以下条件：</p>
<ol>
<li>基类（父类）中声明一个虚函数。</li>
<li>派生类（子类）中重写（覆盖）这个虚函数，并使用关键字<code>override</code>进行标记。</li>
</ol>
<p>例如，考虑一个基类<code>Shape</code>和两个派生类<code>Circle</code>和<code>Rectangle</code>的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a shape.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shape1 = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    Shape* shape2 = <span class="keyword">new</span> <span class="built_in">Rectangle</span>();</span><br><span class="line"></span><br><span class="line">    shape1-&gt;<span class="built_in">draw</span>();  <span class="comment">// 调用派生类的方法：Drawing a circle.</span></span><br><span class="line">    shape2-&gt;<span class="built_in">draw</span>();  <span class="comment">// 调用派生类的方法：Drawing a rectangle.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，基类<code>Shape</code>声明了一个虚函数<code>draw()</code>，并且两个派生类<code>Circle</code>和<code>Rectangle</code>分别重写了这个函数。在<code>main()</code>函数中，我们创建了两个指向基类的指针<code>shape1</code>和<code>shape2</code>，分别指向派生类<code>Circle</code>和<code>Rectangle</code>的对象。然后，通过基类指针调用<code>draw()</code>函数，由于这个函数是虚函数，实际调用的是派生类的版本，即产生了多态行为。</p>
<p>通过多态，我们可以使用统一的接口来处理不同的对象，提高了代码的灵活性和可维护性。此外，通过将基类指针或引用传递给函数或方法，我们可以在运行时确定要调用的具体实现，而不是在编译时静态地确定。</p>
<p>需要注意的是，在基类中使用关键字<code>virtual</code>来声明虚函数是很重要的，而派生类中的重写函数则使用关键字<code>override</code>进行标记，以确保正确的绑定和多态行为。</p>
<h5 id="函数体内部声明一个string变量，未进行初始化，会进行默认初始化吗？"><a href="#函数体内部声明一个string变量，未进行初始化，会进行默认初始化吗？" class="headerlink" title="函数体内部声明一个string变量，未进行初始化，会进行默认初始化吗？"></a>函数体内部声明一个string变量，未进行初始化，会进行默认初始化吗？</h5><p>在c++中，如果你在函数体内部声明一个<code>std::string</code>变量而不进行初始化，该变量会被默认初始化。对于<code>std::string</code>，默认初始化意味着会创建一个空字符串。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    <span class="comment">// ..... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>s</code> 被默认初始化为一个空字符串。当你尝试打印 <code>s</code> 或者获取 <code>s.length()</code> 时，你会发现<code>s</code>是一个空字符串。</p>
<p>注意这与内置类型如<code>int</code>、<code>float</code>等不同，这些类型如果没有明确初始化，它们的值是未定义的。</p>
<h6 id="string属于内置类型吗？"><a href="#string属于内置类型吗？" class="headerlink" title="string属于内置类型吗？"></a><span style="color:black">string属于内置类型吗？</span></h6><p>是的，<code>string</code> 类型不属于内置类型。<code>std::string</code> 是 C++ 标准库中的一个类，它是对字符数组（C 风格字符串）的封装，提供了更加方便、安全的字符串操作功能。</p>
<p>内置类型（也称为基本类型或原始类型）是编程语言中预定义的、最基本的数据类型，例如 <code>int</code>、<code>float</code>、<code>double</code>、<code>char</code> 等。这些类型通常直接映射到计算机硬件上的表示，所以操作起来非常高效。</p>
<p>相比之下，<code>std::string</code> 是一个类，其对象由多个数据成员和成员函数组成，提供了对字符串的各种操作。虽然 <code>std::string</code> 不是内置类型，但它在 C++ 中被广泛使用，因为它提供了比 C 风格字符串更方便和安全的方式来处理字符串。</p>
<h5 id="pragma-once的作用和-ifndef一样么"><a href="#pragma-once的作用和-ifndef一样么" class="headerlink" title="#pragma once的作用和#ifndef一样么"></a><code>#pragma once</code>的作用和<code>#ifndef</code>一样么</h5><p>是的，<code>#pragma once</code> 和 <code>#ifndef</code>（加上对应的 <code>#define</code> 和 <code>#endif</code>）都用于防止头文件的重复包含。它们的作用相似，但实现方式有所不同。</p>
<ol>
<li><p><code>#pragma once</code>：<br><code>#pragma once</code> 是一种编译器指令，用于确保头文件只被包含一次。当编译器遇到 <code>#pragma once</code> 时，它会记录已经包含了该头文件，从而避免重复包含。这种方法简洁易懂，只需在头文件的开头添加一行代码。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// header.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 声明和定义</span></span><br></pre></td></tr></table></figure>

<p>请注意，<code>#pragma once</code> 不是 C++ 标准的一部分，但大多数现代编译器都支持它。</p>
</li>
<li><p><code>#ifndef</code>，<code>#define</code> 和 <code>#endif</code>：<br>这是一种被称为“包含保护”的技术，通过预处理器指令来防止头文件的重复包含。首先使用 <code>#ifndef</code> 检查一个特定的宏是否已定义，如果未定义，则使用 <code>#define</code> 定义宏，并将头文件的内容包含在 <code>#ifndef</code> 和 <code>#endif</code> 之间。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// header.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 声明和定义</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HEADER_H</span></span></span><br></pre></td></tr></table></figure>

<p>这种方法是 C++ 标准的一部分，因此具有更好的可移植性。</p>
</li>
</ol>
<p>总的来说，<code>#pragma once</code> 和 <code>#ifndef</code> 都可以防止头文件的重复包含，但实现方式不同。在实际项目中，你可以根据编译器支持和代码可移植性的需求来选择其中一种方法。</p>
<p>总结一下上面的：作用是一样的，关于<code>ifndef</code>的具体细节可以去看<code>C++ primer</code>第68页的有关介绍。</p>
<h5 id="C-分离式编译"><a href="#C-分离式编译" class="headerlink" title="C++分离式编译"></a>C++分离式编译</h5><p>举例一个简单情况：</p>
<p>我在<code>Chapter6.h</code>头文件中声明了<code>fact</code>函数，在<code>fact.cpp</code>文件中定义了<code>fact</code>函数，并在<code>factMain.cpp</code>文件中使用了<code>fact</code>函数，为什么在<code>factMain.cpp</code>文件中，只需要引入<code>Chapter6.h</code>头文件就可以调用到<code>fact</code>函数，<code>Chapter6.h</code>头文件里不是只有一个声明吗？</p>
<p>解答：</p>
<p><code>Chapter6.h</code> 头文件中只有 <code>fact</code> 函数的声明。然而，这就是在 C++ 中分离声明和定义的好处。你在头文件中声明函数（告诉编译器有一个名为 <code>fact</code> 的函数存在），然后在一个源文件（例如 <code>fact.cpp</code>）中定义该函数（提供函数的具体实现）。这样，其他源文件（例如 <code>factMain.cpp</code>）可以通过包含相应的头文件来获取函数的声明，从而能够调用该函数。</p>
<p>在编译阶段，编译器会分别编译 <code>fact.cpp</code> 和 <code>factMain.cpp</code>，并生成相应的对象文件（例如 <code>fact.o</code> 和 <code>factMain.o</code>）。在 <code>fact.cpp</code> 中定义的 <code>fact</code> 函数的具体实现会在 <code>fact.o</code> 中。</p>
<p>然后在链接阶段，链接器会把所有的对象文件连接在一起，形成一个可执行文件。链接器会解决所有未解决的符号引用，例如在 <code>factMain.o</code> 中对 <code>fact</code> 函数的调用。因为 <code>fact</code> 函数在 <code>fact.o</code> 中定义了，所以链接器能够找到它，并正确地设置引用。</p>
<p>因此，尽管 <code>Chapter6.h</code> 头文件中只有 <code>fact</code> 函数的声明，但只要 <code>fact</code> 函数在其他地方被定义，那么在 <code>factMain.cpp</code> 中就可以通过包含 <code>Chapter6.h</code> 来调用 <code>fact</code> 函数。</p>
<h5 id="为什么不可以同时用const和static修饰成员函数。详细解释一下"><a href="#为什么不可以同时用const和static修饰成员函数。详细解释一下" class="headerlink" title="为什么不可以同时用const和static修饰成员函数。详细解释一下"></a>为什么不可以同时用<code>const</code>和<code>static</code>修饰成员函数。详细解释一下</h5><p>在<code>C++</code>中，<code>const</code>和<code>static</code>都可以用于修饰成员函数，但它们有不同的含义，并且不能同时应用于同一个成员函数。下面我们来详细了解一下：</p>
<ol>
<li><p><code>const</code>成员函数：如果一个成员函数被声明为<code>const</code>，那么它就不能修改对象的任何非静态数据成员或者调用任何非<code>const</code>成员函数。在<code>const</code>成员函数中，关键字<code>const</code>是在参数列表之后声明的。<code>const</code>成员函数可以被任何类型的对象调用，无论是<code>const</code>还是非<code>const</code>对象。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nonConstMethod</span><span class="params">()</span> </span>&#123; <span class="comment">/* 可以修改对象的状态 */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">constMethod</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">/* 不能修改对象的状态 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>static</code> 成员函数：<code>static</code> 成员函数与类的对象无关，不需要对象就可以调用。它不能访问类的非静态成员（包括数据成员和成员函数），因为非静态成员都是与特定对象关联的，而 <code>static</code> 成员函数与任何对象都无关。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123; <span class="comment">/* 不能访问非静态成员 */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123; <span class="comment">/* 可以访问非静态成员 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这就是为什么不能同时用 <code>const</code> 和 <code>static</code> 修饰成员函数的原因：<code>const</code> 成员函数是基于对象的，它不能改变对象的状态，但可以访问对象的状态。而 <code>static</code> 成员函数是不基于对象的，它不能访问对象的状态。因此，<code>const</code> 和 <code>static</code> 在这里是冲突的，不能同时用于同一个成员函数。</p>
<h6 id="如果一个成员函数被声明为-const，那么它就不能修改对象的任何非静态数据成员或者调用任何非-const-成员函数。能举个例子吗？解释的更通俗一点"><a href="#如果一个成员函数被声明为-const，那么它就不能修改对象的任何非静态数据成员或者调用任何非-const-成员函数。能举个例子吗？解释的更通俗一点" class="headerlink" title="如果一个成员函数被声明为 const，那么它就不能修改对象的任何非静态数据成员或者调用任何非 const 成员函数。能举个例子吗？解释的更通俗一点"></a><span style="color:black">如果一个成员函数被声明为 const，那么它就不能修改对象的任何非静态数据成员或者调用任何非 const 成员函数。能举个例子吗？解释的更通俗一点</span></h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">data</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123; ++data; &#125;  <span class="comment">// 非const成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data; &#125;  <span class="comment">// const成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tryToModify</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        <span class="comment">// ++data;  // 这里将导致编译错误，因为不能在const成员函数中修改非静态数据成员</span></span><br><span class="line">        <span class="comment">// increment();  // 这里也将导致编译错误，因为不能在const成员函数中调用非const成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个类中，<code>increment()</code> 是一个非 <code>const</code> 成员函数，它可以修改对象的状态。<code>getValue()</code> 是一个 <code>const</code> 成员函数，它不能修改对象的状态，只能返回对象的状态。</p>
<p><code>tryToModify()</code> 也是一个 <code>const</code> 成员函数，试图在其中修改 <code>data</code> 或者调用 <code>increment()</code> 都会导致编译错误，因为这些操作都会改变对象的状态，而 <code>const</code> 成员函数不允许这样做。</p>
<p>通俗来说，<code>const</code> 成员函数就像一个诺言，它承诺我不会改变对象的状态。这样，你就可以放心地把对象传给这个函数，知道这个函数不会做任何坏事。这在编程中是非常有用的，因为它可以帮助你避免一些常见的错误，并使你的代码更容易理解和维护。</p>
<h6 id="static-成员函数与类的对象无关，不需要对象就可以调用。这句话怎么理解呢？不需要对象如何调用呢？直接传参吗？能举个例子吗"><a href="#static-成员函数与类的对象无关，不需要对象就可以调用。这句话怎么理解呢？不需要对象如何调用呢？直接传参吗？能举个例子吗" class="headerlink" title="static 成员函数与类的对象无关，不需要对象就可以调用。这句话怎么理解呢？不需要对象如何调用呢？直接传参吗？能举个例子吗"></a><span style="color:black">static 成员函数与类的对象无关，不需要对象就可以调用。这句话怎么理解呢？不需要对象如何调用呢？直接传参吗？能举个例子吗</span></h6><p><code>static</code> 成员函数是与类本身相关联的，而不是与类的特定实例（即对象）相关联。因此，你不需要创建一个类的实例就可以调用 <code>static</code> 成员函数。你可以直接使用类名和作用域解析运算符 <code>::</code> 来调用 <code>static</code> 成员函数。</p>
<p>下面是一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling static method&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass::<span class="built_in">staticMethod</span>();  <span class="comment">// 不需要创建MyClass的实例就可以调用staticMethod</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们没有创建 <code>MyClass</code> 的实例就直接调用了 <code>staticMethod</code>。这是因为 <code>staticMethod</code> 是一个 <code>static</code> 成员函数，它与类本身相关联，而不是与类的特定实例相关联。</p>
<p>注意，<code>static</code> 成员函数不能访问类的非 <code>static</code> 成员（包括数据成员和成员函数），因为非 <code>static</code> 成员都是与特定对象关联的，而 <code>static</code> 成员函数与任何对象都无关。这也是为什么 <code>static</code> 成员函数不能有 <code>this</code> 指针的原因。</p>
<h5 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h5><p>在用户未自定义拷贝构造函数的情况下，系统会调用默认的拷贝构造函数，系统默认的拷贝构造函数执行浅拷贝。当数据成员中没有指针时，浅拷贝是可行的。</p>
<p>但当数据成员中出现指针时，如果依旧使用默认的拷贝构造函数，就会出现调用两次析构函数，造成悬空指针问题。</p>
<p>深拷贝与浅拷贝的区别就在于深拷贝会在<strong>堆内存中另外申请空间来储存数据</strong>，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。</p>
<h5 id="问了一个很愚蠢的问题：我发现在定义一个类的时候，构造函数会对private里的类似于int，string和指针等类型显式或隐式的初始化，而一些函数只给出了声明，函数为什么不用给出定义？"><a href="#问了一个很愚蠢的问题：我发现在定义一个类的时候，构造函数会对private里的类似于int，string和指针等类型显式或隐式的初始化，而一些函数只给出了声明，函数为什么不用给出定义？" class="headerlink" title="问了一个很愚蠢的问题：我发现在定义一个类的时候，构造函数会对private里的类似于int，string和指针等类型显式或隐式的初始化，而一些函数只给出了声明，函数为什么不用给出定义？"></a>问了一个很愚蠢的问题：我发现在定义一个类的时候，构造函数会对private里的类似于int，string和指针等类型显式或隐式的初始化，而一些函数只给出了声明，函数为什么不用给出定义？</h5><p>在<code>C++</code>中，类的定义通常分为两部分：声明和定义。声明是告诉编译器某个东西（例如变量、函数、类等）的存在，而定义则提供了这个东西的实际实现或分配了它的内存。</p>
<p>在类的定义中，构造函数对数据成员进行初始化，这是构造函数的主要目的。对于简单类型如<code>int</code>、<code>string</code>或者指针，可以在构造函数中显式初始化，也可以使用默认的初始化（对于类类型，调用其默认构造函数；对于内置类型，如果它们是静态存储期的对象，则进行值初始化，即初始化为0，否则不进行初始化）。</p>
<p>对于成员函数，只需要在类定义中给出声明，这是因为我们通常希望将函数的定义（实现）放在类定义之外，例如在一个<code>.cpp</code>文件中。这样可以将接口（即类的声明）与实现（即函数的定义）分离，使代码更清晰，易于理解和维护。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyClass.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a);  <span class="comment">// 构造函数声明</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;  <span class="comment">// 成员函数声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyClass.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> a) : <span class="built_in">data</span>(a) &#123;&#125;  <span class="comment">// 构造函数定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::foo</span><span class="params">()</span> </span>&#123;  <span class="comment">// 成员函数定义</span></span><br><span class="line">    std::cout &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，也可以直接在类定义中提供成员函数的定义。这通常在函数体很短，或者希望函数被内联（<code>inline</code>）时这样做：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a) : <span class="built_in">data</span>(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; data &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>foo</code>函数会自动被编译器视为内联函数，可以减少函数调用开销，但可能增加代码大小。</p>
<h4 id="数组不允许拷贝和赋值"><a href="#数组不允许拷贝和赋值" class="headerlink" title="数组不允许拷贝和赋值"></a>数组不允许拷贝和赋值</h4><p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> a2[] = a;	<span class="comment">//错误，不允许使用一个数组初始化另一个数组</span></span><br><span class="line">a2 = a;			<span class="comment">//错误，不能把一个数组直接赋值给另外一个数组</span></span><br></pre></td></tr></table></figure>



<h4 id="标准库函数begin-和end"><a href="#标准库函数begin-和end" class="headerlink" title="标准库函数begin()和end()"></a>标准库函数begin()和end()</h4><p>数组毕竟不是类类型，因此这两个函数不是成员函数，正确的使用形式是把数组作为他们的参数传入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"><span class="type">int</span>* beg = <span class="built_in">begin</span>(ia);	<span class="comment">//指向ia首元素的指针</span></span><br><span class="line"><span class="type">int</span>* last = <span class="built_in">end</span>(ia);	<span class="comment">//指向ia尾元素的下一位置的指针</span></span><br></pre></td></tr></table></figure>





<h5 id="创建一个vector容器存放string类型的对象"><a href="#创建一个vector容器存放string类型的对象" class="headerlink" title="创建一个vector容器存放string类型的对象"></a>创建一个<code>vector</code>容器存放<code>string</code>类型的对象</h5><p>1、首先我们确定一下这个类要实现哪些功能，初步设计包括三个：</p>
<ul>
<li>实现<code>push_back</code>向容器尾后迭代器指定位置添加元素；</li>
<li>实现<code>size</code>获取容器中存放元素个数的功能；</li>
<li>实现<code>capacity</code>获取容器当前最大容量的功能；</li>
</ul>
<p>同时，可以想到以上三个要在<code>public</code>里实现，作为对外的接口。</p>
<p>2、要实现以上这些功能（拷贝控制函数那些后面再实现）需要哪些变量呢？</p>
<ul>
<li><p>在一开始，我们需要获得一个原始内存，在这里我们采用一个<code>allocator</code>来获得原始内存；</p>
</li>
<li><p>三个指针，分别指向<code>vector</code>容器的首元素、最后一个实际元素之后的位置、分配的内存末尾之后的位置；</p>
</li>
</ul>
<p>3、拷贝控制函数的实现需要哪些工具函数</p>
<p>为了方便各种拷贝控制函数的实现，我们需要实现一些工具函数。拿拷贝构造函数举例来说，我们需要对一个<code>vector</code>容器对象进行拷贝，在拷贝构造函数里直接调用工具函数肯定会使得整个代码结构更加清晰明朗。</p>
<ul>
<li><code>alloc_n_copy</code>：分配内存，并拷贝一个给定范围中的元素；</li>
<li><code>free</code>：销毁构造的元素并释放内存；</li>
<li><code>chk_n_alloc</code>：保证<code>StrVec</code>至少有容纳一个新元素的空间。如果没有空间添加新元素，<code>chk_n_alloc</code>会调用<code>reallocate</code>来分配更多内存；</li>
<li><code>reallocate</code>在内存用完时为<code>StrVec</code>分配新内存；</li>
</ul>
<h5 id="我决定先实现StrVec类的拷贝构造函数"><a href="#我决定先实现StrVec类的拷贝构造函数" class="headerlink" title="我决定先实现StrVec类的拷贝构造函数"></a>我决定先实现StrVec类的拷贝构造函数</h5><p>我们可以将拷贝构造函数设想为将一个vector容器里的所有string拷贝到另一个vector里面。可以简单思考一下，在实现拷贝构造函数时最先遇到的两个问题：</p>
<ul>
<li>既然我要拷贝到另外一个vector里面，那我要如何分配这个新vector的空间？</li>
<li>分配的新空间应该多大呢？</li>
</ul>
<p>在分配空间时我们需要使用到c++里的模板类allocator（后面我会给出有关介绍），</p>
<h4 id="返回类型-函数名-形参列表-const-函数体，请问这个const作用是什么"><a href="#返回类型-函数名-形参列表-const-函数体，请问这个const作用是什么" class="headerlink" title="返回类型+函数名+形参列表+const+函数体，请问这个const作用是什么"></a>返回类型+函数名+形参列表+<code>const</code>+函数体，请问这个<code>const</code>作用是什么</h4><p>在 <code>C++</code>中，函数后面的 <code>const</code> 关键字用于说明函数是一个常量成员函数。这意味着该函数不能修改它所在类的任何非静态成员变量的值。换句话说，常量成员函数不能修改对象的状态。</p>
<p>例如，考虑以下类定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        x = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>getValue()</code> 是一个常量成员函数，因为它后面有 <code>const</code> 关键字。这意味着 <code>getValue()</code> 函数不能修改 <code>MyClass</code> 对象的任何成员变量的值（在这个例子中是 <code>x</code>）。如果你尝试在 <code>getValue()</code> 函数中修改 <code>x</code> 的值，编译器会报错。</p>
<p>常量成员函数通常用于定义不应改变对象状态的操作。这有助于提高代码的安全性和易读性，因为读者可以明确知道哪些函数不会修改对象的状态。</p>
<p>另外，常量成员函数可以在常量对象上调用，非常量成员函数则不能。这使得你可以在需要保证对象不被修改的情况下，仍然可以调用其上的一些成员函数。</p>
<h5 id="常量成员函数可以在常量对象上调用，非常量成员函数则不能。这句话的意思是常量对象不能调用非常量成员函数？"><a href="#常量成员函数可以在常量对象上调用，非常量成员函数则不能。这句话的意思是常量对象不能调用非常量成员函数？" class="headerlink" title="常量成员函数可以在常量对象上调用，非常量成员函数则不能。这句话的意思是常量对象不能调用非常量成员函数？"></a>常量成员函数可以在常量对象上调用，非常量成员函数则不能。这句话的意思是常量对象不能调用非常量成员函数？</h5><p>常量对象（即被 <code>const</code> 修饰的对象）只能调用常量成员函数。这是因为常量对象一旦初始化，其值就不能再被改变。因此，为了保证常量对象的状态不被改变，编译器禁止在常量对象上调用可能会改变对象状态的非常量成员函数。</p>
<p>举一个例子，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;    <span class="comment">// 常量成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; x = val; &#125;   <span class="comment">// 非常量成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;   <span class="comment">// 声明一个常量对象</span></span><br><span class="line">    std::cout &lt;&lt; obj.<span class="built_in">getValue</span>() &lt;&lt; std::endl;  <span class="comment">// 合法，因为getValue是常量成员函数</span></span><br><span class="line">    obj.<span class="built_in">setValue</span>(<span class="number">20</span>);  <span class="comment">// 非法，编译错误。因为setValue是非常量成员函数，不能在常量对象上调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>obj</code> 是一个常量对象。尽管 <code>setValue()</code> 是 <code>MyClass</code> 的一个成员函数，但你不能在 <code>obj</code> 上调用它，因为 <code>setValue()</code> 可能会改变对象的状态，这违反了 <code>obj</code> 是常量的事实。但你可以在 <code>obj</code> 上调用 <code>getValue()</code>，因为它是一个常量成员函数，不会改变对象的状态。</p>
<p>总结：常量对象不能调用非常量成员函数，非常量对象可以调用常量成员函数。（<code>c++ primer p231</code>：引入<code>const</code>成员函数）</p>
<h4 id="封装定义"><a href="#封装定义" class="headerlink" title="封装定义"></a>封装定义</h4><p>封装是指保护类的成员不被随意访问的能力，通过把类的实现细节设置为<code>private</code>，我们就能完成类的封装，实现类的接口与实现分离。</p>
<p>封装的两个重要优点：</p>
<p>1、用户代码不会无意间破坏封装对象的状态；</p>
<p>2、被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码；</p>
<h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>类允许其他类或者函数访问它的非公有成员（私有成员），方法是将其他类或者函数定义成友元，使用关键字<code>friend</code></p>
<p>注意：</p>
<p>友元只能出现在类定义的内部，在类内出现的具体位置不受约束。友元不是类的成员，不受它所在区域访问控制级别的约束。</p>
<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>右值引用主要用来解决两个问题：</p>
<p>1、临时对象非必要的昂贵的拷贝操作</p>
<p>2、在模板函数中如何按照参数的实际类型进行转发</p>
<p>在<code>c++11</code>中所有的值必属于左值、将亡值和纯右值之一。</p>
<p>右值引用绑定了右值，让临时右值的生命周期延长了，可以利用这个特点做一些性能优化，即避免临时对象的拷贝构造和析构</p>
<p>右值引用类型既可能是左值也可能是右值，如<code>T&amp;&amp; t</code>，这里的t既可能是左值也可能是右值。如下所示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; t)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>); <span class="comment">//t是右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>(x); <span class="comment">//t是左值</span></span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/qicosmos/p/4283455.html">贴一个超级详细的连接</a></p>
]]></content>
  </entry>
  <entry>
    <title>单例懒汉模式</title>
    <url>/2023/08/25/%E5%8D%95%E4%BE%8B%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>话不多说，直接上代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//双重检查锁定模式</span></span><br><span class="line">    <span class="comment">//这样做的目的是，如果实例已经被创建，可以避免每次加锁解锁的操作，提高性能</span></span><br><span class="line">    <span class="comment">//但看文字可能不好理解，这里给出不是双重检查锁定模式就好理解了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    static Singleton&amp; getInstance()&#123;</span></span><br><span class="line"><span class="comment">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</span></span><br><span class="line"><span class="comment">        if(instance_ == nullptr)&#123;</span></span><br><span class="line"><span class="comment">            instance_ = new Singleton();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return *instance_;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    这种写法性能非常低下，因为每次调用instance()都会加锁释放锁，而这个步骤只有在第一次new Singleton()才是有必要的。</span></span><br><span class="line"><span class="comment">    只要p被创建出来了，不管多少线程同时访问，使用if (p == nullptr) 进行判断都是足够的（只是读操作，不需要加锁），没有线程安全问题，</span></span><br><span class="line"><span class="comment">    加了锁之后反而存在性能问题。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance_ == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(instance_ == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                instance_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *instance_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::mutex mutex_;</span><br><span class="line">    <span class="type">static</span> Singleton *instance_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::mutex Singleton::mutex_;</span><br><span class="line">Singleton* Singleton::instance_ = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>



<p><strong>问题</strong></p>
<p>构造析构为什么要私有</p>
<p>解答：</p>
<p>在单例模式中，构造函数和析构函数被设置为私有的原因是为了确保满足单例模式的核心要求：系统中某个类只能存在一个实例。</p>
<p>通过将构造函数和析构函数设为私有，我们可以确保以下几点：</p>
<ol>
<li><p><strong>外部无法实例化</strong>：由于构造函数是私有的，这意味着不能在类的外部直接创建该类的实例。这确保了实例的创建只能通过单例类提供的某些特定方法（如<code>getInstance</code>）来完成，从而控制实例的数量。</p>
</li>
<li><p><strong>禁止复制</strong>：单例模式要确保只有一个实例存在，所以我们不希望该类的对象被复制。将构造函数设为私有可以防止复制构造，但为了进一步确保不被复制，我们通常还需要禁止拷贝构造函数和拷贝赋值操作符（通过<code>= delete</code>）。</p>
</li>
<li><p><strong>外部无法销毁</strong>：将析构函数设为私有可以确保外部代码无法直接删除单例对象。通常，单例对象在程序结束时自动销毁，或者单例类提供了一个专门的方法来手动销毁它。</p>
</li>
<li><p><strong>继承控制</strong>：由于构造函数和析构函数是私有的，这也意味着这个类不能被继承（因为派生类的构造函数需要调用基类的构造函数）。</p>
</li>
</ol>
<p>综上所述，将构造函数和析构函数设为私有是为了确保满足单例模式的设计原则，即系统中该类只有一个实例，并提供对该实例的全局访问点。</p>
]]></content>
  </entry>
  <entry>
    <title>对象的优化</title>
    <url>/2023/10/22/%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>一、拷贝构造、赋值运算符重载的相关知识</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> a = <span class="number">10</span>): <span class="built_in">ma</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test &amp;t): <span class="built_in">ma</span>(t.ma) &#123; cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    Test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Test &amp;t)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">        ma = t.ma;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test t1;</span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;</span><br><span class="line">    Test t3 = t1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Test(20)显式生成临时对象 生存周期：所在的语句</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    c++编译器对于对象构造的优化：</span></span><br><span class="line"><span class="comment">    用临时对象生成新对象的时候，临时对象就不产生了，直接构造新对象就可以了。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Test t4 = <span class="built_in">Test</span>(<span class="number">20</span>); <span class="comment">// Test t4(20)没有区别的!</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t4 = t2; <span class="comment">// t4已经存在，这是赋值</span></span><br><span class="line">    t4 = <span class="built_in">Test</span>(<span class="number">30</span>); <span class="comment">// t4.operator=(const Test &amp;t)</span></span><br><span class="line">    t4 = (Test)<span class="number">30</span>; <span class="comment">// int -&gt; Test,强制转换编译器会看有没有合适的构造函数</span></span><br><span class="line">    t4 = <span class="number">30</span>; <span class="comment">// 隐式生成临时对象 隐式类型转换，注意如果30换成一个char类型变量，那就不行了，因为没有对应的构造	  函数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Test *p = &amp;<span class="built_in">Test</span>(<span class="number">40</span>); <span class="comment">// p指向的是一个已经析构的临时对象</span></span><br><span class="line">    <span class="type">const</span> Test &amp;ref = <span class="built_in">Test</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="comment">// 使用引用引用一个临时变量，临时变量的周期就变为了变量的生命周期</span></span><br><span class="line">    <span class="comment">// 自己思考为引用给变量起了一个别名，在引用的生命周期内，就可以继续访问这个临时变量了</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> a = <span class="number">5</span>, <span class="type">int</span> b = <span class="number">5</span>): <span class="built_in">ma</span>(a), <span class="built_in">mb</span>(b)&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test(int, int)&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test &amp;src): <span class="built_in">ma</span>(src.ma), <span class="built_in">mb</span>(src.mb)&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Test &amp;src)&#123;</span><br><span class="line">        ma = src.ma;</span><br><span class="line">        mb = src.mb;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">    <span class="type">int</span> mb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;  <span class="comment">//1. Test(int , int)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;  <span class="comment">//3. Test(int , int)</span></span><br><span class="line">    Test t3 = t2; <span class="comment">// 4.Test(const Test&amp;)</span></span><br><span class="line">    <span class="type">static</span> Test t4 = <span class="built_in">Test</span>(<span class="number">30</span>, <span class="number">30</span>); <span class="comment">//5. Test(int, int)</span></span><br><span class="line">    t2 = <span class="built_in">Test</span>(<span class="number">40</span>, <span class="number">40</span>); <span class="comment">//6.Test(int, int), operetor=, ~Test()</span></span><br><span class="line">    t2 = (Test)(<span class="number">50</span>, <span class="number">50</span>); <span class="comment">//7.Test(int, int), operetor=, ~Test()</span></span><br><span class="line">    t2 = <span class="number">60</span>; <span class="comment">//8.Test(int, int), operetor=, ~Test()</span></span><br><span class="line">    Test *p1 = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">70</span>, <span class="number">70</span>); <span class="comment">// 9.Test(int, int),堆上需要显式释放</span></span><br><span class="line">    Test *p2 = <span class="keyword">new</span> Test[<span class="number">2</span>]; <span class="comment">// 10.Test(int, int), Test(int, int)</span></span><br><span class="line">    Test *p3 = &amp;<span class="built_in">Test</span>(<span class="number">80</span>, <span class="number">80</span>); <span class="comment">//11.Test(int, int), ~Test()</span></span><br><span class="line">    <span class="type">const</span> Test &amp;p4 = <span class="built_in">Test</span>(<span class="number">90</span>, <span class="number">90</span>); <span class="comment">//12.Test(int, int)</span></span><br><span class="line">    <span class="keyword">delete</span> p1; <span class="comment">// 13.~Test()</span></span><br><span class="line">    <span class="keyword">delete</span> []p2; <span class="comment">// 14. ~Test(), ~Test()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Test <span class="title">t5</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;  <span class="comment">//2. Test(int , int)</span></span><br><span class="line"><span class="comment">// 注意，t4的析构最晚，它在数据段，需要等程序结束。</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2023/05/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="tips：为什么快速排序算法把基准元素名称定义为pivot"><a href="#tips：为什么快速排序算法把基准元素名称定义为pivot" class="headerlink" title="tips：为什么快速排序算法把基准元素名称定义为pivot"></a>tips：为什么快速排序算法把基准元素名称定义为pivot</h5><p>在快速排序算法中，”<code>pivot</code>“（基准元素）是一个用来将数据集分割成两部分的元素。所有比基准元素小的元素都被放到它的左边，而所有比它大的元素都被放到它的右边。这就是为什么它被称为 “<code>pivot</code>“（枢轴），因为它在排序过程中起到了中心轴的作用，就像一个旋转门或者天平的支点那样。</p>
<p>在一次快速排序的分割操作中，我们从数组的一端开始，将所有比<code>pivot</code>小的元素放到左边，比<code>pivot</code>大的元素放到右边。这个过程称为分区操作（<code>partitioning</code>）。经过分区操作后，<code>pivot</code>元素会位于数组的某个位置，它左边的所有元素都不大于它，它右边的所有元素都不小于它，所以它就到了排序后应该在的位置。</p>
<p>然后我们可以递归地对<code>pivot</code>左边的元素和右边的元素分别进行快速排序，这样整个数组就会变得有序。</p>
<p>所以，<code>pivot</code>元素在快速排序中起到了关键的作用，它是算法的核心部分。</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>以下是一个C++的快速排序实现示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序的一次划分操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];   <span class="comment">// 选择最右边的元素作为基准元素</span></span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = low; j &lt;= high<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i+<span class="number">1</span>], arr[high]);</span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high);   <span class="comment">// 执行一次划分操作</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>);   <span class="comment">// 对左侧子数组递归执行快速排序</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high);  <span class="comment">// 对右侧子数组递归执行快速排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: \n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个程序中，<code>partition</code>函数是快速排序的核心，它实现了一次划分操作。我们首先选择一个基准元素（这里选择的是数组最右侧的元素），然后将所有比基准元素小的元素移动到数组的左侧，比基准元素大的元素移动到数组的右侧。</p>
<p><code>quickSort</code>函数是一个递归函数，它首先调用<code>partition</code>函数进行一次划分操作，然后对基准元素左侧和右侧的子数组分别递归调用<code>quickSort</code>函数进行排序。这个过程会一直递归下去，直到子数组的大小为1或0，此时子数组已经是有序的，递归结束。</p>
<h5 id="在实现代码时犯了一个小错误"><a href="#在实现代码时犯了一个小错误" class="headerlink" title="在实现代码时犯了一个小错误"></a>在实现代码时犯了一个小错误</h5><p>在<code>partition</code>函数实现时，最后一步的交换过程中，应该是<code>swap(arr[i+1], arr[high])</code>，而我第一次实现时写成了<code>swap(arr[i+1], pivot)</code>。为什么这样不行呢？貌似看起来是合理的，因为我们在一开始就有语句：<code>int pivot = arr[high];</code>但是恰巧问题就是出现在了这里，因为我们要交换的是<code>vector</code>容器里的元素，我们在实现<code>int pivot = arr[high];</code>这个语句时<code>pivot</code>只是拿到了<code>arr[high]</code>的值，因此我们并没有实际交换<code>arr[i+1]</code>和<code>arr[high]</code>，所以排序后的结果肯定是错的。（因此，定义成这样<code>int&amp; pivot = arr[high]</code>，就可以这样写：<code>swap(arr[i+1], pivot)</code>）</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序是一种基于堆的排序算法。它使用了一种叫做堆的数据结构。堆有两种类型：最大堆和最小堆。最大堆的特性是父节点的值大于或等于其所有子节点的值，最小堆的特性是父节点的值小于或等于其所有子节点的值。</p>
<p>堆排序的基本步骤如下：</p>
<ol>
<li>建立最大堆：将待排序序列构造成一个最大堆，这样就能保证整个序列的最大值就是堆顶的根节点。</li>
<li>交换数据：将根节点与最后一个元素交换位置，然后断开（排除）最后一个元素。</li>
<li>重建最大堆：通过调整使剩余元素重新构成最大堆。</li>
<li>重复步骤2~3，直到整个序列有序。</li>
</ol>
<p>这里挂一个讲堆排序很好的博客，一定要耐心阅读！<a href="%5B(92%E6%9D%A1%E6%B6%88%E6%81%AF">引用链接</a> 堆排序详细图解（通俗易懂）_右大臣的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_51609435/article/details/122982075">https://blog.csdn.net/weixin_51609435/article/details/122982075</a>))</p>
<h5 id="堆排序c-实现"><a href="#堆排序c-实现" class="headerlink" title="堆排序c++实现"></a>堆排序c++实现</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> largest = i;   <span class="comment">//从largest往下开始建立大根堆，暂不考虑largset往上的数据</span></span><br><span class="line">	<span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">		largest = left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">		largest = right;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line">		<span class="built_in">heapify</span>(arr, n, largest);    </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">		<span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; arr = &#123; <span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	<span class="built_in">heapSort</span>(arr);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> a : arr) &#123;</span><br><span class="line">		cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="自己初步实现时没有彻底弄明白堆排序，所以有如下这个问题"><a href="#自己初步实现时没有彻底弄明白堆排序，所以有如下这个问题" class="headerlink" title="自己初步实现时没有彻底弄明白堆排序，所以有如下这个问题"></a>自己初步实现时没有彻底弄明白堆排序，所以有如下这个问题</h5><p>为什么第一次需要</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>而从<code>i=n-1</code>开始，就直接 <code>heapify(arr, i, 0); </code>就没有<code>i=n/2-1</code>的这个过程</p>
<p>这是因为我们在开始的时候是在创建最大堆。在创建最大堆的过程中，我们需要从最后一个非叶子节点（即 <code>n / 2 - 1</code>）开始，然后向前遍历到根节点（即 <code>0</code>），对每个节点进行下沉操作，确保其满足最大堆的性质。这是创建最大堆的过程。</p>
<p>然后，我们进入排序的步骤，每次将当前最大的元素（即堆顶元素）与当前堆的最后一个元素交换，然后断开最后一个元素（即排除最后一个元素，使堆的大小减小1），然后再将新的堆顶元素进行下沉操作，确保剩余元素还是一个最大堆。这个过程一直持续到整个堆的元素都被排除，即整个数组都被排序。</p>
<p>因此，在排序的过程中，我们不需要再从 <code>n / 2 - 1</code> 开始了，因为除了堆顶元素以外，其他元素都满足最大堆的性质，所以我们只需要将新的堆顶元素进行下沉操作即可，也就是 <code>heapify(arr, i, 0);</code>。</p>
]]></content>
  </entry>
  <entry>
    <title>日志模块设计</title>
    <url>/2023/08/25/%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p><strong>本篇文章主要参考如下文章，主要是对代码做一个较为详尽的解释</strong></p>
<p>参考链接：<a href="https://blog.csdn.net/qq_46495964/article/details/122952567">https://blog.csdn.net/qq_46495964/article/details/122952567</a></p>
<p><strong>前言：</strong><br>日志系统在程序运行中有着非常大的作用，用于记录程序的运行情况，在程序出错后查看日志，方便地定位出错的大概范围。在设计日志系统之前，先考虑一下日志需要输出什么信息呢？什么信息才是有用的信息，都知道写日志是一种对文件的<code>io</code>操作，所以尽可能避免输出没用的信息。<br><strong>有用的信息：关键变量的值、运行的位置（哪个文件、哪个函数、哪一行）、时间、线程号、进程号等等。</strong></p>
<h4 id="日志系统的设计"><a href="#日志系统的设计" class="headerlink" title="日志系统的设计"></a>日志系统的设计</h4><ol>
<li><p>日志的级别</p>
<p>在测试、调试、交付等场景需要输出不同的级别日志。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常见的日志级别</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LOGLEVEL</span></span><br><span class="line">&#123;</span><br><span class="line">	LOG_LEVEL_NONE,</span><br><span class="line">	LOG_LEVEL_ERROR,     <span class="comment">// error</span></span><br><span class="line">	LOG_LEVEL_WARNING,   <span class="comment">// warning</span></span><br><span class="line">	LOG_LEVEL_DEBUG,     <span class="comment">// debug</span></span><br><span class="line">	LOG_LEVEL_INFO,      <span class="comment">// info	</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>日志的输出地</p>
<p>日志输出的地方可能不同，终端、控制台、UI界面、文件等等都有。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">LOGTARGET</span></span><br><span class="line">&#123;</span><br><span class="line">	LOG_TERM      = <span class="number">0x00</span>,</span><br><span class="line">	LOG_FILE      = <span class="number">0x01</span>,</span><br><span class="line">	LOG_UI        = <span class="number">0x10</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>日志的作用域</p>
<p>日志做到什么时候都可以输出，可作用于全程序文件，考虑到多线程情况下，必须保证日志的输出需要得到线程安全的保障，所以需要一个<strong>全局且唯一的日志器</strong>。使用设计模式中的<strong>单例模式—–日志器</strong></p>
</li>
</ol>
<h4 id="C-版本的日志系统的实现"><a href="#C-版本的日志系统的实现" class="headerlink" title="C++版本的日志系统的实现"></a>C++版本的日志系统的实现</h4><p><strong>Logger.h</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这是一个基本的线程安全日志系统的头文件，其目的是为应用程序提供日志功能。以下是对这个头文件的详细解释：</span><br><span class="line"></span><br><span class="line">1. **预处理指令和宏**:</span><br><span class="line">    - `<span class="comment">#ifndef`, `#define`, 和 `#endif` 用于保证头文件只被包含一次，避免重复定义。</span></span><br><span class="line">    - `<span class="comment">#define` 宏定义了三个日志级别：`LogInfo`, `LogWarning`, 和 `LogError`。这些宏都使用了变参（`...`），允许用户为日志提供自定义的格式和参数。这些宏捕获了日志消息的来源（文件、行号和函数）并将其添加到日志队列中。</span></span><br><span class="line"></span><br><span class="line">2. **类定义：Logger**</span><br><span class="line">    - 是一个单例类，这意味着整个程序中只能有一个实例。这通过私有的默认构造函数、删除的复制构造函数和赋值运算符来实现。</span><br><span class="line">    - `GetInstance()` 方法提供了对单例实例的访问。</span><br><span class="line">    - `SetFileName()` 允许设置日志文件的名称。</span><br><span class="line">    - `Start()` 和 `Stop()` 用于启动和停止日志线程。</span><br><span class="line">    - `AddToQueue()` 是用于将新的日志消息添加到日志队列的方法。</span><br><span class="line">    - `threadfunc()` 是日志线程的工作函数，它持续从日志队列中读取消息并写入文件。</span><br><span class="line"></span><br><span class="line">3. **类的私有成员**:</span><br><span class="line">    - `filename_`: 存储日志文件的名称。</span><br><span class="line">    - `fp_`: 用于文件操作的文件指针。请注意，在所给代码中，`FILE` 的声明被注释掉了，你需要包含 `&lt;cstdio&gt;` 或者直接使用 C++ 的文件流类（如 `std::ofstream`）。</span><br><span class="line">    - `spthread_`: 一个智能指针，指向日志线程。</span><br><span class="line">    - `mutex_`: 用于保护日志队列和其他共享资源，确保多线程访问时的线程安全。</span><br><span class="line">    - `cv_`: 条件变量，用于通知日志线程有新的消息到来。</span><br><span class="line">    - `exit_`: 一个标志，指示日志线程何时退出。</span><br><span class="line">    - `queue_`: 存储待处理日志消息的队列。</span><br><span class="line"></span><br><span class="line">4. **注释**: </span><br><span class="line">    - 提供了关于该文件的基本信息，如文件名称和日期。</span><br><span class="line"></span><br><span class="line">总之，这个日志系统设计的思路是：</span><br><span class="line">1. 用户调用预定义的宏添加日志消息。</span><br><span class="line">2. 日志消息被添加到一个线程安全的队列。</span><br><span class="line">3. 一个独立的日志线程从队列中取出消息并写入文件。</span><br><span class="line"></span><br><span class="line">这种设计允许应用程序非阻塞地添加日志消息，而将I/O操作留给专门的线程，从而提高应用程序的性能。</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 日志类头文件, Logger.h</span></span><br><span class="line"><span class="comment"> *  2022.02.1</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LOGGER_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LOGGER_H__</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//struct FILE;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LogInfo(...)        Logger::GetInstance().AddToQueue(<span class="string">&quot;INFO&quot;</span>, __FILE__, __LINE__, __PRETTY_FUNCTION__, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LogWarning(...)     Logger::GetInstance().AddToQueue(<span class="string">&quot;WARNING&quot;</span>, __FILE__, __LINE__, __PRETTY_FUNCTION__, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LogError(...)       Logger::GetInstance().AddToQueue(<span class="string">&quot;ERROR&quot;</span>, __FILE__, __LINE__, __PRETTY_FUNCTION__, __VA_ARGS__)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetFileName</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddToQueue</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszLevel, <span class="type">const</span> <span class="type">char</span>* pszFile, <span class="type">int</span> lineNo, <span class="type">const</span> <span class="type">char</span>* pszFuncSig, <span class="type">char</span>* pszFmt, ...)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Logger</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> Logger&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    Logger&amp; <span class="keyword">operator</span> =(Logger&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadfunc</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string                     filename_;</span><br><span class="line">    FILE*                           fp_&#123;&#125;;</span><br><span class="line">    std::shared_ptr&lt;std::thread&gt;    spthread_;</span><br><span class="line">    std::mutex                      mutex_;</span><br><span class="line">    std::condition_variable         cv_;            <span class="comment">//有新的日志到来的标识</span></span><br><span class="line">    <span class="type">bool</span>                            exit_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    std::list&lt;std::string&gt;          queue_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//!__LOGGER_H__</span></span></span><br></pre></td></tr></table></figure>



<p>Logger.cpp</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这是日志类的实现文件`Logger.cpp`。它对`Logger.h`中定义的函数进行了具体的实现。我将分步解释这个文件的内容：</span><br><span class="line"></span><br><span class="line">1. **<span class="comment">#include语句**: 引入了所需的头文件，其中`Logger.h`是之前你展示的日志类的头文件，其他的是C和C++标准库中的头文件。</span></span><br><span class="line"></span><br><span class="line">2. **GetInstance方法**: 实现了单例模式的核心功能。通过使用局部静态对象`logger`，它确保只创建一次`Logger`类的实例。</span><br><span class="line"></span><br><span class="line">3. **SetFileName方法**: 允许用户设置日志文件的名称。</span><br><span class="line"></span><br><span class="line">4. **Start方法**: </span><br><span class="line">    - 如果用户没有提供日志文件名，它会生成一个默认的日志文件名，该文件名包含当前的日期和时间。</span><br><span class="line">    - 尝试打开日志文件以写入和读取。</span><br><span class="line">    - 创建一个新线程来处理日志消息。</span><br><span class="line"></span><br><span class="line">5. **Stop方法**: </span><br><span class="line">    - 设置`exit_`标志为`<span class="literal">true</span>`。</span><br><span class="line">    - 通过条件变量通知日志线程。</span><br><span class="line">    - 等待日志线程结束。</span><br><span class="line"></span><br><span class="line">6. **AddToQueue方法**: </span><br><span class="line">    - 使用变长参数列表格式化日志消息。</span><br><span class="line">    - 生成一个包含日期、时间、日志级别、线程ID、源文件名、行号、函数签名和日志消息的完整日志字符串。</span><br><span class="line">    - 使用互斥锁将完整的日志字符串添加到队列。</span><br><span class="line">    - 通过条件变量通知日志线程有新的消息到来。</span><br><span class="line"></span><br><span class="line">7. **threadfunc方法**:</span><br><span class="line">    - 日志线程的核心功能。</span><br><span class="line">    - 检查文件指针是否为空。</span><br><span class="line">    - 在`exit_`为`<span class="literal">false</span>`的情况下，循环处理日志消息。</span><br><span class="line">    - 使用互斥锁和条件变量等待新的消息到来。</span><br><span class="line">    - 当有新的消息时，从队列中取出并写入日志文件。</span><br><span class="line">    - 如果设置了退出标志并且队列为空，线程将退出。</span><br><span class="line"></span><br><span class="line">总体上，这是一个简单但功能完整的日志系统实现。它使用了多线程，互斥锁和条件变量来确保线程安全，并使日志操作与应用程序的其他部分异步进行，从而提高了性能。</span><br><span class="line"></span><br><span class="line">然而，也有一些可以进一步优化或改进的地方：</span><br><span class="line">1. 在`Start()`中，文件是以<span class="string">&quot;wt+&quot;</span>模式打开的，这意味着如果文件已经存在，它会被覆盖。如果希望在现有文件中追加日志，则应使用<span class="string">&quot;at+&quot;</span>。</span><br><span class="line">2. 代码中没有明确的错误处理或异常处理策略。例如，如果`fopen`失败或`std::thread`创建失败时。</span><br><span class="line">3. 在`threadfunc`中，当队列不为空时，每处理一个消息就会刷新文件，这可能影响性能。可以考虑在队列中有多个消息时，一次性写入多个消息，然后再刷新。</span><br><span class="line">4. 可能会考虑添加一个`Rotate`功能，当日志文件大小超过某个限制时，自动将当前日志文件重命名，并创建一个新的日志文件。</span><br><span class="line">5. 为了提高性能，可以考虑使用双缓冲技术，这样可以减少互斥锁的争用。</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 日志类实现文件, Logger.cpp</span></span><br><span class="line"><span class="comment"> *  2022.02.1</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">Logger&amp; <span class="title">Logger::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Logger logger;</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::SetFileName</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    filename_ = filename;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Logger::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (filename_.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">tm</span>* t = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line">        <span class="type">char</span> timestr[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(timestr, <span class="string">&quot;%04d%02d%02d%02d%02d%02d.imserver.log&quot;</span>, t-&gt;tm_year + <span class="number">1900</span>, t-&gt;tm_mon + <span class="number">1</span>, t-&gt;tm_mday, t-&gt;tm_hour, t-&gt;tm_min, t-&gt;tm_sec);</span><br><span class="line">        filename_ = timestr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fp_ = <span class="built_in">fopen</span>(filename_.<span class="built_in">c_str</span>(), <span class="string">&quot;wt+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp_ == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    spthread_.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">thread</span>(std::<span class="built_in">bind</span>(&amp;Logger::threadfunc, <span class="keyword">this</span>)));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::Stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    exit_ = <span class="literal">true</span>;</span><br><span class="line">    cv_.<span class="built_in">notify_one</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//等待时间线程结束</span></span><br><span class="line">    spthread_-&gt;<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::AddToQueue</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszLevel, <span class="type">const</span> <span class="type">char</span>* pszFile, <span class="type">int</span> lineNo, <span class="type">const</span> <span class="type">char</span>* pszFuncSig, <span class="type">char</span>* pszFmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> msg[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    va_list vArgList;                            </span><br><span class="line">    <span class="built_in">va_start</span>(vArgList, pszFmt);</span><br><span class="line">    <span class="built_in">vsnprintf</span>(msg, <span class="number">256</span>, pszFmt, vArgList);</span><br><span class="line">    <span class="built_in">va_end</span>(vArgList);</span><br><span class="line"> </span><br><span class="line">    <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span>* tmstr = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line">    <span class="type">char</span> content[<span class="number">512</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;[%04d-%02d-%02d %02d:%02d:%02d][%s][0x%04x][%s:%d %s]%s\n&quot;</span>,</span><br><span class="line">                tmstr-&gt;tm_year + <span class="number">1900</span>,</span><br><span class="line">                tmstr-&gt;tm_mon + <span class="number">1</span>,</span><br><span class="line">                tmstr-&gt;tm_mday,</span><br><span class="line">                tmstr-&gt;tm_hour,</span><br><span class="line">                tmstr-&gt;tm_min,</span><br><span class="line">                tmstr-&gt;tm_sec,</span><br><span class="line">                pszLevel,</span><br><span class="line">                std::this_thread::<span class="built_in">get_id</span>(),</span><br><span class="line">                pszFile,</span><br><span class="line">                lineNo,</span><br><span class="line">                pszFuncSig,</span><br><span class="line">                msg);</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        queue_.<span class="built_in">emplace_back</span>(content);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::threadfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fp_ == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (!exit_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//写日志</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (queue_.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (exit_)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">            cv_.<span class="built_in">wait</span>(guard);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//写日志</span></span><br><span class="line">        <span class="type">const</span> std::string&amp; str = queue_.<span class="built_in">front</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">fwrite</span>((<span class="type">void</span>*)str.<span class="built_in">c_str</span>(), str.<span class="built_in">length</span>(), <span class="number">1</span>, fp_);</span><br><span class="line">        <span class="built_in">fflush</span>(fp_);</span><br><span class="line">        queue_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ol>
<li><p>Stop方法: 设置exit_标志为true。 通过条件变量通知日志线程。 等待日志线程结束 </p>
<p><strong>请问这里为什么需要通知日志线程</strong></p>
<p>解答：在<code>Logger</code>类的实现中，日志线程的工作是从队列中获取日志消息并将其写入文件。为了实现这个功能，它在队列为空时通过<code>cv_.wait(guard)</code>进入休眠状态，等待新的日志消息的到来。</p>
<p>当你调用<code>Stop</code>方法时，你希望日志线程能够尽快结束。但有一种情况需要考虑：当<code>Stop</code>被调用时，队列可能仍然是空的，这意味着日志线程可能处于<code>cv_.wait(guard)</code>的休眠状态。</p>
<p>在这种情况下，即使你设置了<code>exit_</code>标志为<code>true</code>，日志线程仍然不会醒来检查这个标志，因为它正在等待新的日志消息到来。</p>
<p>为了确保日志线程能够醒来、检查<code>exit_</code>标志并正确地退出，你需要在<code>Stop</code>方法中通过<code>cv_.notify_one()</code>通知日志线程。这样，日志线程将被唤醒，然后它可以检查<code>exit_</code>标志，并根据该标志的值决定是否退出。</p>
<p>总之，通知日志线程是为了确保它可以从<code>cv_.wait(guard)</code>中醒来，然后检查退出条件并安全地退出。</p>
</li>
<li><p>这个程序没有设计线程来将新的日志信息加入队列吗</p>
<p>从提供的代码来看，日志系统中只设计了一个专门的日志线程（在<code>Logger::Start()</code>方法中启动），其任务是从队列中提取日志消息并将其写入文件。此外，并没有为添加新日志消息到队列专门设计线程。</p>
<p>当你希望写入日志时，只需在你的主程序或任何其他线程中调用<code>LogInfo()</code>, <code>LogWarning()</code>, 或 <code>LogError()</code>这样的宏。这些宏内部会调用<code>Logger::AddToQueue()</code>，该方法将日志消息格式化并加入到队列中。这种设计的优点是简单且高效，因为它允许多个线程在运行时无缝地向日志系统添加消息，而无需额外的线程。</p>
<p>但值得注意的是，<code>Logger::AddToQueue()</code>使用了互斥锁<code>mutex_</code>来保证多个线程同时向队列添加消息时的线程安全。这意味着，即使多个线程同时调用日志宏，<code>Logger::AddToQueue()</code>中的代码仍然是线程安全的。</p>
<p>总的来说，这个日志系统的设计考虑到了多线程环境，允许多个线程同时添加日志消息，但它并没有专门设置一个线程来完成这项任务，而是允许主程序或其他任何线程来直接调用添加日志的宏。</p>
<p>自己的话：你自己程序在运行的时候是不是有多个线程，这些线程就是负责啥时候要调用<code>LogInfo()</code>, <code>LogWarning()</code>, 或 <code>LogError()</code>这样的宏。所以当然不需要额外的线程来操作加入队列操作，只需要一个带锁函数即可。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>C++头文件保护符</title>
    <url>/2023/04/20/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="头文件保护符定义"><a href="#头文件保护符定义" class="headerlink" title="头文件保护符定义"></a>头文件保护符定义</h2><p>头文件保护符（Header guards）的主要作用是防止头文件在同一个编译单元中被多次包含。这可以避免因多次包含相同的头文件导致的编译错误，例如重复定义类、函数或变量。头文件保护符是通过使用预处理器指令 <code>#ifndef</code>、<code>#define</code> 和 <code>#endif</code> 实现的。</p>
<p><code>#define</code>: 把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否定义；</p>
<p><code>#ifdef</code>: 当且仅当变量已定义时为真；</p>
<p><code>#ifndef</code>: 当且仅当变量未定义时为真；</p>
<p>注意：<code>ifdef</code> 和 <code>ifndef</code> 一旦检查结果为真，则执行后续程序直至遇到 <code>endif</code> 为止。</p>
<h2 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h2><p>假设我们有一个名为 <code>my_class.h</code> 的头文件，其中定义了一个名为 <code>MyClass</code> 的类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// my_class.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_CLASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_CLASS_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MY_CLASS_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个头文件中，我们使用了头文件保护符。<code>#ifndef MY_CLASS_H</code> 检查一个名为 <code>MY_CLASS_H</code> 的宏是否已被定义。如果尚未定义，编译器会继续处理 <code>#define MY_CLASS_H</code>，将 <code>MY_CLASS_H</code> 定义为宏，并包含 <code>MyClass</code> 的定义。<code>#endif</code> 结束了这个条件编译块。</p>
<p>现在，假设我们有一个名为 <code>main.cpp</code> 的源文件，它包含了 <code>my_class.h</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_class.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_class.h&quot;</span> <span class="comment">// 这里再次包含了同一个头文件，但是没有问题，因为有头文件保护符</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">print_hello</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>main.cpp</code> 中，我们包含了 <code>my_class.h</code> 头文件两次。如果没有头文件保护符，这将导致 <code>MyClass</code> 类被重复定义，从而引发编译错误。由于我们使用了头文件保护符，当第二次尝试包含 <code>my_class.h</code> 时，<code>MY_CLASS_H</code> 宏已经被定义，因此 <code>#ifndef MY_CLASS_H</code> 的条件为 false，<code>MyClass</code> 的定义不会再次被包含。</p>
<p>这个简单的例子展示了头文件保护符如何防止头文件在同一个编译单元中被多次包含，从而避免了编译错误。</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>include ifndef</tag>
        <tag>include define</tag>
        <tag>include endif</tag>
      </tags>
  </entry>
  <entry>
    <title>构造函数</title>
    <url>/2023/04/22/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="对象的副本"><a href="#对象的副本" class="headerlink" title="对象的副本"></a>对象的副本</h2><p>在 C++ 中，一个对象的副本是指创建了原始对象的一个拷贝，这个拷贝具有与原始对象相同的属性和状态。换句话说，副本是源对象的一个独立副本，它们的值相同，但是<code>它们在内存中占用不同的空间</code>。</p>
<p>创建对象副本的过程通常称为拷贝构造。当我们创建一个新对象时，如果使用另一个已经存在的对象作为模板，那么新对象就是原始对象的一个副本。通常，这会涉及调用拷贝构造函数。</p>
<p>以下是一个简单的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a) : <span class="built_in">x</span>(a) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) : <span class="built_in">x</span>(other.x) &#123;&#125; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 使用构造函数创建一个对象</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(obj1)</span></span>; <span class="comment">// 使用拷贝构造函数创建 obj1 的一个副本</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj1.x = &quot;</span> &lt;&lt; obj1.x &lt;&lt; std::endl; <span class="comment">// 输出：obj1.x = 10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj2.x = &quot;</span> &lt;&lt; obj2.x &lt;&lt; std::endl; <span class="comment">// 输出：obj2.x = 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们有一个名为 <code>MyClass</code> 的类，它具有一个整数成员变量 <code>x</code>。我们为 <code>MyClass</code> 提供了一个构造函数和一个拷贝构造函数。在 <code>main</code> 函数中，我们首先使用构造函数创建了一个名为 <code>obj1</code> 的对象，然后使用拷贝构造函数创建了 <code>obj1</code> 的一个副本，名为 <code>obj2</code>。<code>obj2</code> 是 <code>obj1</code> 的副本，因为它具有与 <code>obj1</code> 相同的属性（在这种情况下，是 <code>x</code> 的值）。</p>
<p>请注意，尽管 <code>obj1</code> 和 <code>obj2</code> 具有相同的值，但它们在内存中是独立的。这意味着更改其中一个对象的状态不会影响另一个对象。</p>
<h2 id="拷贝构造函数通常不应该是explicit的"><a href="#拷贝构造函数通常不应该是explicit的" class="headerlink" title="拷贝构造函数通常不应该是explicit的"></a>拷贝构造函数通常不应该是explicit的</h2><p>在 C++ 中，<code>explicit</code> 关键字用于指定构造函数或类型转换操作不应该进行隐式类型转换。换句话说，<code>explicit</code> 可以防止在需要显式构造的情况下发生隐式类型转换。</p>
<p>当我们说 “拷贝构造函数通常不应该是 <code>explicit</code> 的” 时，意味着拷贝构造函数应该允许隐式类型转换，以方便编译器在需要时自动执行拷贝构造。</p>
<p>拷贝构造函数允许隐式转换的原因是因为它们在很多情况下被编译器隐式调用，例如：</p>
<ol>
<li>将一个对象作为函数参数传递时。</li>
<li>从函数返回一个对象时。</li>
<li>使用赋值运算符初始化一个对象时。</li>
</ol>
<p>在这些情况下，如果拷贝构造函数被声明为 <code>explicit</code>，则可能会导致编译错误，因为编译器不能隐式调用拷贝构造函数。</p>
<p>以下是一个例子，说明为什么拷贝构造函数不应该是 <code>explicit</code> 的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a) : <span class="built_in">x</span>(a) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">const</span> MyClass&amp; other)</span> : x(other.x) &#123;</span>&#125; <span class="comment">// explicit 拷贝构造函数（不推荐）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_function</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... do something ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行代码会导致编译错误，因为拷贝构造函数是 explicit 的，编译器不能隐式调用它。</span></span><br><span class="line">    <span class="built_in">some_function</span>(obj1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们将拷贝构造函数声明为 <code>explicit</code>，这导致了编译错误。当我们尝试将 <code>obj1</code> 传递给 <code>some_function</code> 时，编译器无法隐式调用拷贝构造函数，因此会报错。为了避免这种情况，拷贝构造函数通常应该允许隐式类型转换，不应该被声明为 <code>explicit</code>。</p>
<h3 id="如果不想上面这个报错，也不去掉explicit，应该怎么做"><a href="#如果不想上面这个报错，也不去掉explicit，应该怎么做" class="headerlink" title="如果不想上面这个报错，也不去掉explicit，应该怎么做"></a>如果不想上面这个报错，也不去掉explicit，应该怎么做</h3><p>如果您希望保留 <code>explicit</code> 关键字并避免编译错误，您需要显式地调用拷贝构造函数。在这种情况下，可以使用以下方法：</p>
<ol>
<li>使用花括号 <code>&#123;&#125;</code> 或圆括号 <code>()</code> 显式地创建一个临时对象并传递给 <code>some_function</code>。</li>
<li>使用 <code>static_cast</code> 来显式地创建一个副本。</li>
</ol>
<p>以下是两种方法的示例：</p>
<p>方法 1：使用花括号 <code>&#123;&#125;</code> 或圆括号 <code>()</code> 显式地创建一个临时对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用花括号显式地调用拷贝构造函数</span></span><br><span class="line">    <span class="built_in">some_function</span>(MyClass&#123;obj1&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者，使用圆括号显式地调用拷贝构造函数</span></span><br><span class="line">    <span class="built_in">some_function</span>(<span class="built_in">MyClass</span>(obj1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法 2：使用 <code>static_cast</code> 来显式地创建一个副本。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 static_cast 显式地调用拷贝构造函数</span></span><br><span class="line">    <span class="built_in">some_function</span>(<span class="built_in">static_cast</span>&lt;MyClass&gt;(obj1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这些示例中，我们显式地调用了拷贝构造函数，因此编译器不再需要隐式地调用它。这使得代码能够正常编译和运行，尽管拷贝构造函数被声明为 <code>explicit</code>。</p>
<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a><code>static_cast</code></h4><p><code>static_cast</code> 是 C++ 中一种用于执行编译时类型转换的操作符。它可以在相关类型之间进行转换，例如将指针或引用的类型从基类转换为派生类，将枚举类型转换为整数，或在数值类型（如 int、float、double 等）之间进行转换。与 C 风格的强制类型转换相比，<code>static_cast</code> 提供了更严格的类型检查，因此更安全。</p>
<p>以下是使用 <code>static_cast</code> 的一些示例：</p>
<ol>
<li>在数值类型之间进行转换：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(i); <span class="comment">// 将 int 类型转换为 double 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将枚举类型转换为整数：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Color c = RED;</span><br><span class="line">    <span class="type">int</span> color_code = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(c); <span class="comment">// 将枚举类型转换为 int 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在类层次结构中进行向上转换（从派生类到基类）：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived *derived_ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    Base *base_ptr = <span class="built_in">static_cast</span>&lt;Base*&gt;(derived_ptr); <span class="comment">// 将 Derived* 类型转换为 Base* 类型</span></span><br><span class="line">    <span class="keyword">delete</span> derived_ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>static_cast</code> 不能转换无关的类型，例如将 <code>void*</code> 转换为其他类型的指针，或将非类类型转换为类类型。对于这些情况，可以使用其他类型的转换操作符，如 <code>reinterpret_cast</code> 或 <code>dynamic_cast</code>。注意：<code>double d = (int) i</code>即为C中的强制类型转换。</p>
<h4 id="static-cast-提供了更严格的类型检查是如何体现的"><a href="#static-cast-提供了更严格的类型检查是如何体现的" class="headerlink" title="static_cast 提供了更严格的类型检查是如何体现的"></a>static_cast 提供了更严格的类型检查是如何体现的</h4><p><code>static_cast</code> 提供更严格类型检查的体现主要在于它在编译时执行类型检查，而不是在运行时。这意味着，如果类型转换不安全或不正确，编译器将在编译期间发出错误或警告，而不是在运行时导致未定义行为。</p>
<p>以下是一些<code>static_cast</code>类型检查的例子：</p>
<ol>
<li><p>在数值类型之间进行转换时，<code>static_cast</code> 会检查转换是否合理。例如，将一个 <code>double</code> 转换为 <code>int</code> 会丢失小数部分，但这种转换仍然是明确的，因此编译器允许它。然而，如果转换可能导致数据损失或无法执行，编译器将发出警告或错误。</p>
</li>
<li><p>在类层次结构中进行向上转换（从派生类到基类）时，<code>static_cast</code> 会确保两个类之间存在继承关系。例如，将一个 <code>Derived*</code> 转换为 <code>Base*</code> 是允许的，前提是 <code>Derived</code> 类真正继承自 <code>Base</code> 类。如果这两个类没有继承关系，编译器将发出错误。</p>
</li>
</ol>
<p>与 C 风格的强制类型转换相比，<code>static_cast</code> 更安全，因为 C 风格的强制类型转换不会进行类型检查。例如，您可以使用 C 风格的强制类型转换将一个 <code>float</code> 指针转换为一个 <code>int</code> 指针，尽管这样做可能导致未定义行为。使用 <code>static_cast</code> 进行此类转换会导致编译错误。</p>
<p>总之，<code>static_cast</code> 在编译时进行类型检查，确保转换是明确的、安全的且合理的。这使得它比 C 风格的强制类型转换更安全。然而，应谨慎使用 <code>static_cast</code>，并且只在确信转换是安全的情况下使用，因为它仍然可能导致数据损失或其他问题，尤其是在数值类型转换和向下转换（从基类到派生类）时。在这些情况下，应考虑使用其他类型转换操作符，如 <code>dynamic_cast</code> 或 <code>reinterpret_cast</code>。</p>
<h4 id="为什么输出color-code是0呢"><a href="#为什么输出color-code是0呢" class="headerlink" title="为什么输出color_code是0呢"></a>为什么输出color_code是0呢</h4><p>在您提供的代码示例中，<code>color_code</code> 的值为 0，因为 <code>Color</code> 枚举中的 <code>RED</code> 成员被隐式地赋予了整数值 0。C++ 中的枚举成员会从 0 开始递增地分配整数值，除非您明确地为它们指定其他值。因此，在这个例子中，<code>Color</code> 枚举成员的整数值如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>RED</code> 的值为 0</li>
<li><code>GREEN</code> 的值为 1</li>
<li><code>BLUE</code> 的值为 2</li>
</ul>
<p>当您将 <code>c</code> 赋值为 <code>RED</code> 并将其转换为 <code>int</code> 类型时，<code>color_code</code> 变量将接收整数值 0，因为这是 <code>RED</code> 枚举成员对应的值。这就是为什么 <code>color_code</code> 的输出值为 0 的原因。</p>
<h4 id="如何赋值其他值呢"><a href="#如何赋值其他值呢" class="headerlink" title="如何赋值其他值呢"></a>如何赋值其他值呢</h4><p>在 C++ 中，您可以为枚举成员显式分配整数值。为此，只需在枚举成员后使用等号 (&#x3D;) 并指定所需的整数值。以下是一个示例，说明如何为 <code>Color</code> 枚举的成员分配自定义整数值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED = <span class="number">3</span>, GREEN = <span class="number">7</span>, BLUE = <span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们将 <code>RED</code> 的值设为 3，<code>GREEN</code> 的值设为 7，而 <code>BLUE</code> 的值设为 10。现在，当您将枚举成员转换为整数类型时，它们将具有这些显式分配的值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Color c = RED;</span><br><span class="line">    <span class="type">int</span> color_code = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(c); <span class="comment">// 将枚举类型转换为 int 类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Color code for RED: &quot;</span> &lt;&lt; color_code &lt;&lt; std::endl; <span class="comment">// 输出：Color code for RED: 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>color_code</code> 的值为 3，因为我们为 <code>RED</code> 枚举成员分配了整数值 3。</p>
<h2 id="合成拷贝构造函数和拷贝构造函数有什么不同吗"><a href="#合成拷贝构造函数和拷贝构造函数有什么不同吗" class="headerlink" title="合成拷贝构造函数和拷贝构造函数有什么不同吗"></a>合成拷贝构造函数和拷贝构造函数有什么不同吗</h2><p>拷贝构造函数和合成拷贝构造函数的主要区别在于它们的来源和行为。拷贝构造函数是用户自定义的，而合成拷贝构造函数是编译器自动生成的。</p>
<ol>
<li>拷贝构造函数（User-defined copy constructor）：<br>当您在类中显式地定义一个拷贝构造函数时，就是创建了一个用户自定义的拷贝构造函数。这意味着您可以根据需要自定义拷贝行为。例如，您可能需要执行深拷贝以避免潜在的浅拷贝问题。自定义拷贝构造函数的例子如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户自定义的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass &amp;other) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(*other.data); <span class="comment">// 深拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>合成拷贝构造函数（Synthesized copy constructor）：<br>当您没有在类中显式地定义拷贝构造函数时，编译器会自动生成一个合成拷贝构造函数。合成拷贝构造函数执行成员逐个拷贝，即：对于类类型的成员，调用其拷贝构造函数；对于内置类型的成员，直接进行值拷贝。需要注意的是，合成拷贝构造函数执行的是浅拷贝，这可能导致潜在的内存问题（例如，当类包含指针成员时）。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器自动生成的合成拷贝构造函数</span></span><br><span class="line">    <span class="comment">// MyClass(const MyClass &amp;other) = default;</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>总之，拷贝构造函数和合成拷贝构造函数的主要区别在于：拷贝构造函数是用户自定义的，可以自定义拷贝行为；合成拷贝构造函数是编译器自动生成的，执行逐个成员的拷贝。如果类中没有显式地定义拷贝构造函数，编译器将自动生成一个合成拷贝构造函数。如果您需要自定义拷贝行为（例如执行深拷贝），则应在类中显式地定义拷贝构造函数。</p>
<h2 id="拷贝初始化除了在使用-x3D-定义变量时会发生，还有什么情况下会发生"><a href="#拷贝初始化除了在使用-x3D-定义变量时会发生，还有什么情况下会发生" class="headerlink" title="拷贝初始化除了在使用&#x3D;定义变量时会发生，还有什么情况下会发生"></a>拷贝初始化除了在使用&#x3D;定义变量时会发生，还有什么情况下会发生</h2><p>拷贝初始化不仅在使用等号 <code>=</code> 定义变量时会发生，还会在以下几种情况下发生：</p>
<ol>
<li>作为函数参数传递对象时：<br>当将对象作为函数参数传递时，如果参数是按值传递的（即不是引用或指针），则会发生拷贝初始化。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass a;</span><br><span class="line">    <span class="built_in">foo</span>(a); <span class="comment">// 拷贝初始化：将 a 作为参数传递给函数 foo</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>从函数返回对象时：<br>当从函数返回一个对象时，会发生拷贝初始化。这通常涉及到返回值优化（RVO），在许多情况下，编译器会优化这个过程，避免不必要的拷贝。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">create_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> obj; <span class="comment">// 拷贝初始化：从函数返回一个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass b = <span class="built_in">create_object</span>(); <span class="comment">// 拷贝初始化：接收从函数返回的对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用花括号 <code>&#123;&#125;</code> 或圆括号 <code>()</code> 初始化对象时：<br>当用另一个对象初始化新对象时，如果使用花括号 <code>&#123;&#125;</code> 或圆括号 <code>()</code>，也会发生拷贝初始化。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass c;</span><br><span class="line">    <span class="function">MyClass <span class="title">d</span><span class="params">(c)</span></span>; <span class="comment">// 拷贝初始化：使用圆括号初始化对象</span></span><br><span class="line">    MyClass e&#123;c&#125;; <span class="comment">// 拷贝初始化：使用花括号初始化对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>初始化列表中的成员初始化：<br>当在类的构造函数的初始化列表中初始化成员对象时，也会发生拷贝初始化。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnotherClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass obj;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AnotherClass</span>(<span class="type">const</span> MyClass &amp;other_obj) : <span class="built_in">obj</span>(other_obj) &#123;</span><br><span class="line">        <span class="comment">// 拷贝初始化：在初始化列表中初始化成员对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass f;</span><br><span class="line">    <span class="function">AnotherClass <span class="title">g</span><span class="params">(f)</span></span>; <span class="comment">// 拷贝初始化：将 f 传递给 AnotherClass 的构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上各种情况下，都可能发生拷贝初始化。然而，需要注意的是，编译器通常会尽可能地优化这些拷贝操作，以提高程序的性能。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
        <tag>拷贝构造函数</tag>
        <tag>合成拷贝构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title>第三篇博客</title>
    <url>/2023/04/27/%E7%AC%AC%E4%B8%89%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="赋值运算符为什么必须定义为成员函数"><a href="#赋值运算符为什么必须定义为成员函数" class="headerlink" title="赋值运算符为什么必须定义为成员函数"></a>赋值运算符为什么必须定义为成员函数</h2><p>在C++中，赋值运算符（&#x3D;）通常需要被定义为类的成员函数，而不能是友元函数或非成员函数。这是因为以下几个原因：</p>
<ol>
<li><p>语法限制：在C++中，某些运算符（如赋值运算符、下标运算符、函数调用运算符等）只能作为成员函数来重载，而不能作为非成员函数。这是C++语言本身的规定，设计者这样规定是为了让这些运算符的行为更接近其内建类型的原生行为。</p>
</li>
<li><p>保持语义一致性：赋值运算符用于将一个对象的值赋给另一个对象。将赋值运算符定义为成员函数，有助于保持与内建类型的赋值操作一致的语义。此外，成员函数可以访问类的私有成员，这使得赋值操作可以在内部完成，而无需暴露类的实现细节。</p>
</li>
<li><p>自动处理自赋值情况：当赋值运算符被定义为成员函数时，如果发生自赋值（如a &#x3D; a），编译器可以更容易地识别这种情况并进行优化。如果将赋值运算符定义为非成员函数，处理自赋值情况可能会更加困难。</p>
</li>
<li><p>提供默认赋值运算符：如果在类中没有显式地定义赋值运算符，编译器会自动生成一个默认的赋值运算符。这个默认的赋值运算符会执行逐成员（逐个数据成员）的赋值操作。默认的赋值运算符是一个成员函数，可以满足大多数场景的需求。如果你需要自定义赋值运算符，定义成员函数是最直接的方式。</p>
</li>
</ol>
<p>总之，将赋值运算符定义为成员函数，有助于保持与内建类型的赋值操作一致的语义，简化自赋值情况的处理，并允许访问类的私有成员。这些原因使得赋值运算符作为成员函数更加合适。</p>
<h2 id="给出定义成成员函数和非成员函数的例子，以及如果是编译器自动生成的，默认赋值是怎么赋值的，都给出例子"><a href="#给出定义成成员函数和非成员函数的例子，以及如果是编译器自动生成的，默认赋值是怎么赋值的，都给出例子" class="headerlink" title="给出定义成成员函数和非成员函数的例子，以及如果是编译器自动生成的，默认赋值是怎么赋值的，都给出例子"></a>给出定义成成员函数和非成员函数的例子，以及如果是编译器自动生成的，默认赋值是怎么赋值的，都给出例子</h2><p>首先，我们给出一个成员函数和非成员函数的简单示例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">memberFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nonMemberFunction</span><span class="params">(MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    obj.x = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成员函数</span></span><br><span class="line">    obj.<span class="built_in">memberFunction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用非成员函数</span></span><br><span class="line">    <span class="built_in">nonMemberFunction</span>(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了如何使用成员函数和非成员函数来操作类的公共数据成员。请注意，这个示例没有涉及运算符重载，只是展示了成员函数和非成员函数的基本概念。</p>
<p>接下来，我们讨论编译器自动生成的默认赋值运算符。当你没有为类显式定义赋值运算符时，编译器会生成一个默认的赋值运算符。默认赋值运算符会执行逐成员赋值，即逐个拷贝源对象的数据成员到目标对象。这里有一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point p1;</span><br><span class="line">    p1.x = <span class="number">3</span>;</span><br><span class="line">    p1.y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    Point p2;</span><br><span class="line">    p2.x = <span class="number">0</span>;</span><br><span class="line">    p2.y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用编译器生成的默认赋值运算符</span></span><br><span class="line">    p2 = p1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果：3, 4</span></span><br><span class="line">    std::cout &lt;&lt; p2.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p2.y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们没有为<code>Point</code>类显式定义赋值运算符。然而，当我们执行<code>p2 = p1</code>时，编译器生成的默认赋值运算符会被调用。默认赋值运算符会将<code>p1</code>的数据成员逐个拷贝到<code>p2</code>，所以在赋值操作之后，<code>p2.x</code>和<code>p2.y</code>分别是3和4。</p>
<h2 id="如果把MyClass类里的x定义成private，那么非成员函数传入的obj的x还能被赋值吗，你能详细展开讲讲这些问题吗"><a href="#如果把MyClass类里的x定义成private，那么非成员函数传入的obj的x还能被赋值吗，你能详细展开讲讲这些问题吗" class="headerlink" title="如果把MyClass类里的x定义成private，那么非成员函数传入的obj的x还能被赋值吗，你能详细展开讲讲这些问题吗"></a>如果把MyClass类里的x定义成private，那么非成员函数传入的obj的x还能被赋值吗，你能详细展开讲讲这些问题吗</h2><p>如果将<code>MyClass</code>类中的数据成员<code>x</code>定义为<code>private</code>，则非成员函数将无法直接访问和修改它。以下是修改后的类定义和示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">memberFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个访问x的接口</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个修改x的接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> newX)</span> </span>&#123;</span><br><span class="line">        x = newX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nonMemberFunction</span><span class="params">(MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// obj.x = 42; // 错误！无法访问私有成员</span></span><br><span class="line">    obj.<span class="built_in">setX</span>(<span class="number">42</span>); <span class="comment">// 使用公共接口修改x</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成员函数</span></span><br><span class="line">    obj.<span class="built_in">memberFunction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用非成员函数</span></span><br><span class="line">    <span class="built_in">nonMemberFunction</span>(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>x</code>现在是私有成员，我们不能在类外部直接访问它。这种情况下，我们需要为<code>MyClass</code>提供公共接口（如<code>getX()</code>和<code>setX()</code>），以便在类外部获取和修改<code>x</code>的值。在这个示例中，我们在<code>nonMemberFunction()</code>中使用了<code>setX()</code>方法来修改<code>x</code>的值，而不是直接访问私有成员。</p>
<p>私有成员的主要目的是封装和隐藏类的实现细节。这样，你可以更自由地修改类的内部实现，而不影响使用该类的代码。通过将数据成员设置为私有并提供公共接口，你可以控制类外部对数据成员的访问和修改，从而确保类的正确使用和数据的完整性。</p>
<h3 id="x2F-obj-x-x3D-42-x2F-x2F-错误！无法访问私有成员-obj-setX-42-x2F-x2F-使用公共接口修改x-这个意思是：虽然不能直接对x进行修改，但obj仍然有x这个属性，那么obj的x属性值是多少呢？obj不是拥有它吗？我的理解有误吗"><a href="#x2F-obj-x-x3D-42-x2F-x2F-错误！无法访问私有成员-obj-setX-42-x2F-x2F-使用公共接口修改x-这个意思是：虽然不能直接对x进行修改，但obj仍然有x这个属性，那么obj的x属性值是多少呢？obj不是拥有它吗？我的理解有误吗" class="headerlink" title="&#x2F; obj.x &#x3D; 42; &#x2F;&#x2F; 错误！无法访问私有成员    obj.setX(42); &#x2F;&#x2F; 使用公共接口修改x 这个意思是：虽然不能直接对x进行修改，但obj仍然有x这个属性，那么obj的x属性值是多少呢？obj不是拥有它吗？我的理解有误吗"></a>&#x2F; obj.x &#x3D; 42; &#x2F;&#x2F; 错误！无法访问私有成员    obj.setX(42); &#x2F;&#x2F; 使用公共接口修改x 这个意思是：虽然不能直接对x进行修改，但obj仍然有x这个属性，那么obj的x属性值是多少呢？obj不是拥有它吗？我的理解有误吗</h3><p>是的，你的理解是正确的。<code>MyClass</code>对象<code>obj</code>仍然具有数据成员<code>x</code>，但是由于<code>x</code>是私有的，所以在类的外部不能直接访问或修改它。这就是封装的概念。尽管<code>x</code>是私有的，但它仍然是<code>MyClass</code>对象的一部分。这意味着当你创建一个<code>MyClass</code>对象时，<code>x</code>也会作为对象的一部分被创建。</p>
<p>在上述示例中，当我们创建<code>MyClass</code>对象<code>obj</code>时，<code>x</code>的初始值是未定义的（因为我们没有为<code>x</code>提供初始值）。在调用<code>obj.memberFunction()</code>后，<code>x</code>的值被设置为42。然后，当我们调用<code>nonMemberFunction(obj)</code>时，我们不能直接访问<code>x</code>，但可以通过公共接口<code>setX()</code>来修改<code>x</code>的值。这里，我们再次将<code>x</code>的值设置为42。</p>
<p>所以，在<code>nonMemberFunction()</code>执行之后，<code>obj</code>的<code>x</code>属性值仍然是42。虽然我们不能直接访问<code>x</code>，但通过公共接口<code>getX()</code>，我们可以获取<code>x</code>的值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;obj.x = &quot;</span> &lt;&lt; obj.<span class="built_in">getX</span>() &lt;&lt; std::endl; <span class="comment">// 输出：obj.x = 42</span></span><br></pre></td></tr></table></figure>

<p>总之，<code>obj</code>确实拥有私有成员<code>x</code>，但在类的外部不能直接访问或修改它。为了在类外部操作<code>x</code>，我们需要使用类提供的公共接口。</p>
<h2 id="此外，成员函数可以访问类的私有成员，这使得赋值操作可以在内部完成，而无需暴露类的实现细节。如果不是成员函数就会暴露细节吗？给个例子"><a href="#此外，成员函数可以访问类的私有成员，这使得赋值操作可以在内部完成，而无需暴露类的实现细节。如果不是成员函数就会暴露细节吗？给个例子" class="headerlink" title="此外，成员函数可以访问类的私有成员，这使得赋值操作可以在内部完成，而无需暴露类的实现细节。如果不是成员函数就会暴露细节吗？给个例子"></a>此外，成员函数可以访问类的私有成员，这使得赋值操作可以在内部完成，而无需暴露类的实现细节。如果不是成员函数就会暴露细节吗？给个例子</h2><p>当赋值操作涉及类的私有成员时，使用成员函数可以确保不会暴露类的实现细节。如果尝试使用非成员函数来实现赋值操作，我们需要提供访问私有成员的接口，这可能会破坏封装。让我们用一个例子来说明这个问题。</p>
<p>首先，考虑以下<code>MyClass</code>定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> initialX) : <span class="built_in">x</span>(initialX) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员赋值运算符</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x = other.x; <span class="comment">// 可以直接访问私有成员</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了一个成员赋值运算符。因为这是一个成员函数，所以它可以直接访问<code>other</code>对象的私有成员<code>x</code>。这样，我们不需要提供额外的接口来访问<code>x</code>，可以保持封装。</p>
<p>现在，假设我们尝试使用非成员函数来实现赋值操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> initialX) : <span class="built_in">x</span>(initialX) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供访问x的接口</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供修改x的接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> newX)</span> </span>&#123;</span><br><span class="line">        x = newX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非成员赋值运算符</span></span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp; lhs, <span class="type">const</span> MyClass&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (&amp;lhs == &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无法直接访问私有成员，需要使用公共接口</span></span><br><span class="line">    lhs.<span class="built_in">setX</span>(rhs.<span class="built_in">getX</span>());</span><br><span class="line">    <span class="keyword">return</span> lhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们试图使用非成员函数实现赋值运算符。然而，由于非成员函数无法直接访问私有成员，我们必须提供公共接口<code>getX()</code>和<code>setX()</code>来访问和修改<code>x</code>。这暴露了类的实现细节，并可能破坏封装。</p>
<p>需要注意的是，这个例子中的非成员赋值运算符尝试重载等号运算符（&#x3D;），然而，实际上在C++中赋值运算符（&#x3D;）必须被定义为类的成员函数，不能作为非成员函数。这个例子只是用来说明如果使用非成员函数来实现类似赋值操作的情况，可能会导致封装的破坏。</p>
<h2 id="类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值，这句话如何理解"><a href="#类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值，这句话如何理解" class="headerlink" title="类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值，这句话如何理解"></a>类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值，这句话如何理解</h2><p>这句话的意思是，对于某些类，编译器生成的合成拷贝赋值运算符可能不适用，或者类的设计者希望禁止对象之间的赋值操作。在这种情况下，合成拷贝赋值运算符会被显式地删除或声明为私有，从而阻止用户对该类的对象执行赋值操作。</p>
<p>当类中包含不可复制的资源（如文件句柄、互斥锁等）或类的实例应该保持唯一时（如单例模式），通常需要禁止类的对象之间的赋值操作。让我们通过一个例子来说明这个概念。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyableResource</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有拷贝构造函数</span></span><br><span class="line">    <span class="built_in">NonCopyableResource</span>(<span class="type">const</span> NonCopyableResource&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有拷贝赋值运算符</span></span><br><span class="line">    NonCopyableResource&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyableResource&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NonCopyableResource</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了一个<code>NonCopyableResource</code>类，它具有私有的拷贝构造函数和拷贝赋值运算符。因为这两个函数是私有的，所以在类的外部不能使用它们。这样，我们就阻止了该类对象之间的拷贝和赋值操作。</p>
<p>从C++11开始，我们可以更明确地禁止拷贝构造函数和拷贝赋值运算符，方法是将它们声明为<code>= delete</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyableResource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NonCopyableResource</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line">    <span class="built_in">NonCopyableResource</span>(<span class="type">const</span> NonCopyableResource&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝赋值运算符</span></span><br><span class="line">    NonCopyableResource&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyableResource&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方法更清晰地表明了拷贝构造函数和拷贝赋值运算符是被禁止的。当试图对这个类的对象执行拷贝或赋值操作时，编译器会报错。</p>
<p>总之，当类的对象不应该被复制或赋值时，可以通过将拷贝构造函数和拷贝赋值运算符声明为私有或删除它们来禁止这些操作。这样可以确保类的对象在程序中具有正确的行为。</p>
<h2 id="如果拷贝赋值运算符不是出于禁止拷贝的目的，他会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，为啥static不能赋值过去，是因为他的存储位置吗"><a href="#如果拷贝赋值运算符不是出于禁止拷贝的目的，他会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，为啥static不能赋值过去，是因为他的存储位置吗" class="headerlink" title="如果拷贝赋值运算符不是出于禁止拷贝的目的，他会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，为啥static不能赋值过去，是因为他的存储位置吗"></a>如果拷贝赋值运算符不是出于禁止拷贝的目的，他会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，为啥static不能赋值过去，是因为他的存储位置吗</h2><p>是的，你的理解是正确的。当拷贝赋值运算符执行时，它会将右侧运算对象的每个非static成员逐一赋值给左侧运算对象的对应成员。static成员变量的赋值不涉及到拷贝赋值运算符，因为它们不属于类的单个实例。</p>
<p>static成员变量属于类本身，而不是类的对象。它们在内存中的存储位置与类的实例对象不同。实际上，所有类的实例共享同一个static成员变量。因此，当你修改一个类实例的static成员变量时，这个修改会影响所有类实例。这就是为什么在拷贝赋值操作中，不需要拷贝static成员变量的原因。</p>
<p>以下是一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> nonStaticMember;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticMember;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> nonStaticValue) : <span class="built_in">nonStaticMember</span>(nonStaticValue) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化static成员变量</span></span><br><span class="line"><span class="type">int</span> MyClass::staticMember = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改static成员变量</span></span><br><span class="line">    MyClass::staticMember = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值操作</span></span><br><span class="line">    obj1 = obj2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果：20, 42</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj1: &quot;</span> &lt;&lt; obj1.nonStaticMember &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; MyClass::staticMember &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 输出结果：20, 42</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj2: &quot;</span> &lt;&lt; obj2.nonStaticMember &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; MyClass::staticMember &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>MyClass</code>具有一个非static成员变量<code>nonStaticMember</code>和一个static成员变量<code>staticMember</code>。当我们执行拷贝赋值操作<code>obj1 = obj2</code>时，只有<code>nonStaticMember</code>被拷贝，而<code>staticMember</code>保持不变。这是因为<code>staticMember</code>属于类本身，而不是类的实例。</p>
<h2 id="哪些情况下指针所指的对象会随着指针的销毁而销毁，哪些情况下不会？指针指向的对象没了，指针就没了吗？"><a href="#哪些情况下指针所指的对象会随着指针的销毁而销毁，哪些情况下不会？指针指向的对象没了，指针就没了吗？" class="headerlink" title="哪些情况下指针所指的对象会随着指针的销毁而销毁，哪些情况下不会？指针指向的对象没了，指针就没了吗？"></a>哪些情况下指针所指的对象会随着指针的销毁而销毁，哪些情况下不会？指针指向的对象没了，指针就没了吗？</h2><p>指针和指针所指向的对象是两个不同的概念。指针是一种变量，它存储了对象在内存中的地址。当指针被销毁时，它所指向的对象不会自动销毁。同样，当指针所指向的对象被销毁时，指针本身也不会自动销毁。它们的生命周期是独立的。</p>
<ol>
<li><p>指针所指向的对象会随着指针的销毁而销毁的情况：<br>实际上，没有这样的情况。当指针被销毁时，它所指向的对象不会自动销毁。只有当你显式地销毁指针所指向的对象时，对象才会被销毁。</p>
</li>
<li><p>指针指向的对象没了，指针就没了吗？<br>不是这样的。当指针所指向的对象被销毁时，指针本身不会自动销毁。指针仍然存在，但它现在指向的是一个已经销毁的对象，也就是所谓的悬空指针（dangling pointer）。在这种情况下，访问该悬空指针可能导致未定义行为，因为它可能指向无效的内存区域。</p>
</li>
</ol>
<p>以下是一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>); <span class="comment">// 动态分配内存，p指向该内存区域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 销毁p所指向的对象，释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// p没有被销毁，但现在是一个悬空指针，因为它指向的对象已经被销毁</span></span><br><span class="line">    <span class="comment">// 访问p可能导致未定义行为</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; *p &lt;&lt; std::endl; // 不安全！不要这样做</span></span><br><span class="line"></span><br><span class="line">    p = <span class="literal">nullptr</span>; <span class="comment">// 将悬空指针设置为nullptr，避免未定义行为</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免未定义行为，当销毁指针所指向的对象后，通常将指针设置为<code>nullptr</code>。这样，即使指针没有被销毁，也不会指向一个无效的内存区域。</p>
<h2 id="HasPtr-const-HasPtr-amp-rhs-this-gt-i-x3D-rhs-i-this-gt-ps-x3D-amp-rhs-ps-和下面这个-HasPtr-const-HasPtr-amp-rhs-this-gt-i-x3D-rhs-i-ps-x3D-new-string-rhs-ps-从拷贝构造函数的实现意义层面来说，有区别吗？是不是都是拷贝了ps指向的对象，而不是拷贝ps本身"><a href="#HasPtr-const-HasPtr-amp-rhs-this-gt-i-x3D-rhs-i-this-gt-ps-x3D-amp-rhs-ps-和下面这个-HasPtr-const-HasPtr-amp-rhs-this-gt-i-x3D-rhs-i-ps-x3D-new-string-rhs-ps-从拷贝构造函数的实现意义层面来说，有区别吗？是不是都是拷贝了ps指向的对象，而不是拷贝ps本身" class="headerlink" title="HasPtr(const HasPtr&amp; rhs) { 	this-&gt;i &#x3D; rhs.i; 	this-&gt;ps &#x3D; &amp;(*rhs.ps); } 和下面这个 HasPtr(const HasPtr&amp; rhs) { 	this-&gt;i &#x3D; rhs.i; 	ps &#x3D; new string(*rhs.ps); } 从拷贝构造函数的实现意义层面来说，有区别吗？是不是都是拷贝了ps指向的对象，而不是拷贝ps本身"></a>HasPtr(const HasPtr&amp; rhs) { 	this-&gt;i &#x3D; rhs.i; 	this-&gt;ps &#x3D; &amp;(*rhs.ps); } 和下面这个 HasPtr(const HasPtr&amp; rhs) { 	this-&gt;i &#x3D; rhs.i; 	ps &#x3D; new string(*rhs.ps); } 从拷贝构造函数的实现意义层面来说，有区别吗？是不是都是拷贝了ps指向的对象，而不是拷贝ps本身</h2><p>这两个拷贝构造函数的实现在语义层面上有很大的区别。</p>
<p>第一个拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;i = rhs.i;</span><br><span class="line">    <span class="keyword">this</span>-&gt;ps = &amp;(*rhs.ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个拷贝构造函数的实现仅仅是将<code>rhs</code>对象的<code>ps</code>成员的地址赋值给当前对象的<code>ps</code>成员。这意味着，两个<code>HasPtr</code>对象的<code>ps</code>成员指向同一个<code>string</code>对象。在这种情况下，我们说这是一种浅拷贝（shallow copy）。浅拷贝可能导致资源管理问题，如在析构函数中释放同一个对象两次。</p>
<p>第二个拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;i = rhs.i;</span><br><span class="line">    ps = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个拷贝构造函数的实现不仅将<code>rhs</code>对象的<code>ps</code>成员的值复制给当前对象的<code>ps</code>成员，还为当前对象的<code>ps</code>成员创建了一个新的<code>string</code>对象。这样，两个<code>HasPtr</code>对象的<code>ps</code>成员指向两个不同的、相互独立的<code>string</code>对象。在这种情况下，我们说这是一种深拷贝（deep copy）。深拷贝通常可以避免资源管理问题，因为每个对象都有自己独立的资源副本。</p>
<p>所以，从拷贝构造函数的实现意义层面来说，这两个实现有很大的区别。第一个实现是浅拷贝，可能导致资源管理问题；而第二个实现是深拷贝，可以避免这些问题。在实际编程中，根据具体需求选择合适的拷贝策略是很重要的。</p>
<h2 id="include-class-HasPtr-public-HasPtr-const-std-string-amp-s-x3D-std-string-ps-new-std-string-s-i-0-x2F-HasPtr-const-HasPtr-amp-rhs-this-gt-i-x3D-rhs-i-this-gt-ps-x3D-amp-rhs-ps-x2F-HasPtr-delete-ps-private-std-string-ps-int-i-HasPtr-f-HasPtr-hp-HasPtr-ret-x3D-hp-return-ret-int-main-HasPtr-p-“hello-world”-f-p-HasPtr-q-p-return-0-这里我有一个疑问，f函数的返回值是HasPtr类型，为什么我在main函数里调用f不需要使用HasPtr类型的对象来接受它的返回值呢"><a href="#include-class-HasPtr-public-HasPtr-const-std-string-amp-s-x3D-std-string-ps-new-std-string-s-i-0-x2F-HasPtr-const-HasPtr-amp-rhs-this-gt-i-x3D-rhs-i-this-gt-ps-x3D-amp-rhs-ps-x2F-HasPtr-delete-ps-private-std-string-ps-int-i-HasPtr-f-HasPtr-hp-HasPtr-ret-x3D-hp-return-ret-int-main-HasPtr-p-“hello-world”-f-p-HasPtr-q-p-return-0-这里我有一个疑问，f函数的返回值是HasPtr类型，为什么我在main函数里调用f不需要使用HasPtr类型的对象来接受它的返回值呢" class="headerlink" title="#include  class HasPtr { public: HasPtr(const std::string &amp;s &#x3D; std::string()): ps(new std::string(s)), i(0) {} 	&#x2F;HasPtr(const HasPtr&amp; rhs) { 	this-&gt;i &#x3D; rhs.i; 	this-&gt;ps &#x3D; &amp;(rhs.ps); }&#x2F; 	~HasPtr() { delete ps; } private: std::string ps; int i; }; HasPtr f(HasPtr hp) { HasPtr ret &#x3D; hp; return ret; } int main() { HasPtr p(“hello world”); f(p); HasPtr q(p); 	return 0; } 这里我有一个疑问，f函数的返回值是HasPtr类型，为什么我在main函数里调用f不需要使用HasPtr类型的对象来接受它的返回值呢"></a>#include <iostream> class HasPtr { public: HasPtr(const std::string &amp;s &#x3D; std::string()): ps(new std::string(s)), i(0) {} 	&#x2F;<em>HasPtr(const HasPtr&amp; rhs) { 	this-&gt;i &#x3D; rhs.i; 	this-&gt;ps &#x3D; &amp;(<em>rhs.ps); }</em>&#x2F; 	~HasPtr() { delete ps; } private: std::string</em> ps; int i; }; HasPtr f(HasPtr hp) { HasPtr ret &#x3D; hp; return ret; } int main() { HasPtr p(“hello world”); f(p); HasPtr q(p); 	return 0; } 这里我有一个疑问，f函数的返回值是HasPtr类型，为什么我在main函数里调用f不需要使用HasPtr类型的对象来接受它的返回值呢</iostream></h2><p>在这个例子中，当你调用<code>f(p)</code>时，即使没有为<code>f</code>函数的返回值指定一个<code>HasPtr</code>类型的对象来接收它，C++编译器仍然会处理这种情况。在没有指定接收返回值的情况下，编译器会创建一个临时<code>HasPtr</code>对象，用于接收<code>f</code>函数的返回值。这个临时对象会在表达式结束后立即销毁。</p>
<p>这就是为什么你不需要显式地使用一个<code>HasPtr</code>对象来接收<code>f</code>函数的返回值。然而，为了避免潜在的性能损失和资源浪费，通常建议你在调用返回对象的函数时指定一个接收返回值的变量。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">HasPtr <span class="title">p</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line">    HasPtr r = <span class="built_in">f</span>(p);  <span class="comment">// 使用HasPtr对象r来接收f函数的返回值</span></span><br><span class="line">    <span class="function">HasPtr <span class="title">q</span><span class="params">(p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，你可以避免创建和销毁临时对象，从而提高程序的性能。</p>
<h2 id="为什么需要拷贝操作的类也需要赋值操作，反之亦然，这句话是什么意思"><a href="#为什么需要拷贝操作的类也需要赋值操作，反之亦然，这句话是什么意思" class="headerlink" title="为什么需要拷贝操作的类也需要赋值操作，反之亦然，这句话是什么意思"></a>为什么需要拷贝操作的类也需要赋值操作，反之亦然，这句话是什么意思</h2><p>这句话的意思是，当你为一个类实现拷贝操作（拷贝构造函数）时，通常也需要实现赋值操作（拷贝赋值运算符），反之亦然。这是因为拷贝操作和赋值操作通常在语义上是相似的，而且在实际使用中经常会一起出现。实现一个而不实现另一个可能导致类的行为不一致或不完整。</p>
<p>拷贝构造函数和拷贝赋值运算符的主要区别在于它们的用途：</p>
<ol>
<li>拷贝构造函数（Copy Constructor）：当创建一个新对象并用另一个已存在的对象初始化它时，会调用拷贝构造函数。典型的情况包括：将一个对象作为参数传递给函数、从函数返回一个对象、初始化列表等。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyClass obj1;</span><br><span class="line"><span class="function">MyClass <span class="title">obj2</span><span class="params">(obj1)</span></span>;  <span class="comment">// 调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拷贝赋值运算符（Copy Assignment Operator）：当两个已经存在的对象之间进行赋值操作时，会调用拷贝赋值运算符。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyClass obj1;</span><br><span class="line">MyClass obj2;</span><br><span class="line">obj2 = obj1;  <span class="comment">// 调用拷贝赋值运算符</span></span><br></pre></td></tr></table></figure>

<p>在许多情况下，拷贝构造函数和拷贝赋值运算符需要执行相似的操作（如深拷贝）。实现两者可以确保类在各种情况下都能正确地处理拷贝和赋值操作。这就是为什么“需要拷贝操作的类也需要赋值操作，反之亦然”的原因。如果仅实现其中之一，可能会导致类在某些情况下无法正确地执行拷贝或赋值操作，从而引发问题。</p>
<p>当然可以。让我们通过一个简单的示例来说明仅实现拷贝构造函数而不实现拷贝赋值运算符可能导致的问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> std::string&amp; s) : <span class="built_in">data</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(s)) &#123;&#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) : <span class="built_in">data</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(*other.data)) &#123;&#125; <span class="comment">// 拷贝构造函数实现了深拷贝</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; <span class="keyword">delete</span> data; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="string">&quot;world&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MyClass <span class="title">obj3</span><span class="params">(obj1)</span></span>; <span class="comment">// 使用拷贝构造函数，执行正确</span></span><br><span class="line"></span><br><span class="line">    obj2 = obj1; <span class="comment">// 这里使用默认的拷贝赋值运算符，执行浅拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们实现了<code>MyClass</code>的拷贝构造函数，它执行深拷贝。但是，我们没有实现拷贝赋值运算符。因此，在赋值操作（如<code>obj2 = obj1;</code>）时，编译器会生成一个默认的拷贝赋值运算符，该运算符执行浅拷贝。</p>
<p>问题出现在这个默认的拷贝赋值运算符上。因为它执行浅拷贝，<code>obj2</code>和<code>obj1</code>的<code>data</code>成员将指向同一个<code>std::string</code>对象。当<code>main</code>函数结束时，<code>obj1</code>和<code>obj2</code>的析构函数都将被调用，它们都会尝试删除同一个<code>std::string</code>对象。这将导致未定义行为，可能会导致程序崩溃。</p>
<p>如果我们为<code>MyClass</code>同时实现拷贝构造函数和拷贝赋值运算符，并确保它们都执行深拷贝，就可以避免这个问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 其他成员函数 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符实现了深拷贝</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::string* newData = <span class="keyword">new</span> std::<span class="built_in">string</span>(*other.data);</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">        data = newData;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string* data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，无论是使用拷贝构造函数还是拷贝赋值运算符，<code>MyClass</code>对象都将正确地执行深拷贝，从而避免了资源管理问题。</p>
<h2 id="你这个例子并没有解释为什么二者需要同时定义啊，比如第一个程序，我不执行赋值对拷贝构造也没影响啊"><a href="#你这个例子并没有解释为什么二者需要同时定义啊，比如第一个程序，我不执行赋值对拷贝构造也没影响啊" class="headerlink" title="你这个例子并没有解释为什么二者需要同时定义啊，比如第一个程序，我不执行赋值对拷贝构造也没影响啊"></a>你这个例子并没有解释为什么二者需要同时定义啊，比如第一个程序，我不执行赋值对拷贝构造也没影响啊</h2><p>抱歉，我的示例可能没有充分解释为什么两者需要同时定义。请允许我通过另一个例子来解释这个问题。</p>
<p>假设你有一个类，它表示一个动态分配的二维数组，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> rows, <span class="type">int</span> cols)</span><br><span class="line">        : <span class="built_in">rows</span>(rows), <span class="built_in">cols</span>(cols), <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[rows * cols]) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">const</span> Matrix&amp; other)</span><br><span class="line">        : <span class="built_in">rows</span>(other.rows), <span class="built_in">cols</span>(other.cols), <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[rows * cols]) &#123;</span><br><span class="line">        std::<span class="built_in">copy</span>(other.data, other.data + rows * cols, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Matrix</span>() &#123; <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他成员函数 ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> rows, cols;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们实现了<code>Matrix</code>的拷贝构造函数，它执行深拷贝。然而，我们没有实现拷贝赋值运算符。因此，编译器会生成一个默认的拷贝赋值运算符，执行浅拷贝。</p>
<p>现在，假设你需要执行以下操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Matrix <span class="title">m1</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Matrix <span class="title">m2</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设有一个函数，它需要一个Matrix对象作为参数，并返回一个Matrix对象</span></span><br><span class="line">Matrix result = <span class="built_in">some_function</span>(m1);</span><br><span class="line"></span><br><span class="line">m2 = result; <span class="comment">// 使用默认的拷贝赋值运算符</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了两个<code>Matrix</code>对象，它们具有不同的尺寸。然后我们调用一个函数<code>some_function</code>，它返回一个<code>Matrix</code>对象。接下来，我们将<code>result</code>对象赋值给<code>m2</code>。这里，编译器会使用默认的拷贝赋值运算符，它执行浅拷贝。</p>
<p>问题在于，默认的拷贝赋值运算符无法处理不同尺寸的矩阵。由于它执行浅拷贝，<code>m2</code>的<code>data</code>指针将简单地指向<code>result</code>的<code>data</code>，而不会调整其大小。这将导致错误的行为，因为<code>m2</code>现在引用了一个与其原始大小不匹配的数组。此外，原始<code>m2</code>的<code>data</code>指针已经丢失，导致内存泄漏。</p>
<p>为了解决这个问题，我们需要同时实现拷贝构造函数和拷贝赋值运算符，以确保它们都执行深拷贝，并正确处理不同尺寸的矩阵。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 其他成员函数 ...</span></span><br><span class="line"></span><br><span class="line">    Matrix&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Matrix&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>* newData = <span class="keyword">new</span> <span class="type">int</span>[other.rows * other.cols];</span><br><span class="line">        std::<span class="built_in">copy</span>(other.data, other.data + other.rows * other.cols, newData);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        data = newData;</span><br><span class="line">        rows = other.rows;</span><br><span class="line">        cols = other.cols;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>自制服务器1</title>
    <url>/2023/04/24/%E8%87%AA%E5%88%B6%E6%9C%8D%E5%8A%A1%E5%99%A81/</url>
    <content><![CDATA[<h2 id="服务端—客户端通信大致流程"><a href="#服务端—客户端通信大致流程" class="headerlink" title="服务端—客户端通信大致流程"></a>服务端—客户端通信大致流程</h2><ul>
<li><p>服务端创建一个监听套接字（对创建的监听套接字进行判断，是否创建成功，返回非负整数则代表创建成功，返回-1代表创建失败），调用函数<code>socket()</code>。在<code>linux</code>系统中一切皆文件，每个文件都有一个整数类型的文件描述符。<code>socket()</code>也是一个文件，也有文件描述符。使用<code>socket()</code>函数创建套接字以后，返回值就是一个int类型的文件描述符。</p>
<p>在<code>linux</code>下使用<code>&lt;sys/socket.h&gt;</code>头文件中<code>socket()</code>函数来创建套接字，函数原型为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，第一个参数<code>af</code>为地址族<code>（Address Family）</code>，也就是<code>IP</code>地址类型，常用的<code>IP</code>地址类型有<code>AF_INET</code>和<code>AF_INET6</code>。<code>AF</code>是<code>”Address Family“</code>的简写，<code>INET</code>是<code>”Internet“</code>的简写。<code>AF_INET</code>表示<code>IPv4</code>地址，例如<code>127.0.0.1</code>；<code>AF_INET6</code>表示<code>IPv6</code>地址，例如<code>1030::C9B4:FF12:48AA:1A2B</code>。<code>127.0.0.1</code>是一个特殊的<code>IP</code>地址，表示本机地址。</p>
<p>第二个参数<code>type</code>为数据传输方式&#x2F;套接字类型，常用的有<code>SOCK_STREAM</code>（流格式套接字&#x2F;面向连接的套接字）和<code>SOCK_DGRAM</code>（数据报套接字&#x2F;无连接的套接字）。</p>
<p>第三个参数<code>protocol</code>表示传输协议，常用的有<code>IPPROTO_TCP</code>和<code>IPPTOTO_UDP</code>，即所谓的：<code>TCP</code>和<code>UDP</code>。</p>
</li>
</ul>
<p>我们经常会看见别人程序里创建套接字如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>很多人可能会好奇为什么第三个参数会设置为0？其实既满足<code>IP</code>地址类型为：<code>AF_INET</code>又满足套接字类型为：<code>SOCK_STREAM/SOCK_DGRAM</code>的只有<code>TCP/UDP</code>，系统会自动推演出来应该使用什么协议，此时则可以将<code>protocol</code>设置为0。</p>
<h5 id="lt-semaphore-h-gt-头文件"><a href="#lt-semaphore-h-gt-头文件" class="headerlink" title="&lt;semaphore.h&gt;头文件"></a>&lt;semaphore.h&gt;头文件</h5><p>&lt;semphore.h&gt;头文件是POSIX标准中定义的一个头文件，用于提供信号量的函数和数据类型。</p>
<p>信号量是一种用于提供不同进程或线程之间进行同步或者互斥的简单抽象。通常，信号量被用来限制对特定资源的访问，这在多线程和多进程环境中非常有用。</p>
<p>在<code>&lt;semaphore.h&gt;</code>头文件中，定义了以下的函数：</p>
<ul>
<li><code>sem_init()</code>：初始化一个未命名的信号量</li>
<li><code>sem_destroy()</code>：销毁一个未命名的信号量</li>
<li><code>sem_open()</code>：打开一个命名信号量，如果该信号量不存在，则创建一个</li>
<li><code>sem_close()</code>：关闭一个命名信号量</li>
<li><code>sem_unlink()</code>：删除一个命名信号量</li>
<li><code>sem_post()</code>：增加（解锁）信号量的值</li>
<li><code>sem_wait()</code>：减少（锁定）信号量的值，如果信号量的值为0，则调用该函数的线程会阻塞，直到信号量的值大于0</li>
<li><code>sem_trywait()</code>：尝试减少信号量的值，如果信号量的值为0，则立即返回错误，而不会阻塞</li>
<li><code>sem_getvalue()</code>：获取信号量的当前值</li>
</ul>
<h5 id="为什么要转换为sockaddr"><a href="#为什么要转换为sockaddr" class="headerlink" title="为什么要转换为sockaddr"></a>为什么要转换为<code>sockaddr</code></h5><p>所有专用<code>socket</code>地址（以及<code>sockaddr_storage</code>）类型的变量在实际使用时都需要转换为通用<code>socket</code>地址类型<code>sockaddr</code>（强制转换即可），因为所有<code>socket</code>编程接口使用的地址参数的类型都是<code>sockaddr</code>。</p>
<h5 id="网络服务中的三种端口：知名端口、注册端口、动态或私有端口"><a href="#网络服务中的三种端口：知名端口、注册端口、动态或私有端口" class="headerlink" title="网络服务中的三种端口：知名端口、注册端口、动态或私有端口"></a>网络服务中的三种端口：知名端口、注册端口、动态或私有端口</h5><p>服务端口（<code>Service Port</code>）是计算机网络中，网络服务使用的网络端口。这些端口通常被分为三个范围：知名端口、注册端口和动态或私有端口。</p>
<p>知名端口（<code>Well-Known Ports</code>）是从0到1023的端口号。它们通常被系统进程或者管理员级别的进程使用。这些端口通常关联到一些广泛使用的网络服务，例如：</p>
<ul>
<li><code>HTTP</code>：端口80</li>
<li><code>HTTPS</code>：端口443</li>
<li><code>FTP</code>：端口20和21</li>
<li><code>SSH</code>：端口22</li>
<li><code>Telnet</code>：端口23</li>
<li><code>DNS</code>：端口53</li>
<li><code>SMTP</code>：端口25</li>
<li><code>POP3</code>：端口110</li>
<li><code>IMAP</code>：端口143</li>
</ul>
<p>由于这些服务广泛地被用于许多网络应用，所以这些端口号被称为“知名端口”。这些端口的分配和维护由互联网号码分配局（<code>Internet Assigned Numbers Authority</code>，简称<code>IANA</code>）进行。</p>
<p>需要注意的是，除了这些知名端口，其他的端口也可以被任何应用程序使用，只要它们具备了适当的权限和配置。对于某些特定的应用程序，开发者可能会选择在1024-49151的范围内选择一个注册端口（<code>Registered Ports</code>），或者在49152–65535的范围内选择一个动态或私有端口（<code>Dynamic or Private Ports</code>）。</p>
<h5 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a><code>signal</code>函数</h5><p>在网络编程中，<code>signal</code>函数是一个非常重要的函数，它被用于设置处理特定信号的函数。</p>
<p>信号（<code>signal</code>）是一种在 <code>Unix</code> 系统（包括 <code>Linux</code>）中用于进程间通信的方式。它类似于一个异步的中断，当一个进程接收到一个信号时，操作系统会暂停该进程的正常执行流程，并去执行与该信号关联的处理函数。</p>
<p><code>signal</code>函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> signum, <span class="type">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>这个函数接收两个参数：</p>
<ol>
<li><p><code>signum</code>：这是一个整数，表示信号的类型。例如，<code>SIGINT</code>表示中断信号（通常是用户按下了<code>Ctrl+C</code>），<code>SIGABRT</code>表示一个异常条件，等等。</p>
</li>
<li><p><code>handler</code>：这是一个函数指针，指向用于处理这个信号的函数。处理函数的原型应该为<code>void func(int)</code>，也就是说，它应该是一个接收整数参数并且没有返回值的函数。你可以提供自己的处理函数，也可以使用两个预定义的值：<code>SIG_IGN</code>表示忽略这个信号，<code>SIG_DFL</code>表示使用系统默认的处理方式。</p>
</li>
</ol>
<p><code>signal</code>函数的返回值是一个函数指针，它指向之前设置的处理函数（如果有的话）。如果函数执行失败，那么返回的将是<code>SIG_ERR</code>。</p>
<p>需要注意的是，<code>signal</code>函数并不是 <code>POSIX</code> 标准的一部分，不同的系统可能会有不同的行为。在进行跨平台编程时，通常建议使用<code>sigaction</code>函数代替<code>signal</code>，因为<code>sigaction</code>提供了更多的控制选项，并且它的行为在不同的系统上更加一致。</p>
<p><code>SIGINT</code>、<code>SIGABRT</code>等都是预定义的宏，这些宏在<code>signal.h</code>或者其他相关的头文件中定义，它们的值是整数。例如，在许多系统中，<code>SIGINT</code>的值是2，但这个值并不是在所有系统中都一样。</p>
<p>这些宏名（例如<code>SIGINT</code>）只是为了在代码中更好地表示不同的信号，使得代码更易于理解。实际上，当我们在代码中写<code>SIGINT</code>时，编译器会将其替换为对应的整数值。</p>
<p>所以，当我们调用<code>signal(SIGINT, handler)</code>时，我们实际上是在说：“我想将处理<code>SIGINT</code>信号的函数设置为<code>handler</code>。”这里的<code>SIGINT</code>在被编译器处理后，就是一个整数值，代表了中断信号。</p>
<h5 id="telnet命令"><a href="#telnet命令" class="headerlink" title="telnet命令"></a><code>telnet</code>命令</h5><p><code>telnet</code>是一个网络协议和一个用于在互联网或局域网上执行此协议的命令行工具。它基于文本，主要用于远程管理网络设备和运行服务器端应用。然而，请注意，由于<code>telnet</code>不提供任何加密的方式，所以任何通过<code>telnet</code>发送的数据，包括密码，都是明文的，因此它已经被认为是不安全的，并且在许多新的系统和设备中已经被<code>SSH（Secure Shell）</code>所取代。</p>
<p>基本的<code>telnet</code>命令的语法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet [host] [port]</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><p><code>host</code>：这是你想要连接的远程主机的IP地址或主机名。例如，如果你想要连接到位于<code>192.168.1.1</code>的主机，你可以输入<code>telnet 192.168.1.1</code>。</p>
</li>
<li><p><code>port</code>：这是你想要连接到的远程服务的端口号。这个参数是可选的，如果你不提供，<code>telnet</code>会默认连接到端口23，这是Telnet协议的标准端口。例如，如果你想要测试一个位于<code>192.168.1.1</code>的主机的80端口（通常是HTTP服务器），你可以输入<code>telnet 192.168.1.1 80</code>。</p>
</li>
</ul>
<p>在<code>telnet</code>连接建立之后，你可以输入任何文本并按Enter键发送。当你想要断开连接时，你可以输入特殊的<code>telnet</code>命令，这通常是<code>Ctrl+]</code>（输入<code>Ctrl</code>和<code>]</code>键），然后输入<code>quit</code>。</p>
<h4 id="webServer服务器整体描述"><a href="#webServer服务器整体描述" class="headerlink" title="webServer服务器整体描述"></a>webServer服务器整体描述</h4><p>本项目主要目的就是对浏览器的链接请求进行处理并给予相应响应。对于请求的处理，系统整体运行流程为：主线程对I&#x2F;O进行监听，获取I&#x2F;O请求后把请求放入请求队列，等待工作线程处理。工作线程对于请求的处理（HTTP报文的解析）主要采用状态机思想来解析HTTP报文的解析。</p>
<h4 id="多路I-x2F-O复用"><a href="#多路I-x2F-O复用" class="headerlink" title="多路I&#x2F;O复用"></a>多路I&#x2F;O复用</h4><p>多路 I&#x2F;O 复用的基本概念是，一个进程使用一个线程来监控多个文件描述符（通常是套接字描述符），当其中任何一个文件描述符准备好进行读或写操作时，该线程就可以进行相应的处理。这样，一个线程就可以同时处理多个 I&#x2F;O 事件，提高了系统的并发性。常用的多路 I&#x2F;O 复用的系统调用有 <code>select</code>、<code>poll</code>、<code>epoll</code>。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p><code>select</code>是Unix&#x2F;Linux系统下的一种I&#x2F;O多路复用机制。它允许应用程序监视多个文件描述符，等待一个或多个描述符成为就绪状态，以进行I&#x2F;O操作（例如读或写）。这是一种异步I&#x2F;O模型，因为你不需要阻塞等待单个I&#x2F;O操作的完成。</p>
<p><code>select</code>的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><code>nfds</code>：需要监视的文件描述符数量，通常设置为所监视文件描述符中的最大值加1。</li>
<li><code>readfds</code>：需要监视读状态的文件描述符集合。</li>
<li><code>writefds</code>：需要监视写状态的文件描述符集合。</li>
<li><code>exceptfds</code>：需要监视异常状态的文件描述符集合。</li>
<li><code>timeout</code>：等待就绪的最长时间。如果设为NULL，则表示无限等待。</li>
</ul>
<p><code>select</code>函数返回准备好的文件描述符的数量，如果超时则返回0，如果出错则返回-1。</p>
<p><code>fd_set</code>是一种数据结构，用于存储文件描述符集合。你可以使用以下的宏来操作这个集合：</p>
<ul>
<li><code>FD_ZERO(fd_set *fdset)</code>: 清除一个文件描述符集合。</li>
<li><code>FD_SET(int fd, fd_set *fdset)</code>: 添加一个新的文件描述符到集合中。</li>
<li><code>FD_CLR(int fd, fd_set *fdset)</code>: 从集合中移除一个文件描述符。</li>
<li><code>FD_ISSET(int fd, fd_set *fdset)</code>: 检查集合中的一个文件描述符是否就绪。</li>
</ul>
<p>注意，在调用<code>select</code>函数后，这些集合会被修改，只包含那些状态发生变化（即准备好进行读或写操作）的文件描述符。因此，如果你想要在一个循环中重复使用<code>select</code>，你需要在每次调用<code>select</code>前重新设置这些集合。</p>
<p>虽然<code>select</code>在一些场景下非常有用，但是它有一些已知的限制，例如最大的文件描述符数量（通常是1024），以及处理大量文件描述符时的效率问题。在这些情况下，你可能需要使用其他的I&#x2F;O多路复用机制，例如<code>poll</code>或<code>epoll</code>。</p>
<h5 id="tip：这是一种异步I-x2F-O模型，因为你不需要阻塞等待单个I-x2F-O操作的完成。"><a href="#tip：这是一种异步I-x2F-O模型，因为你不需要阻塞等待单个I-x2F-O操作的完成。" class="headerlink" title="tip：这是一种异步I&#x2F;O模型，因为你不需要阻塞等待单个I&#x2F;O操作的完成。"></a>tip：这是一种异步I&#x2F;O模型，因为你不需要阻塞等待单个I&#x2F;O操作的完成。</h5><p>当我们说一个I&#x2F;O操作是“阻塞”的，这意味着执行这个操作的线程或进程在操作完成之前会被挂起。例如，如果你在一个阻塞的套接字上执行读操作，而这个套接字当前并没有接收到任何数据，那么执行读操作的线程就会被挂起，直到有数据到达。在这个过程中，线程不能做任何其他的事情。</p>
<p>相反，“非阻塞”的I&#x2F;O操作意味着即使操作不能立即完成，执行这个操作的线程或进程也不会被挂起。例如，如果你在一个非阻塞的套接字上执行读操作，而这个套接字当前并没有接收到任何数据，那么读操作会立即返回一个错误，而线程可以继续做其他的事情。</p>
<p>I&#x2F;O多路复用（例如select、poll或epoll）提供了一种异步的I&#x2F;O模型。在这个模型中，你可以同时监视多个文件描述符，并在任何一个描述符准备好进行I&#x2F;O操作时得到通知。这样，你就可以在等待I&#x2F;O操作的同时做其他的事情，或者同时处理多个I&#x2F;O操作。这就是为什么我们说这是一个“异步”的模型：你不需要为每个I&#x2F;O操作分别阻塞等待。</p>
<p>例如，在上述select的例子中，服务器可以同时处理多个客户端的请求。当任何一个客户端的套接字准备好进行读操作（即有数据到达）时，select函数就会返回，然后服务器可以读取这个套接字上的数据。在这个过程中，服务器并不需要为每个客户端分别阻塞等待。</p>
<p>通俗解释一下：</p>
<p>你想从你家到县城去，阻塞方式是：你去车站等车，等车期间你哪也不能去，就干等到车来；非阻塞方式，你在家等车，这期间你想干啥就干啥，等车来了，司机会滴喇叭，跟你说快上车。</p>
<h4 id="让我们通过一个简单的服务器代码示例来进一步理解select的使用。这个示例是一个TCP回显服务器，它使用select来同时处理多个客户端的连接和请求。"><a href="#让我们通过一个简单的服务器代码示例来进一步理解select的使用。这个示例是一个TCP回显服务器，它使用select来同时处理多个客户端的连接和请求。" class="headerlink" title="让我们通过一个简单的服务器代码示例来进一步理解select的使用。这个示例是一个TCP回显服务器，它使用select来同时处理多个客户端的连接和请求。"></a>让我们通过一个简单的服务器代码示例来进一步理解<code>select</code>的使用。这个示例是一个TCP回显服务器，它使用<code>select</code>来同时处理多个客户端的连接和请求。</h4><p>这是一个非常基础的示例，它没有处理一些可能的错误情况，例如文件描述符耗尽，以及<code>select</code>的最大文件描述符限制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    listen(listen_fd, MAX_CLIENTS);</span><br><span class="line"></span><br><span class="line">    fd_set read_fds;</span><br><span class="line">    <span class="type">int</span> max_fd = listen_fd;</span><br><span class="line">    <span class="type">int</span> clients[MAX_CLIENTS] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        FD_ZERO(&amp;read_fds);</span><br><span class="line">        FD_SET(listen_fd, &amp;read_fds);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clients[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                FD_SET(clients[i], &amp;read_fds);</span><br><span class="line">                <span class="keyword">if</span> (clients[i] &gt; max_fd) &#123;</span><br><span class="line">                    max_fd = clients[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        select(max_fd + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listen_fd, &amp;read_fds)) &#123;</span><br><span class="line">            <span class="type">int</span> client_fd = accept(listen_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (clients[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    clients[i] = client_fd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clients[i] &gt; <span class="number">0</span> &amp;&amp; FD_ISSET(clients[i], &amp;read_fds)) &#123;</span><br><span class="line">                <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">                <span class="type">int</span> len = read(clients[i], buffer, BUFFER_SIZE - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Received from client: %s\n&quot;</span>, buffer);</span><br><span class="line">                    write(clients[i], buffer, len);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    close(clients[i]);</span><br><span class="line">                    clients[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序首先创建一个监听套接字，然后进入一个无限循环，在循环中调用<code>select</code>函数等待新的连接或者已连接的客户端的请求。每次循环都会重新设置文件描述符集合，添加监听套接字以及所有已连接的客户端的套接字。</p>
<p>如果<code>select</code>函数返回并指示监听套接字已经准备好（有新的连接请求），程序就接受新的连接，并把新的客户端套接字添加到客户端数组中。</p>
<p>如果<code>select</code>函数返回并指示某个客户端套接字已经准备好（有新的数据到达），程序就</p>
<p>读取这个套接字上的数据，然后回显（即原样返回）这些数据。如果读取操作返回0或负值（表示连接已经关闭或出错），程序就关闭这个套接字，并把它从客户端数组中移除。</p>
<p>这个示例展示了如何使用<code>select</code>处理多个客户端的连接和请求。然而在实际的程序中，你需要处理更多的问题，例如<code>select</code>的最大文件描述符限制，以及文件描述符耗尽的问题。在处理大量连接时，你可能需要考虑使用其他的I&#x2F;O多路复用技术，例如<code>poll</code>或<code>epoll</code>。</p>
<h5 id="max-fd到底有啥作用呢？select函数第一个参数我为啥感觉没啥作用呢？"><a href="#max-fd到底有啥作用呢？select函数第一个参数我为啥感觉没啥作用呢？" class="headerlink" title="max_fd到底有啥作用呢？select函数第一个参数我为啥感觉没啥作用呢？"></a>max_fd到底有啥作用呢？select函数第一个参数我为啥感觉没啥作用呢？</h5><p><code>select</code>函数的第一个参数，即<code>nfds</code>，表示需要监视的文件描述符的范围，它的值应该是所有文件描述符中最大的那个加1。</p>
<p>为什么需要最大文件描述符呢？</p>
<p>原因是<code>select</code>函数在内部实现时会遍历所有的文件描述符，从0到<code>nfds - 1</code>。**<code>select</code>函数将检查这个范围内的每一个文件描述符，看看它是否在<code>readfds</code>、<code>writefds</code>或<code>exceptfds</code>集合中，并且它的状态是否发生了变化（即是否准备好进行读、写或者是否有异常）**。</p>
<p>实际上，<code>select</code>不关心文件描述符是否连续，它只是检查你指定的范围内的每一个文件描述符。因此，如果你的程序中最大的文件描述符是10，那么你就应该把<code>nfds</code>设为11，即使你的程序并没有使用文件描述符0到9。</p>
<p>在设置<code>nfds</code>时，使用最大文件描述符加1是一个优化的选择。如果你把<code>nfds</code>设得过大，<code>select</code>函数就会浪费时间去检查那些并不存在的文件描述符。反之，如果你把<code>nfds</code>设得过小，<code>select</code>函数就会忽略那些超出范围的文件描述符，即使它们在<code>readfds</code>、<code>writefds</code>或<code>exceptfds</code>集合中，并且状态发生了变化。</p>
<p>因此，<code>max_fd</code>在这里的作用就是帮助我们正确地设置<code>select</code>函数的<code>nfds</code>参数，以便让<code>select</code>函数高效地监视我们关心的所有文件描述符。</p>
<h5 id="代码里面貌似自始至终也没体现select函数的作用，因为连select函数的返回值都没用上，就好比现在select现在监听1-2-3-4-5-6这6个文件描述符，假设5准备就绪了，我怎么知道5准备就绪了呢，在你的代码貌似并没有体现出来"><a href="#代码里面貌似自始至终也没体现select函数的作用，因为连select函数的返回值都没用上，就好比现在select现在监听1-2-3-4-5-6这6个文件描述符，假设5准备就绪了，我怎么知道5准备就绪了呢，在你的代码貌似并没有体现出来" class="headerlink" title="代码里面貌似自始至终也没体现select函数的作用，因为连select函数的返回值都没用上，就好比现在select现在监听1 2 3 4 5 6这6个文件描述符，假设5准备就绪了，我怎么知道5准备就绪了呢，在你的代码貌似并没有体现出来"></a>代码里面貌似自始至终也没体现select函数的作用，因为连select函数的返回值都没用上，就好比现在select现在监听1 2 3 4 5 6这6个文件描述符，假设5准备就绪了，我怎么知道5准备就绪了呢，在你的代码貌似并没有体现出来</h5><p>实际上，当<code>select</code>函数返回后，我们可以通过检查<code>read_fds</code>集合来确定哪些文件描述符已经准备就绪。</p>
<p>具体来说，如果<code>FD_ISSET(fd, &amp;read_fds)</code>为真，那么就表示<code>fd</code>已经准备好进行读操作。在我的示例代码中，这个检查分别在处理监听套接字和客户端套接字时进行。</p>
<p>如果<code>select</code>函数指示监听套接字已经准备好（有新的连接请求），那么我们就接受新的连接：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (FD_ISSET(listen_fd, &amp;read_fds)) &#123;</span><br><span class="line">    <span class="type">int</span> client_fd = accept(listen_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 添加新的客户端到 clients 数组...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>select</code>函数指示某个客户端套接字已经准备好（有新的数据到达），那么我们就读取这个套接字上的数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (clients[i] &gt; <span class="number">0</span> &amp;&amp; FD_ISSET(clients[i], &amp;read_fds)) &#123;</span><br><span class="line">        <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">        <span class="type">int</span> len = read(clients[i], buffer, BUFFER_SIZE - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 处理读取到的数据...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例代码的目的是展示<code>select</code>函数如何用于处理多个连接和请求。在实际的应用中，你可能还需要处理更多的情况，例如写就绪和异常，以及<code>select</code>函数的返回值（表示已经准备就绪的文件描述符的数量）。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>有了select的基础，理解poll起来就方便一点啦。<code>poll</code>函数是另一种I&#x2F;O多路复用的技术。与<code>select</code>相比，它的主要优点是没有文件描述符的数量限制，而且API使用起来可能更加直观。<code>poll</code>函数使用一个<code>pollfd</code>结构体数组，其中每个结构体都包含一个文件描述符和一些标志位，表示我们对哪些事件感兴趣（例如POLLIN表示我们对读事件感兴趣）。</p>
<p>下面是一个简单的使用<code>poll</code>的服务器代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    listen(listen_fd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">clients</span>[<span class="title">MAX_CLIENTS</span>];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">        clients[i].fd = <span class="number">-1</span>; <span class="comment">// -1表示该位置没有使用</span></span><br><span class="line">        clients[i].events = POLLIN; <span class="comment">// 对读事件感兴趣</span></span><br><span class="line">    &#125;</span><br><span class="line">    clients[<span class="number">0</span>].fd = listen_fd; <span class="comment">// 监听套接字始终在clients[0]的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> nready = poll(clients, MAX_CLIENTS, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clients[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">            <span class="comment">// 监听套接字准备好了，表示有新的连接请求</span></span><br><span class="line">            <span class="type">int</span> client_fd = accept(listen_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 将新的连接添加到clients数组中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (clients[i].fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    clients[i].fd = client_fd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clients[i].fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (clients[i].revents &amp; (POLLIN | POLLERR)) &#123;</span><br><span class="line">                <span class="comment">// 客户端套接字准备好了，表示有数据可以读取</span></span><br><span class="line">                <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">                <span class="type">int</span> len = read(clients[i].fd, buffer, BUFFER_SIZE - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 连接已经关闭或出错，将该客户端从数组中移除</span></span><br><span class="line">                    close(clients[i].fd);</span><br><span class="line">                    clients[i].fd = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 将接收到的数据回显给客户端</span></span><br><span class="line">                    write(clients[i].fd, buffer, len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，服务器使用<code>poll</code>函数同时监视所有连接的客户端套接字。每次当<code>poll</code>函数返回时，服务器会检查哪些套接字已经准备好进行I&#x2F;O操作，并相应地处理它们。</p>
<h5 id="clients-0-revents-amp-POLLIN这个代表啥意思"><a href="#clients-0-revents-amp-POLLIN这个代表啥意思" class="headerlink" title="clients[0].revents &amp; POLLIN这个代表啥意思"></a>clients[0].revents &amp; POLLIN这个代表啥意思</h5><p>这是在检查<code>poll</code>函数返回后哪些文件描述符发生了事件。</p>
<p><code>clients[0].revents &amp; POLLIN</code>这个表达式使用了位运算符<code>&amp;</code>来检查<code>revents</code>字段的某个特定位（在这个例子中是<code>POLLIN</code>位）是否被设置。如果结果非零，那么说明<code>POLLIN</code>事件发生了，也就是说对应的文件描述符已经准备好进行读操作。</p>
<p>这里的<code>POLLIN</code>是一个常量，表示可以从文件描述符中读取数据。<code>revents</code>字段则是<code>poll</code>函数返回后设置的，表示在调用<code>poll</code>函数期间，哪些事件发生了。</p>
<p>如果<code>clients[0].revents &amp; POLLIN</code>为真，那么就表示监听套接字已经准备好，我们可以从这个套接字上接受新的连接。</p>
<h5 id="这个能不能给出一个实例，不太理解"><a href="#这个能不能给出一个实例，不太理解" class="headerlink" title="这个能不能给出一个实例，不太理解"></a>这个能不能给出一个实例，不太理解</h5><p>当然可以，让我们试着用一个简单的例子来理解这个概念。</p>
<p>首先，我们要知道<code>POLLIN</code>和<code>revents</code>都是整型（int）变量，也就是说，它们都可以表示为二进制数。</p>
<p>假设<code>POLLIN</code>的值是4，也就是二进制的<code>100</code>，而<code>revents</code>的值是5，也就是二进制的<code>101</code>。</p>
<p>我们用<code>&amp;</code>（位运算符AND）来对这两个值进行操作，得到的结果是<code>100</code>，也就是4，非零值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  POLLIN:  100 (二进制)</span><br><span class="line">  revents: 101 (二进制)</span><br><span class="line">----------------------</span><br><span class="line">  结果:    100 (二进制) = 4 (十进制)</span><br></pre></td></tr></table></figure>

<p>这个结果是非零的，所以<code>if (clients[0].revents &amp; POLLIN)</code>的判断结果是真。这就表示<code>revents</code>的<code>POLLIN</code>位被设置了，也就是说，对应的文件描述符已经准备好进行读操作了。</p>
<p>如果<code>revents</code>的值是2（二进制<code>010</code>），那么结果就是零：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  POLLIN:  100 (二进制)</span><br><span class="line">  revents: 010 (二进制)</span><br><span class="line">----------------------</span><br><span class="line">  结果:    000 (二进制) = 0 (十进制)</span><br></pre></td></tr></table></figure>

<p>这个结果是零，所以<code>if (clients[0].revents &amp; POLLIN)</code>的判断结果是假。这就表示<code>revents</code>的<code>POLLIN</code>位没有被设置，也就是说，对应的文件描述符还没有准备好进行读操作。</p>
<p>所以，这个表达式就是在检查<code>revents</code>是否表示文件描述符已经准备好进行读操作。</p>
<h5 id="recv函数"><a href="#recv函数" class="headerlink" title="recv函数"></a><code>recv</code>函数</h5><p>在<code>socket</code>编程中，<code>recv</code>函数的返回值有以下三种情况：</p>
<ol>
<li><p>当<code>recv</code>函数返回0时，表示连接已经关闭，也就是说，另一端已经执行了<code>close</code>操作。</p>
</li>
<li><p>当<code>recv</code>函数返回-1时，表示接收数据时发生了错误，你可以通过检查全局变量<code>errno</code>来确定具体的错误类型。在非阻塞模式下，如果没有可读取的数据，<code>recv</code>函数也会返回-1，并且<code>errno</code>会被设置为<code>EAGAIN</code>或者<code>EWOULDBLOCK</code>。</p>
</li>
<li><p>如果返回值大于0，表示成功接收到了数据。</p>
</li>
</ol>
<p>在你给出的代码中，<code>if (ret &lt;= 0)</code>这个判断语句实际上就是在处理以上的前两种情况。也就是说，如果连接已经关闭，或者在接收数据时发生了错误，就关闭<code>socket</code>。</p>
<p>在你的例子中，<code>ret=0</code>实际上并不是代表LT模式下未响应此事件，而是表示对端关闭了连接。因此，关闭这个<code>socket</code>是合理的，因为这个连接已经没有用了。即使接收缓冲区里还有未读取的数据，这些数据也无法被发送到已经关闭的对端，所以就没有必要保持这个<code>socket</code>打开了。</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>Linux</tag>
        <tag>webServer</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2023/11/10/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>2023-11-10</p>
<p>并查集：<a href="https://blog.csdn.net/YSJ367635984/article/details/113504723">https://blog.csdn.net/YSJ367635984/article/details/113504723</a></p>
<span id="more"></span>

<p>C++代码实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisjointSets</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DisjointSets</span>();</span><br><span class="line">    ~<span class="built_in">DisjointSets</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findParentNode</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionSetNode</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DisjointSets::<span class="built_in">DisjointSets</span>(): <span class="built_in">count</span>(<span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)&#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DisjointSets::~<span class="built_in">DisjointSets</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int DisjointSets::findParentNode(int x)&#123;</span></span><br><span class="line"><span class="comment">    if(x != parent[x])&#123;</span></span><br><span class="line"><span class="comment">        findParentNode(parent[x]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return x;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化版本的并查集，减小以后查找时间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DisjointSets::findParentNode</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x != parent[x])&#123;</span><br><span class="line">        <span class="comment">// 找一次x只是压缩一次，多找几次就会导致父节点为根节点</span></span><br><span class="line">        parent[x] = parent[parent[x]];</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisjointSets::unionSetNode</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> parent_x = <span class="built_in">findParentNode</span>(x);</span><br><span class="line">    <span class="type">int</span> parent_y = <span class="built_in">findParentNode</span>(y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(parent_x == parent_y) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    parent[parent_y] = parent_x;</span><br><span class="line">    </span><br><span class="line">    --count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>计算机网络八股文</title>
    <url>/2023/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1%E6%96%87/</url>
    <content><![CDATA[<p>1、HTTP常见的状态码</p>
<ul>
<li>1XX	提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</li>
<li>2XX    成功，报文已经成功收到并被正确处理；</li>
<li>3XX    重定向，资源位置发生变动，需要客户端重新发送请求；</li>
<li>4XX    客户端错误，请求报文有误，服务器无法处理；</li>
<li>5XX    服务器错误。服务器在处理请求时内部发生了错误；</li>
</ul>
<p>2、HTTP请求和响应的各自组成部分</p>
<p>HTTP通信协议由请求（Request）和响应（Response）两部分构成。每个请求和响应都由头部和主体组成，其中头部包含了各种元数据，而主体则包含了实际的内容（如果有的话）。</p>
<h5 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h5><p>HTTP请求包括以下字段：</p>
<ol>
<li><p><strong>请求行（Request Line）</strong>：请求行包括HTTP方法（比如GET、POST、PUT、DELETE等）、请求的URI、以及HTTP版本。</p>
</li>
<li><p><strong>请求头（Request Headers）</strong>：请求头包含了一系列的字段，每个字段都提供了一些关于请求的元数据。常见的请求头包括：</p>
<ul>
<li>Host: 请求的目标主机名和端口号。</li>
<li>User-Agent: 发起请求的用户代理的信息，通常包括浏览器类型、版本、操作系统等信息。</li>
<li>Accept: 客户端可以处理的MIME类型。</li>
<li>Accept-Language: 客户端接受的语言。</li>
<li>Accept-Encoding: 客户端接受的内容编码，比如gzip。</li>
<li>Cookie: 客户端存储的用于服务器识别的cookie。</li>
<li>Content-Type: 如果请求包含了主体，这个字段描述了主体的MIME类型。</li>
<li>Content-Length: 如果请求包含了主体，这个字段描述了主体的长度。</li>
</ul>
</li>
<li><p><strong>请求主体（Request Body）</strong>：不是所有的请求都包含主体。比如GET和HEAD请求就没有主体。但是POST和PUT请求通常会有主体，包含了要发送给服务器的数据。</p>
</li>
</ol>
<h5 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h5><p>HTTP响应包括以下字段：</p>
<ol>
<li><strong>状态行（Status Line）</strong>：状态行包括HTTP版本、状态码（比如200表示成功，404表示未找到等），以及状态描述。</li>
<li><strong>响应头（Response Headers）</strong>：响应头包含了一系列的字段，每个字段都提供了一些关于响应的元数据。常见的响应头包括：<ul>
<li>Server: 发送响应的服务器的信息。</li>
<li>Content-Type: 响应主体的MIME类型。</li>
<li>Content-Length: 响应主体的长度。</li>
<li>Content-Encoding: 响应主体的内容编码，比如gzip。</li>
<li>Set-Cookie: 服务器想要设置在客户端的cookie。</li>
<li>Last-Modified: 资源的最后修改日期。</li>
<li>ETag: 资源的版本标识。</li>
</ul>
</li>
<li><strong>响应主体（Response Body）</strong>：响应的主体包含了服务器返回的数据，比如HTML页面、图片、JSON数据等。</li>
</ol>
<p>3、完整的HTTP请求和响应展示</p>
<p>让我们来看一下一对典型的HTTP请求和响应。</p>
<h5 id="HTTP请求示例"><a href="#HTTP请求示例" class="headerlink" title="HTTP请求示例"></a>HTTP请求示例</h5><p>假设你在浏览器中访问 <code>http://www.example.com</code>，你的浏览器可能会发送如下的GET请求：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Language: en-US,en;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<h5 id="HTTP响应示例"><a href="#HTTP响应示例" class="headerlink" title="HTTP响应示例"></a>HTTP响应示例</h5><p>对于上述的请求，服务器可能会返回如下的响应：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">HTTP/1.1</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">Date:</span> <span class="string">Mon,</span> <span class="number">23</span> <span class="string">May</span> <span class="number">2023 22:38:34 </span><span class="string">GMT</span></span><br><span class="line"><span class="attr">Server:</span> <span class="string">Apache/2.4.1</span> <span class="string">(Unix)</span></span><br><span class="line"><span class="attr">Last-Modified:</span> <span class="string">Sat,</span> <span class="number">20</span> <span class="string">May</span> <span class="number">2023 18:56:51 </span><span class="string">GMT</span></span><br><span class="line"><span class="attr">ETag:</span> <span class="string">&quot;2dcd3-2c-54b5a5e68b177&quot;</span></span><br><span class="line"><span class="attr">Accept-Ranges:</span> <span class="string">bytes</span></span><br><span class="line"><span class="attr">Content-Length:</span> <span class="number">44</span></span><br><span class="line"><span class="attr">Vary:</span> <span class="string">Accept-Encoding</span></span><br><span class="line"><span class="attr">Content-Type:</span> <span class="string">text/html</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It</span> <span class="string">works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个响应表示请求成功（状态码是200），服务器返回了一个简单的HTML页面作为响应主体。响应头还包含了一些其他的信息，比如服务器类型（Apache），最后修改日期，内容长度，内容类型等。</p>
<p>希望这些示例可以帮助你更好地理解HTTP请求和响应！</p>
<p>4、TCP的KeepAlive和HTTP的Keep-Alive</p>
<p>TCP的KeepAlive和HTTP的Keep-Alive虽然名字类似，但实际上是两个不同级别的概念，分别在TCP和HTTP协议层级中起作用。</p>
<p><strong>TCP的KeepAlive</strong>：</p>
<p>TCP的KeepAlive是一个底层的、可选的机制，其目的是为了检测和维护处于空闲状态的TCP连接。一旦启用，如果在特定的时间间隔内（通常在数小时）没有任何数据在TCP连接上进行交换，那么发送方就会发送一个KeepAlive数据包到接收方，而无需传输任何应用级别的数据。接收方需要对这个数据包做出响应。如果发送方在一定时间内没有收到响应，它将重发KeepAlive数据包，一般会尝试多次。如果仍然没有收到响应，发送方将假设连接已经断开，并将其关闭。</p>
<p><strong>HTTP的Keep-Alive</strong>：</p>
<p>HTTP的Keep-Alive是在HTTP 1.1引入的，用来允许单一的TCP连接被多个HTTP请求&#x2F;响应共享，而不是每个请求&#x2F;响应都重新建立一个新的连接。这显著提高了网络通信的效率，因为建立和关闭TCP连接需要时间和资源。</p>
<p>在HTTP 1.0中，每个HTTP请求&#x2F;响应都需要一个新的TCP连接，这被称为非持久连接。而在HTTP 1.1中，默认启用了Keep-Alive，也就是说默认使用持久连接，除非明确指定”Connection: close”。</p>
<p>当使用HTTP Keep-Alive时，HTTP请求的头部会包含一个”Connection: keep-alive”字段，这告诉服务器客户端希望保持连接以便发送更多的请求。服务器的响应也会包含一个”Connection: keep-alive”字段，这表示服务器同意保持连接。</p>
<p>总的来说，这两个概念都关于连接的维护，但是工作在不同的层级。TCP的KeepAlive主要是为了检测和处理僵死连接，而HTTP的Keep-Alive则是为了提高效率，通过复用已存在的TCP连接来发送多个HTTP请求&#x2F;响应。</p>
<p><strong>队头阻塞</strong></p>
<p>这里涉及到一个小概念需要说一下：可以想象，当我们开启Keep-Alive时，我们无需像以前那样，先发送A请求，等待服务器回应，再发送B请求…..一直如此运作下去。我们可以发送A请求后，无需等待服务器响应，紧接着发送B请求。但是服务器还是按照顺序响应，先响应A请求，完成后再响应B请求。其实这里很明显感觉到会有问题，如果迟迟收不到A响应，后面的响应就更收不到了，就会造成所谓的<strong>队头阻塞</strong>问题。</p>
<p><strong>在使用HTTP长连接时，如果一个客户端完成了一个HTTP请求后不在发起请求，此时这个TCP连接一直占用不就会导致浪费资源吗？</strong></p>
<p>对没错，所以为了避免资源浪费的情况，web 服务软件一般都会提供 <code>keepalive_timeout</code> 参数，用来指定 HTTP 长连接的超时时间。</p>
<p>比如设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会<strong>启动一个定时器</strong>，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接。</strong></p>
<p><strong>传输层协议有哪些</strong></p>
<p><code>UDP</code>和<code>TCP</code>协议；</p>
<p><strong><code>TCP</code>协议的特点</strong></p>
<p>面向连接的：采用<code>TCP</code>协议通信的双方必须通过三次握手建立连接才能开始数据的读写。完成数据交换以后，通信双方都必须断开连接，以释放内核的资源。</p>
<p>面向字节流的：当用户消息通过<code>TCP</code>协议传输时，<code>TCP</code>模块先将这些消息放入<code>TCP</code>发送缓冲区，发送的时候消息可能会被操作系统分组成多个<code>TCP</code>报文。注意，当我们调用<code>send</code>函数的时候，消息并没有真正被发送出去，只是被拷贝到了操作系统内核协议栈中。何时被真正发送，取决于<strong>发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件</strong>。</p>
<p>可靠的：1、<code>TCP</code>采用发送应答机制，即<code>TCP</code>发送端发送每一个<code>TCP</code>报文段都要接收到对方的应答，才认为这个<code>TCP</code>报文段传输成功；2、<code>TCP</code>协议采用超时重传机制，发送端发送一个<code>TCP</code>报文段之后，开启定时器，如果在规定时间内没有接收到应答，则重传此<code>TCP</code>报文段；3、因为<code>TCP</code>报文段最终是以<code>IP</code>数据报发送的，<code>IP</code>数据报到达接受方的时候可能乱序、重复，TCP协议还会对接收到的TCP报文段重排、整理，再交付给应用层。</p>
<p><strong>描述TCP头部结构的大致组成部分</strong></p>
<p>16位源端口号、16位目标端口号、32位序号、32位确认号、4位头部长度、6位保留、6位标志位、16位窗口大小、16位校验和、16位紧急指针</p>
<p><strong>简述各部分作用</strong></p>
<p>源端口号代表的是是从发送端的哪一个端口发送出来的，目的端口号代表的是发送给接收端上层应用程序的哪一个端口。</p>
<p><code>TCP</code>报文段的序号值等于系统初始化的某个随机值<code>ISN</code>加上该报文段在字节流中的偏移（偏移值）。</p>
<p>确认号就是接收到的<code>TCP</code>报文段的序号值加1。</p>
<p>4位头部长度代表<code>TCP</code>报文段整个头部长度有多少个<code>32bit</code>字（四字节）。</p>
<p>6位标志位分别为：<code>URG</code>（紧急指针是否有效）、<code>ACK</code>（确认号）、<code>PSH</code>（接收端应立即从<code>TCP</code>接收缓冲区中读走数据）、<code>RST</code>（表示要求对方重新建立连接）、<code>SYN</code>（请求建立一个连接）、<code>FIN</code>（通知对方本端要关闭连接）。</p>
<p>16位窗口大小是流量控制的一个手段，他告诉对方本端的<code>TCP</code>接收缓冲区还能容纳多少字节的数据。</p>
<p>16位校验和由发送端填充，接收端采取<code>CRC</code>算法对接收到的<code>TCP</code>报文段验证。</p>
<p><strong>TCP连接的建立和关闭</strong></p>
<p>首先，通过数据展示一下三次握手：</p>
<p>发送端：<code>seq 12345 (SYN)</code>     ————-      接收端：<code>seq 56789 (SYN)</code>  <code>ack 12346</code>    ————-   发送端：<code>ack 56790</code></p>
<p>接下来是四次握手，假设发送端首先发出了断开连接请求</p>
<p>发：<code>seq 12346</code>, <code>ack 56790</code> <code>(FIN)</code> —— 收：<code>ack 12347</code> —— 收：<code>seq 56790</code>, <code>ack 12347</code> <code>(FIN)</code> ——- 发：<code>ack 56791</code>  </p>
<p>实际上，四次握手中的收的第一次确认报文段可以省略，因为下一次收的TCP报文段里包含了<code>ack</code>。其实第一个<code>ack</code>是否应该出现取决于<code>TCP</code>的延迟确认特性。</p>
<p><strong>TCP状态转移</strong></p>
<p>服务器处于被动等待客户连接，可以简单描述一下当有客户端请求连接时，该连接服务器端的状态变化为：</p>
<p><code>LISTEN</code> ————- <code>SYN RCVD</code> —————– <code>ESTABLISHED</code>.</p>
<p>当客户端主动关闭连接时，服务器端状态变化为：</p>
<p><code>CLOSE_WAIT</code> ————– <code>LAST_ACK</code>.</p>
<p>请求连接时，客户端状态变化为，考虑<code>connect</code>系统调用成功</p>
<p><code>SYN_SENT</code> ————- <code>ESTABLISHED</code></p>
<p>注意，<code>connect</code>系统调用失败有三个原因：</p>
<p>1、<code>connect</code>连接的目标端口不存在（未被任何线程监听）</p>
<p>2、<code>connect</code>试图连接的端口处在<code>TIME_WAIT</code>状态</p>
<p>3、没有收到服务器端的应答报文</p>
<p><code>connect</code>调用失败则返回<code>CLOSE</code>状态。</p>
<p>客户端请求关闭时，客户端状态变化为</p>
<p><code>FIN_WAIT_1</code> ———- <code>(FIN_WAIT_2)</code> ————– <code>TIME_WAIT</code></p>
<p><strong>TIME_WAIT状态好好看看书的3.4.2节，讲的很好</strong></p>
<p><strong>复位报文段</strong></p>
<p><strong>什么情况下接收端会回复复位报文段？</strong></p>
<p>1、发送端访问一个不存在的窗口。</p>
<p>2、发送端访问的服务器端的窗口仍处于<code>TIME_WAIT</code>状态。</p>
<p>3、半打开状态向连接发送数据，会收到复位报文段。</p>
<p><strong>收到复位报文段应该如何处理呢</strong></p>
<p>收到复位报文段的机器应该断开连接或者重新发起连接。</p>
<p><strong>半打开状态</strong></p>
<p>假设现在服务器端（或者客户端）关闭或者异常终止了连接，客户端（或者服务器端）并没有接收到结束报文段，依旧保持连接状态，就称为半打开连接状态。如果此时客户端（或者服务器端）向此连接发送数据，会收到一个复位报文段的回应报文。</p>
<p><strong>关于<code>MSS</code>的计算</strong></p>
<p>首先需要了解两个名词，一个是<code>MTU</code>（<code>MaxMaximum Transmission Unit</code>）是指网络传输中最大的数据包大小，<code>MSS</code>（<code>Maximum Segment Size</code>）是指<code>TCP</code>协议中数据段的最大大小。在<code>TCP</code>协议中，<code>MSS</code>是由<code>MTU</code>减去<code>IP</code>和<code>TCP</code>头部的长度得出的。</p>
<p><code>IP</code>头部的长度通常为20个字节，<code>TCP</code>头部的长度通常为20个字节，所以<code>MSS</code>的计算方法为：</p>
<p><code>MSS</code>&#x3D; <code>MTU</code> - <code>IP</code>头部长度 - <code>TCP</code>头部长度</p>
<p>因此，在<code>MTU</code>为16436字节的情况下，<code>MSS</code>的计算公式为：</p>
<p><code>MSS</code> &#x3D; 16436 - 20 - 20 &#x3D; 16396</p>
<p>其中，20是<code>IP</code>头部和<code>TCP</code>头部的长度之和，这是因为<code>IP</code>和<code>TCP</code>协议都需要使用头部来传递各种控制信息，如源地址、目标地址、端口号、序列号、确认号等。因此，在<code>TCP</code>协议中，<code>MSS</code>是<code>MTU</code>减去<code>IP</code>和<code>TCP</code>头部长度的结果。</p>
]]></content>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2023/10/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>DiaDSP</title>
    <url>/2024/10/22/DiaDSP/</url>
    <content><![CDATA[<p>Differentially Private Distributed Optimization via State and Direction Perturbation in Multiagent Systems</p>
<span id="more"></span>
<p>Introduction</p>
<p>Problem Formulation</p>
<p>DiaDSP Algorithm</p>
<p>B. Development of DiaDSP</p>
<p>We employ the combine-then-adapt strategy for each agent $i$, which is expressed as </p>
<script type="math/tex; mode=display">x_{i}(k+1) = \sum_{j=1}^{n} a_{ij} x_{j}(k) - \alpha_{i} y_{i}(k).</script><p>Convergence Analysis of DiaDSP</p>
<p>Differential Privacy</p>
<p>Simulations</p>
<p>Conclusion</p>
]]></content>
      <categories>
        <category>Scholarly Reads</category>
      </categories>
      <tags>
        <tag>Distributed Optimization Algorithm</tag>
      </tags>
  </entry>
</search>

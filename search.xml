<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++内存管理</title>
    <url>/2023/08/27/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>有关C++内存管理问题总结如下</p>
<h3 id="基础问题"><a href="#基础问题" class="headerlink" title="基础问题"></a>基础问题</h3><h4 id="C-中堆和栈的区别是什么"><a href="#C-中堆和栈的区别是什么" class="headerlink" title="C++中堆和栈的区别是什么"></a><code>C++</code>中堆和栈的区别是什么</h4><ol>
<li>栈由系统分配释放，栈上变量的生命周期是确定的，一般与作用域有关。栈的地址由高到低，栈上分配的空间大小在编译时通常已知。</li>
<li>堆由程序员手动开辟释放，堆上的变量除非被显示释放，否则会持续存在。堆的地址由低到高，堆上几乎可以分配任意大小的内存块，但可能会造成内存碎片。</li>
<li>这里说一下<code>C++</code>的内存分区：堆区、栈区、<code>data</code>区、<code>bss</code>段、代码段。数据<code>data</code>区存放的是静态变量和初始化的全局变量，<code>bss</code>段存放的是未初始化的全局变量。</li>
</ol>
<h4 id="什么是RAII？为什么它在C-中很重要"><a href="#什么是RAII？为什么它在C-中很重要" class="headerlink" title="什么是RAII？为什么它在C++中很重要"></a>什么是<code>RAII</code>？为什么它在<code>C++</code>中很重要</h4><p><code>RAII</code>是一种编程思想和设计模式，核心思想是：将资源的获取与对象的初始化捆绑在一起，将资源的释放与对象的销毁捆绑在一起。这样，资源管理就与对象的生命周期紧密关联。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::fstream fs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">File</span>(<span class="type">const</span> std::string&amp; filename) &#123;</span><br><span class="line">        fs.<span class="built_in">open</span>(filename, std::ios::in | std::ios::out);</span><br><span class="line">        <span class="keyword">if</span> (!fs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Failed to open the file&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他与文件相关的操作...</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">File</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (fs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            fs.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="function">File <span class="title">myFile</span><span class="params">(<span class="string">&quot;sample.txt&quot;</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 进行文件操作...</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当myFile对象离开其作用域时，它的析构函数会自动被调用，从而关闭文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="解释new和delete，与malloc和free的区别"><a href="#解释new和delete，与malloc和free的区别" class="headerlink" title="解释new和delete，与malloc和free的区别"></a>解释<code>new</code>和<code>delete</code>，与<code>malloc</code>和<code>free</code>的区别</h4><ul>
<li><p>属性的区别</p>
<p><code>new/delete</code>：这两个是<code>C++</code>中的关键字；</p>
<p><code>malloc/free</code>：这两个是库函数；</p>
</li>
<li><p>使用上的区别</p>
<p><code>malloc</code>：申请空间需要显式填入申请内存的大小；</p>
<p><code>new</code>：无需显式填入申请内存的大小，<code>new</code>会根据<code>new</code>的类型分配内存；</p>
</li>
<li><p>返回类型的区别</p>
<p><code>new</code>操作符内存分配成功，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，故<code>new</code>是符合类型安全性的操作符。</p>
<p><code>malloc</code>内存分配成功返回的是<code>void*</code>指针，需要通过强制类型转换，转换成我们需要的类型。</p>
<p>所以<code>C++</code>中<code>new</code>比<code>malloc</code>安全可靠。</p>
</li>
<li><p>分配失败的区别</p>
<p><code>malloc</code>分配失败会返回<code>NULL</code>，我们可以通过判断返回值是否是<code>NULL</code>得知是否分配成功。</p>
<p><code>new</code>分配失败会抛出<code>bad_alloc</code>异常。</p>
</li>
<li><p>扩张内存的区别</p>
<p><code>malloc</code>有内存扩张机制（通过<code>realloc</code>实现）。</p>
<p><code>new</code>没有扩张内存机制。</p>
</li>
</ul>
<h3 id="中级问题"><a href="#中级问题" class="headerlink" title="中级问题"></a>中级问题</h3><h4 id="为什么C-推荐使用智能指针，如shared-ptr和unique-ptr"><a href="#为什么C-推荐使用智能指针，如shared-ptr和unique-ptr" class="headerlink" title="为什么C++推荐使用智能指针，如shared_ptr和unique_ptr"></a>为什么<code>C++</code>推荐使用智能指针，如<code>shared_ptr</code>和<code>unique_ptr</code></h4><ul>
<li>自动管理内存：对于<code>unique_ptr</code>，当它超出作用域或者被重新分配时，它指向的对象会被删除。对于<code>shared_ptr</code>，当它的引用计数为0时，它指向的对象会被删除。</li>
<li>异常安全：当函数抛出异常，智能指针确保资源被正确清理，避免资源泄露。</li>
<li>防止悬挂指针：悬挂指针是指指向已经释放内存的指针。<code>unique_ptr</code>和<code>shared_ptr</code>可以减少悬挂指针的风险，因为他们确保在没有引用的时候释放资源。</li>
</ul>
<h4 id="你能解释shared-ptr中的引用计数机制是如何工作的吗"><a href="#你能解释shared-ptr中的引用计数机制是如何工作的吗" class="headerlink" title="你能解释shared_ptr中的引用计数机制是如何工作的吗"></a>你能解释<code>shared_ptr</code>中的引用计数机制是如何工作的吗</h4><ul>
<li>通过一个指针实现引用计数功能，加锁，保证线程安全</li>
</ul>
<h4 id="什么情况下会导致内存泄漏，你如何检测和预防"><a href="#什么情况下会导致内存泄漏，你如何检测和预防" class="headerlink" title="什么情况下会导致内存泄漏，你如何检测和预防"></a>什么情况下会导致内存泄漏，你如何检测和预防</h4><ul>
<li><p>指针重新赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line"><span class="type">int</span> *np = <span class="keyword">new</span> <span class="built_in">int</span>();</span><br><span class="line">p = np;</span><br><span class="line"><span class="comment">//p原来的指向的内存无法释放，因为现在没有指针指向这块内存</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>错误的内存释放</p>
<p>假设有一个指针<code>p</code>指向10字节的内存，该内存的第三个字节<code>np</code>又指向某个动态分配的内存， 如果此时你直接<code>delete(p)</code>，则会导致<code>np</code>指向的内存无法释放。</p>
</li>
<li><p>返回值的不正确处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于没有对函数f()的返回值做正确接收，将会导致f函数分配的内存无法释放。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>关于内存泄露可以使用工具：<code>Valgrind</code>。</p>
<h3 id="高级问题"><a href="#高级问题" class="headerlink" title="高级问题"></a>高级问题</h3><h4 id="描述C-的内存模型是什么？如何保证线程间的数据同步？"><a href="#描述C-的内存模型是什么？如何保证线程间的数据同步？" class="headerlink" title="描述C++的内存模型是什么？如何保证线程间的数据同步？"></a>描述C++的内存模型是什么？如何保证线程间的数据同步？</h4><h4 id="什么是内存屏障-memory-barrier-或内存栅栏？在哪些场景中需要使用它？"><a href="#什么是内存屏障-memory-barrier-或内存栅栏？在哪些场景中需要使用它？" class="headerlink" title="什么是内存屏障(memory barrier)或内存栅栏？在哪些场景中需要使用它？"></a>什么是内存屏障(memory barrier)或内存栅栏？在哪些场景中需要使用它？</h4><h4 id="你有没有用过定制的内存分配器，比如为某些高性能的应用场景？如果有，请描述其工作原理和使用场景。"><a href="#你有没有用过定制的内存分配器，比如为某些高性能的应用场景？如果有，请描述其工作原理和使用场景。" class="headerlink" title="你有没有用过定制的内存分配器，比如为某些高性能的应用场景？如果有，请描述其工作原理和使用场景。"></a>你有没有用过定制的内存分配器，比如为某些高性能的应用场景？如果有，请描述其工作原理和使用场景。</h4><h3 id="实践问题"><a href="#实践问题" class="headerlink" title="实践问题"></a>实践问题</h3><h4 id="描述一个你曾遇到的复杂的内存相关bug，你是如何诊断和解决的？"><a href="#描述一个你曾遇到的复杂的内存相关bug，你是如何诊断和解决的？" class="headerlink" title="描述一个你曾遇到的复杂的内存相关bug，你是如何诊断和解决的？"></a>描述一个你曾遇到的复杂的内存相关bug，你是如何诊断和解决的？</h4><h4 id="你如何评估一个C-程序的内存使用效率？你使用过哪些工具或技术"><a href="#你如何评估一个C-程序的内存使用效率？你使用过哪些工具或技术" class="headerlink" title="你如何评估一个C++程序的内存使用效率？你使用过哪些工具或技术"></a>你如何评估一个C++程序的内存使用效率？你使用过哪些工具或技术</h4><h4 id="请编写一个小程序，其中创建一个有资源泄漏的类，然后展示如何使用工具或方法找到并修复该泄漏。"><a href="#请编写一个小程序，其中创建一个有资源泄漏的类，然后展示如何使用工具或方法找到并修复该泄漏。" class="headerlink" title="请编写一个小程序，其中创建一个有资源泄漏的类，然后展示如何使用工具或方法找到并修复该泄漏。"></a>请编写一个小程序，其中创建一个有资源泄漏的类，然后展示如何使用工具或方法找到并修复该泄漏。</h4>]]></content>
  </entry>
  <entry>
    <title>CMake</title>
    <url>/2023/08/29/CMake/</url>
    <content><![CDATA[<p>这里画一个图直接直接展示一下CMake和Makefile的使用过程</p>
<p><img src="png1.png"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g++ *.cpp -o app  <span class="comment">//直接编译    </span></span><br></pre></td></tr></table></figure>

<p>使用#注释</p>
<p>块注释#[[ ]]</p>
<p>camke_minimum_required：指定使用的cmake的最低版本</p>
<p>project：定义工程名称</p>
<p>add_executable：定义工程会生成一个可执行程序 add_executable(可执行程序名称 源文件名称（空格或者分号隔离源文件)）</p>
<p>cmake CMakeLists.txt：文件所在路径</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.15</span>)</span><br><span class="line"><span class="keyword">project</span>(<span class="keyword">test</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(app, add.cpp div.cpp mult.cpp main.cpp sub.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果CMakeLists.txt文件就在当前目录下，直接执行以下命令</span></span><br><span class="line">cmake .</span><br><span class="line">make</span><br><span class="line"><span class="comment">#就会出现app可执行文件</span></span><br></pre></td></tr></table></figure>

<p>生成了很多其他文件，我们可以把这些临时文件放在一个文件夹里，一般为build文件夹。创建build文件后，cd进build文件，执行camke ..，则cmake执行后生成的文件都放在了build文件夹里。</p>
<h3 id="set的使用"><a href="#set的使用" class="headerlink" title="set的使用"></a><code>set</code>的使用</h3><p>set是为了简化add_executable(app, add.cpp div.cpp mult.cpp main.cpp sub.cpp)的编写，要不然这样和直接编译感觉没啥区别。set给一个变量赋值都是字符串类型，这些文件的名字会作为一个字符串存在变量里。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set指令的语法是：</span></span><br><span class="line"><span class="comment"># [] 中的参数为可选项，如不需要可以不写</span></span><br><span class="line"><span class="keyword">set</span>(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># VAR：变量名</span></span><br><span class="line"><span class="comment"># VALUE：变量值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一：各个源文件之间使用空格间隔</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST add.c div.c main.c mult.c sub.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二：各个源文件之间使用;间隔</span></span><br><span class="line"><span class="keyword">set</span>(SRC_LIST add.c;div.c;main.c;mult.c;sub.c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>取变量值必须以这种方式。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># &quot;$ + &#123;变量名&#125;&quot;</span></span><br><span class="line"><span class="variable">$&#123;SRC_LIST&#125;</span></span><br></pre></td></tr></table></figure>

<p>还可以通过set设置使用C++的标准（C++11，C++17）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正常编译选定c++标准</span></span><br><span class="line">g++ *.cpp -std=c++11 -o app</span><br></pre></td></tr></table></figure>

<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用camke指定c++标准，对应有一个宏叫做DCMAKE_Cxx_STANDARD</span></span><br><span class="line"><span class="comment"># 由两种方式指定C++标准</span></span><br><span class="line"><span class="comment"># 第一种：在CMakeLists.txt中通过set命令指定</span></span><br><span class="line"><span class="keyword">set</span>(CAMKE_CXX_STANDARD <span class="number">11</span>)  <span class="comment"># 等价于增加 -std=c++11</span></span><br><span class="line"><span class="keyword">set</span>(CAMKE_CXX_STANDARD <span class="number">14</span>)</span><br><span class="line"><span class="keyword">set</span>(CAMKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种：在执行camke命令的时候制定出这个宏的值</span></span><br><span class="line">camke CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=<span class="number">11</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=<span class="number">14</span></span><br><span class="line">cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=<span class="number">17</span></span><br></pre></td></tr></table></figure>

<p>set还可以指定输出路径，建议使用绝对路径，如果这个路径中的子目录不存在，会自动生成，无需自己手动创建。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在CMake中指定可执行程序输出的路径，也对应一个宏，叫做EXECUTABLE_OUTPUT_PATH，它的值还是通过set命令设置</span></span><br><span class="line"><span class="keyword">set</span>(HOME /home/zcl/linux/soft)</span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_UOTPUT_PATH <span class="variable">$&#123;HOME&#125;</span>/bin)</span><br><span class="line"><span class="comment"># 第一行：定义一个变量用于存储一个绝对路径</span></span><br><span class="line"><span class="comment"># 第二行：将拼接好的路径值设置给EXECUTABLE_OUTPUT_PATH宏</span></span><br></pre></td></tr></table></figure>



<h3 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h3><p>我们可以看到我们上面所讲的使用set并没有解决要将所有源文件名字写出来的本质问题。为了解决这个问题，这里我们讲一下通过搜索某个目录下的文件来引入源文件的方法。CMake给我们提供了两种方法来搜索文件，aux_source_directory命令或者file命令。</p>
<h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>在CMake中使用aux_source_directory命令可以查找某个路径下的所有源文件。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(&lt;dir&gt; &lt;variable&gt;)</span><br><span class="line"><span class="comment"># dir：要搜索的目录</span></span><br><span class="line"><span class="comment"># variable：将从dir目录下搜索到的源文件列表存储到该变量中</span></span><br><span class="line"><span class="comment"># 这里介绍一个宏，PROJECT_SOURCE_DIR宏代表的就是我们在camke命令后携带的那个路径。比如camke ..，PROJECT_SORCE_DIR宏代表的就是`..`</span></span><br><span class="line"><span class="comment"># 再介绍另外一个宏，CMAKE_CURRENT_SOURCE_DIR宏代表的就是当前CMakelists.txt文件所在的路径</span></span><br><span class="line"><span class="comment"># 下面进入实操，比如搜索当前CMakelists.txt文件所在目录下的src目录</span></span><br><span class="line"><span class="keyword">aux_source_directory</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src SRC_LIST)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>通过file命令来搜索出所有需要的源文件</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令格式</span></span><br><span class="line"><span class="keyword">file</span>(GLOB 变量名 要搜索的文件路径和文件类型)</span><br><span class="line"><span class="keyword">file</span>(GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)</span><br><span class="line"><span class="comment"># GLOB：将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中</span></span><br><span class="line"><span class="comment"># GLOB_RECURSE：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中</span></span><br><span class="line"><span class="comment"># 比如：搜索当前目录的src目录下所有的源文件，并将其存储到变量中</span></span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_HEAD <span class="variable">$&#123;CAMKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/*.h)</span><br><span class="line"><span class="comment"># 注：关于要搜索的文件路径和类型可以加双引号，也可不加</span></span><br><span class="line"><span class="keyword">file</span>(GLOB MAIN_SRC <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="搜索头文件路径"><a href="#搜索头文件路径" class="headerlink" title="搜索头文件路径"></a>搜索头文件路径</h3><p>在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能找到这些头文件。在CMake里搜索头文件的命令也很简单</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(headpath)</span><br><span class="line"><span class="comment"># headpath就是头文件路径，这里建议写绝对路径</span></span><br><span class="line"><span class="comment"># 实操</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>



<h3 id="通过CMake制作库文件"><a href="#通过CMake制作库文件" class="headerlink" title="通过CMake制作库文件"></a>通过CMake制作库文件</h3><p>有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来讲解在cmake中生成这两类库文件的方法。</p>
<h4 id="制作静态库"><a href="#制作静态库" class="headerlink" title="制作静态库"></a>制作静态库</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在cmake中，如果要制作静态库，需要使用的命令如下：</span></span><br><span class="line"><span class="keyword">add_library</span>(库名称 STATIC 源文件<span class="number">1</span> [源文件<span class="number">2</span>] ...) </span><br><span class="line"><span class="comment"># 注：在Linux中，静态库名字分为三部分：lib+库名字+.a，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。</span></span><br><span class="line"><span class="comment"># 如果是动态库，最终生成的库的名字就是：libXXX.so(Linux)，libXXX.dll(Windows)；</span></span><br><span class="line"><span class="comment"># 如果是静态库，最终生成的库的名字就是：libXXX.a(Linux)，libXXX.lib(Windows)；</span></span><br><span class="line"><span class="comment"># 下面有一个目录，需要将src目录中的源文件编译成静态库，然后再使用：</span></span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── <span class="keyword">include</span>           <span class="comment"># 头文件目录</span></span><br><span class="line">│   └── head.h</span><br><span class="line">├── main.cpp          <span class="comment"># 用于测试的源文件</span></span><br><span class="line">└── src               <span class="comment"># 源文件目录</span></span><br><span class="line">    ├── add.cpp</span><br><span class="line">    ├── div.cpp</span><br><span class="line">    ├── mult.cpp</span><br><span class="line">    └── sub.cpp</span><br><span class="line"><span class="comment"># 根据上面的目录结构，可以这样编写CMakeLists.txt文件:</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="comment"># 注：STATIC对应的是静态库，SHARED对应的是动态库</span></span><br></pre></td></tr></table></figure>

<h4 id="制作动态库"><a href="#制作动态库" class="headerlink" title="制作动态库"></a>制作动态库</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(calc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="指定输出路径"><a href="#指定输出路径" class="headerlink" title="指定输出路径"></a>指定输出路径</h4><p>对于生成的库文件来说和可执行程序一样都可以指定输出路径。这里使用LIBRARY_OUTPUT_PATH宏，这个宏对应静态库文件和动态库文件都适用。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src/*.cpp&quot;</span>)</span><br><span class="line"><span class="comment"># 设置动态库/静态库生成路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 生成动态库</span></span><br><span class="line"><span class="comment">#add_library(calc SHARED $&#123;SRC_LIST&#125;)</span></span><br><span class="line"><span class="comment"># 生成静态库</span></span><br><span class="line"><span class="keyword">add_library</span>(calc STATIC <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="包含库文件"><a href="#包含库文件" class="headerlink" title="包含库文件"></a>包含库文件</h3><p>在编写程序的过程中，可能会用到一些系统提供的动态库或者自己制作出的动态库或者静态库文件，cmake中也为我们提供了相关的加载动态库的命令。</p>
<h4 id="链接静态库"><a href="#链接静态库" class="headerlink" title="链接静态库"></a>链接静态库</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">src</span><br><span class="line">├── add.cpp</span><br><span class="line">├── div.cpp</span><br><span class="line">├── main.cpp</span><br><span class="line">├── mult.cpp</span><br><span class="line">└── sub.cpp</span><br></pre></td></tr></table></figure>

<p>现在我们把上面src目录中的add.cpp、div.cpp、mult.cpp、sub.cpp编译成一个静态库文件libcalc.a。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试目录结构</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tree</span> </span><br><span class="line">.</span><br><span class="line">├── build</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── head.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libcalc.a     # 制作出的静态库的名字</span><br><span class="line">└── src</span><br><span class="line">    └── main.cpp</span><br><span class="line"></span><br><span class="line">4 directories, 4 files</span><br></pre></td></tr></table></figure>

<p>在cmake中，链接静态库的命令如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">link_libraries</span>(&lt;static lib&gt; [&lt;static lib&gt;...])</span><br><span class="line"><span class="comment"># 参数1：指定出要链接的静态库的名字，可以是全名 libxxx.a，也可以是掐头（lib）去尾（.a）之后的名字 xxx</span></span><br><span class="line"><span class="comment"># 参数2-N：要链接的其它静态库的名字</span></span><br></pre></td></tr></table></figure>

<p>如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">link_directories</span>(&lt;lib path&gt;)</span><br></pre></td></tr></table></figure>

<p>这样，修改之后的CMakeLists.txt文件内容如下:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(CALC)</span><br><span class="line"><span class="comment"># 搜索指定目录下源文件</span></span><br><span class="line"><span class="keyword">file</span>(GLOB SRC_LIST <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/src/*.cpp)</span><br><span class="line"><span class="comment"># 包含头文件路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br><span class="line"><span class="comment"># 包含静态库路径 添加了这行代码，就可以根据参数指定的路径找到这个静态库了。</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"><span class="comment"># 链接静态库</span></span><br><span class="line"><span class="keyword">link_libraries</span>(calc)</span><br><span class="line"><span class="keyword">add_executable</span>(app <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="链接动态库"><a href="#链接动态库" class="headerlink" title="链接动态库"></a>链接动态库</h4><p>target不知道这个符号是来自它链接的多个库中的哪一个库，它只知道有这么一个库。</p>
<p>FATAL_ERROR：CMake 错误, 终止所有处理过程（CMake在生成”message to display”这条消息之后就不在执行了，直接中断）</p>
<p>CMake在底层管理的时候会将子字符串通过分号隔开，但通过message打印变量值的时候，看不到这个分号。这个分号有助于cmake进行字符串删除操作。只能删除组成变量的子串。比如一开始SRC&#x3D;”A123”，后来apeend了“456”, “789”，如果没有分号，你可能可以删除”345”，但有了分号后，就删除不了了，你只能删除组成SRC的完整的子串，比如”A123”, “456”等。</p>
<p>注意，存储列表长度的output variable依旧是一个字符串类型。</p>
]]></content>
  </entry>
  <entry>
    <title>Linux 高性能服务器--第五章</title>
    <url>/2023/08/27/Linux-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
    <content><![CDATA[<h4 id="5-1-1-判断主机是小端字节序还是大端字节序"><a href="#5-1-1-判断主机是小端字节序还是大端字节序" class="headerlink" title="5.1.1 判断主机是小端字节序还是大端字节序"></a>5.1.1 判断主机是小端字节序还是大端字节序</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">byteOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">short</span> value;</span><br><span class="line">        <span class="type">char</span> union_bytes[<span class="built_in">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    &#125;test;</span><br><span class="line">    </span><br><span class="line">    test.value = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span>(test.union_bytes[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; test.union_bytes[<span class="number">1</span>] == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端字节序\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(test.union_bytes[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; test.union_bytes[<span class="number">1</span>] == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端字节序\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;不清楚\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">byteOrder</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-1-3专用socket地址"><a href="#5-1-3专用socket地址" class="headerlink" title="5.1.3专用socket地址"></a>5.1.3专用<code>socket</code>地址</h4><p><code>TCP/IP</code>协议族有<code>sockaddr_in</code>和<code>sockaddr_in6</code>两个专用<code>socket</code>地址结构体，他们分别用于<code>IPv4</code>和<code>IPv6</code>，这里我只介绍<code>sockaddr_in</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span>&#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;  <span class="comment">// 地址族：AF_INET</span></span><br><span class="line">    <span class="type">u_int16_t</span> sin_port;	<span class="comment">// 端口号：要用网络字节序表示</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;	<span class="comment">// IPv4地址结构体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span>&#123;</span><br><span class="line">    <span class="type">u_int32_t</span> s_addr;	<span class="comment">// 要用网络字节序表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：所有专用<code>socket</code>地址类型的变量在实际使用时都需要转换为通用<code>socket</code>地址类型<code>sockaddr</code>（强制转换即可），因为所有<code>socket</code>编程接口使用的地址参数的类型都是<code>sockaddr</code>。</p>
<h4 id="5-1-4IP地址转换函数"><a href="#5-1-4IP地址转换函数" class="headerlink" title="5.1.4IP地址转换函数"></a>5.1.4<code>IP</code>地址转换函数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span>;	<span class="comment">// 用于将字符串表示的IP地址转换为用网络字节序整数表示的IP地址</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> cnt)</span></span>;	<span class="comment">// 最后一个参数指定目标存储单元的大小，这两个宏可以帮我们指定</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">inet_pton成功时返回1，失败时返回0并设置errno</span></span><br><span class="line"><span class="comment">inet_ntop成功时返回目标存储单元的地址，失败返回NULL并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET_ADDRSTRLEN 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INET6_ADDRSTRLEN 64</span></span><br></pre></td></tr></table></figure>



<h4 id="5-2创建socket"><a href="#5-2创建socket" class="headerlink" title="5.2创建socket"></a>5.2创建socket</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">domain一般为PF_INET(IPv4)，或者PF_INET6(IPv6)</span></span></span><br><span class="line"><span class="comment"><span class="function">type参数指定服务类型，主要有SOCK_STREAM和SOCK_UGRAM</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span> </span></span><br></pre></td></tr></table></figure>

<p>socket系统调用成功时返回一个socket文件描述符，失败返回-1并设置errno</p>
<h4 id="5-3命名socket"><a href="#5-3命名socket" class="headerlink" title="5.3命名socket"></a>5.3命名socket</h4><p>创建socket时，我们给它指定了地址族，但是并未指定使用该地址族中的哪个具体socket地址。将一个socket与socket地址绑定称为给socket命名。在服务器程序中，我们通常需要命名socket，<strong>因为只有命名后客户端才知道该如何连接它</strong>。客户端通常不需要命名socket，而是采用匿名方式，也就是使用操作系统自动分配的socket地址。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* my_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bind将my_addr所指的socket地址分配给未命名的socket文件描述符，addrlen参数指出该socket地址的长度</span></span><br><span class="line"><span class="comment">bind成功时返回0，失败时返回-1并设置errno，其中两种常见的errno是：EACCES和EADDRINUSE。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="5-4监听socket"><a href="#5-4监听socket" class="headerlink" title="5.4监听socket"></a>5.4监听socket</h4><p>socket被命名之后，还不能立即接收客户端连接，我们需要使用如下系统调用来创建一个监听队列以存放待处理的客户连接</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sockfd参数指定被监听的socket，backlog参数提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客户端连接，客户端也将收到ECONNREFUSED错误信息。（实际上最多可以接收backlog + 1个客户端连接）</span></span><br><span class="line"><span class="comment">listen成功时返回0，失败时返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>下面我们编写一个程序测试一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">basename使用示例：</span></span><br><span class="line"><span class="comment">`basename()` 是一个常用于处理文件路径和程序参数的库函数。</span></span><br><span class="line"><span class="comment">它的主要目的是从一个给定的路径中提取基础名（base name），也就是最后一部分的名称，不包含任何前导的目录。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">来自 `&lt;libgen.h&gt;`（或在某些系统中是 `&lt;string.h&gt;` 或 `&lt;strings.h&gt;`），`basename()` 函数的原型如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">char *basename(char *path);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">让我们看一些使用 `basename()` 的例子：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 输入 `/home/user/documents/file.txt` 返回 `file.txt`</span></span><br><span class="line"><span class="comment">2. 输入 `/home/user/documents/folder/` 返回 `folder`</span></span><br><span class="line"><span class="comment">3. 输入 `/home/user/documents/` 返回 `documents`</span></span><br><span class="line"><span class="comment">4. 输入 `file.txt` 返回 `file.txt`</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在给出的代码示例中：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">printf(&quot;usage: %s ip_address port_num backlog\n&quot;, basename(argv[0]));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">`argv[0]` 通常是程序的名称，包括它被执行时的完整路径。</span></span><br><span class="line"><span class="comment">使用 `basename()` 函数，你可以仅提取程序的实际名称，而不包括其路径，这在显示帮助或错误消息时特别有用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">举个例子，假设程序的完整路径是 `/home/user/my_program`，那么 `basename(argv[0])` 就会返回 `my_program`。这样，上述的 `printf` 语句将输出：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">usage: my_program ip_address port_num backlog</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">需要注意的是，`basename()` 函数可能会修改其参数，也可能返回一个指向静态存储区的指针。</span></span><br><span class="line"><span class="comment">因此，如果原始路径字符串不应被修改，那么在调用 `basename()` 之前，最好先复制这个字符串。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">term_handler</span><span class="params">(<span class="type">int</span> sig)</span>&#123;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    signal(SIGTERM, term_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s ip_address port_num backlog\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sockfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sign = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    server_addr.sin_family = PF_INET;</span><br><span class="line">    server_addr.sin_port = htons(port);</span><br><span class="line">    inet_pton(PF_INET, ip, &amp;server_addr.sin_addr);</span><br><span class="line"></span><br><span class="line">    sign = bind(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    assert(sign != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    sign = listen(sockfd, <span class="number">5</span>);</span><br><span class="line">    assert(sign != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果忘记截图了，大家可以自己试一下，具体步骤</span></span><br><span class="line"><span class="comment">./test 172.30.78.145 8000 5</span></span><br><span class="line"><span class="comment">另开终端多次	telnet 172.30.78.145 8000</span></span><br><span class="line"><span class="comment">netstat -nt | grep 8000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>这个命令组合使用了两个命令：<code>netstat</code> 和 <code>grep</code>，并通过管道（<code>|</code>）将第一个命令的输出作为第二个命令的输入。我会为你逐步解释它：</p>
<ol>
<li><p><strong><code>netstat -nt</code></strong>:</p>
<ul>
<li><code>netstat</code>: 这是一个命令行工具，用于显示网络状态，包括网络连接、路由表、接口统计等。</li>
<li><code>-n</code>: 表示以数字形式显示地址和端口号，而不是尝试解析它们的名称。</li>
</ul>
</li>
</ol>
<ul>
<li><code>-t</code>: 仅显示TCP连接。</li>
</ul>
<p>因此，<code>netstat -nt</code> 的输出会列出系统上所有活动的TCP连接，同时显示它们的源和目标IP地址以及端口号，并直接显示数字而不进行名称解析。</p>
<ol start="2">
<li><strong><code>|</code></strong>:</li>
</ol>
<ul>
<li>这是一个管道操作符，用于将前一个命令的输出作为后一个命令的输入。</li>
</ul>
<ol start="3">
<li><p><strong><code>grep 8000</code></strong>:</p>
<ul>
<li><code>grep</code>: 是一个强大的文本搜索工具，用于搜索匹配的字符串。</li>
<li><code>8000</code>: 是你想在 <code>netstat</code> 的输出中搜索的字符串。</li>
</ul>
<p>这个命令会从 <code>netstat</code> 的输出中筛选出所有包含 “8000” 的行，这通常意味着你正在查找与端口 <code>8000</code> 相关的所有活动连接。</p>
</li>
</ol>
<p>综上所述，<code>netstat -nt | grep 8000</code> 会显示所有在端口 <code>8000</code> 上的活动TCP连接。</p>
<h4 id="5-5接受连接"><a href="#5-5接受连接" class="headerlink" title="5.5接受连接"></a>5.5接受连接</h4><p>代码：接受一个异常的连接</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libgen.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;运行程序，需输入这三个参数：%s, ip_address, port_num\n&quot;</span>, <span class="built_in">basename</span>(argv[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">    address.sin_port = <span class="built_in">ntohs</span>(port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sock = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(sock &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(sock, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">    <span class="type">socklen_t</span> client_len = <span class="built_in">sizeof</span>(client);</span><br><span class="line">    <span class="type">int</span> connfd = <span class="built_in">accept</span>(sock, (<span class="keyword">struct</span> sockaddr*)&amp;client, &amp;client_len);</span><br><span class="line">    <span class="keyword">if</span>(connfd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;errno is: %d\n&quot;</span>, errno);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">char</span> remote[INET_ADDRSTRLEN];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>, <span class="built_in">inet_ntop</span>(AF_INET, &amp;client.sin_addr, remote, client_len),</span><br><span class="line">                <span class="built_in">ntohs</span>(client.sin_port));</span><br><span class="line">        <span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、第一次运行报错，<code>undefined reference to main</code>，这种情况一般有三种可能：</p>
<ul>
<li>没有定义main函数</li>
<li>main函数的main拼写错误</li>
<li>刚写的代码忘记保存了</li>
</ul>
<p>2、<code>accept</code>函数是阻塞的，上述代码即服务器端运行的时候，会阻塞在<code>accept</code>处，一旦客户端请求建立连接，服务器立马终止程序。注意<code>accept</code>只是从<code>listen</code>监听队列中取出连接，它不会理会客户端处于什么状态。</p>
<p>3、一直在思考<code>select/poll/epoll</code>这些有什么用。首先因为listen是有监听队列的，劣势就在于只能一个个处理，并且同时接入的连接数有限。比如队列长度为5，处理完一个，再建立下一个连接，这样如果某一个连接处理很长时间一直阻塞在那里，就导致后面的新请求连接建立超时。很直观的想法是<code>fork</code>新进程或者创建新线程来处理新连接，每来一个连接我就创建一个来跟他对接。这样资源消耗太大。因此就有了<code>select/poll/epoll</code>，先把连接建立起来并放进文件描述符，最后从这里面寻找哪些发生了可读可写事件，也避免了因为读写事件造成的阻塞（没有数据到来就阻塞了）。</p>
]]></content>
  </entry>
  <entry>
    <title>Linux高性能服务器-第八章</title>
    <url>/2023/09/07/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E7%AC%AC%E5%85%AB%E7%AB%A0/</url>
    <content><![CDATA[<p>这里因为做项目的需要，我先写下8.6节有关有限状态机的内容</p>
<p>这一节我们介绍逻辑单元内部的一种高效编程方法：有限状态机。有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻辑。</p>
]]></content>
  </entry>
  <entry>
    <title>Cpp高频面经</title>
    <url>/2023/06/29/Cpp%E9%AB%98%E9%A2%91%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h4 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h4><ul>
<li><p>属性的区别</p>
<p>new&#x2F;delete：这两个是C++中的关键字；</p>
<p>malloc&#x2F;free：这两个是库函数；</p>
</li>
<li><p>使用上的区别</p>
<p>malloc：申请空间需要显式填入申请内存的大小；</p>
<p>new：无需显式填入申请内存的大小，new会根据new的类型分配内存；</p>
</li>
<li><p>返回类型的区别</p>
<p>new操作符内存分配成功，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，故new是符合类型安全性的操作符。</p>
<p>malloc内存分配成功返回的是void*指针，需要通过强制类型转换，转换成我们需要的类型。</p>
<p>所以C++中new比malloc安全可靠。</p>
</li>
<li><p>分配失败的区别</p>
<p>malloc分配失败会返回NULL，我们可以通过判断返回值是否是NULL得知是否分配成功。</p>
<p>new分配失败会抛出bad_alloc异常。</p>
</li>
<li><p>扩张内存的区别</p>
<p>malloc有内存扩张机制（通过realloc实现）。</p>
<p>new没有扩张内存机制。</p>
</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/338489910">https://zhuanlan.zhihu.com/p/338489910</a></p>
<h4 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h4><ul>
<li>明确动态内存使用范围：在程序中使用动态内存时，需要明确该内存的使用范围，确保在不需要使用该内存时能够及时释放内存。</li>
<li>使用RAII技术：RAII（Resource Acquisition Is Initialization）是C++中一种常用的资源管理技术，它利用了C++对象的构造函数和析构函数自动调用的特性，在对象的构造函数中申请资源，在对象的析构函数中释放资源，从而避免资源泄漏问题。</li>
<li>使用智能指针：智能指针可以自动管理动态内存的分配和释放。</li>
</ul>
<h4 id="线程池的数量一般怎么设置"><a href="#线程池的数量一般怎么设置" class="headerlink" title="线程池的数量一般怎么设置"></a>线程池的数量一般怎么设置</h4><p>线程池中线程数量的设置主要考虑两个方面：</p>
<ul>
<li><p>I&#x2F;O密集型</p>
</li>
<li><p>如果说任务是耗时I&#x2F;O型，比如涉及数据库、文件的读写，网络通信等任务，这种任务的特点是不会特别消耗CPU资源，但是我们需要考虑到I&#x2F;O操作耗时较长。这种情况一般会将线程数设置的比较大，达到了CPU核心数的很多倍。因为如果线程数设置的比较少，会造成CPU计算资源的浪费。</p>
</li>
<li><p>CPU密集型</p>
</li>
<li><p>对于CPU密集型任务，线程数不宜设置的过多，因为过多的线程都会去抢占CPU资源，就会产生不必要的上下文切换，反而会造成整体性能的下降</p>
</li>
</ul>
<p>线程数通用计算公示：线程数 &#x3D; CPU核心数 * (1 + I&#x2F;O耗时 &#x2F; CPU耗时)</p>
<h4 id="来了一个新任务，线程池是怎么工作的（本答案有待商榷）"><a href="#来了一个新任务，线程池是怎么工作的（本答案有待商榷）" class="headerlink" title="来了一个新任务，线程池是怎么工作的（本答案有待商榷）"></a>来了一个新任务，线程池是怎么工作的（本答案有待商榷）</h4><p>当有一个新任务到来时，线程池会先判断是否有空闲线程，如果有，则将任务分配给空闲线程；</p>
<p>如果此时线程池里没有空线程，则先将任务放任务任务队列，待有空闲线程之后，再从任务队列中取出任务。</p>
<h4 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h4><p>在我的理解里，完美转发 &#x3D; std::forward + 万能引用 + 引用折叠。首先引用折叠机制为T&amp;&amp;类型的万能引用中的模板参数T赋予了一个恰到好处的值，而我们用T去指明std::forward的模板参数，从而使得std::forward返回的是正确的类型（这里关于返回的是正确的类型，应该去看std::forward实现的源码，知乎链接如下：<a href="https://zhuanlan.zhihu.com/p/369203981%EF%BC%89">https://zhuanlan.zhihu.com/p/369203981）</a></p>
<h4 id="去掉std-forward会咋样"><a href="#去掉std-forward会咋样" class="headerlink" title="去掉std::forward会咋样"></a>去掉std::forward会咋样</h4><p>可能会导致在传递参数的时候丢失类型信息，从而导致编译器无法正确推断模板类型或者在模板类型推断中发生错误。</p>
<h4 id="讲一下C-中的虚继承"><a href="#讲一下C-中的虚继承" class="headerlink" title="讲一下C++中的虚继承"></a>讲一下C++中的虚继承</h4><h4 id="基类的析构函数为什么是虚函数？"><a href="#基类的析构函数为什么是虚函数？" class="headerlink" title="基类的析构函数为什么是虚函数？"></a>基类的析构函数为什么是虚函数？</h4><p>如果基类的虚构函数不是虚函数，当我们定义一个父类指针指向子类对象时，最后子类的析构函数不会调用，导致内存泄漏。</p>
<h4 id="struct和union的区别（默写）"><a href="#struct和union的区别（默写）" class="headerlink" title="struct和union的区别（默写）"></a>struct和union的区别（默写）</h4><h4 id="C-内存布局-x2F-程序分段（默写）"><a href="#C-内存布局-x2F-程序分段（默写）" class="headerlink" title="C++内存布局&#x2F;程序分段（默写）"></a>C++内存布局&#x2F;程序分段（默写）</h4><h4 id="了解shared-ptr吗？如果让你手写一个shared-ptr，你会怎么设计"><a href="#了解shared-ptr吗？如果让你手写一个shared-ptr，你会怎么设计" class="headerlink" title="了解shared_ptr吗？如果让你手写一个shared_ptr，你会怎么设计"></a>了解shared_ptr吗？如果让你手写一个shared_ptr，你会怎么设计</h4><p>shared_ptr是智能指针里面的共享指针，即多个指针指向同一个内存。每多一个指针指向这片内存，引用计数加1。当对象的引用计数减少为0时，对象会自动析构，对应内存被自动释放。智能指针是模板类，而不是指针。</p>
<p>设计：将shared_ptr定义为一个模板类，包括两个成员：模板类指针和一个指向引用计数的指针。指向引用计数类型的指针应该包括这些成员函数：增加计数、减少计数、返回现有计数。一个私有成员就是用于计数的变量。共享指针模板类的构造函数接受一个模板类型指针，并且需要声明为explicit，表示必须直接初始化。另外就是拷贝构造函数和移动构造函数。拷贝构造需要注意拷贝的对象的指针是否为nullptr，如果不是nullptr，则需要增加引用计数。移动构造函数需要注意将传入的右值引用对象的指针置空，引用计数清零。析构函数有两个判断条件，第一个最后一个指向对象的指针需要为非nullptr并且此时引用计数减一后为0。然后就是重载*、-&gt;、bool，还有一个函数用于获得指针get()。动态转换（可考虑）。</p>
<h4 id="介绍一下TCP，TCP粘包如何解决"><a href="#介绍一下TCP，TCP粘包如何解决" class="headerlink" title="介绍一下TCP，TCP粘包如何解决"></a>介绍一下TCP，TCP粘包如何解决</h4><p>解决办法：</p>
<ul>
<li>发送端：使用TCP_NODELAY关闭Nagle算法，但是如果不是时延敏感的应用尽量不要关闭</li>
<li>接收端：没法解决，只能交给应用端解决</li>
<li>应用层：有三种解决办法<ul>
<li>只发送固定包长的数据包，但是这个方法基本不用，灵活性太差</li>
<li>指定标识结尾，比如\r\n之类的</li>
<li>包头加包体，包头一般是固定长度，并且里面有一个字段可以告知我们接下来的包体有多大</li>
</ul>
</li>
</ul>
<h4 id="回调函数是什么，回调函数的本质"><a href="#回调函数是什么，回调函数的本质" class="headerlink" title="回调函数是什么，回调函数的本质"></a>回调函数是什么，回调函数的本质</h4><p>回调函数允许我们将一个函数（或函数对象）作为参数传递给另一个函数，并在需要的时候由后者调用执行。回调函数定义了在特定事件或条件满足时应该执行的操作。主调函数是接受回调函数作为参数的函数。</p>
<h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><ol>
<li>进程<ul>
<li>进程拥有独立内存空间和系统资源</li>
<li>进程之间相互独立，一个进程的崩溃通常不会影响其他进程</li>
<li>创建、销毁和切换进程开销比较大</li>
</ul>
</li>
<li>线程<ul>
<li>一个进程可以包含多个线程，所有线程共享相同的地址空间和系统资源</li>
<li>线程之间可以直接读写进程内的共享数据，执行起来更高效</li>
<li>线程的创建、销毁和切换开销比较小</li>
</ul>
</li>
</ol>
<h4 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h4><p>GET用于获取资源，参数通过URL传递，不适合传输敏感信息，幂等，有缓存，传输数据的大小受限于URL的长度。POST用于提交数据，参数通过请求体传递，适合传输敏感信息，不幂等，无缓存，没有数据大小限制。</p>
<h4 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h4><ol>
<li>HTTP<ul>
<li>HTTP是一种应用层协议，用于在Web浏览器和Web服务器之间传输超文本和其他资源</li>
<li>HTTP是明文传输的协议，意味着数据在传输过程中是未加密的，容易被窃听和篡改</li>
<li>HTTP默认使用80端口号</li>
</ul>
</li>
<li>HTTPS<ul>
<li>HTTPS是HTTP协议的安全版本，加强了数据传输的安全性和保密性</li>
<li>HTTPS使用了SSL&#x2F;TLS协议进行数据加密和身份认证</li>
<li>HTTPS默认使用443端口通信</li>
</ul>
</li>
</ol>
<h4 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++ 11新特性"></a>C++ 11新特性</h4><ul>
<li><p>auto关键字</p>
</li>
<li><p>智能指针</p>
</li>
<li><p>lambda表达式	参考链接（<a href="https://blog.51cto.com/u_15323899/5785594%EF%BC%89">https://blog.51cto.com/u_15323899/5785594）</a></p>
<p>Lambda表达式是C++11引入的一种新特性，它允许在代码中定义匿名函数。虽然在使用上非常简洁和方便，但lambda表达式背后的实现相对复杂。以下是lambda表达式在底层的工作原理：</p>
<ol>
<li><p><strong>转换为类</strong>:</p>
<ul>
<li>当你定义一个lambda表达式，编译器会为你生成一个匿名类（也称为闭包类型）。这个类将会覆盖函数调用操作符，使得该对象可以像函数一样被调用。</li>
<li>如果lambda表达式捕获了外部的局部变量（例如通过值或引用），这些变量将会被添加为该匿名类的成员。</li>
</ul>
</li>
<li><p><strong>成员变量</strong>:</p>
<ul>
<li>为了支持捕获，生成的闭包类型可能会包含成员变量。如果使用值捕获，那么这些成员变量将存储捕获的变量的副本；如果使用引用捕获，那么成员变量将存储相应变量的引用。</li>
</ul>
</li>
<li><p><strong>函数调用操作符重载</strong>:</p>
<ul>
<li>生成的类会覆盖函数调用操作符<code>operator()</code>. 这个操作符的实现就是lambda表达式的主体。</li>
</ul>
</li>
<li><p><strong>构造函数</strong>:</p>
<ul>
<li>该匿名类的构造函数会初始化所有捕获的变量。根据捕获方式（值或引用）来复制或绑定这些变量。</li>
</ul>
</li>
<li><p><strong>生成的类是只移动构造的</strong>:</p>
<ul>
<li>这意味着你不能按常规方式复制lambda表达式，但可以移动它。</li>
</ul>
</li>
</ol>
<p>下面是一个简单的lambda表达式的例子以及一个可能的简化版本的匿名类表示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Lambda</span></span><br><span class="line"><span class="keyword">auto</span> lambda = [x](<span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Possible representation by the compiler</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__anonymous</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    __anonymous(<span class="type">int</span> _x) : <span class="built_in">x</span>(_x) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要注意的是，这只是一个简化的表示。实际编译器生成的代码会比这更复杂，尤其是当涉及到更高级的特性（如泛型、<code>mutable</code>关键字或捕获列表）时。</p>
<p>最后，虽然从概念上讲，lambda表达式是转换为类的，但这并不意味着性能会受到影响。优化后的编译器通常会内联这些生成的类和函数调用操作符，从而消除由于间接调用导致的任何额外开销。</p>
</li>
<li><p>右值引用和移动语义</p>
</li>
</ul>
<h4 id="lambda表达式的使用场景"><a href="#lambda表达式的使用场景" class="headerlink" title="lambda表达式的使用场景"></a>lambda表达式的使用场景</h4><p>lambda表达式提供了一种简洁、方便的方式来创建匿名对象。在一些需要传递简单函数对象的场景下，使用lambda表达式可以避免额外的函数对象类。</p>
<h4 id="vector迭代器失效的原因"><a href="#vector迭代器失效的原因" class="headerlink" title="vector迭代器失效的原因"></a>vector迭代器失效的原因</h4><p>vector底层的实现是一个动态数组，vector里面存储的元素都是连续的，一旦比如删除一个元素，后面的所有元素都需要移动。我们可以考虑一种极端情况，删除最后一个元素，此时指向原vector数组的最后一个元素的迭代器就没指向任何元素了，如何此时我们访问这个迭代器所指向的元素，就会导致未定义行为，所以就会判定迭代器失效。其实所有改变vector大小的操作，都会导致vector迭代器失效。</p>
<h4 id="map的底层数据结构"><a href="#map的底层数据结构" class="headerlink" title="map的底层数据结构"></a>map的底层数据结构</h4><p>红黑树参考链接：<a href="https://www.jianshu.com/p/e136ec79235c">https://www.jianshu.com/p/e136ec79235c</a></p>
<p>map是有序容器，底层数据结构是红黑树，时间复杂度为log(n)。红黑树的前身可以说是二叉搜索树。但是二叉搜索树最坏的情况下树的高度为n，那么就导致时间复杂度为o(n), 所以便衍生出来了平衡二叉树。其实红黑树的五大特性就是为了保持二叉搜索树的平衡。保证时间复杂度稳定在o(logn)。</p>
<h4 id="unordered-map底层数据结构"><a href="#unordered-map底层数据结构" class="headerlink" title="unordered_map底层数据结构"></a>unordered_map底层数据结构</h4><p>unordered_map是无序容器，底层使用哈希表实现的。</p>
<h4 id="TCP握手为什么是三次握手，两次握手为什么不行呢"><a href="#TCP握手为什么是三次握手，两次握手为什么不行呢" class="headerlink" title="TCP握手为什么是三次握手，两次握手为什么不行呢"></a>TCP握手为什么是三次握手，两次握手为什么不行呢</h4><p>这里有两个大点，第一个字面意思很好理解，第二点举个例子就通透了，面试时最好全部答上来</p>
<ul>
<li><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤</p>
</li>
<li><p>防止已失效的连接请求又传送到服务器端，因而产生错误</p>
<p>只有采用三次握手可以减少服务端的资源浪费。解释如下：<br>例如，客户端向服务端发送请求同步报文A，因为网络阻塞等原因，服务端没有收到同步报文A，所以没有发送同步确认报文。过了一段时间，客户端没有收到服务端的确认报文，重新向服务端发送请求同步报文B，服务端接收到报文B后，向客户端发送同步确认报文，客户端接收到确认报文后，向服务端发送确认报文，建立连接。数据传输完毕后，连接断开。客户端进入close状态，此时服务端收到之前的报文A，向客户端返回同步确认报文。如果使用两次握手，服务端回应后不确认客户端的状态，连接建立成功。服务端会长时间等待客户端发送数据，连接长期保持，会造成资源浪费。当多个客户端产生这种情况，服务器就会等待多个客户端的响应，连接数量过多，之后的客户端请求，服务器无法响应。造成服务器处于瘫痪状态。<br>只有使用三次握手，当服务端收到确认报文后，保证当前时刻，客户端可以发送数据时，才能建立有意义的连接。当客户端一段时间不发送数据时，服务器应自动断开连接，来节省自身连接的客户端数量，减少资源的浪费。</p>
</li>
</ul>
<h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p>HTTP状态码是在HTTP协议中用于表示服务器对请求的处理结果的三位数字代码。HTTP状态码的分类如下：</p>
<ol>
<li><p>1xx（信息性状态码）：表示服务器已接收请求，需要客户端继续操作。</p>
</li>
<li><p>2xx（成功状态码）：表示服务器成功处理了请求。</p>
</li>
<li><p>3xx（重定向状态码）：表示请求需要进一步的操作，通常用于重定向。</p>
</li>
<li><p>4xx（客户端错误状态码）：表示客户端发出的请求有误。</p>
</li>
<li><p>5xx（服务器错误状态码）：表示服务器在处理请求时发生了错误。</p>
</li>
</ol>
<p>以下是一些常见的HTTP状态码示例：</p>
<ol>
<li><p>200 OK：请求成功，服务器成功处理了请求。</p>
</li>
<li><p>201 Created：请求成功，服务器已成功创建了资源。</p>
</li>
<li><p>204 No Content：请求成功，但服务器没有新的信息返回。</p>
</li>
<li><p>400 Bad Request：请求错误，服务器不理解或无法处理请求。</p>
</li>
<li><p>401 Unauthorized：请求需要用户认证，未提供有效的认证信息。</p>
</li>
<li><p>403 Forbidden：请求被服务器拒绝，没有访问权限。</p>
</li>
<li><p>404 Not Found：请求的资源不存在。</p>
</li>
<li><p>500 Internal Server Error：服务器内部错误，无法完成请求。</p>
</li>
<li><p>502 Bad Gateway：服务器作为网关或代理，从上游服务器收到无效的响应。</p>
</li>
<li><p>503 Service Unavailable：服务器暂时不可用，通常是由于过载或维护。</p>
</li>
</ol>
<p>这只是HTTP状态码中的一部分，实际中可能还会遇到其他状态码。状态码的具体含义可参考HTTP协议的官方文档或RFC文档。不同的状态码代表了服务器对请求的不同响应结果，客户端根据状态码可以做出相应的处理。</p>
<h4 id="使用智能指针了，普通指针还能用吗？"><a href="#使用智能指针了，普通指针还能用吗？" class="headerlink" title="使用智能指针了，普通指针还能用吗？"></a>使用智能指针了，普通指针还能用吗？</h4><p>个人觉得使用了智能指针后不推荐使用普通指针。因为使用了智能指针后，再使用普通指针指向相同对象，并不会增加引用计数，等智能指针引用计数变为0的时候，对象被销毁，此时普通指针就变为了野指针。</p>
<h4 id="什么时候使用智能指针，什么时候使用普通指针-（CHATGPT）"><a href="#什么时候使用智能指针，什么时候使用普通指针-（CHATGPT）" class="headerlink" title="什么时候使用智能指针，什么时候使用普通指针 （CHATGPT）"></a>什么时候使用智能指针，什么时候使用普通指针 （CHATGPT）</h4><p>使用智能指针还是普通指针取决于你的代码需求和内存管理需求。以下是一些指导原则：</p>
<p>使用智能指针的情况：</p>
<ol>
<li><p>动态分配内存：如果你需要动态分配内存，尤其是在使用<code>new</code>关键字时，最好使用智能指针来管理这些资源。智能指针会自动在不再需要时释放内存，避免了内存泄漏的问题。</p>
</li>
<li><p>所有权传递：当多个地方共享一个资源并且需要明确的所有权传递时，智能指针特别有用。例如，使用<code>std::shared_ptr</code>来共享资源，并在最后一个引用释放时自动删除资源。</p>
</li>
<li><p>异常安全：在使用普通指针的代码中，如果在动态分配资源后发生异常，可能会导致资源泄漏。使用智能指针可以更好地处理异常情况，确保资源在退出作用域时得到正确释放。</p>
</li>
<li><p>容器存储：如果要在STL容器中存储指针类型，建议使用智能指针。STL容器在元素添加或删除时可能会复制或移动元素，使用智能指针可以正确管理资源的所有权。</p>
</li>
</ol>
<p>使用普通指针的情况：</p>
<ol>
<li><p>接口和传统API：某些接口和传统的C API可能要求使用原始指针，此时你无法使用智能指针。在这种情况下，你应该小心管理内存，确保手动释放资源。</p>
</li>
<li><p>与C代码交互：当与C语言库或代码进行交互时，普通指针是常用的方式，因为C语言不支持智能指针。</p>
</li>
<li><p>临时指针：对于一些临时指针，其生命周期很短且不需要动态内存管理时，可以使用普通指针。</p>
</li>
<li><p>最低开销：在某些性能关键的场景，智能指针可能带来额外的开销，此时使用普通指针可能更合适。但请注意，在性能优化前确保使用智能指针没有影响到代码的正确性和可维护性。</p>
</li>
</ol>
<p>综上所述，智能指针在大多数情况下是推荐的内存管理方式，特别是在现代C++代码中。然而，有些特定的场景可能需要使用普通指针，但在这种情况下你需要格外小心以避免内存泄漏和悬挂指针问题。</p>
<h4 id="Hash-map原理"><a href="#Hash-map原理" class="headerlink" title="Hash_map原理"></a>Hash_map原理</h4><p>Hash_map基于Hash_map（哈希表）。</p>
<p>哈希表基本原理：使用一个下标范围较大的数组来储存元素。那我们怎么根据关键字知道它应该放在数组的哪个位置呢？这就通过哈希函数（散列函数）来解决。哈希函数使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应。但是，不能保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这就产生了哈希冲突。因此“直接定址”和“解决冲突”是哈希表的两大特点。</p>
<p>哈希冲突的解决主要有以下四种方法：开放地址法，再哈希法，链地址法和建立公共溢出区。关于这四种方法的解释见知乎链接 <a href="https://zhuanlan.zhihu.com/p/29520044">https://zhuanlan.zhihu.com/p/29520044</a></p>
<h4 id="C-多态介绍一下"><a href="#C-多态介绍一下" class="headerlink" title="C++多态介绍一下"></a>C++多态介绍一下</h4><p>C++多态主要包括重载、虚函数、模板。重载包括函数重载和运算符重载，编译期，即编译器在编译阶段就会根据函数调用的上下文来决定使用哪一个重载版本。虚函数是在运行期。重载和模板属于静态多态，虚函数属于动态多态。静态多态与动态多态靠编译期与运行期区分。</p>
<h4 id="虚函数、纯虚函数原理，虚表什么时候建立的https-zhuanlan-zhihu-com-p-37331092"><a href="#虚函数、纯虚函数原理，虚表什么时候建立的https-zhuanlan-zhihu-com-p-37331092" class="headerlink" title="虚函数、纯虚函数原理，虚表什么时候建立的	https://zhuanlan.zhihu.com/p/37331092"></a>虚函数、纯虚函数原理，虚表什么时候建立的	<a href="https://zhuanlan.zhihu.com/p/37331092">https://zhuanlan.zhihu.com/p/37331092</a></h4><ul>
<li>虚函数，在类成员方法的声明（不是定义）语句前加“virtual”，如virtual void func</li>
<li>纯虚函数，在虚函数后加“&#x3D;0”，如virtual void func &#x3D; 0</li>
<li>对于虚函数，子类可以（也可以不）重写基类的虚函数，该行为称之为override</li>
<li>对于纯虚函数，子类必须提供纯虚函数的个性化实现</li>
</ul>
<p>在派生子类中对虚函数和纯虚函数的个性化实现，都体现了多态特性，但区别在于：</p>
<ul>
<li>子类如果不提供虚函数的实现，将会自动调用基类的缺省虚函数实现</li>
<li>子类如果不提供纯虚函数的实现，将会编译失败</li>
</ul>
<p><strong>当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数则由指针指向的实际类型决定</strong></p>
<p>实现虚函数表的关键就是虚函数表指针，这个指针指向一张名为虚函数表的表，为表中的数据则为函数指针，存储了虚函数具体实现所对应的位置。另外，当一个类有多个虚函数时，仍然只有一个虚函数指针，而此时的虚函数表里会有多个<strong>函数指针</strong>，因此，虚函数实现的过程是：<strong>通过对象内存中的虚函数指针vptr找到虚函数表vtbl，再通过vtbl中的函数指针找到对应虚函数的实现区域并进行调用。</strong>所以虚函数的调用时由指针所指向内存块的具体类型决定的。</p>
<h4 id="构造函数和析构函数可以是虚函数吗？"><a href="#构造函数和析构函数可以是虚函数吗？" class="headerlink" title="构造函数和析构函数可以是虚函数吗？"></a>构造函数和析构函数可以是虚函数吗？</h4><p>答案是：构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。</p>
<p>首先，我们已经知道虚函数的实现则是通过对象内存中的vptr来实现的。而构造函数是用来实例化一个对象的，通俗来讲就是为对象内存中的值做初始化操作。那么在构造函数完成之前，也即还没有进行初始化，此时vptr是没有值的，也就无法通过vptr找到作为构造函数和虚函数所在的代码区，所以构造函数只能以普通函数的形式存放在类所指定的代码区中。</p>
<p>而对于析构函数，当我们delete(a)的时候，如果析构函数不是虚函数，那么调用的将会是基类base的析构函数。而当继承的时候，通常派生类会在基类的基础上定义自己的成员，此时我们当然希望可以调用派生类的析构函数对新定义的成员也进行析构。</p>
<h4 id="map为啥用红黑树不用avl树？"><a href="#map为啥用红黑树不用avl树？" class="headerlink" title="map为啥用红黑树不用avl树？"></a>map为啥用红黑树不用avl树？</h4><ul>
<li>平衡调整次数更少</li>
<li>内存使用更少：AVL树需要存储额外的平衡因子信息</li>
<li>更适合于频繁的插入和删除操作</li>
</ul>
<h4 id="怎么判断map里key值存不存在"><a href="#怎么判断map里key值存不存在" class="headerlink" title="怎么判断map里key值存不存在"></a>怎么判断map里key值存不存在</h4><p>c.at(k)	访问关键字为k的元素，如果k不在c中，返回一个out_of_range异常</p>
<p>c.find(k)	如果存在，返回一个迭代器，指向关键字为k的元素；如果不存在，返回尾后迭代器</p>
<p>c.count(k)	不存在返回0，存在返回k关键字的数量</p>
<h4 id="多进程通信方式"><a href="#多进程通信方式" class="headerlink" title="多进程通信方式"></a>多进程通信方式</h4><p>管道、命名管道、消息队列、信号量、共享内存、套接字、RPC</p>
<p>管道：一种最简单的进程间通信方式，通常用于父子进程间通信。管道中数据只能朝一个方向流动，即一方读另一方写。管道通过系统调用pipe()创建。</p>
<p>命名管道：一种更通用的进程间通信方式，它可以在无关的进程之间进行通信。不同于管道，命名管道通过文件系统中的路径名来标识。命名管道可以通过系统调用 <code>mkfifo()</code> 创建。</p>
<p>信号量：讲好sem_init(), sem_wait(), sem_post()系统整体运作过程就好了</p>
<p>套接字：服务器监听一个ip+端口，客户端访问连接</p>
<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><table>
<thead>
<tr>
<th align="left"></th>
<th align="center">TCP</th>
<th align="center">UDP</th>
</tr>
</thead>
<tbody><tr>
<td align="left">可靠性</td>
<td align="center">可靠</td>
<td align="center">不可靠</td>
</tr>
<tr>
<td align="left">连接</td>
<td align="center">面向连接</td>
<td align="center">无连接</td>
</tr>
<tr>
<td align="left">数据传输方式</td>
<td align="center">字节流</td>
<td align="center">数据报</td>
</tr>
<tr>
<td align="left">双工性</td>
<td align="center">全双工</td>
<td align="center">一对一、一对多、多对一、多对多</td>
</tr>
<tr>
<td align="left">流量控制</td>
<td align="center">滑动窗口</td>
<td align="center">无</td>
</tr>
<tr>
<td align="left">拥塞控制</td>
<td align="center">慢启动、拥塞避免、快速重传、快速回复</td>
<td align="center">无</td>
</tr>
<tr>
<td align="left">效率</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
<tr>
<td align="left">传输速度</td>
<td align="center">慢</td>
<td align="center">快</td>
</tr>
</tbody></table>
<h4 id="TCP-x2F-IP协议组"><a href="#TCP-x2F-IP协议组" class="headerlink" title="TCP&#x2F;IP协议组"></a>TCP&#x2F;IP协议组</h4><p>IP协议、TCP协议、UDP协议、ICMP协议、ARP协议、RARP协议</p>
<h4 id="OSI七层"><a href="#OSI七层" class="headerlink" title="OSI七层"></a>OSI七层</h4><p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<h4 id="socket编程recv函数"><a href="#socket编程recv函数" class="headerlink" title="socket编程recv函数"></a>socket编程recv函数</h4><p>返回0：对方关闭连接</p>
<p>返回相应的接收数据大小</p>
<p>返回错误码：传输出现错误</p>
<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>快排思想：选定基准元素，小的放一边，大的放一边，最后分治</p>
<h4 id="HTTP状态码-1"><a href="#HTTP状态码-1" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><ol>
<li>1XX - 信息状态码：<ul>
<li>100 Continue：服务端已经收到了客户端请求，继续发送剩余部分</li>
</ul>
</li>
<li>2XX - 成功状态码：<ul>
<li>200 OK：请求成功，服务器成功处理了请求</li>
<li>201 Created：请求成功，并创建了资源</li>
<li>204 No Content：请求成功，但没有返回内容</li>
</ul>
</li>
<li>3XX - 重定向状态码：<ul>
<li>301 Moved Permanently：永久重定向，请求的资源被永久移到了新位置</li>
<li>302 Found：临时重定向，请求的资源被临时移到了新位置</li>
<li>304 Not Modified：客户端缓存资源仍然有效，未修改</li>
</ul>
</li>
<li>4XX - 客户端错误状态码：<ul>
<li>400 Bad Request：客户端请求错误，服务器无法理解</li>
<li>401 Unauthorized：请求要求身份验证，客户端未提供有效的身份信息</li>
<li>403 Forbidden：服务器拒绝请求，没有访问权限</li>
<li>404 Not Found：请求的资源不存在</li>
</ul>
</li>
<li>5XX - 服务器错误状态码：<ul>
<li>500 Internet Server Error：服务器内部错误，无法完成请求</li>
<li>502 Bad Gateway：作为网关或代理的服务器从上游服务器收到无效响应</li>
<li>503 Service Unavailable：服务器暂时过载或维护中，无法处理请求</li>
<li>504 Gateway Timeout：作为网关或代理服务器未及时从上游服务器接收响应</li>
</ul>
</li>
</ol>
<h4 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h4><p>DNS就是域名解析服务，查询过程依次递增。本地域名解析（操作系统首先会查询本地DNS缓存） —–》本地域名服务器查询 —–》根域名服务器查询 —–》顶级域名服务器查询 —–》权威域名服务器查询 —–》返回结果。DNS查询和应答报文具有相同格式，主要区别在于某些字段的标识。下面讲几个重要的字段。</p>
<ul>
<li>16位标识：用于标记一对DNS查询和应答，以此区分一个DNS应答是哪一个DNS查询的回应</li>
<li>16位标志<ul>
<li>QR：查询报文（0）&#x2F;	应答报文（1）</li>
<li>opcode：标准查询（0）&#x2F;    反向查询（1）就是是通过域名获取ip地址还是通过ip地址获取域名</li>
</ul>
</li>
</ul>
<h4 id="TCP为什么需要四次挥手，三次挥手有什么问题"><a href="#TCP为什么需要四次挥手，三次挥手有什么问题" class="headerlink" title="TCP为什么需要四次挥手，三次挥手有什么问题"></a>TCP为什么需要四次挥手，三次挥手有什么问题</h4><ol>
<li>客户端最后一个ACK可能会丢失，这样服务端就无法正常进入CLOSED状态。于是B会重传请求释放的报文，而此时如果A已经关闭了，那就收不到B的重传请求，就会导致B无法正常释放。而如果A还在等待时间内，就会收到B的重传，然后进行应答，这样B就可以进入CLOSED状态</li>
<li>如果三次挥手的话，服务端收到来自客户端的FIN请求后，需要同时回复ACK和发送FIN断开连接请求。但是在TCP连接中是有一个半关闭状态的，也就是服务端其实还是可以继续发送数据的，如果三次挥手，就无法做到服务器再发送数据了。</li>
</ol>
<h4 id="TCP传输为什么是可靠的"><a href="#TCP传输为什么是可靠的" class="headerlink" title="TCP传输为什么是可靠的"></a>TCP传输为什么是可靠的</h4><ul>
<li>确认与重传：如果一定时间内未收到ACK，则会重传</li>
<li>序列号与顺序性：TCP为每一个数据包分配一个序列号，接收端会进行数据包重组</li>
<li>流量控制</li>
<li>拥塞控制</li>
<li>连接管理：三次握手与四次挥手</li>
<li>超时与重试</li>
</ul>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p>新建、就绪、运行、阻塞、等待、终止</p>
<h4 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h4><p>死锁发生的必要条件，通常被称为死锁的四个条件，分别是：</p>
<ol>
<li><strong>互斥条件（Mutual Exclusion）：</strong> 指某个资源在一段时间内只能被一个线程或进程占用，其他线程或进程需要等待资源释放才能继续执行。</li>
<li><strong>请求与保持条件（Hold and Wait）：</strong> 指线程在保持至少一个资源的同时，还请求其他资源，而这些资源可能被其他线程占用，导致请求阻塞。</li>
<li><strong>不剥夺条件（No Preemption）：</strong> 指资源只能由占有它的线程显式释放，其他线程不能强行抢占资源。</li>
<li><strong>循环等待条件（Circular Wait）：</strong> 指多个线程形成一个循环，每个线程都在等待下一个线程所持有的资源，导致一个闭环的等待状态。</li>
</ol>
<h4 id="死锁解决方案"><a href="#死锁解决方案" class="headerlink" title="死锁解决方案"></a>死锁解决方案</h4><ul>
<li>系统重新启动</li>
<li>撤销进程、剥夺资源</li>
<li>进程回退策略，即让参与死锁的进程回退到没有发生死锁前某一点处。</li>
</ul>
<h4 id="树的知识"><a href="#树的知识" class="headerlink" title="树的知识"></a>树的知识</h4><p><a href="https://oi-wiki.org/ds/bplus-tree/">https://oi-wiki.org/ds/bplus-tree/</a></p>
<h4 id="Linux-API调用返回值汇总"><a href="#Linux-API调用返回值汇总" class="headerlink" title="Linux API调用返回值汇总"></a>Linux API调用返回值汇总</h4><p>int pthread_create：成功时返回0，失败时返回错误码</p>
<p>void pthread_exit：不会失败</p>
<p>int pthread_join ( pthread_t thread, void** retval)：成功时返回0，失败时返回错误码。错误码：EDEADLK：可能引起死锁，比如两个线程互相针对对方调用pthread_join，或者线程对自身调用pthread_join；EINVAL：目标线程是不可回收的，或者已经有其他线程在回收该目标线程；ESRCH：目标线程不存在。</p>
<p>int sem_init( sem_t* sem, int pshared, unsigned int value )</p>
<p>int sem_destroy( sem_t* sem )</p>
<p>int sem_wait( sem_t* sem)</p>
<p>int sem_trywait( sem_t* sem )</p>
<p>int sem_post( sem_t* sem )：以上五个成功时返回0， 失败时返回-1并设置errno</p>
<h4 id="DNS的解析过程"><a href="#DNS的解析过程" class="headerlink" title="DNS的解析过程"></a>DNS的解析过程</h4><p>DNS是实现域名和IP地址相互映射的一个分布式数据库。DNS解析过程主要包括以下步骤</p>
<ol>
<li>本地缓存查询：当用户通过浏览器访问某域名时，浏览器会首先在自己的缓存里查询是否有该域名对应的IP地址。</li>
<li>本地系统查询：查看本计算机系统Host文件DNS缓存是否有对应DNS缓存</li>
<li>查看路由器缓存</li>
<li>查询ISP DNS缓存：也称本地域名服务器查询，计算机会向你的ISP（互联网服务提供商）分配的本地域名服务器发出查询请求</li>
<li>根域名服务器</li>
<li>顶级域名服务器：根域名服务器并不会直接返回用户IP地址，而是会指向查询请求对应的顶级域名服务器</li>
<li>权威域名服务器：顶级域名服务器会指向域名的权威域名服务器，这些服务器管理特定的域名的DNS服务。</li>
</ol>
<h4 id="TCP传输为什么是可靠的-1"><a href="#TCP传输为什么是可靠的-1" class="headerlink" title="TCP传输为什么是可靠的"></a>TCP传输为什么是可靠的</h4><p>总结下来主要包括三个方面：</p>
<ul>
<li>检验和</li>
<li>确认应答（ACK和序列号一应一答）</li>
<li>超时重传</li>
</ul>
<h4 id="NAT协议和跨域（不了解）"><a href="#NAT协议和跨域（不了解）" class="headerlink" title="NAT协议和跨域（不了解）"></a>NAT协议和跨域（不了解）</h4><h4 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h4><p>最明显的一个区别就是GET请求会把参数放在URL（统一资源定位符）中，POST会把参数放在请求体中。</p>
<p>数据大小限制：GET请求把参数放在URL中，GET请求数据大小收到URL长度限制。POST请求则不会</p>
<p>幂等性：GET请求每次相同请求返回的结果都一样，多次重复请求不会对资源产生影响。POST请求则相反</p>
<p>安全性：POST更安全，参数没有暴露在URL上</p>
<p>缓存：GET请求可以被浏览器缓存，POST请求不会被浏览器缓存</p>
<h4 id="写一段死锁的代码"><a href="#写一段死锁的代码" class="headerlink" title="写一段死锁的代码"></a>写一段死锁的代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_a;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">another</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in child thread, get mutex a\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_b);</span><br><span class="line">    b += a;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_b);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_a, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_b, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;id, <span class="literal">NULL</span>, another, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in parent thread, get mutex b\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    ++b;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_a);</span><br><span class="line">    a += b;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pro is end\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="删除字符串头尾空格代码"><a href="#删除字符串头尾空格代码" class="headerlink" title="删除字符串头尾空格代码"></a>删除字符串头尾空格代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::string tmp;</span><br><span class="line">    <span class="built_in">getline</span>(std::cin, s);   <span class="comment">//这里很重要哦，如果用cin，“hello world”会被截断成hello</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = s.<span class="built_in">substr</span>(i, s.<span class="built_in">size</span>() - i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = s.<span class="built_in">substr</span>(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="shared-ptr是线程安全的吗？https-cloud-tencent-com-developer-article-1654442"><a href="#shared-ptr是线程安全的吗？https-cloud-tencent-com-developer-article-1654442" class="headerlink" title="shared_ptr是线程安全的吗？https://cloud.tencent.com/developer/article/1654442"></a>shared_ptr是线程安全的吗？<a href="https://cloud.tencent.com/developer/article/1654442">https://cloud.tencent.com/developer/article/1654442</a></h4><ul>
<li>多线程同时读一个shared_ptr对象是安全的</li>
<li>多线程同时对一个shared_ptr对象进行读和写是不安全的，需要加锁</li>
</ul>
<p>这里给出一个伪代码的简单例子</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shared_ptr&lt;Foo&gt; g(new Foo1);   // 线程之间共享的shared_ptr</span><br><span class="line">shared_ptr&lt;Foo&gt; x;   		  // 线程A的局部变量</span><br><span class="line">shared_ptr&lt;Foo&gt; n(new Foo2);   // 线程B的局部变量</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">线程A</span><br><span class="line">x = g;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">线程B</span><br><span class="line">g = n;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">测试场景：</span><br><span class="line"></span><br><span class="line">线程A </span><br><span class="line">  智能指针x 读取Foo1,然后还重置Foo1计数。</span><br><span class="line"></span><br><span class="line">线程 B:</span><br><span class="line"> 销毁了Foo1</span><br><span class="line">线程A</span><br><span class="line">重置计数时，foo1已经被销毁。</span><br></pre></td></tr></table></figure>



<h4 id="mysql读写锁怎么实现-mysql-读写锁和互斥锁的区别https-blog-51cto-com-u-16099299-7031260"><a href="#mysql读写锁怎么实现-mysql-读写锁和互斥锁的区别https-blog-51cto-com-u-16099299-7031260" class="headerlink" title="mysql读写锁怎么实现 mysql 读写锁和互斥锁的区别	https://blog.51cto.com/u_16099299/7031260"></a>mysql读写锁怎么实现 mysql 读写锁和互斥锁的区别	<a href="https://blog.51cto.com/u_16099299/7031260">https://blog.51cto.com/u_16099299/7031260</a></h4><ul>
<li>请你讲述一下互斥锁机制，以及互斥锁和读写锁的区别<ul>
<li>互斥锁（mutex），用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</li>
<li>读写锁（rwlock），分为读锁和写锁。处于读操作的时候，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其他获得写锁失败的线程将会进入睡眠状态，直到写锁释放时被唤醒。注意;写锁会阻塞其他读写锁。当有一个线程获得写锁在写时，读锁也不能被其他线程获取；写者优于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。<br>读写锁：区分读者和写者，而互斥锁不区分，互斥锁只允许同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。</li>
</ul>
</li>
<li>Linux中的四种锁机制<ul>
<li>互斥锁：在同一时间内只允许一个线程访问对象</li>
<li>读写锁：同一时间内允许多个读者同时读对象，同一时间内只允许一个写者访问对象，且当有一个线程获得写操作的时候，读锁也不能被其他的线程获取，写者优于读者，唤醒时先唤醒写者。</li>
<li>自旋锁：在任何时刻内自能有一个线程访问资源，但是当获取锁操作失败时，不会进入睡眠状态而是会原地自旋，直到锁被释放，这样减少了线程从睡眠状态到被唤醒状态的资源消耗，在加锁时间短暂的情况下使用会提高效率。但是加锁时间过长会非常浪费CPU</li>
<li>RCU（read-copy-update）：在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改，然后在将老数据update成新数据。在RCU的时候读者几乎不需要同步开销，即不需要获取锁，也不适用原子指令，不会导致竞争因此不用考虑死锁问题了。但是对于写者的同步开销比较大，他需要复制被修改的数据，还必须使用锁机制同步并行其他写者的改操作，在有大量读操作，少量写操作的时候使用。</li>
</ul>
</li>
</ul>
<h4 id="delete关键字的作用"><a href="#delete关键字的作用" class="headerlink" title="delete关键字的作用"></a>delete关键字的作用</h4><ol>
<li><p>删除特殊的成员函数：在C++11中可以使用delete来显示的阻止编译器自动生成某些特殊的成员函数。通过在类的声明中将这些特殊函数标记为delete，可以防止这些函数隐式的生成。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() = <span class="keyword">delete</span>; <span class="comment">// 阻止生成默认构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp;) = <span class="keyword">delete</span>; <span class="comment">// 阻止生成拷贝构造函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除特定的函数重载：在函数重载时，可以使用delete关键字来标记某个特定的函数重载，防止特定的重载函数被调用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">(<span class="type">double</span> x)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// 阻止调用带有 double 参数的函数</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="define和const的区别"><a href="#define和const的区别" class="headerlink" title="define和const的区别"></a>define和const的区别</h4><ul>
<li>就起作用的阶段而言：#define是在编译的预处理阶段起作用，而const是在编译、运行时起作用；</li>
<li>就起作用的方式而言：#define只是简单的字符串替换，没有类型检查，而const有类型检查，避免相应的错误；</li>
<li>就存储方式而言：#define只是进行展开，有多少地方使用，就有多少替换。const定义的只读变量在程序运行过程中只有一份备份；</li>
</ul>
<h4 id="写时拷贝（COW）https-www-cnblogs-com-biyeymyhjob-archive-2012-07-20-2601655-html"><a href="#写时拷贝（COW）https-www-cnblogs-com-biyeymyhjob-archive-2012-07-20-2601655-html" class="headerlink" title="写时拷贝（COW）	https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html"></a>写时拷贝（COW）	<a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html">https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html</a></h4><p>在linux里，fork（）会产生一个子进程，子进程与父进程用的是相同的物理空间，也就是说两者的虚拟空间不同，但对应的物理空间是一个。当父&#x2F;子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。这里的相应段你能理解不？其实就是一个程序一般分为哪些段，主要可以分为四大段：栈、堆、数据段、代码段；再细分的话可以加一个bss段，也就是用于存放程序中未初始化的全局变量的一块内存区域。</p>
<p>还有一个细节问题就是，fork之后内核会将子进程放在队列的前面，以让子进程先执行，以免父进程执行导致写时复制，造成不必要的复制，导致效率的下降。可以这么理解，可能子进程执行的代码并不需要写，完全可以使用原共享段，而父进程反而会改变（fork之后），如果父进程先执行，则子进程就要COW。</p>
<h4 id="coredump，gdb怎么定位"><a href="#coredump，gdb怎么定位" class="headerlink" title="coredump，gdb怎么定位"></a>coredump，gdb怎么定位</h4><p>整体流程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -g source.cpp -o <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./source</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb ./source ./core</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">where(在gdb下输入)</span><br></pre></td></tr></table></figure>



<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><code>epoll</code></h4><p>关于<code>epoll</code>问题在这暂且不多写，只需记住内核事件表，<code>select</code>和<code>poll</code>都是轮询，事件复杂度：<code>epoll（o1）</code>，其他<code>（on）</code>。</p>
<p><code>select</code>和<code>poll</code>必须遍历内核事件表上所有已注册的文件描述符以找到其中的就绪者；<code>epoll</code>仅遍历就绪的文件描述符。</p>
<h4 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用"></a>static的作用</h4><ol>
<li><p>在函数体内，被声明为静态的变量在这一函数被调用过程中维持其值不变。</p>
<p>这句话其实是想说如果在函数内部声明了一个静态变量，那么这个变量在函数调用期间不会被重新初始化。它的生命周期是从程序开始到程序结束，但其作用域仍然限制在该函数内。这里给一段示例代码最好理解：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    num++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num is: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">count</span>();	<span class="comment">// num = 1</span></span><br><span class="line">    <span class="built_in">count</span>();	<span class="comment">// num = 2 正常情况下，如果是非static，num会被重新置0，但这里并没有体现出来。</span></span><br><span class="line">    <span class="built_in">count</span>();	<span class="comment">// num = 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其他函数访问。它是一个本地的全局变量。</p>
<p>这句话就是表面意思，很好理解，这里给一个代码帮助理解</p>
<p><strong>moduleA.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> secretValue = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSecretValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; secretValue &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifySecretValue</span><span class="params">(<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">    secretValue = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>moudleB.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">printSecretValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">modifySecretValue</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printSecretValue</span>();</span><br><span class="line">    <span class="built_in">modifySecretValue</span>(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; secretValue &lt;&lt; std::endl; </span></span><br><span class="line">    <span class="comment">// 记住，这句话是会导致编译错误的，模块B不能直接访问模块A的变量。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在模块内，一个被声明为静态的函数只可被本模块内的其他函数调用。也就是，这个函数被限制在声明它的模块的本地范围内使用。</p>
<p>这里的意思其实就和第二点差不多了，也给一个简单示例代码吧</p>
<p><strong>moduleA.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个静态函数，只在moduleA.cpp中可见</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">secretFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside secret function of moduleA!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公开的函数，可以被其他模块调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">publicFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside public function of moduleA.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">secretFunction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>moduleB.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">publicFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">publicFunction</span>();  <span class="comment">// 可以调用这个函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能调用 secretFunction，因为它在moduleA.cpp中是静态的</span></span><br><span class="line">    <span class="comment">// secretFunction();  // 这一行会导致编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>moduleA.cpp</code>定义了一个静态函数<code>secretFunction</code>。在<code>moduleB.cpp</code>中，我们可以调用<code>publicFunction</code>，但当我们尝试调用<code>secretFunction</code>时，会导致编译错误，因为<code>secretFunction</code>只在<code>moduleA.cpp</code>中可见。</p>
</li>
</ol>
<h4 id="有关static的必要补充"><a href="#有关static的必要补充" class="headerlink" title="有关static的必要补充"></a>有关static的必要补充</h4><ul>
<li><p>修饰成员变量</p>
<p>用static修饰类的数据成员，使其成为类的全局变量，会被类的所有对象共享，包括派生类对象。<strong>所有对象只维持同一个实例。</strong>因此类的static成员必须进行类外初始化，而不能在构造函数内进行初始化，不过也可以用const修饰static数据成员在类内初始化。因为const修饰的变量无法修改。</p>
</li>
<li><p>修饰成员函数</p>
<p>用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针，因而只能访问static成员变量。<strong>注意</strong>：正是因为static修饰的成员函数不含this指针，而const修饰的成员函数会添加一个隐藏的参数const this*，所以这两种语义是矛盾的，所以在成员函数上不能同时用他们。</p>
</li>
<li><p>this指针理解</p>
<p>对象就是大房子，成员就是房子里的物件，this是一个指着房子的指针，如果要获取对象的成员也就是大房子内的物件，需要使用this指针加-&gt;这个符号。</p>
</li>
</ul>
<h4 id="三种智能指针"><a href="#三种智能指针" class="headerlink" title="三种智能指针"></a>三种智能指针</h4><p>智能指针是在栈中的一个类，用于管理堆上分配的内存。传统的C&#x2F;C++对于堆上内存的开辟释放，需要程序手动管理，而智能指针是一个类，有构造函数和析构函数，在超出作用范围后，程序会自动调用析构函数释放其管理的指针指向的内存，不需要手动释放。</p>
<ul>
<li>shared_ptr	共享智能指针，多个智能指针可以指向同一个对象，对象的资源在最后一个指针销毁时释放，通过引用计数来判断是否是最后一个智能指针。</li>
<li>unique_ptr	独占智能指针，同一时刻只有一个智能指针可以指向该对象，如果要安全重用该指针，标准库函数std::move()可以将unique_ptr赋值给另一个unique_ptr。</li>
<li>weak_ptr      弱智能指针，不会增加shared_ptr的引用计数，可以避免两个shared_ptr相互引用的死锁问题。weak_ptr只能用shared_ptr或者另一个weak_ptr构造，通过lock()方法weak_ptr可以转化为shared_ptr。</li>
</ul>
<p>下面给出代码示例</p>
<p><strong>unique_ptr</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string str;</span><br><span class="line">    ~<span class="built_in">test</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;test::~test()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> test())</span></span>;</span><br><span class="line">    p1-&gt;str = <span class="string">&quot;test string&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1-&gt;str: &quot;</span> &lt;&lt; p1-&gt;str &lt;&lt; std::endl;</span><br><span class="line">    std::unique_ptr&lt;test&gt; p2;</span><br><span class="line">    p2 = std::<span class="built_in">move</span>(p1);</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; p1-&gt;str &lt;&lt; std::endl; p1此时已经访问不到资源了</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p2-&gt;str: &quot;</span> &lt;&lt; p2-&gt;str &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// p1-&gt;str: test string</span></span><br><span class="line"><span class="comment">// p2-&gt;str: test string</span></span><br><span class="line"><span class="comment">// test::~test() 析构函数发生了调用，自动释放资源</span></span><br></pre></td></tr></table></figure>

<p><strong>shared_ptr</strong>造成的死锁问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; a;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;A&gt; b;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::~B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*******前边两个类中相互引用，此时引入weak_ptr解决死锁问题*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    p1-&gt;a = p2;</span><br><span class="line">    p2-&gt;b = p1;<span class="comment">//这种情况发生死锁,两个shared_ptr计数都不会为0，资源不会被释放</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count():&quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count():&quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体解释一下死锁的产生主要原因是引用计数无法降为0。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">首先，来理解下为什么这种情况会导致资源不能被释放：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 当你创建`p1`和`p2`时，它们都有一个引用计数为1。</span></span><br><span class="line"><span class="comment">2. 当执行`p1-&gt;a = p2;`，`p2`的引用计数增加到2，因为现在有两个`shared_ptr`对象（`p1-&gt;a`和`p2`）指向同一个`B`对象。</span></span><br><span class="line"><span class="comment">3. 当执行`p2-&gt;b = p1;`，`p1`的引用计数增加到2，因为现在有两个`shared_ptr`对象（`p2-&gt;b`和`p1`）指向同一个`A`对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">到此，我们得到了一个环状结构：`p1`指向`A`对象，`A`对象内部的`shared_ptr`指向`B`对象，`B`对象内部的`shared_ptr`又指向`A`对象。这就形成了循环引用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当`main`函数返回时，`p1`和`p2`的析构函数将被调用，但是它们的引用计数都不会降为0，因为循环引用。所以，`A`和`B`对象的析构函数永远不会被调用，这就导致了资源泄漏。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">要解决这个问题，可以使用`weak_ptr`来打破循环引用。你可以将其中一个类的`shared_ptr`成员变量替换为`weak_ptr`。这样，`weak_ptr`不会增加引用计数，从而避免了循环引用的问题。当你需要从`weak_ptr`获取一个`shared_ptr`时，可以使用`lock`方法。</span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></figure>

<p><strong>weak_prt</strong>解决循环引用问题</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; a;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    weak_ptr&lt;A&gt; b;  <span class="comment">// 将 shared_ptr 替换为 weak_ptr</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::~B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line">    p1-&gt;a = p2;</span><br><span class="line">    p2-&gt;b = p1;  <span class="comment">// 这里不会增加 p1 的引用计数</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 use_count(): &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 输出 1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2 use_count(): &quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 当 main 返回时，p1 和 p2 都会被析构，它们所指向的对象也会被正确地销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="STL内存池机制"><a href="#STL内存池机制" class="headerlink" title="STL内存池机制"></a>STL内存池机制</h4><ul>
<li><p>第一级配置器</p>
<p>第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。</p>
</li>
<li><p>第二级配置器</p>
<p>在STL的第二级配置器中多了一些机制，避免太多小区造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。</p>
<p>如果要分配的区块大于128bytes，则移交给第一级配置器处理。<br>如果要分配的区块小于128bytes，则以 内存池管理（memory pool），又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。</p>
<p>参考连接：<a href="https://blog.csdn.net/a987073381/article/details/52245795">https://blog.csdn.net/a987073381/article/details/52245795</a></p>
</li>
</ul>
<h4 id="索引选B-树的原因"><a href="#索引选B-树的原因" class="headerlink" title="索引选B+树的原因"></a>索引选B+树的原因</h4><p>个人感觉主要就是探讨B+树和B树之间的区别。<br>参考链接：<a href="https://www.cnblogs.com/JCpeng/p/15231338.html">https://www.cnblogs.com/JCpeng/p/15231338.html</a></p>
<h4 id="服务端TIME-WAIT过多的危害及解决办法"><a href="#服务端TIME-WAIT过多的危害及解决办法" class="headerlink" title="服务端TIME_WAIT过多的危害及解决办法"></a>服务端TIME_WAIT过多的危害及解决办法</h4><p>危害</p>
<ul>
<li>导致大量socket连接端口被占用无法释放，导致系统停转</li>
<li>处理大量的TIME_WAIT状态的连接会占用更多的CPU时间，导致服务器响应时间增加</li>
</ul>
<p>解决办法</p>
<ul>
<li>调整系统内核参数</li>
<li>调整短连接为长连接</li>
</ul>
<h4 id="set底层数据结构"><a href="#set底层数据结构" class="headerlink" title="set底层数据结构"></a>set底层数据结构</h4><p>set底层数据结构是红黑树。关于map和set的一些问题列举如下：</p>
<p><strong>为何map和set的插入删除效率比用其他序列容器高？</strong><br>因为对于关联容器来说，不需要做内存拷贝和内存移动。因为map和set容器内部所有元素都是以节点的方式来存储，父节点和子节点。因此插入和删除的时候都是指针的指向换来换去，并没有内存移动。</p>
<p><strong>为何每次插入&#x2F;删除后以前保存的迭代器不会失效</strong><br>在这里，迭代器就相当于指向节点的指针，内存没有变，指向内存的指针当然不会失效。不同于map&#x2F;set，vector就会失效，比如需要扩容的时候，需要一块更大的内存，就必须把之前的内存释放，申请更大的内存，复制已有的数据元素到新的内存。</p>
<p><strong>为何map和set不能像vector一样有个reserve函数来预分配数据</strong><br>不懂！预留本问题</p>
<p><strong>当数据元素增多时（10000到20000个比较），map和set的插入和搜索速度变化如何？</strong><br>map和set使用的是二分查找，举例来说就是，16个元素查四次，32个元素查5次，10000个也就是14次，20000也就15次。</p>
<h4 id="mapreduce原理（不懂，预留）"><a href="#mapreduce原理（不懂，预留）" class="headerlink" title="mapreduce原理（不懂，预留）"></a>mapreduce原理（不懂，预留）</h4><h4 id="socket哪些操作会产生阻塞"><a href="#socket哪些操作会产生阻塞" class="headerlink" title="socket哪些操作会产生阻塞"></a>socket哪些操作会产生阻塞</h4><p>accept()：在等待客户端的连接请求时会阻塞。如果没有客户端尝试连接，调用这个函数的进程或者线程会被挂起。</p>
<p>connect()：当客户端尝试与远程主机建立连接时，此操作会阻塞，知道连接成功或失败</p>
<p>recv()：当数据从网络到达时，如果没有数据可读，函数调用就会被挂起，阻塞</p>
<p>send()：当发送缓冲区已满，并且无法接受更多数据发送到网络时，操作阻塞。</p>
<h4 id="申请一块大内存和一块小内存的效率是一样的吗？"><a href="#申请一块大内存和一块小内存的效率是一样的吗？" class="headerlink" title="申请一块大内存和一块小内存的效率是一样的吗？"></a>申请一块大内存和一块小内存的效率是一样的吗？</h4><p>不一样，申请一块小内存通常是不需要一级配置器，小块内存通常由内存分配器从预先分配的内存池中分配，这些池被称为<code>bins</code>，这种分配通常非常快，因为它只是涉及到从已存在的内存池中返回一个指针。大的内存通常要调用<code>mmap()</code>。</p>
<h4 id="TCP慢启动和拥塞控制"><a href="#TCP慢启动和拥塞控制" class="headerlink" title="TCP慢启动和拥塞控制"></a>TCP慢启动和拥塞控制</h4><p>TCP连接建立好之后，CWND（congestion window，拥塞窗口）被设置为初始值IW（initial window），其大小为2~4个SMSS（TCP报文段的最大长度，仅指数据部分），新的linux内核加大了这个值。此时发送端最多能发送IW字节的数据，此后发送端每收到一个确认，CWND就按照如下公式增长：<br>$$<br>CWND +&#x3D; min(N, SMSS)<br>$$<br>其中N是此次确认中包含的之前未被确认的字节数。<br>如果不施加其他手段，慢启动必然使得CWND增长的很快，所以TCP拥塞控制中有另外一个非常重要的变量：慢启动门限。当CWND超过慢启动门限值时，TCP将进入拥塞避免阶段。</p>
<h4 id="发送端判断发生拥塞的依据"><a href="#发送端判断发生拥塞的依据" class="headerlink" title="发送端判断发生拥塞的依据"></a>发送端判断发生拥塞的依据</h4><ul>
<li>传输超时</li>
<li>接收到重复的确认报文段</li>
</ul>
<h4 id="Linux下的POSIX互斥锁和条件变量"><a href="#Linux下的POSIX互斥锁和条件变量" class="headerlink" title="Linux下的POSIX互斥锁和条件变量"></a>Linux下的POSIX互斥锁和条件变量</h4><p>牢记这几个函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">pthread_mutex_destory(&amp;mutex);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">pthread_mutex_trylock(&amp;mutex);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pthread_cond_init(&amp;cond, NULL);</span><br><span class="line">pthread_cond_destory(&amp;cond);</span><br><span class="line">pthread_cond_broadcast(&amp;cond);</span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);</span><br></pre></td></tr></table></figure>

<p>条件变量要配合互斥锁使用。这里挂一个讲的比较清晰明了的博客链接（<a href="https://punmy.cn/2018/06/07/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condition%20Variables%EF%BC%89.html%EF%BC%89%EF%BC%8C%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E5%8A%A0%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B">https://punmy.cn/2018/06/07/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condition%20Variables%EF%BC%89.html），下面是使用互斥锁加条件变量实现的生产者-消费者模型</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mutex_;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span> condition_;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_t</span> notifying_thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;condition_, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;condition_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span> *args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">    <span class="keyword">while</span>(value != <span class="number">10</span>)&#123;</span><br><span class="line">        value++;</span><br><span class="line">    &#125;</span><br><span class="line">    notifying_thread = <span class="built_in">pthread_self</span>();</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;condition_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">    <span class="keyword">while</span>(value != <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;condition_, &amp;mutex_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value is 10, the pthread is: %lu\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)notifying_thread);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">consumer</span><span class="params">(<span class="type">void</span> *args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">waitCondition</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> a1;</span><br><span class="line">    <span class="type">pthread_t</span> a2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;a1, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;a2, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(a1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(a2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">destory</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="写一个生产者-x2F-消费者模型（采用信号量）"><a href="#写一个生产者-x2F-消费者模型（采用信号量）" class="headerlink" title="写一个生产者&#x2F;消费者模型（采用信号量）"></a>写一个生产者&#x2F;消费者模型（采用信号量）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_BUFFERS = <span class="number">10</span>;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> empty;</span><br><span class="line"><span class="type">sem_t</span> full;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        num = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;empty);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">        buffer.<span class="built_in">push</span>(num);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">comsumer</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;full);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">        num = buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Comsumed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> proThread, comPthread;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;empty, <span class="number">0</span>, MAX_BUFFERS);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;full, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;proThread, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;comPthread, <span class="literal">NULL</span>, comsumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(proThread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(comPthread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;empty);</span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;full);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="基类的析构函数为什么是虚函数"><a href="#基类的析构函数为什么是虚函数" class="headerlink" title="基类的析构函数为什么是虚函数"></a>基类的析构函数为什么是虚函数</h4><p>当基类的析构函数不是虚函数可能会导致派生类对象的析构函数不被调用。从而引发资源泄露或者其他未定义行为。下面给出示例代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base obj is constructed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="comment">// ~Base() &#123; std::cout &lt;&lt; &quot;Base obj is deconstructed&quot; &lt;&lt; std::endl; &#125;</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base obj is deconstructed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()&#123;</span><br><span class="line">        num_ = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived is constructed&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Derived</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived is deconstructed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *num_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base *base = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）"><a href="#为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）" class="headerlink" title="为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）"></a>为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）</h4><p>当一个基类没有虚析构函数，并且通过基类指针删除一个派生类对象时，只有基类的析构函数会被调用。这是因为编译器在编译时期决定了调用哪个析构函数，而不是在运行时期，这种机制被称为“静态绑定”。</p>
<p>如果基类的析构函数是虚函数，那么编译器会在运行时决定要调用哪个析构函数，这种机制称为“动态绑定”或“多态”。</p>
<h4 id="拷贝构造函数为什么要用引用"><a href="#拷贝构造函数为什么要用引用" class="headerlink" title="拷贝构造函数为什么要用引用"></a>拷贝构造函数为什么要用引用</h4><p>避免拷贝构造函数无限递归下去！那传引用为什么行呢？回忆一下引用定义，传引用人家根本就不会涉及到构造函数这玩意，形参相当于实参的一个别名。</p>
<h4 id="左右值的差别"><a href="#左右值的差别" class="headerlink" title="左右值的差别"></a>左右值的差别</h4><h4 id="C-中的虚继承"><a href="#C-中的虚继承" class="headerlink" title="C++中的虚继承"></a>C++中的虚继承</h4><p>c++中的虚继承主要是为了解决多继承情况中存在的二义性问题。比如，现在类A为基类，类B和类C继承自类A，类D继承自类B和类C，假设此时A中有一个名为x的变量且B和C都定义了x，如果此时D直接访问x会产生二义性问题。因为不清楚是A-&gt;B-&gt;D还是A-&gt;C-&gt;D。此时如果让类B和类C虚继承自A，就使得在派生类中只保留有一份成员变量x，解决了二义性问题。<br>参考链接：<br><a href="http://c.biancheng.net/view/2280.html">http://c.biancheng.net/view/2280.html</a><br><a href="https://zhuanlan.zhihu.com/p/41309205%EF%BC%88%E8%99%9A%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E9%83%BD%E8%AE%B2%E4%BA%86%EF%BC%8C%E5%8D%81%E5%88%86%E8%AF%A6%E7%BB%86%EF%BC%89">https://zhuanlan.zhihu.com/p/41309205（虚继承、虚函数都讲了，十分详细）</a></p>
<h4 id="C-中的forward函数"><a href="#C-中的forward函数" class="headerlink" title="C++中的forward函数"></a>C++中的forward函数</h4><p>左值引用和右值引用的结果都是左值，无法通过引用区分原本变量的左右值，forward可以保持变量的原本的左右值属性，帮助我们区分。</p>
<h4 id="如何判断TCP断开"><a href="#如何判断TCP断开" class="headerlink" title="如何判断TCP断开"></a>如何判断TCP断开</h4><ol>
<li>发送心跳消息</li>
<li>利用recv&#x2F;send函数的返回值<ul>
<li>recv返回0代表对方关闭了连接</li>
<li>recv返回-1并且errno&#x3D;&#x3D;EAGAIN或者EWOULDBLOCK时，表示没有数据可读，可以稍后再试。</li>
<li><strong>send返回非负值</strong>:<ul>
<li><code>send</code>返回的是实际发送的字节数，这可能会少于你请求发送的字节数（缓冲区已满）。</li>
<li>如果没有可用的缓冲区空间，那么在非阻塞模式下，<code>send</code>可能会返回<code>EAGAIN</code>或<code>EWOULDBLOCK</code>。</li>
</ul>
</li>
<li><strong>send返回-1</strong>:<ul>
<li>与<code>recv</code>类似，这表示出现了错误。</li>
<li>可以使用<code>perror</code>、<code>strerror</code>或检查<code>errno</code>来确定具体的错误原因。</li>
<li>常见的错误原因包括<code>EPIPE</code>（对端已关闭，本端仍尝试发送数据导致的”Broken pipe”错误）和<code>ECONNRESET</code>（连接被对端重置）。</li>
</ul>
</li>
</ul>
</li>
<li>利用tcp自带的keepalive机制</li>
</ol>
<h4 id="如何查看系统的最大进程数和线程数"><a href="#如何查看系统的最大进程数和线程数" class="headerlink" title="如何查看系统的最大进程数和线程数"></a>如何查看系统的最大进程数和线程数</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/kernel/pid_max    # 最大进程数</span><br><span class="line">cat /proc/sys/kernel/threads-max	# 最大线程数</span><br></pre></td></tr></table></figure>



<h4 id="git-rebase和git-merge的区别（https-joyohub-com-2020-04-06-git-rebase-）"><a href="#git-rebase和git-merge的区别（https-joyohub-com-2020-04-06-git-rebase-）" class="headerlink" title="git rebase和git merge的区别（https://joyohub.com/2020/04/06/git-rebase/）"></a>git rebase和git merge的区别（<a href="https://joyohub.com/2020/04/06/git-rebase/%EF%BC%89">https://joyohub.com/2020/04/06/git-rebase/）</a></h4><h4 id="C-calss-和-struct的区别"><a href="#C-calss-和-struct的区别" class="headerlink" title="C++ calss 和 struct的区别"></a>C++ calss 和 struct的区别</h4><p>class默认访问类型是private，struct默认访问类型是public</p>
<h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><ol>
<li>指针是一个变量，它保存了另一个变量的内存地址；引用是另一个变量的别名，与原变量共享内存地址。</li>
<li>指针可以被重新赋值，指向新的对象；引用绑定对象后不能更改。</li>
<li>指针可以为nullptr；引用必须初始化。</li>
</ol>
<h4 id="为什么模板类的声明和实现不能分别写在-h文件和-cpp文件中"><a href="#为什么模板类的声明和实现不能分别写在-h文件和-cpp文件中" class="headerlink" title="为什么模板类的声明和实现不能分别写在.h文件和.cpp文件中"></a>为什么模板类的声明和实现不能分别写在.h文件和.cpp文件中</h4><p>首先，模板不是传统意义上的代码。它更像是编译器的“代码生成工具”。当你使用一个特定的模板类型（例如<code>std::vector&lt;int&gt;</code>)，<strong>编译器会为你生成这种类型的实例代码</strong>。为了做到这一点，编译器需要能够看到模板的完整定义。注意：这就是模板和普通类的最大区别。普通类在编译阶段并没有（并不依赖于）编译时的类型特化，只需要在链接阶段将所有.cpp文件链接在一起就好了。而如果模板分开写，其他使用模板的.cpp文件在编译时找不到定义，导致链接错误。</p>
<h4 id="动态链接与静态链接"><a href="#动态链接与静态链接" class="headerlink" title="动态链接与静态链接"></a>动态链接与静态链接</h4><p>静态链接（.a&#x2F;.lib）：把要调用的函数或者过程链接到可执行文件中，成为可执行文件的一部分。如果多个程序使用相同的库，那么该库的代码在每个程序中都会被复制，这浪费了磁盘和内存空间。但是所有代码都在可执行文件中，没有运行时链接开销。</p>
<p>动态链接（.so&#x2F;.ddl）：动态链接所调用的函数代码并没有被拷贝到应用程序的可执行文件中去，而是仅仅在其中加入了所调用函数的描述信息（往往是一些重定位信息）。仅当应用程序被装入内存开始运行时，在Windows的管理下，才在应用程序与相应的DLL之间建立链接关系。当要执行所调用DLL中的函数时，根据链接产生的重定位信息，Windows才转去执行DLL中相应的函数代码。多份代码可以共享同一份库代码。</p>
<h4 id="pragma-pack编译宏"><a href="#pragma-pack编译宏" class="headerlink" title="pragma pack编译宏"></a>pragma pack编译宏</h4><p>pragma pack用于指定内存对齐值。</p>
<h4 id="vector底层实现原理"><a href="#vector底层实现原理" class="headerlink" title="vector底层实现原理"></a>vector底层实现原理</h4><p>理解vector的实现主要考虑四个东西就好了：三个指针加动态内存申请。</p>
<p>三个指针：</p>
<ul>
<li>first_：指向vector容器对象起始地址的位置</li>
<li>last_：指向vector容器对象中当前最后一个元素的末尾字节</li>
<li>end_：指向vector容器所占内存空间的最后一个字节</li>
</ul>
<p><img src="png1.gif"></p>
<p>动态内存申请：</p>
<p>当 vector 的大小和容量相等（size&#x3D;&#x3D;capacity）也就是满载时，如果再向其添加元素，那么 vector 就需要扩容。vector 容器扩容的过程需要经历以下 3 步：</p>
<ol>
<li>完全弃用现有的内存空间，重新申请更大的内存空间；</li>
<li>将旧内存空间中的数据，按原有顺序移动到新的内存空间中；</li>
<li>最后将旧的内存空间释放。</li>
</ol>
<h4 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h4><p>常量指针：记忆方法（常量的指针），指针指向的对象是一个常量，只能读取指针指向的内容，不能修改指针指向的内容。</p>
<p>指针常量：指针本身是一个常量，不能修改指针指向的地址，可以修改指针指向地址的内容。</p>
<h4 id="C-中一些特别的关键字（default，override、final、volatile）"><a href="#C-中一些特别的关键字（default，override、final、volatile）" class="headerlink" title="C++中一些特别的关键字（default，override、final、volatile）"></a>C++中一些特别的关键字（default，override、final、volatile）</h4><p>参考链接：<a href="https://blog.csdn.net/u011947630/article/details/103062773">https://blog.csdn.net/u011947630/article/details/103062773</a></p>
<h4 id="字节算法题：小于N的最大数"><a href="#字节算法题：小于N的最大数" class="headerlink" title="字节算法题：小于N的最大数"></a>字节算法题：小于N的最大数</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> value = <span class="number">14132</span>;</span><br><span class="line">string valueStr = <span class="built_in">to_string</span>(value);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index, <span class="type">bool</span> judge, <span class="type">int</span> temp)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(index == valueStr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ans = temp;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(judge) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">true</span>, temp * <span class="number">10</span> + (nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>]));    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> val = valueStr[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val == nums[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">false</span>, temp * <span class="number">10</span> + nums[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; nums[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">true</span>, temp * <span class="number">10</span> + nums[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最终结果为空</span></span><br><span class="line">        <span class="keyword">if</span>(index != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//少了一位，显然小了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">true</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="如果同时有大量客户并发建立连接，服务器端有什么机制进行处理"><a href="#如果同时有大量客户并发建立连接，服务器端有什么机制进行处理" class="headerlink" title="如果同时有大量客户并发建立连接，服务器端有什么机制进行处理"></a>如果同时有大量客户并发建立连接，服务器端有什么机制进行处理</h4><ol>
<li>多进程和多线程</li>
<li>连接池</li>
<li>异步I&#x2F;O</li>
<li>负载均衡</li>
<li>限流</li>
<li>短连接与长连接</li>
</ol>
<h4 id="HTTP和TCP之间的关系"><a href="#HTTP和TCP之间的关系" class="headerlink" title="HTTP和TCP之间的关系"></a>HTTP和TCP之间的关系</h4><ol>
<li><p>HTTP是一个应用层协议，TCP是一个传输层协议</p>
</li>
<li><p>HTTP依赖于TCP来进行数据的传输。比如，当你使用浏览器访问一个网页时，背后发生的是HTTP请求和响应的交换，而这些HTTP数据包是通过TCP连接发送的。</p>
</li>
<li><p>HTTP&#x2F;1.0对于每一个请求-响应都会新建一个TCP连接，使用完之后就关闭</p>
<p>HTPP&#x2F;1.1引入了keep-alive机制，允许在单个TCP连接上发送多个HTTP请求和响应</p>
<p>HTTP&#x2F;2进一步扩展了这种机制，允许在单个TCP连接上同时多路复用多个HTTP请求和响应</p>
</li>
</ol>
<h4 id="HTTP从请求到得到结果的过程"><a href="#HTTP从请求到得到结果的过程" class="headerlink" title="HTTP从请求到得到结果的过程"></a>HTTP从请求到得到结果的过程</h4><ol>
<li><p><strong>域名解析</strong>：</p>
<ul>
<li>客户端（通常是浏览器）首先检查URL是否包含域名（例如 <code>www.example.com</code>）。</li>
<li>如果包含，客户端首先会查找其DNS缓存是否已经有该域名的IP地址。</li>
<li>如果没有，客户端会发起一个DNS查询到配置的DNS服务器，以获取对应的IP地址。</li>
</ul>
</li>
<li><p><strong>建立TCP连接</strong>：</p>
<ul>
<li>使用从DNS查询得到的IP地址，客户端尝试与服务器的80端口（HTTP）或443端口（HTTPS）建立一个TCP连接。</li>
<li>这涉及到TCP三次握手过程。</li>
</ul>
</li>
<li><p><strong>（HTTPS的情况）SSL&#x2F;TLS握手</strong>：</p>
<ul>
<li>如果是HTTPS请求，一旦TCP连接建立，客户端和服务器会进行SSL&#x2F;TLS握手来建立加密的通信通道。</li>
</ul>
</li>
<li><p><strong>发送HTTP请求</strong>：</p>
<ul>
<li>连接建立后，客户端会发送HTTP请求报文。这包括请求行（例如 <code>GET /path HTTP/1.1</code>）、请求头和（对于某些请求如POST）请求体。</li>
</ul>
</li>
<li><p><strong>服务器处理请求</strong>：</p>
<ul>
<li>服务器接收到请求后，由其HTTP服务软件（如Apache、Nginx等）处理。</li>
<li>服务器可能会根据请求路径查询文件、与数据库交互或调用其他服务，以生成响应。</li>
</ul>
</li>
<li><p><strong>服务器发送响应</strong>：</p>
<ul>
<li>服务器生成响应后，它将响应报文发送回客户端。响应通常包括状态行（例如 <code>HTTP/1.1 200 OK</code>）、响应头和响应体。</li>
<li>对于动态内容，如由PHP、Python或Node.js等后端语言生成的页面，服务器可能会进行一些额外的处理来生成响应内容。</li>
</ul>
</li>
<li><p><strong>客户端处理响应</strong>：</p>
<ul>
<li>客户端（如浏览器）接收响应，并基于响应内容采取相应的行动。</li>
<li>如果响应是一个HTML页面，浏览器会开始解析HTML，并可能发起其他请求来获取页面上的资源，如图片、CSS、JavaScript文件等。</li>
</ul>
</li>
<li><p><strong>关闭连接</strong>：</p>
<ul>
<li>一旦数据交换完成，通常会关闭TCP连接。然而，在HTTP&#x2F;1.1中，默认使用<code>keep-alive</code>，意味着连接可以被复用，从而减少后续请求的延迟。</li>
</ul>
</li>
</ol>
<h4 id="https和http的区别是什么，https具体是怎么做的"><a href="#https和http的区别是什么，https具体是怎么做的" class="headerlink" title="https和http的区别是什么，https具体是怎么做的"></a>https和http的区别是什么，https具体是怎么做的</h4><p>HTTPS和HTTP唯一的区别就是HTTPS使用TLS&#x2F;SSL来加密普通的HTTP请求和响应。</p>
<p>关于https具体是如何做的，这里有一个参考博文链接，写的超好（参考链接：<a href="https://www.runoob.com/w3cnote/http-vs-https.html%EF%BC%89">https://www.runoob.com/w3cnote/http-vs-https.html）</a></p>
<h4 id="gdb中，如何查看每个线程相关的信息"><a href="#gdb中，如何查看每个线程相关的信息" class="headerlink" title="gdb中，如何查看每个线程相关的信息"></a>gdb中，如何查看每个线程相关的信息</h4><p>在 gdb 中，可以使用 <code>info threads</code> 命令查看当前进程中的所有线程信息。这个命令会列出每个线程的编号、状态（如运行、挂起等）以及当前所在的函数名称。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) info threads</span><br><span class="line">  Id   Target Id         Frame </span><br><span class="line">  2    Thread 0x7ffff7fc8700 (LWP 13627) <span class="string">&quot;main&quot;</span> __libc_start_main (argc=1, argv=0x7fffffffe4c8, <span class="built_in">env</span>=0x7fffffffe4d8,</span><br><span class="line">      auxvec=0x7fffffffe4d8, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffe4c8) at ../csu/libc-start.c:310</span><br><span class="line">  3    Thread 0x7ffff77c7700 (LWP 13628) <span class="string">&quot;main&quot;</span> foo () at test.c:6</span><br><span class="line">  4    Thread 0x7ffff6fc6700 (LWP 13629) <span class="string">&quot;main&quot;</span> bar () at test.c:11</span><br></pre></td></tr></table></figure>

<p>你还可以使用 <code>thread &lt;thread-id&gt;</code> 命令来切换到指定的线程，然后使用其他 gdb 命令来查看线程的信息或调试线程。</p>
<p>例如，你可以输入 <code>thread 3</code> 命令切换到编号为 3 的线程，然后输入 <code>bt</code> 命令来查看线程的调用堆栈：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) thread 3</span><br><span class="line">[Switching to thread 3 (Thread 0x7ffff77c7700 (LWP 13628))]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  foo () at test.c:6</span></span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  foo () at test.c:6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00007ffff7bbb830 <span class="keyword">in</span> start_thread (arg=&lt;optimized out&gt;) at pthread_create.c:486</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007ffff78f95fd <span class="keyword">in</span> <span class="built_in">clone</span> () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span></span><br></pre></td></tr></table></figure>



<h4 id="构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因"><a href="#构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因" class="headerlink" title="构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因"></a>构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因</h4><p>构造函数从语法上调用虚函数没有任何问题，但这样做可能并不会达到预期的结果。因为在构造函数执行期间，对象的虚表仍在被设置，因此调用的虚函数版本可能并不是我们想要的版本。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base construct\n&quot;</span>;</span><br><span class="line">        <span class="built_in">call</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base call\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived construct\n&quot;</span>;</span><br><span class="line">        <span class="built_in">call</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived call\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这段程序，可能我们期望得到的结果是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Derived call</span><br><span class="line">Derived constructor</span><br><span class="line">Derived call</span><br></pre></td></tr></table></figure>

<p>但我们实际得到的结果是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Base call</span><br><span class="line">Derived constructor</span><br><span class="line">Derived call</span><br></pre></td></tr></table></figure>

<p>原因是在Base构造函数执行时，Derived部分的对象还没有完全构造出来，因此，此时vtable仍然指向Base类的vtable。因此，当在Base构造函数中调用call虚函数时，他会调用Base版本，而不是Derived版本。</p>
<p><strong>这里延伸一下不要在析构函数中调用虚函数的原因</strong>：析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经“销毁”，这个时再调用子类的虚函数已经没有意义了。</p>
<h4 id="迭代器的实现"><a href="#迭代器的实现" class="headerlink" title="迭代器的实现"></a>迭代器的实现</h4><p>参考链接：<a href="https://www.cnblogs.com/wengle520/p/12492708.html">https://www.cnblogs.com/wengle520/p/12492708.html</a></p>
<h4 id="epoll红黑树的作用"><a href="#epoll红黑树的作用" class="headerlink" title="epoll红黑树的作用"></a>epoll红黑树的作用</h4><p>简单点讲就是在内核事件表上快速注册&#x2F;删除所需连接文件描述符。下面两篇文章基本阐述了这个问题，好好看！</p>
<p><a href="https://cloud.tencent.com/developer/article/1862671">https://cloud.tencent.com/developer/article/1862671</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/366955699">https://zhuanlan.zhihu.com/p/366955699</a></p>
<h4 id="用户态和内核态分别会做什么，怎么切换的"><a href="#用户态和内核态分别会做什么，怎么切换的" class="headerlink" title="用户态和内核态分别会做什么，怎么切换的"></a>用户态和内核态分别会做什么，怎么切换的</h4><p>内核空间主要负责操作系统内核线程以及用户程序系统调用。</p>
<p>用户空间主要负责用户程序的非系统调用。</p>
<p>从用户态切换到内核态主要有三种方式：</p>
<ol>
<li>系统调用：系统调用本身就是中断，但是<strong>软件中断</strong>，跟硬中断不同。系统调用机制是使用了操作系统为用户特别开放的一个中断来实现，如 Linux 的 int 80h 中断。</li>
<li>异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，会触发由当前运行进程切换到处理此异常的内核相关进程中</li>
<li>外围设备中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序。</li>
</ol>
<p>有一个面试问题：I&#x2F;O频繁发生内核态和用户态切换，怎么解决？</p>
<p>答案：使用用户进程缓冲区。</p>
<p>用户进程缓冲区</p>
<p>你看一些程序在读取文件时，会先申请一块内存数组，称为buffer，然后每次调用read，读取设定字节长度的数据，写入buffer。之后的程序都是从buffer中获取数据，当buffer使用完后，在进行下一次调用，填充buffer。所以说：用户缓冲区的目的就是是为了减少系统调用次数，从而降低操作系统在用户态与核心态切换所耗费的时间。除了在进程中设计缓冲区，内核也有自己的缓冲区。</p>
<p>内核缓存区</p>
<p>当一个用户进程要从磁盘读取数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程缓冲区中。但若是内核缓冲区中没有数据，内核会把对数据块的请求，加入到请求队列，然后把进程挂起，为其它进程提供服务。等到数据已经读取到内核缓冲区时，把内核缓冲区中的数据读取到用户进程中，才会通知进程，当然不同的IO模型，在调度和使用内核缓冲区的方式上有所不同。</p>
<p>参考链接：</p>
<p><a href="https://blog.csdn.net/qq_42052956/article/details/111562280">https://blog.csdn.net/qq_42052956/article/details/111562280</a></p>
<p><a href="https://cloud.tencent.com/developer/article/2131401">https://cloud.tencent.com/developer/article/2131401</a></p>
<h4 id="进程的创建需要系统分配什么资源"><a href="#进程的创建需要系统分配什么资源" class="headerlink" title="进程的创建需要系统分配什么资源"></a>进程的创建需要系统分配什么资源</h4><p>根据其他博客里写的底层源码来看，分配给一个进程的东西太多啦，我们挑几个记一下：内存、CPU处理时间、输入输出设备、存储空间。</p>
<p>参考链接：</p>
<p><a href="https://blog.csdn.net/lvyibin890/article/details/82193900">https://blog.csdn.net/lvyibin890/article/details/82193900</a></p>
<p><a href="https://juejin.cn/s/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%99%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E4%BB%80%E4%B9%88%E8%B5%84%E6%BA%90">https://juejin.cn/s/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%99%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E4%BB%80%E4%B9%88%E8%B5%84%E6%BA%90</a></p>
<h4 id="HTTPS加密方式：对称加密、非对称加密"><a href="#HTTPS加密方式：对称加密、非对称加密" class="headerlink" title="HTTPS加密方式：对称加密、非对称加密"></a>HTTPS加密方式：对称加密、非对称加密</h4><p>对称加密：密钥只有一个，加密解密为同一个密码。利用这种加密方式时必须把密钥也发送给对方，密钥在传输过程中被窃取，也就失去了加密的意义。</p>
<p>非对称加密：密钥成对出现，公钥加密需要私钥解密，私钥加密需要公钥解密。</p>
<p>参考链接：</p>
<p><a href="https://www.runoob.com/w3cnote/http-vs-https.html">https://www.runoob.com/w3cnote/http-vs-https.html</a></p>
<p><a href="https://www.itwork.club/2022/05/27/why-did-https-use-mixed-encryption-algorithm/">https://www.itwork.club/2022/05/27/why-did-https-use-mixed-encryption-algorithm/</a></p>
<h4 id="线程的三种状态"><a href="#线程的三种状态" class="headerlink" title="线程的三种状态"></a>线程的三种状态</h4><p>就绪态、运行态、阻塞态</p>
<h4 id="析构函数里能不能抛异常-为什么？"><a href="#析构函数里能不能抛异常-为什么？" class="headerlink" title="析构函数里能不能抛异常?为什么？"></a>析构函数里能不能抛异常?为什么？</h4><p>析构函数从语法上是可以抛出异常的，但是这样做很危险，请尽量不要这要做。原因在《More Effective C++》中提到两个： </p>
<p>（1）如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。 </p>
<p>（2）通常异常发生时，c++的异常处理机制在异常的传播过程中会进行栈展开（stack-unwinding），因发生异常而逐步退出复合语句和函数定义的过程，被称为栈展开。在栈展开的过程中就会调用已经在栈构造好的对象的析构函数来释放资源，此时若其他析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃。</p>
<h4 id="两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？"><a href="#两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？" class="headerlink" title="两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？"></a>两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？</h4><p>有虚函数的大，因为有虚函数的类的会包含一个虚函数指针。注意不同操作系统指针大小不一样。</p>
<p>参考链接：<a href="https://blog.csdn.net/luolaihua2018/article/details/110736211">https://blog.csdn.net/luolaihua2018/article/details/110736211</a></p>
<h4 id="数据报和数据流的区别？"><a href="#数据报和数据流的区别？" class="headerlink" title="数据报和数据流的区别？"></a>数据报和数据流的区别？</h4><p>可以这么简单理解：</p>
<p>假设现在有100字节数据，面向数据流和面向数据报的连接可以分别怎么样处理呢？</p>
<ul>
<li>数据流是发送端可以调用10次write，每次10字节。接收端调用一次read。也可以是发送端调用一次write，接收端调用10次read。数据流是没有边界的</li>
<li>数据报则是一次write就需要一次read，是有边界的。</li>
</ul>
<h4 id="在分布式系统中，如果某个节点宕机了咋办？"><a href="#在分布式系统中，如果某个节点宕机了咋办？" class="headerlink" title="在分布式系统中，如果某个节点宕机了咋办？"></a>在分布式系统中，如果某个节点宕机了咋办？</h4><p>做一个数据副本策略，把每一台机器上的数据做几个副本的冗余，放在别的机器上。万一说某一台机器宕机，没事啊，因为其他机器上还有他的副本。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>所谓自旋锁就是通过while循环实现的，让拿到锁的线程进入临界区执行代码，让没有拿到锁的线程一直进行while死循环，这其实就是线程自己“旋”在while循环了，因而这种锁就叫做自旋锁。</p>
<p>自旋锁实现参考链接：<a href="https://blog.csdn.net/jeffasd/article/details/80661804">https://blog.csdn.net/jeffasd/article/details/80661804</a></p>
<h4 id="线程同步的方式有哪些"><a href="#线程同步的方式有哪些" class="headerlink" title="线程同步的方式有哪些"></a>线程同步的方式有哪些</h4><p>互斥锁、信号量、条件变量、自旋锁、读写锁、屏障</p>
]]></content>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2023/08/29/MySQL/</url>
    <content><![CDATA[<h3 id="DAY1"><a href="#DAY1" class="headerlink" title="DAY1"></a><code>DAY1</code></h3><p>使用指令创建数据库：CREATE DATABASE zcl_db01;</p>
<p>删除数据库指令：DROP DATABASE zcl_db01;</p>
<p>创建一个使用utf8字符集的zcl_db02数据库：CREATE DATABASE zcl_db02 CHARACTER SET utf8</p>
<p>创建一个使用utf8字符集，并带校对规则的zcl_db03数据库：CREATE DATABASE zcl_db03 CHARACTER SET utf8 COLLATE utf8_bin<br>utf8_bin区分大小写，utf8_general_ci不区分大小写</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查看当前数据库服务器中的所有数据库</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES</span><br><span class="line"></span><br><span class="line">#查看前面创建的zcl_db01数据库的定义信息</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE `zcl_db01`</span><br><span class="line"></span><br><span class="line">#在创建数据库、表的时候，为了规避关键字，可以使用``解决</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE `<span class="keyword">CREATE</span>`</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#备份数据库</span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p <span class="operator">-</span>B zcl_db03 <span class="operator">&gt;</span> e:\\tmp.sql (文件名)</span><br><span class="line"></span><br><span class="line">#恢复数据库</span><br><span class="line">source e:\\tmp.sql</span><br><span class="line"></span><br><span class="line">#备份数据库的表</span><br><span class="line">mysqldump <span class="operator">-</span>u root <span class="operator">-</span>p zcl_db03 t1 t2 (t1和t2是表名) <span class="operator">&gt;</span> e:\\tmp1.sql</span><br></pre></td></tr></table></figure>



<h3 id="DAY2"><a href="#DAY2" class="headerlink" title="DAY2"></a><code>DAY2</code></h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建表</span><br><span class="line"># create table table_name</span><br><span class="line"># (</span><br><span class="line"># 	filed1 datatype,</span><br><span class="line">#	filed2 datatype,</span><br><span class="line">#	filed3 datatype</span><br><span class="line"># )character set 字符集 collate 校对规则 engine 存储引擎</span><br><span class="line">#  filed：指定列名	   datatype：指定列类型（字段类型）</span><br><span class="line">#  character set：如不指定则为所在数据库字符集</span><br><span class="line">#  collate：如不指定则为所在数据库校对规则</span><br><span class="line"></span><br><span class="line"># 实操</span><br><span class="line">create table `user`(</span><br><span class="line">	id int,</span><br><span class="line">    `name` varchar(255),</span><br><span class="line">    `passward` varchar(255),</span><br><span class="line">    `birthday` date</span><br><span class="line">)character set utf8 collate utf8_general_ci engine innodb; </span><br></pre></td></tr></table></figure>



<h4 id="Mysql常用数据类型"><a href="#Mysql常用数据类型" class="headerlink" title="Mysql常用数据类型"></a>Mysql常用数据类型</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Mysql列类型就是Mysql的数据类型</span><br><span class="line"># 数值类型：</span><br><span class="line"># 整型：tinyint(1个字节)	smallint(2个字节)	mediumint(3个字节)	int(4个字节)	bigint(8个字节)</span><br><span class="line"># 小数类型：float(单精度 4个字节)	double(双精度 8个字节)	decimal[M,D](大小不确定，M代表长度，D代表小数位数)</span><br><span class="line"></span><br><span class="line"># 文本类型（字符串类型）</span><br><span class="line"># char(0-255)	varchar(0~65535)	text(0~2^16-1)	longtext(0~2^32-1)</span><br><span class="line"></span><br><span class="line"># 二进制数据类型</span><br><span class="line"># blob[0~2^16-1]	longblob[0~2^32-1]</span><br><span class="line"></span><br><span class="line"># 日期类型</span><br><span class="line"># date[日期 年月日] time[时间 时分秒]	datetime[年月日 时分秒 YYYY-MM-DD HH:MM:SS]	timestamp[时间戳]</span><br></pre></td></tr></table></figure>

<p>在满足需求的情况下，尽量选择占用空间小的类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE t3(</span><br><span class="line">	id TINYINT</span><br><span class="line">);</span><br><span class="line"># INSERT INTO t3 VALUES(128); 错误：越界了，超过了tinyint范围。 </span><br><span class="line">INSERT INTO t3 VALUES(127);</span><br><span class="line"># 定义无符号的整数 指定unsigned</span><br><span class="line">CREATE TABLE t4(</span><br><span class="line">	id TINYINT UNSIGNED</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># BIT(M), M在1-64。显示按照bit。</span><br><span class="line">CREATE TABLE t5(</span><br><span class="line">	num BIT(8)</span><br><span class="line">);</span><br><span class="line">INSERT INTO t5 VALUES(255);</span><br><span class="line">SELECT * FROM t5;</span><br><span class="line"># 输出：11111111</span><br><span class="line">SELECT * FROM t5 WHERE num = 255;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># DECIMAL[M, D] </span><br><span class="line"># M是小数位数（精度）的总数，D是小数点（标度）后面的位数。</span><br><span class="line"># 如果D是0，则值没有小数点或分数部分，M最大是65，D最大是30。如果D被省略，则默认是0，如果M被省略，默认是10。</span><br><span class="line">CREATE TABLE t6(</span><br><span class="line">	num1 FLOAT,</span><br><span class="line">    num2 DOUBLE,</span><br><span class="line">    num3 DECIMAL(30, 20)</span><br><span class="line">);</span><br><span class="line">INSERT INTO t6 VALUES(88.123456789123456, 88.123456789123456, 88.123456789123456)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># char(4) 这个4表示字符数（最大255），不是字节数，不管是中文还是英文都是放四个，按字符计算，定长，即使你插入&#x27;aa&#x27;，也会占用分配的4个字符的空间</span><br><span class="line"># varchar(4) 这个4表示字符数，是变长，如果你插入&#x27;aa&#x27;，实际占用空间并不是4个字符，而是实际占用的空间。</span><br><span class="line"># utf-8：一个字符占三个字节</span><br><span class="line">CREATE TABLE t11(</span><br><span class="line">	&#x27;name&#x27; CHAR(4)</span><br><span class="line">);</span><br><span class="line"># INSERT INTO t11 VALUES(&#x27;ABCDE&#x27;) 报错，太长</span><br><span class="line">INSERT INTO t11 VALUES(&#x27;ABCD&#x27;)</span><br><span class="line">INSERT INTO t11 VALUES(&#x27;你好&#x27;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 日期类型 date datetime timestamp</span><br><span class="line">CREATE TABLE birthday11(</span><br><span class="line">	birthday DATE,</span><br><span class="line">    worktime DATETIME,</span><br><span class="line">    login_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP</span><br><span class="line">);</span><br><span class="line">INSERT INTO bithday11(birthday, worktime) VALUES(&#x27;2022-11-11&#x27;, &#x27;2022-11-11 10:10:10&#x27;);</span><br></pre></td></tr></table></figure>



<h4 id="创建表的课堂练习"><a href="#创建表的课堂练习" class="headerlink" title="创建表的课堂练习"></a>创建表的课堂练习</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#x27;emp&#x27;(</span><br><span class="line">	id INT,</span><br><span class="line">    &#x27;name&#x27; VARCHAR(32),</span><br><span class="line">    sex CHAR(1),</span><br><span class="line">    birthday DATE,</span><br><span class="line">    entry_date DATETIME,</span><br><span class="line">    job VARCHAR(32),</span><br><span class="line">    saraly DOUBLE,</span><br><span class="line">    &#x27;resume&#x27; TEXT</span><br><span class="line">) CHARSET utf8 COLLATE utf8_bin ENGINE INNODB;</span><br><span class="line">INSERT INTO &#x27;emp&#x27; VALUES(</span><br><span class="line">	100, &#x27;小妖怪&#x27;, &#x27;男&#x27;, &#x27;2000-11-11&#x27;, &#x27;巡山的&#x27;, 3000, &#x27;大王叫我来巡山&#x27;</span><br><span class="line">);</span><br><span class="line">SELECT * FROM &#x27;emp&#x27;;</span><br><span class="line"></span><br><span class="line"># 增加列</span><br><span class="line">ALTER TABLE emp ADD image VARCHAR(32) NOT NULL DEFAULT &#x27;&#x27; AFTER RESUME</span><br><span class="line"></span><br><span class="line"># 显示表结构</span><br><span class="line">DESC emp</span><br><span class="line"></span><br><span class="line"># 修改job长度</span><br><span class="line">ALTER TABLE emp MODIFY job VARCHAR(60) NOT NULL DEFAULT &#x27;&#x27;</span><br><span class="line"></span><br><span class="line"># 删除列</span><br><span class="line">ALTER TABLE emp DROP sex</span><br><span class="line"></span><br><span class="line"># 修改表名</span><br><span class="line">RENAME TABLE emp TO employee</span><br><span class="line"></span><br><span class="line"># 修改表的字符集</span><br><span class="line">ALTER TABLE employee CHARACTER SET utf8</span><br><span class="line"></span><br><span class="line"># 修改列名</span><br><span class="line">ALTER TABLE employee CHANGE &#x27;name&#x27; user_name VARCHAR(64) NOT NULL DEFAULT &#x27;&#x27;</span><br></pre></td></tr></table></figure>



<h4 id="数据库CRUD语句"><a href="#数据库CRUD语句" class="headerlink" title="数据库CRUD语句"></a>数据库CRUD语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用INSERT语句向表中插入数据</span><br><span class="line">CREATE TABLE &#x27;goods&#x27;(</span><br><span class="line">	id INT,</span><br><span class="line">    goods_name VARCHAR(10),</span><br><span class="line">    price DOUBLE</span><br><span class="line">);</span><br><span class="line">INSERT INTO &#x27;goods&#x27; (id, goods_name, price) VALUES (10, &#x27;华为手机&#x27;, 2000);</span><br><span class="line">INSERT INTO &#x27;goods&#x27; (id, goods_name, price) VALUES (20, &#x27;苹果手机&#x27;, 20000);</span><br><span class="line"></span><br><span class="line"># INSERT语句的细节</span><br><span class="line">-- 插入的数据应与字段的数据类型相同，比如把&#x27;abc&#x27;添加到int类型会错误。</span><br><span class="line">-- 数据的长度应在列的规定范围内，不能将一个长度为80的字符串加入到长度为40的列中。</span><br><span class="line">-- 在VALUES中列出的数据位置必须与被加入的列的排列位置相对应。</span><br><span class="line">-- 字符和日期类型应包含在单引号中</span><br><span class="line">-- 列可以插入空值，前提是该字段允许为空（没有NOT NULL）</span><br><span class="line">-- INSERT INTO TABLE_NAME (列名) VALUES (),(),()，添加多条数据一次性</span><br><span class="line">-- 如果是给表中的所有字段添加数据，(id, goods_name, price)这个可以省略</span><br><span class="line">-- 默认值的使用，当不给某个字段赋值时，如果有默认值就会添加，否则报错。</span><br><span class="line">-- 如果我们希望指定某个列的默认值，可以在创建表时指定。</span><br><span class="line">CREATE TABLE &#x27;goods2&#x27;(</span><br><span class="line">	id INT,</span><br><span class="line">    goods_name VARCHAR(10),</span><br><span class="line">    price DOUBLE NOT NULL DEFAULT 100</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 演示update语句</span><br><span class="line">-- employee是表名，salary是列名</span><br><span class="line">-- 将所有员工薪水修改为5000，如果没有带where条件，会修改所有的记录，因此要小心</span><br><span class="line">UPDATE employee SET salary = 5000 </span><br><span class="line">-- 将姓名为小妖怪的员工薪水修改为3000</span><br><span class="line">UPDATE employee SET salary = 3000 WHERE user_name = &#x27;小妖怪&#x27;</span><br><span class="line">-- 将老妖怪的薪水在原有基础上增加1000</span><br><span class="line">INSERT INTO employee VALUES(200, &#x27;老妖怪&#x27;, &#x27;1990-11-11&#x27;, &#x27;2000-11-11 10:10:10&#x27;, &#x27;捶背的&#x27;, 5000,  &#x27;给大王捶背的&#x27;);</span><br><span class="line">UPDATE employee SET salary = salary + 1000 WHERE user_name = &#x27;老妖怪&#x27;</span><br><span class="line">UPDATE employee SET salary = salary + 1000, job = &#x27;出主意的&#x27; WHERE user_name = &#x27;老妖怪&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 演示delete语句</span><br><span class="line">-- 删除表中名称为‘老妖怪’的记录</span><br><span class="line">DELETE FROM employee WHERE user_name = &#x27;老妖怪&#x27;;</span><br><span class="line">-- 删除表中所有记录</span><br><span class="line">DELETE FROM employee</span><br><span class="line">-- DELETE删除不了一列的值，但可以使用UPDATE语句置为null</span><br><span class="line">UPDATE employee SET job = NULL WHERE user_name = &#x27;老妖怪&#x27;;</span><br><span class="line">-- 要删除这个表</span><br><span class="line">DROP TABLE employee</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- select指定查询哪些列的数据</span><br><span class="line">-- *代表查询所有列</span><br><span class="line">-- from指定查询哪张表</span><br><span class="line">-- DISTINCT可选，指显示结果时，是否去掉重复数据</span><br><span class="line">CREATE TABLE student(</span><br><span class="line">	id INT NOT NULL DEFAULT 1,</span><br><span class="line">    NAME VARCHAR(20) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">    chinese FLOAT NOT NULL DEFAULT 0.0,</span><br><span class="line">    english FLOAT NOT NULL DEFAULT 0.0,</span><br><span class="line">    math FLOAT NOT NULL DEFAULT 0.0</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(1, &#x27;韩顺平&#x27;, 89, 78, 90);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(2, &#x27;张飞&#x27;, 67, 98, 56);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(3, &#x27;宋江&#x27;, 87, 78, 77);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(4, &#x27;关羽&#x27;, 88, 98, 90);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(5, &#x27;赵云&#x27;, 82, 84, 67);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(6, &#x27;欧阳锋&#x27;, 55, 85, 45);</span><br><span class="line">INSERT INTO student(id, NAME, chinese, english, math) VALUES(7, &#x27;黄蓉&#x27;, 75, 65, 30);</span><br><span class="line"></span><br><span class="line">SELECT * FROM student;</span><br><span class="line"></span><br><span class="line">-- 查寻表中所有学生的信息</span><br><span class="line">SELECT * FROM student;</span><br><span class="line"></span><br><span class="line">-- 查询表中所有学生的姓名和对应的英语成绩</span><br><span class="line">SELECT &#x27;NAME&#x27;, english FROM student;</span><br><span class="line"></span><br><span class="line">-- 过滤表中重复数据distinct</span><br><span class="line">-- 要查询的记录每个字段都相同，才会去重</span><br><span class="line">SELECT DISTINCT english FROM student;</span><br><span class="line"></span><br><span class="line">-- 统计每个学生的总分</span><br><span class="line">SELECT &#x27;NAME&#x27;, (chinese + english + math) FROM student;</span><br><span class="line"></span><br><span class="line">-- 在所有学生总分加10分</span><br><span class="line">SELECT &#x27;NAME&#x27;, (chinese + english + math + 10) FROM student;</span><br><span class="line"></span><br><span class="line">-- 使用别名表示学生分数</span><br><span class="line">SELECT &#x27;NAME&#x27;, (chinese + english + math + 10) AS total_score FROM student;</span><br><span class="line">SELECT &#x27;NAME&#x27; AS &#x27;名字&#x27;, (chinese + english + math + 10) AS total_score FROM student;</span><br><span class="line"></span><br><span class="line">-- 查询姓名为赵云的学生成绩</span><br><span class="line">SELECT * FROM student WHERE &#x27;NAME&#x27; = &#x27;赵云&#x27;;</span><br><span class="line"></span><br><span class="line">-- 查询英语成绩大于90分的同学</span><br><span class="line">SELECT * FROM student WHERE english &gt; 90;</span><br><span class="line"></span><br><span class="line">-- 查询总分大于200分的所有同学</span><br><span class="line">SELECT * FROM student WHERE (chinese + english + math) &gt; 200;</span><br><span class="line"></span><br><span class="line">-- 查询math大于60并且id大于4的学生成绩</span><br><span class="line">SELECT * FROM student WHERE math &gt; 60 AND id &gt; 4;</span><br><span class="line"></span><br><span class="line">-- 查询英语成绩大于语文成绩的同学</span><br><span class="line">SELECT * FROM student WHERE english &gt; chinese;</span><br><span class="line"></span><br><span class="line">-- 查询总分大于200分并且数学成绩小于语文成绩的姓韩的学生</span><br><span class="line">-- 韩% 表示名字以韩开头的就可以</span><br><span class="line">SELECT * FROM student WHERE (chinese + english + math) &gt; 200 AND </span><br><span class="line">						  math &lt; chinese AND &#x27;NAME&#x27; LIKE &#x27;韩%&#x27;;</span><br><span class="line">						  </span><br><span class="line">-- 查询英语分数在80-90之间的同学</span><br><span class="line">SELECT * FROM student WHERE english &gt;= 80 AND english &lt;= 90;</span><br><span class="line">SELECT * FROM student WHERE english BETWWWN 80 AND 90; -- BETWEEN AND 是闭区间</span><br><span class="line"></span><br><span class="line">-- 查询数学分数为89，90，91的同学</span><br><span class="line">SELECT * FROM student WHERE math = 89 OR math = 90 OR math = 91;</span><br><span class="line">SELECT * FROM student WHERE math IN (89, 90, 91);</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>OS_ucore</title>
    <url>/2023/10/18/OS-ucore/</url>
    <content><![CDATA[<p>1、操作系统要干啥？哪些操作&#x2F;任务不属于操作系统的管理范畴？</p>
<p>2、工具使用</p>
<p>阅读源码工具：<code>understannd</code></p>
<p>源码文档自动生成工具：<code>doxygen</code></p>
<p>虚拟运行环境：<code>qemu</code></p>
<p><code>Lab0</code></p>
<p>1、了解汇编</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">asm</span>(</span><br><span class="line">        <span class="string">&quot;cld \n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;rep \n\t&quot;</span></span><br><span class="line">            <span class="string">&quot;stosl&quot;</span></span><br><span class="line">        :</span><br><span class="line">        : <span class="string">&quot;c&quot;</span> (count), <span class="string">&quot;a&quot;</span>(value), <span class="string">&quot;D&quot;</span> (buf[<span class="number">0</span>])</span><br><span class="line">        :</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这段 C 代码给出了一个简单的函数，其中包括了一段内联汇编。</span></span><br><span class="line"><span class="comment">该代码试图展示如何使用 `rep stos` 指令来填充一个缓冲区，但存在一些问题和错误。</span></span><br><span class="line"><span class="comment">我会逐步解释代码，然后提出建议的更正。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 变量定义:</span></span><br><span class="line"><span class="comment">    ```c</span></span><br><span class="line"><span class="comment">    int count = 1;</span></span><br><span class="line"><span class="comment">    int value = 1;</span></span><br><span class="line"><span class="comment">    int buf[10];</span></span><br><span class="line"><span class="comment">    ```</span></span><br><span class="line"><span class="comment">    你定义了三个变量：一个 `count` 用于记录要重复的次数，</span></span><br><span class="line"><span class="comment">                    一个 `value` 用于指定要存储的值，</span></span><br><span class="line"><span class="comment">                    以及一个 `buf` 数组用于存储数据。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 主函数和内联汇编:</span></span><br><span class="line"><span class="comment">    ```c</span></span><br><span class="line"><span class="comment">    void main()&#123;</span></span><br><span class="line"><span class="comment">        asm(</span></span><br><span class="line"><span class="comment">            &quot;cld \n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;rep \n\t&quot;</span></span><br><span class="line"><span class="comment">            &quot;stsol&quot;</span></span><br><span class="line"><span class="comment">            :</span></span><br><span class="line"><span class="comment">            : &quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf[0])</span></span><br><span class="line"><span class="comment">        );</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    ```</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    - `cld`: 清除方向标志（Direction Flag）。这确保了字符串操作（如 `stos`）从低地址向高地址操作。</span></span><br><span class="line"><span class="comment">    - `rep stos`: 这应该是一个组合的指令，意思是&quot;重复存储&quot;。</span></span><br><span class="line"><span class="comment">      你试图使用这个指令将 `value` 的内容存储到 `buf` 指定的内存位置，</span></span><br><span class="line"><span class="comment">      并根据 `count` 的值重复该操作。但这里有个小错误: 你写的是 `&quot;stsol&quot;`，它是不正确的。应该是 `&quot;stosl&quot;`。</span></span><br><span class="line"><span class="comment">    - 输出约束（Output operands）: 这里没有列出输出操作数，所以你只有一个冒号。</span></span><br><span class="line"><span class="comment">    - 输入约束（Input operands）: `&quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf[0])`，这里:</span></span><br><span class="line"><span class="comment">        * `&quot;c&quot; (count)`：把 `count` 放入 `ECX` 寄存器（这是 `rep` 指令使用的计数寄存器）。</span></span><br><span class="line"><span class="comment">        * `&quot;a&quot;(value)`：把 `value` 放入 `EAX` 寄存器（这是 `stosl` 指令使用的源数据寄存器）。</span></span><br><span class="line"><span class="comment">        * `&quot;D&quot; (buf[0])`：把 `buf` 的首地址放入 `EDI` 寄存器（这是 `stosl` 指令使用的目标地址寄存器）。</span></span><br><span class="line"><span class="comment">          但这样写是不准确的，应该是 `&quot;D&quot; (buf)`。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">修正后的代码如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">```c</span></span><br><span class="line"><span class="comment">int count = 1;</span></span><br><span class="line"><span class="comment">int value = 1;</span></span><br><span class="line"><span class="comment">int buf[10];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void main()&#123;</span></span><br><span class="line"><span class="comment">    asm(</span></span><br><span class="line"><span class="comment">        &quot;cld \n\t&quot;</span></span><br><span class="line"><span class="comment">        &quot;rep \n\t&quot;</span></span><br><span class="line"><span class="comment">        &quot;stosl&quot;</span></span><br><span class="line"><span class="comment">        :</span></span><br><span class="line"><span class="comment">        : &quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf)</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">```</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：使用内联汇编通常是平台和编译器特定的。</span></span><br><span class="line"><span class="comment">上述代码假定你正在使用 GCC 或其它支持 GNU 汇编语法的编译器，并且在一个 x86 架构的机器上运行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在 GCC 的内联汇编中，第三个冒号后面的部分是用于指定被汇编代码修改的寄存器列表的，也叫做“Clobber List”。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以下是 `asm` 的基本格式：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">asm ( assembly code </span></span><br><span class="line"><span class="comment">     : output operands                  // optional</span></span><br><span class="line"><span class="comment">     : input operands                   // optional</span></span><br><span class="line"><span class="comment">     : list of clobbered registers      // optional</span></span><br><span class="line"><span class="comment">     );</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. Assembly Code: 包含汇编指令的字符串。</span></span><br><span class="line"><span class="comment">2. Output Operands: 输出操作数列表。</span></span><br><span class="line"><span class="comment">3. Input Operands: 输入操作数列表。</span></span><br><span class="line"><span class="comment">4. Clobber List: 表示汇编指令可能会更改的寄存器列表，</span></span><br><span class="line"><span class="comment">   这告诉编译器这些寄存器的值可能会被修改，所以不要依赖它们的原始值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在你的例子中，你使用了 `&quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf[0])` 为汇编指令提供输入操作数，</span></span><br><span class="line"><span class="comment">但你并没有指定输出操作数，也没有列出任何可能被修改的寄存器。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">虽然在此例中，你知道 `ECX`, `EAX`, 和 `EDI` 寄存器会被修改，</span></span><br><span class="line"><span class="comment">但在许多情况下，列出clobbered registers是很有必要的，因为它可以帮助编译器更好地优化生成的代码。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以，理论上，你的代码应该像这样：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">int count = 1;</span></span><br><span class="line"><span class="comment">int value = 1;</span></span><br><span class="line"><span class="comment">int buf[10];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">void main()&#123;</span></span><br><span class="line"><span class="comment">    asm(</span></span><br><span class="line"><span class="comment">        &quot;cld \n\t&quot;</span></span><br><span class="line"><span class="comment">        &quot;rep \n\t&quot;</span></span><br><span class="line"><span class="comment">        &quot;stosl&quot;</span></span><br><span class="line"><span class="comment">        :</span></span><br><span class="line"><span class="comment">        : &quot;c&quot; (count), &quot;a&quot;(value), &quot;D&quot; (buf)</span></span><br><span class="line"><span class="comment">        : &quot;ecx&quot;, &quot;eax&quot;, &quot;edi&quot;</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这里，`&quot;ecx&quot;, &quot;eax&quot;, &quot;edi&quot;` 是clobber list，告诉编译器这些寄存器的值已经被汇编代码修改了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>3、掌握指针和类型转换相关的Ｃ编程</p>
<p>实验源码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_IG32 0xE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STS_TG32 0xF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">uint32_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)&#123;\</span></span><br><span class="line"><span class="meta">    (gate).gd_off_15_0 = (uint32_t)(off) &amp; 0xffff;\</span></span><br><span class="line"><span class="meta">    (gate).gd_ss = (sel);\</span></span><br><span class="line"><span class="meta">    (gate).gd_args = 0;\</span></span><br><span class="line"><span class="meta">    (gate).gd_rsv1 = 0;\</span></span><br><span class="line"><span class="meta">    (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;\</span></span><br><span class="line"><span class="meta">    (gate).gd_s = 0;\</span></span><br><span class="line"><span class="meta">    (gate).gd_dpl = (dpl);\</span></span><br><span class="line"><span class="meta">    (gate).gd_p = 1;\</span></span><br><span class="line"><span class="meta">    (gate).gd_off_31_16 = (uint32_t)(off) &gt;&gt; 16;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> gd_off_15_0: <span class="number">16</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_ss: <span class="number">16</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_args: <span class="number">5</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_rsv1: <span class="number">3</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_type: <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_s: <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_dpl: <span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_p: <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> gd_off_31_16: <span class="number">16</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> before;</span><br><span class="line">    <span class="type">unsigned</span> intr;</span><br><span class="line">    <span class="type">unsigned</span> after;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> <span class="title">gintr</span>;</span></span><br><span class="line"></span><br><span class="line">    intr = <span class="number">8</span>;</span><br><span class="line">    before = after = <span class="number">0</span>;</span><br><span class="line">    gintr = *((<span class="keyword">struct</span> gatedesc*)&amp;intr);</span><br><span class="line">    SETGATE(gintr, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    intr = *((<span class="type">unsigned</span>*)&amp;(gintr));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;intr is 0x%x\n&quot;</span>, intr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;gintr is 0x%llx\n&quot;</span>, gintr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自己根据输出即可推出来是怎么做的。注意，<code>gintr</code>等于<code>0xee0000010002</code>中，最高16位全部等于0没有展示出来。而%x只能展示32位，所以<code>intr</code>的输出结果为：<code>0x10002</code>。</p>
<h4 id="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"><a href="#一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？" class="headerlink" title="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"></a>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</h4><p>硬盘主引导扇区（Master Boot Record，MBR）是位于硬盘第一个扇区（通常是逻辑地址0号扇区）的512字节的数据结构，用于引导计算机操作系统。一个符合规范的硬盘主引导扇区应该包含以下几个特征：</p>
<ol>
<li><p><strong>引导代码（Boot Code）：</strong> 前446个字节用于存储引导代码，这是引导加载程序（Boot Loader）的代码，负责加载操作系统。这段代码必须是有效的汇编代码，能够启动计算机。</p>
</li>
<li><p><strong>分区表（Partition Table）：</strong> 接下来的64字节用于存储分区表，每个分区表项占16字节。一个硬盘可以分为最多4个主分区，每个分区表项描述一个分区的起始位置、大小和分区类型等信息。</p>
</li>
<li><p><strong>签名字节（Signature）：</strong> 最后的两个字节（0x55AA）是MBR的签名，标志这个扇区是有效的MBR扇区。这个签名是个小端字节序的16位值，它告诉操作系统这个扇区包含了引导信息，是一个有效的MBR。</p>
</li>
</ol>
<p>总结起来，一个被系统认为是符合规范的硬盘主引导扇区应该包含引导代码、分区表和签名字节。这些特征是为了确保引导加载程序可以正确地读取分区信息，从而启动操作系统。如果这些特征中的任何一个缺失或损坏，可能导致系统无法正确引导。</p>
<p>引导扇区代码（<code>tools/sign.c</code>）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span> </span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: &lt;input filename&gt; &lt;output filename&gt;\n&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stat(argv[<span class="number">1</span>], &amp;st) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error opening file &#x27;%s&#x27;: %s\n&quot;</span>, argv[<span class="number">1</span>], strerror(errno)); </span><br><span class="line">        <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&#x27;%s&#x27; size: %lld bytes\n&quot;</span>, argv[<span class="number">1</span>], (<span class="type">long</span> <span class="type">long</span>)st.st_size); </span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; <span class="number">510</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%lld &gt;&gt; 510!!\n&quot;</span>, (<span class="type">long</span> <span class="type">long</span>)st.st_size); </span><br><span class="line">        <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf)); </span><br><span class="line">    FILE*ifp=fopen(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="type">int</span> size = fread(buf, <span class="number">1</span>,st.st_size, ifp); </span><br><span class="line">    <span class="keyword">if</span> (size != st.st_size) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;read &#x27;%s&#x27; error, size is %d.\n&quot;</span>, argv[<span class="number">1</span>], size); </span><br><span class="line">        <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ifp);</span><br><span class="line">    buf[<span class="number">510</span>]= <span class="number">0x55</span>; </span><br><span class="line">    buf[<span class="number">511</span>] =<span class="number">0xAA</span>;</span><br><span class="line">    FILE*ofp = fopen(argv[<span class="number">2</span>], <span class="string">&quot;wb+&quot;</span>);</span><br><span class="line">    size = fwrite(buf, <span class="number">1</span>, <span class="number">512</span>, ofp); </span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">512</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;write &#x27;%s&#x27; error, size is %d.\n&quot;</span>, argv[<span class="number">2</span>], size); </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ofp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;build 512 bytes boot sector: &#x27;%s&#x27; success!\n&quot;</span>, argv[<span class="number">2</span>]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注释</span></span><br><span class="line"><span class="comment">这是一个简单的C程序，用于生成一个包含引导代码的512字节的引导扇区（Boot Sector）。这样的引导扇区通常用于创建可引导的存储介质，例如硬盘、U盘等。以下是程序的主要功能和流程：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 使用 `stat` 函数获取指定输入文件（`argv[1]`）的信息，主要是文件大小。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 打印输入文件的大小。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. 检查文件大小是否超过了510字节。如果超过，打印错误信息并退出程序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4. 读取输入文件的内容（最多510字节），将内容存储在一个大小为512字节的缓冲区中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5. 在缓冲区的倒数第二个字节（第510字节）写入0x55，倒数第一个字节（第511字节）写入0xAA。这是引导扇区的标志，用于告诉计算机系统这是一个有效的引导扇区。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6. 打开输出文件（`argv[2]`），将修改后的缓冲区写入文件。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">7. 打印成功信息并返回0。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这个程序的目的是创建一个符合标准的引导扇区，其中包含引导代码和标志字节。请注意，生成的引导扇区在实际使用时需要按照引导扇区的规范进行进一步配置，以确保它能够正确地引导计算机系统。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以下是程序的一些可能的改进和注意事项：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 添加更多的错误检查，例如检查文件是否成功打开。</span></span><br><span class="line"><span class="comment">- 考虑处理更多的边界情况，例如文件是否为空。</span></span><br><span class="line"><span class="comment">- 考虑使用二进制文件读写模式（&quot;rb&quot; 和 &quot;wb+&quot;）而不是文本模式。</span></span><br><span class="line"><span class="comment">- 考虑使用 `perror` 函数来打印与 `fopen`、`fread`、`fwrite` 相关的错误信息。</span></span><br><span class="line"><span class="comment">- 考虑处理大端和小端字节序的问题，特别是当涉及到二进制文件时。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>UNIX环境高级编程第一章</title>
    <url>/2023/06/08/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>RPC</title>
    <url>/2023/06/28/RPC/</url>
    <content><![CDATA[<h3 id="开始补上MPRPC项目的代码实现，从头开始———-day1"><a href="#开始补上MPRPC项目的代码实现，从头开始———-day1" class="headerlink" title="开始补上MPRPC项目的代码实现，从头开始———-day1"></a><strong>开始补上<code>MPRPC</code>项目的代码实现，从头开始———-<code>day1</code></strong></h3><p>简介：项目基于muduo高性能网络库 + protobuf开发，所以命名为mprpc。</p>
<p>技术栈</p>
<ul>
<li>集群和分布式概念及原理</li>
<li>RPC远程过程调用原理及实现</li>
<li>Protobuf数据序列化和反序列化协议</li>
<li>Zookeeper分布式一致性协调服务应用及编程（服务注册中心，方便寻找哪个服务在哪台服务器上）</li>
<li>muduo网络库编程</li>
<li>conf配置文件读取</li>
<li>CMake构建项目集成编译环境</li>
</ul>
<h4 id="集群和分布式（搞懂为什么要分布式）"><a href="#集群和分布式（搞懂为什么要分布式）" class="headerlink" title="集群和分布式（搞懂为什么要分布式）"></a><strong>集群和分布式（搞懂为什么要分布式）</strong></h4><p><strong>集群</strong>：每一台服务器独立运行一个工程的所有模块</p>
<p><strong>分布式</strong>：一个工程拆分了很多模块，每一个模块独立部署运行在一个服务器主机上，所有服务器协同工作共同提供服务，每一台服务器称作分布式的一个节点，根据节点的并发要求，对一个节点可以再做节点模块集群部署。</p>
<p><img src="png1.PNG"></p>
<p>如图中<code>server</code>所示，一个聊天系统包括不同模块：用户管理、好友管理、群组管理、消息管理以及后台管理五个模块。每个模块有自己的特定业务，举个例子，用户管理模块包括用户注册、用户登录、用户注销等。</p>
<p>现在让你提出一些单机聊天服务器的缺陷，你能想到哪些？</p>
<ol>
<li>受限于硬件资源，聊天服务器所能承受的用户的并发量，比如端口用光了。</li>
<li>假设这个单机聊天服务器体系很庞大，项目编译需要两个小时！如果现在消息管理模块有一个小<code>bug</code>，需要改动几行，然后导致需要重新编译、部署整个项代码。</li>
<li>系统中，有些模块是属于<code>CPU</code>密集型，有些模块是<code>I/O</code>密集型的，造成各模块对于硬件资源的需求是不一样的。既然受限于硬件资源，我们就多部署几台服务器，横向增加服务器数量。但并未解决问题2和3。</li>
</ol>
<p>集群的优缺点如下，优点：用户的并发量提升了。缺点：项目代码还是需要整体重新编译，而且需要进行多次部署。</p>
<p><img src="png2.png"></p>
<p>现在我们看红色圈，我们把不同模块分类部署在不同服务器上。所有服务器共同构成一个聊天系统，这就是分布式。现在我们将不同服务器分别视为不同分布式节点。比如用户管理模块和消息管理模块对并发要求高，我们可以进行扩容，再部署几台服务器用于用户管理和消息管理（根据节点的并发要求，对一个节点可以再做节点模块集群部署）。分布式系统针对问题2，每个模块独立部署独立运行，哪个模块有<code>bug</code>，我只需要重新编译部署那个模块，其他模块还能正常运行。问题3就很明显了，视不同要求配置不同服务器。</p>
<p>那分布式就全是优点吗？下面我们说说关于分布式设计的难点。</p>
<ol>
<li>大系统的软件模块该怎么划分。</li>
<li>各模块之间怎么访问？集群服务器所有模块运行在一个进程里，不同模块之间访问简便。而分布式各模块都运行在不同的进程里，那服务器1的模块怎么调用服务器2上的模块的一个业务方法呢？我们这个项目所做的就是封装这种远程调用过程，方便用户调用，也就是程序员方便使用我们写的项目（<code>MPRPC</code>）。</li>
</ol>
<h3 id="RPC通信原理———-day2"><a href="#RPC通信原理———-day2" class="headerlink" title="RPC通信原理———-day2"></a><strong><code>RPC</code>通信原理———-<code>day2</code></strong></h3><p><img src="png3.png"></p>
<p>通过上图我们可以看到，我们设计的框架主要由以下部分和流程组成：</p>
<ul>
<li>发起调用端（caller）：调用方需要将调用的函数名、参数打包（序列化），并通过网络发送出去。这里打算采用muduo网络库。</li>
<li>接收端（callee）：接收方接收到包后，将包里的内容反序列化，就能知道调用哪一个函数、传入的参数是啥，然后返回值依旧是序列化之后通过网络发送回去，发送端接收到后反序列化，得到具体的返回值。</li>
<li>我们的框架主要是实现图中的黄绿部分。<ol>
<li>黄色部分是rpc方法参数的打包和解析，也就是数据的序列化与反序列化，通过protobuf完成。</li>
<li>在图中，有一些东西没画进去，比如我们将黄色块分别取名为client-stub和server-stub。这两个stub都是执行数据的序列化与反序列化。</li>
<li>如果远程调用过程中函数执行出错，我们可以返回一些错误码，防止接收端读取错误的返回值。</li>
<li>绿色部分：网络部分，包括寻找rpc服务主机，发起rpc调用请求和响应rpc调用结果，使用muduo网络库和Zookeeper服务配置中心（专门做服务发现）。</li>
</ol>
</li>
</ul>
<p>protobuf相对于json的好处：</p>
<p>1、protobuf是二进制存储；xml和json都是文本存储</p>
<p>2、protobuf不需要存储额外的信息；json通过key-value存储数据</p>
<ul>
<li><p>json：name: “zhang san”, pwd: “123456”</p>
</li>
<li><p>protobuf: “zhangsan” “123456”</p>
</li>
</ul>
<h3 id="项目环境搭建"><a href="#项目环境搭建" class="headerlink" title="项目环境搭建"></a><strong>项目环境搭建</strong></h3><h4 id="文件组成"><a href="#文件组成" class="headerlink" title="文件组成"></a>文件组成</h4><ul>
<li>bin：可执行文件</li>
<li>build：项目编译文件</li>
<li>lib：项目库文件</li>
<li>src：源文件</li>
<li>test：测试代码</li>
<li>example：框架代码使用范例</li>
<li>CMakeLists.txt：顶层的</li>
<li>cmake文件</li>
<li>README.md：项目自述文件</li>
<li>autonbuild.sh：一键编译脚本</li>
</ul>
<h4 id="Ubuntu-protobuf环境搭建"><a href="#Ubuntu-protobuf环境搭建" class="headerlink" title="Ubuntu protobuf环境搭建"></a>Ubuntu protobuf环境搭建</h4><p>首先在GitHub下载源代码，源码包中src&#x2F;README.md有详细的安装说明，也可以按照如下步骤安装：</p>
<ol>
<li>解压压缩包：unzip protobuf-master.zip</li>
<li>进入解压后的文件夹：cd protobuf-master</li>
<li>安装所需工具：sudo apt-get install autoconf automake libtool curl make g++ unzip</li>
<li>自动生成configure配置文件：.&#x2F;autogen.sh</li>
<li>配置环境：.&#x2F;configure</li>
<li>编译源代码（时间比较长）：make</li>
<li>安装：sudo make install</li>
<li>刷新动态库：sudo ldconfig</li>
<li>测试：看能否正常执行protoc命令（直接去终端执行）</li>
</ol>
<p>源码下载地址：<a href="https://github.com/protocolbuffers/protobuf">https://github.com/protocolbuffers/protobuf</a></p>
<h4 id="muduo库安装"><a href="#muduo库安装" class="headerlink" title="muduo库安装"></a>muduo库安装</h4><p>关于muduo库安装，强烈推荐按照施老师的步骤来（参考链接：<a href="https://blog.csdn.net/QIANGWEIYUAN/article/details/89023980%EF%BC%89%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%B8%8D%E7%94%A8%E7%9C%8B%E6%88%91%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4%EF%BC%8C%E4%B8%8D%E5%AE%8C%E6%95%B4%EF%BC%81%EF%BC%81%EF%BC%81">https://blog.csdn.net/QIANGWEIYUAN/article/details/89023980），可以不用看我下面的安装步骤，不完整！！！</a></p>
<ol>
<li>安装依赖：sudo apt-get install libbost-dev libbost-test-dev sudo apt-get install libcurl4-openssl-dev libc-ares-dev</li>
<li>拉文件：git clone <a href="https://github.com/chenshuo/muduo.git">https://github.com/chenshuo/muduo.git</a></li>
<li>.&#x2F;build.sh</li>
</ol>
<p>muduo库是否安装成功的测试：muduo_test.cpp实现了一个简单的echo server</p>
<p>编译：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -std=c++11 muduo_test.cpp -lmuduo_net -lmuduo_base -lpthread -o muduo_test</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<p>一个shell终端执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./muduo_test </span><br></pre></td></tr></table></figure>

<p>另一个shell终端执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">telnet 127.0.0.1 8032</span><br></pre></td></tr></table></figure>

<p>如下图所示则安装成功</p>
<p><img src="png4.png"></p>
<h4 id="创建文件（循序渐进，现在需要哪些文件夹就创建哪些）"><a href="#创建文件（循序渐进，现在需要哪些文件夹就创建哪些）" class="headerlink" title="创建文件（循序渐进，现在需要哪些文件夹就创建哪些）"></a>创建文件（循序渐进，现在需要哪些文件夹就创建哪些）</h4><p>首先，我们可以以自己的名字缩写作为后缀创建一个mprpc文件夹，比如我创建的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir mprpc_zcl</span><br></pre></td></tr></table></figure>

<p>接下来我们需要在mprpc_zcl文件夹里创建以下这些文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd mprpc_zcl</span><br><span class="line">mkdir bin</span><br><span class="line">mkdir build</span><br><span class="line">mkdir example</span><br><span class="line">mkdir lib</span><br><span class="line">mkdir src</span><br><span class="line">mkdir test</span><br><span class="line">touch autobuild.sh</span><br><span class="line">touch CMakeLists.txt</span><br></pre></td></tr></table></figure>

<p>好啦，第一件该做的事我们已经完成啦！</p>
<h4 id="protobuf实践讲解（一）"><a href="#protobuf实践讲解（一）" class="headerlink" title="protobuf实践讲解（一）"></a>protobuf实践讲解（一）</h4><p>首先我们写一个protobuf测试文件来了解一下protobuf的基本使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在<span class="built_in">test</span>文件夹下创建protobuf文件夹，在protobuf文件夹里创建test.proto文件和main.cpp文件</span></span><br><span class="line">cd test/</span><br><span class="line">mkdir protobuf</span><br><span class="line">cd protobuf/</span><br><span class="line">touch main.cpp test.proto</span><br></pre></td></tr></table></figure>

<p>首先编写test.proto文件，必要的注释我会放在代码块里。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 声明protobuf版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug; <span class="comment">// 声明了代码所在的包（对于C++来说就是namespace）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">message就是消息类型，protobuf就是将我们封装好的数据类型进行序列化与反序列化。</span></span><br><span class="line"><span class="comment">定义登录消息类型：名字 + 密码</span></span><br><span class="line"><span class="comment">string name = 1; 1 代表第一个字段</span></span><br><span class="line"><span class="comment">注意，你的name等变量需要使用什么类型，string要指明。</span></span><br><span class="line"><span class="comment">这里的string是protobuf里的string类型，不是c++里的string类型</span></span><br><span class="line"><span class="comment">我们编译protobuf文件的时候需要使用这样的命令编译：protoc test.proto --cpp_out=./ （=后面是编译生成文件的输出路径）</span></span><br><span class="line"><span class="comment">编译后会生成一个LoginRequest类（这里仅拿LoginRequest举例），类有两个成员：string name 和 string pwd。</span></span><br><span class="line"><span class="comment">如果序列化成功，就把序列化的结果放在了send_str里面了，serializeToString是protobuf编译后人家已经帮我们写好的方法，我们直接用就好了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义登录请求消息类型 name pwd</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定于登录响应消息类型 错误码：errcode，错误消息：errmsg， 成功与否：success</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> errmsg = <span class="number">2</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，编写main.cpp进行测试</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// using namespace fixbug</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">protobuf是一个动态库，需要链接，所以整个编译命令为：g++ main.cpp test.pb.cc -lprotobuf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装了login请求对象的数据</span></span><br><span class="line">    fixbug::LoginRequest req;</span><br><span class="line">    req.<span class="built_in">set_name</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    req.<span class="built_in">set_pwd</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象数据序列化</span></span><br><span class="line">    std::string send_str;</span><br><span class="line">    <span class="keyword">if</span>(req.<span class="built_in">SerializeToString</span>(&amp;send_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; send_str.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从send_str反序列化一个login请求对象</span></span><br><span class="line">    fixbug::LoginRequest reqB;</span><br><span class="line">    <span class="keyword">if</span>(reqB.<span class="built_in">ParseFromString</span>(send_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; reqB.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; reqB.<span class="built_in">pwd</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="protobuf实践讲解（二）"><a href="#protobuf实践讲解（二）" class="headerlink" title="protobuf实践讲解（二）"></a>protobuf实践讲解（二）</h4><p>这一小节我们主要引入了两个新知识：</p>
<ul>
<li>在一个消息类型中定义另外一个消息类型</li>
<li>列表</li>
</ul>
<p>必要的注释我已经放在代码块里了，大家可以看看，有不对的地方请谅解并麻烦指出来。</p>
<p>首先是test.proto文件的更新版</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 声明protobuf版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug; <span class="comment">// 声明了代码所在的包（对于C++来说就是namespace）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">message就是消息类型，protobuf就是将我们封装好的数据类型进行序列化与反序列化。</span></span><br><span class="line"><span class="comment">定义登录消息类型：名字 + 密码</span></span><br><span class="line"><span class="comment">string name = 1; 1 代表第一个字段</span></span><br><span class="line"><span class="comment">注意，你的name等变量需要使用什么类型，string要指明。</span></span><br><span class="line"><span class="comment">这里的string是protobuf里的string类型，不是c++里的string类型</span></span><br><span class="line"><span class="comment">我们编译protobuf文件的时候需要使用这样的命令编译：protoc test.proto --cpp_out=./ （=后面是编译生成文件的输出路径）</span></span><br><span class="line"><span class="comment">编译后会生成一个LoginRequest类（这里仅拿LoginRequest举例），类有两个成员：string name 和 string pwd。</span></span><br><span class="line"><span class="comment">如果序列化成功，就把序列化的结果放在了send_str里面了，serializeToString是protobuf编译后人家已经帮我们写好的方法，我们直接用就好了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> errmsg = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义登录请求消息类型 name pwd</span></span><br><span class="line"><span class="comment">// 这里有一个点可以注意一下，一般把string定义成bytes，string也没错，但bytes效率更高</span></span><br><span class="line"><span class="comment">// 因为你定义成string，protobuf还是要转换成bytes</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定于登录响应消息类型 错误码：errcode，错误消息：errmsg， 成功与否：success</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：对于protobuf的消息类型里面定义的成员变量本身又是另外一个消息类型的话，</span></span><br><span class="line"><span class="comment">他都会提供一个mutable用于改变其成员</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在protobuf里还有一个常用的叫列表</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetFriendListsRequest</span>&#123;</span><br><span class="line">    <span class="type">uint32</span> userid = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32</span> age = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">enum </span><span class="title class_">Sex</span>&#123;</span><br><span class="line">        MAN = <span class="number">0</span>;</span><br><span class="line">        WOMAN = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Sex sex = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetFriendListsReponse</span>&#123;</span><br><span class="line">    <span class="comment">// 这里我们注意到，我们每次定义响应的时候好像都会定义errcode和errmsg字段</span></span><br><span class="line">    <span class="comment">// 所以我们决定将其封装起来（ResultCode），便于使用</span></span><br><span class="line">    <span class="comment">// int32 errcode = 1;</span></span><br><span class="line">    <span class="comment">// bytes errmsg = 2;</span></span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的肯定是一个列表，如何表示呢？</span></span><br><span class="line">    <span class="keyword">repeated</span> User friend_list = <span class="number">2</span>; <span class="comment">// 定义了一个列表类型</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>main.cpp更新版</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// using namespace fixbug</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">protobuf是一个动态库，需要链接，所以整个编译命令为：g++ main.cpp test.pb.cc -lprotobuf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装了login请求对象的数据</span></span><br><span class="line">    fixbug::LoginRequest req;</span><br><span class="line">    req.<span class="built_in">set_name</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    req.<span class="built_in">set_pwd</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象数据序列化</span></span><br><span class="line">    std::string send_str;</span><br><span class="line">    <span class="keyword">if</span>(req.<span class="built_in">SerializeToString</span>(&amp;send_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; send_str.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从send_str反序列化一个login请求对象</span></span><br><span class="line">    fixbug::LoginRequest reqB;</span><br><span class="line">    <span class="keyword">if</span>(reqB.<span class="built_in">ParseFromString</span>(send_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; reqB.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; reqB.<span class="built_in">pwd</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixbug::LoginResponse rsp;</span><br><span class="line">    fixbug::ResultCode *rc = rsp.<span class="built_in">mutable_result</span>();</span><br><span class="line">    rc-&gt;<span class="built_in">set_errcode</span>(<span class="number">1</span>);</span><br><span class="line">    rc-&gt;<span class="built_in">set_errmsg</span>(<span class="string">&quot;登陆处理失败了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::string recv_str;</span><br><span class="line">    <span class="keyword">if</span>(rsp.<span class="built_in">SerializeToString</span>(&amp;recv_str))&#123;</span><br><span class="line">        <span class="comment">// 好像设置的errcode并没有输出，暂时不知道为啥</span></span><br><span class="line">        std::cout &lt;&lt; recv_str.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixbug::GetFriendListsReponse rsp2;</span><br><span class="line">    fixbug::ResultCode *rc2 = rsp2.<span class="built_in">mutable_result</span>();</span><br><span class="line">    rc2-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fixbug::User *user1 = rsp2.<span class="built_in">add_friend_list</span>();</span><br><span class="line">    user1-&gt;<span class="built_in">set_name</span>(<span class="string">&quot;zhang san&quot;</span>);</span><br><span class="line">    user1-&gt;<span class="built_in">set_age</span>(<span class="number">20</span>);</span><br><span class="line">    user1-&gt;<span class="built_in">set_sex</span>(fixbug::User::MAN);</span><br><span class="line"></span><br><span class="line">    fixbug::User *user2 = rsp2.<span class="built_in">add_friend_list</span>();</span><br><span class="line">    user2-&gt;<span class="built_in">set_name</span>(<span class="string">&quot;li si&quot;</span>);</span><br><span class="line">    user2-&gt;<span class="built_in">set_age</span>(<span class="number">18</span>);</span><br><span class="line">    user2-&gt;<span class="built_in">set_sex</span>(fixbug::User::MAN);</span><br><span class="line"></span><br><span class="line">    std::string recv_str2;</span><br><span class="line">    <span class="keyword">if</span>(rsp2.<span class="built_in">SerializeToString</span>(&amp;recv_str2))&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; recv_str2.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string user_str;</span><br><span class="line">    <span class="keyword">if</span>(user1-&gt;<span class="built_in">SerializeToString</span>(&amp;user_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; user_str.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; rsp2.<span class="built_in">friend_list_size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="protobuf实践讲解（三）"><a href="#protobuf实践讲解（三）" class="headerlink" title="protobuf实践讲解（三）"></a>protobuf实践讲解（三）</h4><p>这一节我们主要讲了如何引入函数名。因为我们只传输参数给远程rpc服务器是肯定不够的，远程rpc服务器还需要知道我们需要调用哪种方法，因此我们需要使用service在远程rpc服务器上注册函数？（不知道这个理解对不对）同时，方便之后函数调用方传输函数名，里面有一个ServiceDescriptor类型的指针，用于访问方法的各个属性。代码更新如下，主要更新了test.proto文件，main文件没有更新。</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 声明protobuf版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug; <span class="comment">// 声明了代码所在的包（对于C++来说就是namespace）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">message就是消息类型，protobuf就是将我们封装好的数据类型进行序列化与反序列化。</span></span><br><span class="line"><span class="comment">定义登录消息类型：名字 + 密码</span></span><br><span class="line"><span class="comment">string name = 1; 1 代表第一个字段</span></span><br><span class="line"><span class="comment">注意，你的name等变量需要使用什么类型，string要指明。</span></span><br><span class="line"><span class="comment">这里的string是protobuf里的string类型，不是c++里的string类型</span></span><br><span class="line"><span class="comment">我们编译protobuf文件的时候需要使用这样的命令编译：protoc test.proto --cpp_out=./ （=后面是编译生成文件的输出路径）</span></span><br><span class="line"><span class="comment">编译后会生成一个LoginRequest类（这里仅拿LoginRequest举例），类有两个成员：string name 和 string pwd。</span></span><br><span class="line"><span class="comment">如果序列化成功，就把序列化的结果放在了send_str里面了，serializeToString是protobuf编译后人家已经帮我们写好的方法，我们直接用就好了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> errmsg = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义登录请求消息类型 name pwd</span></span><br><span class="line"><span class="comment">// 这里有一个点可以注意一下，一般把string定义成bytes，string也没错，但bytes效率更高</span></span><br><span class="line"><span class="comment">// 因为你定义成string，protobuf还是要转换成bytes</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定于登录响应消息类型 错误码：errcode，错误消息：errmsg， 成功与否：success</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：对于protobuf的消息类型里面定义的成员变量本身又是另外一个消息类型的话，</span></span><br><span class="line"><span class="comment">他都会提供一个mutable用于改变其成员</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在protobuf里还有一个常用的叫列表</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetFriendListsRequest</span>&#123;</span><br><span class="line">    <span class="type">uint32</span> userid = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32</span> age = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">enum </span><span class="title class_">Sex</span>&#123;</span><br><span class="line">        MAN = <span class="number">0</span>;</span><br><span class="line">        WOMAN = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Sex sex = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetFriendListsReponse</span>&#123;</span><br><span class="line">    <span class="comment">// 这里我们注意到，我们每次定义响应的时候好像都会定义errcode和errmsg字段</span></span><br><span class="line">    <span class="comment">// 所以我们决定将其封装起来（ResultCode），便于使用</span></span><br><span class="line">    <span class="comment">// int32 errcode = 1;</span></span><br><span class="line">    <span class="comment">// bytes errmsg = 2;</span></span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的肯定是一个列表，如何表示呢？</span></span><br><span class="line">    <span class="keyword">repeated</span> User friend_list = <span class="number">2</span>; <span class="comment">// 定义了一个列表类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">我们在上面已经完成了参数和反回值传输，但我们仅将函数参数传过去，远程服务器并不知道我们要调用哪种方法啊！</span></span><br><span class="line"><span class="comment">protobuf没有rpc通信功能，只进行序列化与反序列化。但我们依旧要在protobuf里完成rpc方法类型的定义描述。</span></span><br><span class="line"><span class="comment">这就需要使用protobuf的service功能，注意此时需要加入option选项， option cc_generic_services = true; 表示生成service服务类和rpc方法描述</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 不管是message还是service，最后都会生成class类。注意message只生成一个，service会生成两个，一个class UserServiceRpc，一个class UserServiceRpc_stub</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserServiceRpc</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Login(LoginRequest) <span class="keyword">returns</span>(LoginResponse)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> GetFriendLists(GetFriendListsRequest) <span class="keyword">returns</span>(GetFriendListsReponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="本地服务如何发布成RPC服务（一）"><a href="#本地服务如何发布成RPC服务（一）" class="headerlink" title="本地服务如何发布成RPC服务（一）"></a>本地服务如何发布成RPC服务（一）</h4><p>这一块算是正式跨入项目第一步，我们通过业务出发，如果要实现我们所需要的具体需求应该怎么办，直接给出更新后的代码，必要的注释都在代码里</p>
<p>这里先给大家看一个本节之后的文件组成情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── autobuild.sh</span><br><span class="line">├── bin</span><br><span class="line">├── build</span><br><span class="line">├── example</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── callee</span><br><span class="line">│   │   ├── CMakeLists.txt</span><br><span class="line">│   │   └── userservice.cpp</span><br><span class="line">│   ├── caller</span><br><span class="line">│   ├── user.pb.cc</span><br><span class="line">│   ├── user.pb.h</span><br><span class="line">│   └── user.proto</span><br><span class="line">├── lib</span><br><span class="line">├── src</span><br><span class="line">└── test</span><br><span class="line">    └── protobuf</span><br><span class="line">        ├── a.out</span><br><span class="line">        ├── main.cpp</span><br><span class="line">        ├── test.pb.cc</span><br><span class="line">        ├── test.pb.h</span><br><span class="line">        └── test.proto</span><br><span class="line"></span><br><span class="line">9 directories, 13 files</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最上面的小点代表根目录：mprpc_zcl</span></span><br></pre></td></tr></table></figure>

<p>更新后的mprpc_zcl&#x2F;CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置cmake的最低版本和项目名称</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(mprpc_zcl)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目可执行文件输出的路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目库文件输出路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目编译头文件搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/example)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目库文件搜索路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># src里面放的是框架代码</span></span><br><span class="line"><span class="comment"># add_subdirectory(src)  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># example里面放的是rpc服务的使用者和消费者，业务代码</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(example)</span><br></pre></td></tr></table></figure>

<p>更新后的mprpc_zcl&#x2F;example&#x2F;user.proto</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> errmsg = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserServiceRpc</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Login_rpc(LoginRequest) <span class="keyword">returns</span>(LoginResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，编写完之后直接使用protoc user.proto --cpp_out=./编译</span></span><br></pre></td></tr></table></figure>

<p>更新后的mprpc_zcl&#x2F;example&#x2F;CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(callee)</span><br></pre></td></tr></table></figure>

<p>更新后的mprpc_zcl&#x2F;example&#x2F;callee&#x2F;userservice.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我个人觉得这个项目应该从这里开始讲解，我们现在本地有一个用户登录Login_Local方法（隶属于UserService类）。</span></span><br><span class="line"><span class="comment">我们自己在本地调用那肯定很方便，创建一个UserService类对象，直接调用Login_Local方法即可</span></span><br><span class="line"><span class="comment">可是，如果现在有另外一个进程或者另外一台机器想调用我们这个方法怎么办呢？所以我们就要结合谷歌protobuf提供给我们的工具了</span></span><br><span class="line"><span class="comment">这个文件写的就是rpc服务提供者文件，我们在别人想要调用这个本地方法之前需要做哪些基础工作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1、proto文件经过protobuf编译后生成了UserServiceRpc类</span></span><br><span class="line"><span class="comment">2、我们需要在userservice.cpp文件里对这个类里的方法进行重写</span></span><br><span class="line"><span class="comment">3、注意：message会变为类的成员，service会生成一个类，service里的内容会生成方法</span></span><br><span class="line"><span class="comment">4、现在的问题就是：我们重写过后，远方是怎么调用的呢？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Userservice</span> : <span class="keyword">public</span> fixbug::UserServiceRpc   <span class="comment">// 使用在rpc服务发布端（rpc服务提供者）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Login_local</span><span class="params">(std::string name, std::string pwd)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doing local service: Login&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; pwd:&quot;</span> &lt;&lt; pwd;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，作用过程是这样的，当远端将请求发送过来，先会被我们的rpc框架接受，我们rpc框架根据接收到的参数，函数名等数据</span></span><br><span class="line">    <span class="comment">// 匹配到了我们重写的这个函数，然后调用了这个函数。</span></span><br><span class="line">    <span class="comment">// 所以这一块不属于框架的代码，是我们要使用这个框架必须自己写的代码，实现自己需要的功能。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Login_rpc</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> ::fixbug::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::fixbug::LoginResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::google::protobuf::Closure* done)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 暂时还没写完</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新后的mprpc_zcl&#x2F;example&#x2F;callee&#x2F;CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(SRC_LIST userservice.cpp ../user.pb.cc)</span><br><span class="line"><span class="keyword">add_executable</span>(provider <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="本地服务如何发布成RPC服务（二）"><a href="#本地服务如何发布成RPC服务（二）" class="headerlink" title="本地服务如何发布成RPC服务（二）"></a>本地服务如何发布成RPC服务（二）</h4><p>这一节必要的注释我都放在了代码里，以及思考的过程，这一节只对userservice.cpp进行了更新</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我个人觉得这个项目应该从这里开始讲解，我们现在本地有一个用户登录Login_Local方法（隶属于UserService类）。</span></span><br><span class="line"><span class="comment">我们自己在本地调用那肯定很方便，创建一个UserService类对象，直接调用Login_Local方法即可</span></span><br><span class="line"><span class="comment">可是，如果现在有另外一个进程或者另外一台机器想调用我们这个方法怎么办呢？所以我们就要结合谷歌protobuf提供给我们的工具了</span></span><br><span class="line"><span class="comment">这个文件写的就是rpc服务提供者文件，我们在别人想要调用这个本地方法之前需要做哪些基础工作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1、proto文件经过protobuf编译后生成了UserServiceRpc类</span></span><br><span class="line"><span class="comment">2、我们需要在userservice.cpp文件里对这个类里的方法进行重写</span></span><br><span class="line"><span class="comment">3、注意：message会变为类的成员，service会生成一个类，service里的内容会生成方法</span></span><br><span class="line"><span class="comment">4、现在的问题就是：我们重写过后，远方是怎么调用的呢？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Userservice</span> : <span class="keyword">public</span> fixbug::UserServiceRpc   <span class="comment">// 使用在rpc服务发布端（rpc服务提供者）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Login_local</span><span class="params">(std::string name, std::string pwd)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doing local service: Login&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; pwd:&quot;</span> &lt;&lt; pwd;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，作用过程是这样的，当远端将请求发送过来，先会被我们的rpc框架接受，我们rpc框架根据接收到的参数，函数名等数据</span></span><br><span class="line">    <span class="comment">// 匹配到了我们重写的这个函数，然后调用了这个函数。</span></span><br><span class="line">    <span class="comment">// 所以这一块不属于框架的代码，是我们要使用这个框架必须自己写的代码，实现自己需要的功能。</span></span><br><span class="line">    <span class="comment">// 现在的问题是，我callee端收到了参数和函数名，怎么匹配的呢？</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Login_rpc</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> ::fixbug::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::fixbug::LoginResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::google::protobuf::Closure* done)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 框架给业务上报了请求参数LoginRequest，应用获取相应数据做本地业务</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string pwd = request-&gt;<span class="built_in">pwd</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做本地业务</span></span><br><span class="line">        <span class="type">bool</span> login_result = <span class="built_in">Login_local</span>(name, pwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把响应写入，包括错误码、错误消息、返回值。我们不需要管序列化与反序列化，这个是框架来做的</span></span><br><span class="line">        fixbug::ResultCode *code = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        code-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        code-&gt;<span class="built_in">set_errmsg</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(login_result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，我们可以跳进::google::protobuf::Closure类去看看，里面的run是纯虚函数，需要我们进行重新写，那么run应该实现什么功能呢？</span></span><br><span class="line">        <span class="comment">// 其实就是执行响应对象数据的序列化与网络发送</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    总结一下，初始准备步骤：</span></span><br><span class="line"><span class="comment">    写proto文件 ------》继承生成的类，重写类里的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Mprpc框架基础类设计"><a href="#Mprpc框架基础类设计" class="headerlink" title="Mprpc框架基础类设计"></a>Mprpc框架基础类设计</h4><p>这一节我们从服务发布方的需求出发，比如我需要发布一个rpc服务，我需要做什么？我们考虑思路是这样的：假设现在框架写好了，当远端将请求发送过来，先会被我们的rpc框架接受，我们rpc框架根据接收到的参数，函数名等数据。匹配到了我们重写的这个函数，然后调用了这个函数。所以这一块不属于框架的代码，是我们要使用这个框架必须自己写的代码，实现自己需要的功能。<strong>现在的问题是，我callee端收到了参数和函数名，怎么匹配的呢？</strong></p>
<p>我们现在做好了服务发布方的基础工作，我们现在需要思考一个问题：我怎么能让别人想用我们写的rpc框架呢？答案只有一个，就是越简单越好。</p>
<ol>
<li>先进行框架初始化操作</li>
<li>框架里提供了用于发布服务的类</li>
</ol>
<p>这一节更新的文件如下</p>
<p>新加入src&#x2F;include&#x2F;mprpcapplication.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责框架的初始化操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MprpcApplication</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> MprpcApplication &amp;<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">MprpcApplication</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>(<span class="type">const</span> MprpcApplication&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>(MprpcApplication&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新加入src&#x2F;include&#x2F;mprpcprovider.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架提供的专门服务发布rpc服务的网络对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个是框架提供给外部使用的，可以发布rpc方法的函数接口 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新加入src&#x2F;mprpcapplication.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcApplication::Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MprpcApplication &amp;<span class="title">MprpcApplication::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> MprpcApplication app;</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新加入src&#x2F;mprpcprovider.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新了example&#x2F;callee&#x2F;userservice.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我个人觉得这个项目应该从这里开始讲解，我们现在本地有一个用户登录Login_Local方法（隶属于UserService类）。</span></span><br><span class="line"><span class="comment">我们自己在本地调用那肯定很方便，创建一个UserService类对象，直接调用Login_Local方法即可</span></span><br><span class="line"><span class="comment">可是，如果现在有另外一个进程或者另外一台机器想调用我们这个方法怎么办呢？所以我们就要结合谷歌protobuf提供给我们的工具了</span></span><br><span class="line"><span class="comment">这个文件写的就是rpc服务提供者文件，我们在别人想要调用这个本地方法之前需要做哪些基础工作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1、proto文件经过protobuf编译后生成了UserServiceRpc类</span></span><br><span class="line"><span class="comment">2、我们需要在userservice.cpp文件里对这个类里的方法进行重写</span></span><br><span class="line"><span class="comment">3、注意：message会变为类的成员，service会生成一个类，service里的内容会生成方法</span></span><br><span class="line"><span class="comment">4、现在的问题就是：我们重写过后，远方是怎么调用的呢？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;/home/zcl/mprpc_zcl/src/include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;/home/zcl/mprpc_zcl/src/include/mprpcprovider.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> : <span class="keyword">public</span> fixbug::UserServiceRpc   <span class="comment">// 使用在rpc服务发布端（rpc服务提供者）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Login_local</span><span class="params">(std::string name, std::string pwd)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doing local service: Login&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; pwd:&quot;</span> &lt;&lt; pwd;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，作用过程是这样的，当远端将请求发送过来，先会被我们的rpc框架接受，我们rpc框架根据接收到的参数，函数名等数据</span></span><br><span class="line">    <span class="comment">// 匹配到了我们重写的这个函数，然后调用了这个函数。</span></span><br><span class="line">    <span class="comment">// 所以这一块不属于框架的代码，是我们要使用这个框架必须自己写的代码，实现自己需要的功能。</span></span><br><span class="line">    <span class="comment">// 现在的问题是，我callee端收到了参数和函数名，怎么匹配的呢？</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Login_rpc</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> ::fixbug::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::fixbug::LoginResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::google::protobuf::Closure* done)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 框架给业务上报了请求参数LoginRequest，应用获取相应数据做本地业务</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string pwd = request-&gt;<span class="built_in">pwd</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做本地业务</span></span><br><span class="line">        <span class="type">bool</span> login_result = <span class="built_in">Login_local</span>(name, pwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把响应写入，包括错误码、错误消息、返回值。我们不需要管序列化与反序列化，这个是框架来做的</span></span><br><span class="line">        fixbug::ResultCode *code = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        code-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        code-&gt;<span class="built_in">set_errmsg</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(login_result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，我们可以跳进::google::protobuf::Closure类去看看，里面的run是纯虚函数，需要我们进行重新写，那么run应该实现什么功能呢？</span></span><br><span class="line">        <span class="comment">// 其实就是执行响应对象数据的序列化与网络发送</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    总结一下，初始准备步骤：</span></span><br><span class="line"><span class="comment">    写proto文件 ------》继承生成的类，重写类里的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们现在做好了服务发布方的基础工作，我们现在需要思考一个问题：我怎么能让别人想用我们写的rpc框架呢？答案只有一个，就是越简单越好。</span></span><br><span class="line"><span class="comment">1、先进行框架初始化操作</span></span><br><span class="line"><span class="comment">2、框架里提供了用于发布服务的类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="comment">// argc和argv是写ip地址和端口号配置文件这些的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用框架的初始化操作</span></span><br><span class="line">    MprpcApplication::<span class="built_in">Init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// provider是一个rpc网络服务对象。把UserService对象发布到rpc节点上</span></span><br><span class="line">    <span class="comment">// 可能会有很多用户同时使用Rpcprovider，所以这一块必须做到高并发，使用muduo网络库</span></span><br><span class="line">    RpcProvider provider;</span><br><span class="line">    provider.<span class="built_in">NotifyService</span>(<span class="keyword">new</span> <span class="built_in">UserService</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个rpc服务发布节点, Run以后，进程进入阻塞状态，等待远程的rpc调用请求</span></span><br><span class="line">    provider.<span class="built_in">Run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Mprpc框架项目动态库编译"><a href="#Mprpc框架项目动态库编译" class="headerlink" title="Mprpc框架项目动态库编译"></a>Mprpc框架项目动态库编译</h4><p>在init的时候，我们希望用户的输入是这样的：.&#x2F;provider -i config.conf（config.conf是配置文件，自动读取网络服务器和配置中心的ip地址和端口号）。</p>
<p>这节涉及到一个函数：int getopt(int argc, char * const argv[], const char *optstring); 我先给出这个函数的详细解释，方便解读下面的代码</p>
<p>首先，让我们看看<code>getopt</code>函数：</p>
<p><code>getopt</code>函数用于解析命令行参数。其原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getopt</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[], <span class="type">const</span> <span class="type">char</span> *optstring)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>argc</code>和<code>argv</code>是从<code>main</code>函数传递过来的命令行参数数量和参数值。</li>
<li><code>optstring</code>是一个字符串，表示我们期望的选项。例如，如果我们期望一个<code>-i</code>选项，那么<code>optstring</code>就会是<code>&quot;i:&quot;</code>。冒号表示<code>-i</code>后面必须跟一个参数值。</li>
</ul>
<p>函数每次调用都会返回一个字符，这个字符表示被解析到的选项。如果选项后面跟有参数值（如<code>-i value</code>），那么这个值可以通过<code>optarg</code>全局变量获得。当所有选项都被解析完毕后，<code>getopt</code>返回-1。</p>
<p>现在，让我们回到你的代码片段：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;i:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>while</code>循环的目的是持续解析命令行参数，直到所有选项都被解析完毕。</p>
<ul>
<li><p><code>c = getopt(argc, argv, &quot;i:&quot;)</code>：这里，<code>getopt</code>被调用，并返回值赋给<code>c</code>。如果有<code>-i</code>选项，<code>c</code>会等于字符<code>&#39;i&#39;</code>。</p>
</li>
<li><p><code>c != -1</code>：这个条件检查<code>c</code>是否不等于-1。如果<code>c</code>等于-1，那么说明所有选项都已经被解析完毕，<code>while</code>循环结束。</p>
</li>
</ul>
<p>在<code>while</code>循环的内部，你可能会基于<code>c</code>的值做一些操作，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">        <span class="comment">// do something with optarg, which contains the value after -i</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// possibly handle other options</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">        <span class="comment">// handle unknown option</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简而言之，这个代码片段用<code>getopt</code>函数在命令行参数中寻找<code>-i</code>选项，并将找到的值存储在<code>optarg</code>中。</p>
<p>在使用 <code>getopt</code> 函数来解析命令行参数时，你可能会遇到几种特定的返回值。当你在 <code>optstring</code> 中指定了一个选项后跟冒号（如 “i:”），这意味着该选项需要一个参数。</p>
<p>对于 <code>getopt</code> 的返回值：</p>
<ul>
<li>如果一个选项被发现，并且它有一个关联的参数（例如 <code>-i &lt;value&gt;</code>），那么 <code>getopt</code> 返回该选项字符。</li>
<li>如果一个选项被发现，但它缺少一个关联的参数（例如仅仅 <code>-i</code> 而没有后续值），并且在 <code>optstring</code> 中该选项后面有一个冒号，那么 <code>getopt</code> 返回 <code>&#39;:&#39;</code>。</li>
<li>如果找到一个不在 <code>optstring</code> 中的选项，或者找到一个不应有参数但却有参数的选项，那么 <code>getopt</code> 返回 <code>&#39;?&#39;</code>。</li>
</ul>
<p>所以，<code>case &#39;:&#39;</code> 在 <code>switch</code> 语句中处理的是缺少参数的选项情况。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;i:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">            <span class="comment">// handle the -i option with its argument in optarg</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:  <span class="comment">// Missing option argument</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Option -%c requires an argument.\n&quot;</span>, optopt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:  <span class="comment">// Unknown option</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unknown option: -%c\n&quot;</span>, optopt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，如果用户只输入 <code>-i</code> 而没有提供参数，程序将输出 “Option -i requires an argument.”。</p>
<p>新加入src&#x2F;CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="keyword">add_library</span>(mprpc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)  <span class="comment"># 创建一个动态库，方便用户调用</span></span><br></pre></td></tr></table></figure>

<p>更新example&#x2F;callee&#x2F;CMakeLists</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(SRC_LIST userservice.cpp ../user.pb.cc)</span><br><span class="line"><span class="keyword">add_executable</span>(provider <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(provider mprpc protobuf)	<span class="comment"># 链接我们上面创建的mprpc动态库和protobuf库</span></span><br></pre></td></tr></table></figure>

<p>更新mprpcapplication.cpp文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showArgHelp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;format: command -i &lt;configfile&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcApplication::Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">showArgHelp</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    std::string config_file;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;i:&quot;</span>)) != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">                config_file = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;invalid args!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">showArgHelp</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);	<span class="comment">// 配置文件都没加载进来就不要break啦，直接退出运行吧</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;need config_file&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">showArgHelp</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始加载配置文件了 rpcserver_ip=  rpcserver_port=    zookeeper_ip=   zookeeper_port=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MprpcApplication &amp;<span class="title">MprpcApplication::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> MprpcApplication app;</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Mprpc配置文件的加载（一）"><a href="#Mprpc配置文件的加载（一）" class="headerlink" title="Mprpc配置文件的加载（一）"></a>Mprpc配置文件的加载（一）</h4><p>这一节我们主要讲的是如何加载配置文件，换句话说就是解析配置文件。首先我们规定了配置文件的标准格式，如下所示：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rpc节点的ip地址</span></span><br><span class="line">rpcserverip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># rpc节点的port端口号</span></span><br><span class="line">rpcserverport = <span class="number">8000</span></span><br><span class="line"><span class="comment"># zk的IP地址</span></span><br><span class="line">zookeeperip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># zk的port端口号</span></span><br><span class="line">zookeeperport = <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p>这一节引入了MprpcConfig类，我们考虑两部分：解析配置文件 + 查询配置信息。一个自然而然要思考的问题就是如何查询配置信息呢？我们这里考虑的是通过一个map映射即通过键找值。具体如何操作看代码就能了解了。</p>
<p>新加入配置文件&#x2F;bin&#x2F;test.conf</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rpc节点的ip地址</span></span><br><span class="line">rpcserverip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># rpc节点的port端口号</span></span><br><span class="line">rpcserverport = <span class="number">8000</span></span><br><span class="line"><span class="comment"># zk的IP地址</span></span><br><span class="line">zookeeperip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># zk的port端口号</span></span><br><span class="line">zookeeperport = <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p>新加入&#x2F;src&#x2F;include&#x2F;mprpcconfig.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MprpcConfig</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 负责解析加载配置文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *config_file)</span></span>;</span><br><span class="line">    <span class="comment">// 查询配置项信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 每解析到一组ip---port，就insert进m_configMap</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; m_configMap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新加入&#x2F;src&#x2F;mprpcconfig.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcconfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责解析加载配置文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcConfig::loadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *config_file)</span></span>&#123;</span><br><span class="line">    FILE *pf = <span class="built_in">fopen</span>(config_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(pf == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; config_file &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、注释 2、正确的配置项通过=判断 3、去掉开头多余的空格</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">feof</span>(pf))&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">fgets</span>(buf, <span class="number">512</span>, pf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串前面的空格</span></span><br><span class="line">        <span class="comment">// 转换成字符串便于后续操作，因为字符串里有很多函数</span></span><br><span class="line">        <span class="function">std::string <span class="title">src_buf</span><span class="params">(buf)</span></span>;</span><br><span class="line">        <span class="type">int</span> idx = src_buf.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// 说明字符串前面有空格</span></span><br><span class="line">            src_buf = src_buf.<span class="built_in">substr</span>(idx, src_buf.<span class="built_in">size</span>() - idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉字符串后面多余的空格</span></span><br><span class="line">        idx = src_buf.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx != <span class="number">-1</span>)&#123;</span><br><span class="line">            src_buf = src_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断#的注释</span></span><br><span class="line">        <span class="keyword">if</span>(src_buf[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || src_buf.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析配置项</span></span><br><span class="line">        idx = src_buf.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// 配置项不合法</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::string key;</span><br><span class="line">        std::string value;</span><br><span class="line">        key = src_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        value = src_buf.<span class="built_in">substr</span>(idx + <span class="number">1</span>, src_buf.<span class="built_in">size</span>() - idx);</span><br><span class="line">        m_configMap.<span class="built_in">insert</span>(&#123;key, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询配置项信息</span></span><br><span class="line"><span class="function">std::string <span class="title">MprpcConfig::load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_configMap.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(it == m_configMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新&#x2F;src&#x2F;include&#x2F;mprpcapplication.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责框架的初始化操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcconfig.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MprpcApplication</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> MprpcApplication &amp;<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> MprpcConfig m_config;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>(<span class="type">const</span> MprpcApplication&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>(MprpcApplication&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更新&#x2F;src&#x2F;mprpcapplication.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MprpcConfig MprpcApplication::m_config;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showArgHelp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;format: command -i &lt;configfile&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcApplication::Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">showArgHelp</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    std::string config_file;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;i:&quot;</span>)) != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">                config_file = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                <span class="built_in">showArgHelp</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">                <span class="built_in">showArgHelp</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始加载配置文件了 rpcserver_ip=  rpcserver_port=    zookeeper_ip=   zookeeper_port=</span></span><br><span class="line">    <span class="comment">// 这是我们规定的配置文件的标准格式，因为我们后面解析的配置文件也是这个格式</span></span><br><span class="line">    m_config.<span class="built_in">loadConfigFile</span>(config_file.<span class="built_in">c_str</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rpcserverip:&quot;</span> &lt;&lt; m_config.<span class="built_in">load</span>(<span class="string">&quot;reserverip&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rpcserverport:&quot;</span> &lt;&lt; m_config.<span class="built_in">load</span>(<span class="string">&quot;reserverport&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;zookeeperip:&quot;</span> &lt;&lt; m_config.<span class="built_in">load</span>(<span class="string">&quot;zookeeperip&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;zookeeperport:&quot;</span> &lt;&lt; m_config.<span class="built_in">load</span>(<span class="string">&quot;zookeeperport&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MprpcApplication &amp;<span class="title">MprpcApplication::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> MprpcApplication app;</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Mprpc配置文件的加载（二）"><a href="#Mprpc配置文件的加载（二）" class="headerlink" title="Mprpc配置文件的加载（二）"></a>Mprpc配置文件的加载（二）</h4><p>在上一节中好像忘记告诉大家如何编译测试代码了。不知道大家还记不记得我们的可执行文件都是放在bin目录里的，所以我们需要先进入bin目录，即cd bin&#x2F;。</p>
<p>然后为了我们就可以在终端执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./provider -i test.conf</span><br></pre></td></tr></table></figure>

<p>从这个编译命令就可以看出来我们为什么要把test.conf文件和provider都放在bin目录下，这样方便我们编译。然后你们可以测试一下上一节的代码，是有bug的！然后我们需要进行gdb调试，进行gdb调试的话，我们需要在最外层的CMakeLists.txt文件加一行这个代码</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE <span class="string">&quot;Debug&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>bug出现在了mprpcconfig.cpp文件里，你们自己调试一下哈，我下面给出更新后的本节所有代码</p>
<p>更新后的CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置cmake的最低版本和项目名称</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(mprpc_zcl)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb调试选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE <span class="string">&quot;Debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目可执行文件输出的路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目库文件输出路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目编译头文件搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/example)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目库文件搜索路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># src里面放的是框架代码</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># example里面放的是rpc服务的使用者和消费者，业务代码</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(example)</span><br></pre></td></tr></table></figure>

<p>更新后的&#x2F;src&#x2F;include&#x2F;mprpcconfig.h文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MprpcConfig</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 负责解析加载配置文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *config_file)</span></span>;</span><br><span class="line">    <span class="comment">// 查询配置项信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; m_configMap;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 去掉字符串前后的空格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Trim</span><span class="params">(std::string &amp;src_buf)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更新后的mprpcconfig.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcconfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责解析加载配置文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcConfig::loadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *config_file)</span></span>&#123;</span><br><span class="line">    FILE *pf = <span class="built_in">fopen</span>(config_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(pf == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; config_file &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、注释 2、正确的配置项通过=判断 3、去掉开头多余的空格</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">feof</span>(pf))&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">fgets</span>(buf, <span class="number">512</span>, pf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串前面的空格</span></span><br><span class="line">        <span class="comment">// 转换成字符串便于后续操作，因为字符串里有很多函数</span></span><br><span class="line">        <span class="function">std::string <span class="title">read_buf</span><span class="params">(buf)</span></span>;</span><br><span class="line">        <span class="built_in">Trim</span>(read_buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断#的注释</span></span><br><span class="line">        <span class="keyword">if</span>(read_buf[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || read_buf.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析配置项</span></span><br><span class="line">        <span class="type">int</span> idx = read_buf.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// 配置项不合法</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::string key;</span><br><span class="line">        std::string value;</span><br><span class="line">        key = read_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        <span class="built_in">Trim</span>(key);</span><br><span class="line">        <span class="type">int</span> endidx = read_buf.<span class="built_in">find</span>(<span class="string">&#x27;\n&#x27;</span>, idx);</span><br><span class="line">        value = read_buf.<span class="built_in">substr</span>(idx + <span class="number">1</span>, endidx - idx - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Trim</span>(value);</span><br><span class="line">        m_configMap.<span class="built_in">insert</span>(&#123;key, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询配置项信息</span></span><br><span class="line"><span class="function">std::string <span class="title">MprpcConfig::load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_configMap.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(it == m_configMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉字符串前后的空格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcConfig::Trim</span><span class="params">(std::string &amp;src_buf)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = src_buf.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(idx != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 说明字符串前面有空格</span></span><br><span class="line">        src_buf = src_buf.<span class="built_in">substr</span>(idx, src_buf.<span class="built_in">size</span>() - idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去掉字符串后面多余的空格</span></span><br><span class="line">    idx = src_buf.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(idx != <span class="number">-1</span>)&#123;</span><br><span class="line">        src_buf = src_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="开发RpcProvider的网络服务"><a href="#开发RpcProvider的网络服务" class="headerlink" title="开发RpcProvider的网络服务"></a>开发RpcProvider的网络服务</h4><p>是这样的，我们现在已经能够读取到配置文件里的信息了，包括哪些信息呢？还记得吗？来一起回顾一下：rpc服务的ip地址和port端口号，zookeeper的ip地址和port端口号。我们现在回到这个配置文件这里，我们从这个角度出发，我们读取配置文件就是为了获取rpc服务发布节点的ip地址和port端口号，我们是为了什么读取呢？是为了让客户端能够接入，能够调用我们发布的这个rpc服务方法。我们之前在mprpcapplication里说过，为了简便用户的操作，我们提供了一个RpcProvoder类来发布服务节点。所以，这节我们要做的就是通过muduo网络库让配置文件里的rpc服务节点运行起来，可以接收客户端的连接请求。Let‘s go！</p>
<p>新加入mprpcprovider.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架提供的专门服务发布rpc服务的网络对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个是框架提供给外部使用的，可以发布rpc方法的函数接口 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 组合了EventLoop</span></span><br><span class="line">    muduo::net::EventLoop m_eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的socket连接回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已建立连接用户的读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新加入mprpcprovider.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 你启动一个rpc网络服务节点，总要获取ip地址和port端口号吧</span></span><br><span class="line">    <span class="comment">// 所以这里是获取ip地址和port端口号</span></span><br><span class="line">    std::string ip = MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;m_eventLoop, address, <span class="string">&quot;RpcProvider&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 绑定连接回调和消息读写回调方法 分离了网络代码和业务代码</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">// 设置muduo库线程数量，自动分配I/O线程和工作线程</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    m_eventLoop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="RpcProvider发布服务方法（一）"><a href="#RpcProvider发布服务方法（一）" class="headerlink" title="RpcProvider发布服务方法（一）"></a>RpcProvider发布服务方法（一）</h4><p>我们想一下，我们发布的rpc服务节点运行起来阻塞着等待客户的请求连接。假设现在有一个客户端将函数及其参数全部传递过来了，框架应该怎么做匹配呢？框架怎么就能做到这个函数名就匹配这个函数呢？对，有人应该想到了，使用map。我现在的想法也是map。我们将服务与函数对应起来（回忆一下：proto文件里服务生成类，函数就是类成员函数），所以要先限定服务，在限定函数。所以我们使用map将服务函数对应起来就好了。</p>
<p>更新mprpcprovider.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架提供的专门服务发布rpc服务的网络对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个是框架提供给外部使用的，可以发布rpc方法的函数接口 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 组合了EventLoop</span></span><br><span class="line">    muduo::net::EventLoop m_eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// service服务类型信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ServiceInfo</span>&#123;</span><br><span class="line">        google::protobuf::Service *m_service; <span class="comment">// 保存服务对象</span></span><br><span class="line">        std::unordered_map&lt;std::string, <span class="type">const</span> google::protobuf::MethodDescriptor*&gt; m_methodMap; <span class="comment">// 保存服务方法</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::unordered_map&lt;std::string, ServiceInfo&gt; m_serviceMap;  <span class="comment">// 可不止一个服务类型哦，所以也要建立一个映射到不同服务的表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的socket连接回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已建立连接用户的读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更新mprpcprovider.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是框架提供给外部使用的，可以发布rpc方法的函数接口</span></span><br><span class="line"><span class="comment">这里有一个很重要的指针（protobuf提供给我们获取服务及函数的）：google::protobuf::ServiceDescriptor *pserviceDesc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line">    ServiceInfo service_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务对象的描述信息</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::ServiceDescriptor *pserviceDesc = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line">    <span class="comment">// 获取服务的名字</span></span><br><span class="line">    std::string service_name = pserviceDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">    <span class="comment">// 获取服务对象service的方法的数量</span></span><br><span class="line">    <span class="type">int</span> methodCnt = pserviceDesc-&gt;<span class="built_in">method_count</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;service_name: &quot;</span> &lt;&lt; service_name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; methodCnt; ++i)&#123;</span><br><span class="line">        <span class="comment">// 获取了服务对象指定下标的服务方法的描述（抽象描述）</span></span><br><span class="line">        <span class="type">const</span> google::protobuf::MethodDescriptor *pmethodDesc = pserviceDesc-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        std::string method_name = pmethodDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">        service_info.m_methodMap.<span class="built_in">insert</span>(&#123;method_name, pmethodDesc&#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    service_info.m_service = service;</span><br><span class="line">    m_serviceMap.<span class="built_in">insert</span>(&#123;service_name, service_info&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 你启动一个rpc网络服务节点，总要获取ip地址和port端口号吧</span></span><br><span class="line">    <span class="comment">// 所以这里是获取ip地址和port端口号</span></span><br><span class="line">    std::string ip = MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;m_eventLoop, address, <span class="string">&quot;RpcProvider&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 绑定连接回调和消息读写回调方法 分离了网络代码和业务代码</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">// 设置muduo库线程数量，自动分配I/O线程和工作线程</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    m_eventLoop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是要处理当rpc服务节点接收到来自客户端的已经序列化的请求该如何处理。首先，我们框架内部RpcProvider和RpcConsumer协商好之间通信用的protobuf数据类型，这样才方便序列化与反序列化。我们考虑将服务名+方法名作为头部字段，同时，为了防止后面的参数与下一次请求产生粘包问题，我们需要在头部字段里声明参数的大小。另外还有一个问题就是，我们如何分离出头部字段和参数字段呢？一个方法就是指明头部字段有多长。所以，我们的代码更新如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcheader.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是框架提供给外部使用的，可以发布rpc方法的函数接口</span></span><br><span class="line"><span class="comment">这里有一个很重要的指针（protobuf提供给我们获取服务及函数的）：google::protobuf::ServiceDescriptor *pserviceDesc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line">    ServiceInfo service_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务对象的描述信息</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::ServiceDescriptor *pserviceDesc = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line">    <span class="comment">// 获取服务的名字</span></span><br><span class="line">    std::string service_name = pserviceDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">    <span class="comment">// 获取服务对象service的方法的数量</span></span><br><span class="line">    <span class="type">int</span> methodCnt = pserviceDesc-&gt;<span class="built_in">method_count</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;service_name: &quot;</span> &lt;&lt; service_name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; methodCnt; ++i)&#123;</span><br><span class="line">        <span class="comment">// 获取了服务对象指定下标的服务方法的描述（抽象描述）</span></span><br><span class="line">        <span class="comment">// 注意，这里建立map表都是依据proto文件建立的！！！思考一下哦！</span></span><br><span class="line">        <span class="type">const</span> google::protobuf::MethodDescriptor *pmethodDesc = pserviceDesc-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        std::string method_name = pmethodDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">        service_info.m_methodMap.<span class="built_in">insert</span>(&#123;method_name, pmethodDesc&#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    service_info.m_service = service;</span><br><span class="line">    m_serviceMap.<span class="built_in">insert</span>(&#123;service_name, service_info&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 你启动一个rpc网络服务节点，总要获取ip地址和port端口号吧</span></span><br><span class="line">    <span class="comment">// 所以这里是获取ip地址和port端口号</span></span><br><span class="line">    std::string ip = MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;m_eventLoop, address, <span class="string">&quot;RpcProvider&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 绑定连接回调和消息读写回调方法 分离了网络代码和业务代码</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">// 设置muduo库线程数量，自动分配I/O线程和工作线程</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    m_eventLoop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!conn-&gt;<span class="built_in">connected</span>())&#123;</span><br><span class="line">        <span class="comment">// 和rpc client的连接断开了</span></span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在框架内部，RpcProvider和RpcConsumer协商好之间通信用的protobuf数据类型</span></span><br><span class="line"><span class="comment">service_name method_name args   定义proto的message类型，进行数据头的序列化与反序列化</span></span><br><span class="line"><span class="comment">                                service_name method_name args_size（args_size是为了防止粘包问题，指定参数长度）</span></span><br><span class="line"><span class="comment">16UserServiceLogin_rpc16zhang san123456</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">header_size + header_str + args_size + args_str</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr &amp;conn, muduo::net::Buffer *buffer, muduo::Timestamp)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 接收到来自客户端的请求</span></span><br><span class="line">    std::string recv_buf = buffer-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字符流中读取前四个字节的内容</span></span><br><span class="line">    <span class="type">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    recv_buf.<span class="built_in">copy</span>((<span class="type">char</span>*)&amp;header_size, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据header_size读取数据头的原始字符流，反序列化数据，得到rpc请求的详细信息</span></span><br><span class="line">    std::string rpc_header_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span>, header_size);</span><br><span class="line">    mprpc::RpcHeader rpcHeader;</span><br><span class="line">    std::string servcie_name;</span><br><span class="line">    std::string method_name;</span><br><span class="line">    <span class="type">uint32_t</span> args_size;</span><br><span class="line">    <span class="keyword">if</span>(rpcHeader.<span class="built_in">ParseFromString</span>(rpc_header_str))&#123;</span><br><span class="line">        servcie_name = rpcHeader.<span class="built_in">service_name</span>();</span><br><span class="line">        method_name = rpcHeader.<span class="built_in">method_name</span>();</span><br><span class="line">        args_size = rpcHeader.<span class="built_in">args_size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;rpc_header_str:&quot;</span> &lt;&lt; rpc_header_str &lt;&lt; <span class="string">&quot; parse error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取rpc方法参数的字符流数据</span></span><br><span class="line">    std::string args_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span> + header_size, args_size);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;header_size: &quot;</span> &lt;&lt; header_size &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rpc_header_str: &quot;</span> &lt;&lt; rpc_header_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;servcie_name: &quot;</span> &lt;&lt; servcie_name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;args_str: &quot;</span> &lt;&lt; args_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="RpcProvider响应回调实现"><a href="#RpcProvider响应回调实现" class="headerlink" title="RpcProvider响应回调实现"></a>RpcProvider响应回调实现</h4><p>回忆一下provider应该做的事，调用方法并返回response。所以这一节做的就是这个事情。注意request和response都是继承自google::protobuf::Message。</p>
<p>更新mprpcprovider.h</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架提供的专门服务发布rpc服务的网络对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个是框架提供给外部使用的，可以发布rpc方法的函数接口 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 组合了EventLoop</span></span><br><span class="line">    muduo::net::EventLoop m_eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// service服务类型信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ServiceInfo</span>&#123;</span><br><span class="line">        google::protobuf::Service *m_service; <span class="comment">// 保存服务对象</span></span><br><span class="line">        std::unordered_map&lt;std::string, <span class="type">const</span> google::protobuf::MethodDescriptor*&gt; m_methodMap; <span class="comment">// 保存服务方法</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::unordered_map&lt;std::string, ServiceInfo&gt; m_serviceMap;  <span class="comment">// 可不止一个服务类型哦，所以也要建立一个映射到不同服务的表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的socket连接回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已建立连接用户的读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Closure的回调操作，用于序列化rpc的响应和网络发送</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendRpcResponse</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, google::protobuf::Message*)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更新mprpcprovider.cpp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcheader.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是框架提供给外部使用的，可以发布rpc方法的函数接口</span></span><br><span class="line"><span class="comment">这里有一个很重要的指针（protobuf提供给我们获取服务及函数的）：google::protobuf::ServiceDescriptor *pserviceDesc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line">    ServiceInfo service_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务对象的描述信息</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::ServiceDescriptor *pserviceDesc = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line">    <span class="comment">// 获取服务的名字</span></span><br><span class="line">    std::string service_name = pserviceDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">    <span class="comment">// 获取服务对象service的方法的数量</span></span><br><span class="line">    <span class="type">int</span> methodCnt = pserviceDesc-&gt;<span class="built_in">method_count</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;service_name: &quot;</span> &lt;&lt; service_name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; methodCnt; ++i)&#123;</span><br><span class="line">        <span class="comment">// 获取了服务对象指定下标的服务方法的描述（抽象描述）</span></span><br><span class="line">        <span class="comment">// 注意，这里建立map表都是依据proto文件建立的！！！思考一下哦！</span></span><br><span class="line">        <span class="type">const</span> google::protobuf::MethodDescriptor *pmethodDesc = pserviceDesc-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        std::string method_name = pmethodDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">        service_info.m_methodMap.<span class="built_in">insert</span>(&#123;method_name, pmethodDesc&#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    service_info.m_service = service;</span><br><span class="line">    m_serviceMap.<span class="built_in">insert</span>(&#123;service_name, service_info&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 你启动一个rpc网络服务节点，总要获取ip地址和port端口号吧</span></span><br><span class="line">    <span class="comment">// 所以这里是获取ip地址和port端口号</span></span><br><span class="line">    std::string ip = MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;m_eventLoop, address, <span class="string">&quot;RpcProvider&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 绑定连接回调和消息读写回调方法 分离了网络代码和业务代码</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">// 设置muduo库线程数量，自动分配I/O线程和工作线程</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    m_eventLoop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!conn-&gt;<span class="built_in">connected</span>())&#123;</span><br><span class="line">        <span class="comment">// 和rpc client的连接断开了</span></span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在框架内部，RpcProvider和RpcConsumer协商好之间通信用的protobuf数据类型</span></span><br><span class="line"><span class="comment">service_name method_name args   定义proto的message类型，进行数据头的序列化与反序列化</span></span><br><span class="line"><span class="comment">                                service_name method_name args_size（args_size是为了防止粘包问题，指定参数长度）</span></span><br><span class="line"><span class="comment">16UserServiceLogin_rpc16zhang san123456</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">header_size + header_str + args_size + args_str</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr &amp;conn, muduo::net::Buffer *buffer, muduo::Timestamp)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 接收到来自客户端的请求</span></span><br><span class="line">    std::string recv_buf = buffer-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字符流中读取前四个字节的内容</span></span><br><span class="line">    <span class="type">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    recv_buf.<span class="built_in">copy</span>((<span class="type">char</span>*)&amp;header_size, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据header_size读取数据头的原始字符流，反序列化数据，得到rpc请求的详细信息</span></span><br><span class="line">    std::string rpc_header_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span>, header_size);</span><br><span class="line">    mprpc::RpcHeader rpcHeader;</span><br><span class="line">    std::string servcie_name;</span><br><span class="line">    std::string method_name;</span><br><span class="line">    <span class="type">uint32_t</span> args_size;</span><br><span class="line">    <span class="keyword">if</span>(rpcHeader.<span class="built_in">ParseFromString</span>(rpc_header_str))&#123;</span><br><span class="line">        servcie_name = rpcHeader.<span class="built_in">service_name</span>();</span><br><span class="line">        method_name = rpcHeader.<span class="built_in">method_name</span>();</span><br><span class="line">        args_size = rpcHeader.<span class="built_in">args_size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;rpc_header_str:&quot;</span> &lt;&lt; rpc_header_str &lt;&lt; <span class="string">&quot; parse error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取rpc方法参数的字符流数据</span></span><br><span class="line">    std::string args_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span> + header_size, args_size);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;header_size: &quot;</span> &lt;&lt; header_size &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rpc_header_str: &quot;</span> &lt;&lt; rpc_header_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;servcie_name: &quot;</span> &lt;&lt; servcie_name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;args_str: &quot;</span> &lt;&lt; args_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取servcie对象和method对象</span></span><br><span class="line">    <span class="keyword">auto</span> it = m_serviceMap.<span class="built_in">find</span>(servcie_name);</span><br><span class="line">    <span class="keyword">if</span>(it == m_serviceMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; servcie_name &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> mit = it-&gt;second.m_methodMap.<span class="built_in">find</span>(method_name);</span><br><span class="line">    <span class="keyword">if</span>(mit == it-&gt;second.m_methodMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; servcie_name &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; method_name &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    google::protobuf::Service *service = it-&gt;second.m_service;  <span class="comment">// 获取seivice对象</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::MethodDescriptor *method = mit-&gt;second; <span class="comment">// 获取method对像</span></span><br><span class="line"></span><br><span class="line">    google::protobuf::Message *request = service-&gt;<span class="built_in">GetRequestPrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line">    <span class="keyword">if</span>(!request-&gt;<span class="built_in">ParseFromString</span>(args_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;request parse error, content:&quot;</span> &lt;&lt; args_str &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    google::protobuf::Message *response = service-&gt;<span class="built_in">GetResponsePrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给下面的method方法的调用，绑定一个Closure的回调函数</span></span><br><span class="line">    google::protobuf::Closure *done = google::protobuf::<span class="built_in">NewCallback</span>&lt;RpcProvider, <span class="type">const</span> muduo::net::TcpConnectionPtr &amp;, google::protobuf::Message *&gt;(<span class="keyword">this</span>, &amp;RpcProvider::SendRpcResponse, conn, response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在框架上根据远端rpc请求，调用当前rpc节点上发布的方法</span></span><br><span class="line">    service-&gt;<span class="built_in">CallMethod</span>(method, <span class="literal">nullptr</span>, request, response, done);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Closure的回调操作，用于序列化rpc的响应和网络发送</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::SendRpcResponse</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr &amp;conn, google::protobuf::Message *response)</span></span>&#123;</span><br><span class="line">    std::string response_str;</span><br><span class="line">    <span class="keyword">if</span>(response-&gt;<span class="built_in">SerializeToString</span>(&amp;response_str))&#123; <span class="comment">// response进行序列化</span></span><br><span class="line">        <span class="comment">// 序列化成功后，通过网络把rpc方法执行的结果发送回rpc的调用方</span></span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response_str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;serialize response_str error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    conn-&gt;<span class="built_in">shutdown</span>(); <span class="comment">// 模拟http的短连接服务，由provider主动断开连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="RpcController"><a href="#RpcController" class="headerlink" title="RpcController"></a>RpcController</h4><p>为什么需要这个呢？这里我们需要注意到一个问题，举个例子，在我们的callfriendservice.cpp文件中，当我们使用完stub调用函数GetFriendlist之后，就直接开始读取response了。但你有没有想过，如果在序列化、网络发送、反序列化、函数执行等过程中产生错误了呢？那我们根本就拿不到response或者说拿到的response是错误的。RpcController可以帮助我们记录一些rpc调用过程中的状态信息。</p>
]]></content>
  </entry>
  <entry>
    <title>Zookeeper</title>
    <url>/2023/10/22/Zookeeper/</url>
    <content><![CDATA[<p>一、Zookeeper特点</p>
<ol>
<li>Zookeeper:一个领导者(Leader)，多个跟随者(Follower)组成的集群。<br>2)集群中只要有半数以上节点存活，Zookeeper集群就能正常服务。所以Zookeeper适合安装奇数台服务器。<br>3)全局数据一致:每个Server保存一份相同的数据副本， Client无论连接到哪个Server，数据都是一致的。<br>4)更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行。<br>5)数据更新原子性，一次数据更新要么成功，要么失败。<br>6)实时性，在一定时间范围内，Client能读到最新数据。</li>
</ol>
<p>二、数据结构<br>ZooKeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一棵树，每个节点称做一个ZNode。每一个ZNode默认能够存储1MB 的数据，每个ZNode都可以通过其路径唯一标识。</p>
<p>三、应用场景</p>
<p>提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等。</p>
<p>四、配置参数</p>
<p>tickTime &#x3D; 2000：通信心跳时间，Zookeeper服务器与客户端心跳时间，单位毫秒</p>
<p>initLimit &#x3D; 10：LF初始通信时限，10次心跳，也就是20s，Leader和Follower初始链接时限</p>
<p>syncLimit &#x3D; 5：LF同步通信时限，两者之间的通信时间（5s）</p>
<p>dataDir：保存Zookeeper中的数据，可以修改</p>
<p>clientPort &#x3D; 2181：客户端连接端口，通常不做修改</p>
]]></content>
  </entry>
  <entry>
    <title>echo服务器问题</title>
    <url>/2023/05/11/echo%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 5000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_IP <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set_nonblocking</span><span class="params">(<span class="type">int</span> sockfd)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> flags = <span class="built_in">fcntl</span>(sockfd, F_GETFL);</span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>(sockfd, F_SETFL, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> listen_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(listen_fd &gt;= <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;address, <span class="number">0</span>, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, SERVER_IP, &amp;address.sin_addr);</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(listen_fd, (<span class="keyword">struct</span> sockaddr*)(&amp;address), <span class="built_in">sizeof</span>(address));</span><br><span class="line">    <span class="built_in">assert</span>(ret != <span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> ret1 = <span class="built_in">listen</span>(listen_fd, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert</span>(ret1 != <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">set_nonblocking</span>(listen_fd);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> epoll_fd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">assert</span>(epoll_fd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">    ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">    ev.data.fd = listen_fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, listen_fd, &amp;ev) == <span class="number">-1</span>)&#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Failed to add file descriptor to epoll&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(epoll_fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[MAX_EVENTS];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> nfds = <span class="built_in">epoll_wait</span>(epoll_fd, events, MAX_EVENTS, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nfds; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(events[i].data.fd == listen_fd)&#123;</span><br><span class="line">                <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client;</span><br><span class="line">                <span class="type">socklen_t</span> client_len = <span class="built_in">sizeof</span>(client);</span><br><span class="line">                <span class="type">int</span> sock_fd = <span class="built_in">accept</span>(listen_fd, (<span class="keyword">struct</span> sockaddr*)(&amp;client), &amp;client_len);</span><br><span class="line">                <span class="built_in">set_nonblocking</span>(sock_fd);</span><br><span class="line">                ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                ev.data.fd = sock_fd;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, sock_fd, &amp;ev) == <span class="number">-1</span>)&#123;</span><br><span class="line">                    std::cerr &lt;&lt; <span class="string">&quot;Failed to add client socket file descriptor to epoll&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> client_fd = events[i].data.fd;</span><br><span class="line">                <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">                <span class="type">int</span> recv_size;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>((recv_size = <span class="built_in">recv</span>(client_fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;服务端接收到的消息为：&quot;</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">                    <span class="built_in">send</span>(client_fd, buf, <span class="built_in">sizeof</span>(buf), <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(recv_size == <span class="number">0</span> || (recv_size == <span class="number">-1</span> &amp;&amp; errno != EAGAIN &amp;&amp; errno != EWOULDBLOCK))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_DEL, client_fd, &amp;ev) == <span class="number">-1</span>)&#123;</span><br><span class="line">                        std::cerr &lt;&lt; <span class="string">&quot;Failed delete the client_fd&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">close</span>(client_fd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(listen_fd);</span><br><span class="line">    <span class="built_in">close</span>(epoll_fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PORT 5000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_IP <span class="string">&quot;127.0.0.1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EVENTS 5</span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">client_thread_function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> client_sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> serv_addr;</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = <span class="built_in">htons</span>(PORT);</span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, SERVER_IP, &amp;serv_addr.sin_addr);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(client_sockfd, (<span class="keyword">struct</span> sockaddr*)(&amp;serv_addr), <span class="built_in">sizeof</span>(serv_addr)))&#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Connection failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">close</span>(client_sockfd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">    <span class="built_in">strcpy</span>(buf, <span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="type">int</span> send_size = <span class="built_in">send</span>(client_sockfd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(send_size &lt; <span class="number">0</span>) std::cerr &lt;&lt; <span class="string">&quot;Error sending data: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> recv_size = <span class="built_in">recv</span>(client_sockfd, buf, send_size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(recv_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error recving data: &quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; <span class="built_in">lock</span>(mtx);</span><br><span class="line">        i += <span class="number">1</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;客户端&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;接收信息为：&quot;</span> &lt;&lt; buf &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(client_sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> thread_num = <span class="number">5</span>;</span><br><span class="line">    std::vector&lt;std::thread&gt; client_threads;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_num; ++i)&#123;</span><br><span class="line">        client_threads.<span class="built_in">push_back</span>(std::<span class="built_in">thread</span>(client_thread_function));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; t : client_threads)&#123;</span><br><span class="line">        t.<span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="运行时问题及结果截图"><a href="#运行时问题及结果截图" class="headerlink" title="运行时问题及结果截图"></a>运行时问题及结果截图</h2><p>在服务端与客户端均运行起来时，会发现程序并不能完整运行完，可能运行三条&#x2F;一条&#x2F;直接卡住，一条没有等情况，截图如下：</p>
<p><img src="%E4%B8%80%E6%9D%A1echo.png" alt="0条echo，直接卡住不动"></p>
<p>如上图所示，就显示一条echo回声消息，服务端跟客户端就都卡在这不动了。</p>
<p><img src="%E4%B8%A4%E6%9D%A1echo.png" alt="0条echo，直接卡住不动"></p>
<h2 id="解决方案（我并不清楚怎么就解决了！）"><a href="#解决方案（我并不清楚怎么就解决了！）" class="headerlink" title="解决方案（我并不清楚怎么就解决了！）"></a>解决方案（我并不清楚怎么就解决了！）</h2><p>将ET边缘触发模式改为LT水平触发模式就OK了，但从ET结果来看，程序貌似阻塞住了，但哪里会产生阻塞呢？十分不理解？还是其他问题呢（并非阻塞）？</p>
]]></content>
  </entry>
  <entry>
    <title>智能指针shared_ptr的实现</title>
    <url>/2023/07/26/shared-ptr/</url>
    <content><![CDATA[<p>我们今天来实现一个简易版的智能指针吧！拖了好久啦，以后会把vector、string的简易版也给补上，<code>gigigi</code></p>
<p>我们可以先想想<code>shared_ptr</code>最大的特点，就是当他的引用计数为0时，便会自动释放所指对象和析构。所以一个关键点就是这个引用计数怎么设置？static？不可以！static变量同属于一个类的所有对象，这样就会导致不管指的是不是同一个对象，引用计数都相同。所以我们这里决定采用一个指针来进行引用计数。具体实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">shared_ptr</span><span class="params">(T* sPtr = <span class="literal">nullptr</span>)</span>: sPtr_(sPtr)&#123;</span></span><br><span class="line">        <span class="keyword">if</span>(sPtr_)&#123;</span><br><span class="line">            useCount_ = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line">            sMutex_ = <span class="keyword">new</span> std::mutex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>()&#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)&#123;</span><br><span class="line">        useCount_ = sp.useCount_;</span><br><span class="line">        sPtr_ = sp.sPtr_;</span><br><span class="line">        sMutex_ = sp.sMutex_;</span><br><span class="line">        <span class="built_in">addUsecount</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> shared_ptr&lt;T&gt;&amp; sp)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sPtr_ != sp.sPtr_)&#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            sPtr_ = sp.sPtr_;</span><br><span class="line">            useCount_ = sp.useCount_;</span><br><span class="line">            sMutex_ = sp.sMutex_;</span><br><span class="line">            <span class="built_in">addUsecount</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()&#123;</span><br><span class="line">        <span class="keyword">return</span> *sPtr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">        <span class="keyword">return</span> sPtr_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">useCount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *useCount_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sPtr_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addUsecount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sMutex_-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        ++(*useCount_);</span><br><span class="line">        sMutex_-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">bool</span> deleteFlag = <span class="literal">false</span>;</span><br><span class="line">        sMutex_-&gt;<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(--(*useCount_) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">delete</span> useCount_;</span><br><span class="line">            <span class="keyword">delete</span> sPtr_;</span><br><span class="line">            deleteFlag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sMutex_-&gt;<span class="built_in">unlock</span>();</span><br><span class="line">        <span class="keyword">if</span>(deleteFlag)&#123;</span><br><span class="line">            <span class="keyword">delete</span> sMutex_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* useCount_;</span><br><span class="line">    T* sPtr_;</span><br><span class="line">    std::mutex* sMutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;std::string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> std::string(<span class="string">&quot;hello&quot;</span>))</span></span>;</span><br><span class="line">    shared_ptr&lt;std::string&gt; p2 = p1;</span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; p2.useCount() &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="function">shared_ptr&lt;std::string&gt; <span class="title">p3</span><span class="params">(p2)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; p3.<span class="built_in">useCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p2.<span class="built_in">useCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    p2 = p3;</span><br><span class="line">    std::cout &lt;&lt; p3.<span class="built_in">useCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; p2.<span class="built_in">useCount</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入结果图片有点问题，最近没时间弄，各位自己跑一下验证一下，有错误记得说！！！</p>
]]></content>
  </entry>
  <entry>
    <title>webServer</title>
    <url>/2023/08/23/webServer/</url>
    <content><![CDATA[<p>今天开始正式补充完善<code>webServer</code>服务器的内容！想到哪写到哪吧，回头再做整合。</p>
<h3 id="标准C库IO函数"><a href="#标准C库IO函数" class="headerlink" title="标准C库IO函数"></a>标准C库IO函数</h3><p><img src="PNG1.png"></p>
<h4 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、如何处理接收到的HTTP请求</span></span><br><span class="line"><span class="comment">2、如何填写HTTP响应</span></span><br><span class="line"><span class="comment">3、如何建立网络连接传输数据</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="HTTP请求处理"><a href="#HTTP请求处理" class="headerlink" title="HTTP请求处理"></a>HTTP请求处理</h4><p>http_conn头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">http_conn</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">http_conn</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">http_conn</span>() &#123;&#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_epollfd;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_user_count;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> so0ckaddr_in &amp;addr)</span></span>;	<span class="comment">// 初始化连接</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close_conn</span><span class="params">(<span class="type">bool</span> real_close = <span class="literal">true</span>)</span></span>;	<span class="comment">// 关闭连接，关于需要传入real_close参数的原因，后面会讲到，预留问题</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_sockfd;	<span class="comment">// 发起http请求的sockfd</span></span><br><span class="line">    sockaddr_in m_address;	<span class="comment">// 发起http请求的socket地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在http_conn类里主要设置五个对外的接口：</p>
<ul>
<li><p>初始化新接受的连接</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> sockaddr_in &amp;addr)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们会把所有事件注册到一张内核事件表上，因此定义一个内核事件就好了。static int m_epollfd;</span></span><br><span class="line"><span class="comment">同时我们会统计当前连接数，同样是使用一个静态变量，所有实例对象共享。static int m_user_count;</span></span><br><span class="line"><span class="comment">每建立一个新连接，m_user_count就会加1；</span></span><br><span class="line"><span class="comment">当我们向内核事件表注册一个事件时，我们需要考虑我们所要监听的事件类型，这里我们考虑：</span></span><br><span class="line"><span class="comment">读事件（EPOLLIN）、边沿触发模式（EPOLLET）、以及EPOLLRDHUP（检测TCP对端连接的关闭或者半关闭状态）</span></span><br><span class="line"><span class="comment">为了配合ET模式和多线程，我们需要做两个操作，第一是将所监听的文件描述符设置为非阻塞的，第二需要设置为EPOLLONESHOT类型</span></span><br><span class="line"><span class="comment">注意：我们对m_epollfd和m_user_count的初始化分别为</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> m_epollfd = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> m_user_count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>设置非阻塞函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码示例：Linux高性能服务器编程 p113</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="type">int</span> sockfd)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> old_option = <span class="built_in">fcntl</span>(sockfd, F_GETFL);  <span class="comment">// 获取文件描述符旧的状态标志</span></span><br><span class="line">    <span class="type">int</span> new_option = old_option | O_NONBLOCK;	<span class="comment">// 设置非阻塞标志</span></span><br><span class="line">    <span class="built_in">fcntl</span>(sockfd, F_SETFL, new_option);</span><br><span class="line">    <span class="keyword">return</span> old_option;	<span class="comment">// 返回文件描述符旧的状态标志，以便日后恢复该状态标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置感兴趣事件类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们在向内核事件表注册新事件的时候，需要指定自己对这个文件描述符上发生的什么事件感兴趣</span></span><br><span class="line"><span class="comment">// 可读？可写？</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addfd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd, <span class="type">bool</span> one_shot)</span></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line">    <span class="keyword">if</span>(one_shot)&#123;</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">    <span class="built_in">setnonblocking</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化函数代码实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::init</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> sockaddr_in &amp;addr)</span></span>&#123;</span><br><span class="line">	m_sockfd = sockfd;</span><br><span class="line">    m_address = addr;</span><br><span class="line">    <span class="built_in">addfd</span>(m_epollfd, sockfd, <span class="literal">true</span>);</span><br><span class="line">    m_user_count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>关闭连接</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">close_conn</span><span class="params">(<span class="type">bool</span> real_close)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们可以思考一下有关关闭连接需要涉及到哪些操作。</span></span><br><span class="line"><span class="comment">1、首先，如果一个连接关闭了，我们需要将其从内核事件表上移除</span></span><br><span class="line"><span class="comment">2、当前连接数目也会减一</span></span><br><span class="line"><span class="comment">这里我们准备先实现一个从内核事件表上移除文件描述符的函数（void removefd），在实现关闭连接</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>移除文件描述符</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">removefd</span><span class="params">(<span class="type">int</span> epollfd, <span class="type">int</span> fd)</span></span>&#123;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭连接</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">http_conn::close_conn</span><span class="params">(<span class="type">bool</span> real_close)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(real_close &amp;&amp; m_sockfd != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">removefd</span>(m_epollfd, m_sockfd);</span><br><span class="line">        m_sockfd = <span class="number">-1</span>;</span><br><span class="line">        m_user_count--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>处理客户请求</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">关于如何处理客户连接请求的问题，我们从最原始的地方出发。</span></span><br><span class="line"><span class="comment">首先，你了解一个http请求的基本格式吗？因为我们只有在了解http请求的通用格式后才知道如何对其进行解析</span></span><br><span class="line"><span class="comment">下面，我将展示一个最基本的GET请求格式</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /path/to/resource?param1=value1&amp;param2=value2 HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agnet: Mozilla/5.0 (platform; rv:geckoversion) Gecko/geckotrail Firefox/firefoxversion</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: en-US,en;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br><span class="line"><span class="comment"># 关于这个GET请求的详细解释我提一个chatgpt的解释在这，可以阅读一下</span></span><br><span class="line">下面是逐行详细解释：</span><br><span class="line">1. `GET /path/to/resource?param1=value1&amp;param2=value2 HTTP/1.1`</span><br><span class="line">   - `GET`: 这是HTTP请求的方法。`GET` 方法用于请求指定的资源。与POST相比，GET请求是只读的，并且用于获取数据而不是发送数据。</span><br><span class="line">   - `/path/to/resource`: 这是请求的资源路径，通常是文件或者其他资源的位置。</span><br><span class="line">   - `?`: 这个符号表示URL的查询部分的开始。</span><br><span class="line">   - `param1=value1&amp;param2=value2`: 这是查询字符串。在此例中，有两个参数，`param1`和`param2`，它们的值分别是`value1`和`value2`。`&amp;`符号用于分隔查询参数。</span><br><span class="line">   - `HTTP/1.1`: 表示使用的HTTP版本，这里是1.1。</span><br><span class="line"></span><br><span class="line">2. `Host: www.example.com`</span><br><span class="line">   - `Host`: 这是HTTP头的名称。它指定了请求的目标主机和域名。</span><br><span class="line">   - `www.example.com`: 请求的目标域名。</span><br><span class="line"></span><br><span class="line">3. `User-Agent: Mozilla/5.0 (platform; rv:geckoversion) Gecko/geckotrail Firefox/firefoxversion`</span><br><span class="line">   - `User-Agent`: 这是HTTP头的名称。它描述了发出请求的用户代理的类型，通常是浏览器。</span><br><span class="line">   - `Mozilla/5.0`: 这是用户代理的一般标记。虽然名为Mozilla，但它并不仅仅代表Mozilla浏览器，大多数浏览器都会以这种方式标识。</span><br><span class="line">   - `(platform; rv:geckoversion)`: 这部分提供了关于用户代理的详细信息，例如它在哪个平台上运行。</span><br><span class="line">   - `Gecko/geckotrail`: 这是Gecko渲染引擎的标识及其版本。</span><br><span class="line">   - `Firefox/firefoxversion`: 表示用户代理是Firefox浏览器，后面跟着其版本。</span><br><span class="line"></span><br><span class="line">4. `Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8`</span><br><span class="line">   - `Accept`: HTTP头名称，表示客户端可以处理的内容类型。</span><br><span class="line">   - 该头的值列出了浏览器接受的MIME类型，按照优先级排序。例如，`text/html` 表示HTML文档，而`q=0.9`表示相对优先级。</span><br><span class="line"></span><br><span class="line">5. `Accept-Language: en-US,en;q=0.5`</span><br><span class="line">   - `Accept-Language`: HTTP头名称，表示用户代理偏好的自然语言。</span><br><span class="line">   - `en-US,en`: 这指示用户代理首先希望接收美国英语的内容，其次是英语。</span><br><span class="line"></span><br><span class="line">6. `Accept-Encoding: gzip, deflate, br`</span><br><span class="line">   - `Accept-Encoding`: HTTP头名称，表示用户代理可以接受的内容编码。</span><br><span class="line">   - `gzip, deflate, br`: 这些是可以接受的编码方法，用于内容压缩。</span><br><span class="line"></span><br><span class="line">7. `Connection: keep-alive`</span><br><span class="line">   - `Connection`: HTTP头名称，表示是否持续连接。</span><br><span class="line">   - `keep-alive`: 表示浏览器希望服务器保持连接，以便于后续的请求可以复用相同的TCP连接。</span><br><span class="line"></span><br><span class="line">这个请求大体上是一个典型的HTTP GET请求，由HTTP方法、资源路径、HTTP版本、多个头字段组成。每个头字段都有其特定的语义和目的。</span><br></pre></td></tr></table></figure>

<p>现在我们知道了HTTP请求格式了，那么到底如何解析它呢？这里就要引入一种叫做“有限状态机”的方法了，有关这个方法的具体描述与实现，大家可以看我的另一篇文章。</p>
</li>
<li><p>非阻塞读操作</p>
</li>
<li><p>非阻塞写操作</p>
</li>
</ul>
<p><strong>第一个知识点：<code>iovec</code></strong></p>
<p>这里先介绍一个<code>iovec</code>结构体，因为我们在写HTTP响应的时候需要用到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>&#123;</span></span><br><span class="line">  <span class="type">ptr_t</span> iov_base;</span><br><span class="line">  <span class="type">size_t</span> iov_len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct iovec结构体，指针成员iov_base指向一个缓冲区，这个缓冲区是存放read_v所接收的数据或者write_v将要发送的数据。成员iov_len在各种情况下分别确定了接收的最大长度和实际写入的长度。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *<span class="built_in">vector</span>, <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *<span class="built_in">vector</span>, <span class="type">int</span> count)</span>;</span><br></pre></td></tr></table></figure>

<p>下面给出一个应用实例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> part1[] = <span class="string">&quot;This is from writev&quot;</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> part2 = <span class="number">65</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> part3[] = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[3];</span></span><br><span class="line">    </span><br><span class="line">    iov[<span class="number">0</span>].iov_base = part3;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="built_in">strlen</span>(part3);</span><br><span class="line">    </span><br><span class="line">    iov[<span class="number">1</span>].iov_base = part1;</span><br><span class="line">    iov[<span class="number">1</span>].iov_len = <span class="built_in">strlen</span>(part1);</span><br><span class="line">    </span><br><span class="line">    iov[<span class="number">2</span>].iov_base = &amp;part2;</span><br><span class="line">    iov[<span class="number">2</span>].iov_len = <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    </span><br><span class="line">    writev(<span class="number">1</span>, iov, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二个知识点：<code>va_list</code>, <code>vsnprintf</code></strong></p>
<p>参考链接：<a href="https://blog.csdn.net/dengzhilong_cpp/article/details/54944676">https://blog.csdn.net/dengzhilong_cpp/article/details/54944676</a></p>
<p>参考链接：<a href="https://blog.csdn.net/luliplus/article/details/124123219">https://blog.csdn.net/luliplus/article/details/124123219</a></p>
<p>以上是今天要写代码的基础知识，下面开始正式代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*写HTTP响应*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">http_conn::write</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bytes_have_send = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> bytes_to_send = m_write_idx;</span><br><span class="line">    <span class="keyword">if</span>(bytes_to_send == <span class="number">0</span>)&#123;</span><br><span class="line">        modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        temp = writev(m_sockfd, m_iv, m_iv_count);</span><br><span class="line">        <span class="keyword">if</span>(temp &lt;= <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EAGAIN)&#123;</span><br><span class="line">                modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unmap();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bytes_to_send -= temp;</span><br><span class="line">        bytes_have_send += temp;</span><br><span class="line">        <span class="keyword">if</span>(bytes_to_send &lt;= bytes_have_send)&#123;</span><br><span class="line">            unmap();</span><br><span class="line">            <span class="keyword">if</span>(m_linger)&#123;</span><br><span class="line">                init();</span><br><span class="line">                modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                                                                                                                                                           </p>
]]></content>
  </entry>
  <entry>
    <title>中缀表达式转后缀表达式</title>
    <url>/2023/08/23/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>面试时被问到了关于如何将中缀表达式转换为后缀表达式，这里总结一下转换的步骤</p>
<ol>
<li>遇到操作数，直接输出</li>
<li>栈为空时，遇到运算符，入栈</li>
<li>遇到左括号，将其入栈</li>
<li>遇到右括号，执行出栈操作，并将出栈的元素输出，直到弹出栈的是左括号，左括号不输出</li>
<li>遇到其他运算符“+”，“-”，“*”，“&#x2F;”时，弹出所有优先级大于或等于该运算符的栈顶元素，然后将该运算符入栈</li>
<li>最终将栈中的元素依次出栈，输出</li>
</ol>
<p><img src="1.png"></p>
<p>（啊！先写到这吧，为了弄个图片弄了好久）</p>
<p>参考链接：<a href="https://blog.csdn.net/y_16041527/article/details/79684188">https://blog.csdn.net/y_16041527/article/details/79684188</a></p>
]]></content>
  </entry>
  <entry>
    <title>八股文C++</title>
    <url>/2023/05/12/%E5%85%AB%E8%82%A1%E6%96%87C/</url>
    <content><![CDATA[<h5 id="你知道c-三大特性吗？那你又是否清楚他们的特点呢？"><a href="#你知道c-三大特性吗？那你又是否清楚他们的特点呢？" class="headerlink" title="你知道c++三大特性吗？那你又是否清楚他们的特点呢？"></a>你知道c++三大特性吗？那你又是否清楚他们的特点呢？</h5><p>c++三大特性分别为：封装、继承和多态</p>
<p>封装：<br>1、三个特点</p>
<p>结合性，即将属性（数据成员）和行为（成员函数）相结合</p>
<p>信息隐蔽性，利用接口机制隐蔽内部实现细节，只留下接口给外界调用</p>
<p>实现代码重用，在此举个例子解释所谓的实现代码重用：</p>
<p>例如，如果你需要在程序的多个地方进行文件读写操作，你可以创建一个名为<code>FileHandler</code>的类，将文件的打开、关闭、读取和写入等操作封装在该类中的成员函数中。然后，你可以在程序的各个地方实例化<code>FileHandler</code>对象，并调用其成员函数来执行文件操作，而不需要每次都编写打开、关闭、读取和写入的代码。</p>
<p>这种方式可以大大简化程序的编写和维护，并且当你需要对文件操作的逻辑进行修改时，只需要修改<code>FileHandler</code>类中的代码，而不需要修改所有调用该类的地方。</p>
<p>继承：</p>
<p>类的派生就是指从已有类产生新类的过程，原有类称为基类或父类，产生的新类称为子类或派生类，子类继承基类后，可以创建子类对象调用基类的函数和变量等。</p>
<p>多态：</p>
<p>多态（Polymorphism）是面向对象编程中的一个重要概念，它允许使用基类类型的指针或引用来调用派生类对象的特定方法。C++中的多态性是通过虚函数（virtual function）和动态绑定（dynamic binding）实现的。</p>
<p>在C++中，要实现多态，需要满足以下条件：</p>
<ol>
<li>基类（父类）中声明一个虚函数。</li>
<li>派生类（子类）中重写（覆盖）这个虚函数，并使用关键字<code>override</code>进行标记。</li>
</ol>
<p>例如，考虑一个基类<code>Shape</code>和两个派生类<code>Circle</code>和<code>Rectangle</code>的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a shape.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shape1 = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    Shape* shape2 = <span class="keyword">new</span> <span class="built_in">Rectangle</span>();</span><br><span class="line"></span><br><span class="line">    shape1-&gt;<span class="built_in">draw</span>();  <span class="comment">// 调用派生类的方法：Drawing a circle.</span></span><br><span class="line">    shape2-&gt;<span class="built_in">draw</span>();  <span class="comment">// 调用派生类的方法：Drawing a rectangle.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，基类<code>Shape</code>声明了一个虚函数<code>draw()</code>，并且两个派生类<code>Circle</code>和<code>Rectangle</code>分别重写了这个函数。在<code>main()</code>函数中，我们创建了两个指向基类的指针<code>shape1</code>和<code>shape2</code>，分别指向派生类<code>Circle</code>和<code>Rectangle</code>的对象。然后，通过基类指针调用<code>draw()</code>函数，由于这个函数是虚函数，实际调用的是派生类的版本，即产生了多态行为。</p>
<p>通过多态，我们可以使用统一的接口来处理不同的对象，提高了代码的灵活性和可维护性。此外，通过将基类指针或引用传递给函数或方法，我们可以在运行时确定要调用的具体实现，而不是在编译时静态地确定。</p>
<p>需要注意的是，在基类中使用关键字<code>virtual</code>来声明虚函数是很重要的，而派生类中的重写函数则使用关键字<code>override</code>进行标记，以确保正确的绑定和多态行为。</p>
<h5 id="函数体内部声明一个string变量，未进行初始化，会进行默认初始化吗？"><a href="#函数体内部声明一个string变量，未进行初始化，会进行默认初始化吗？" class="headerlink" title="函数体内部声明一个string变量，未进行初始化，会进行默认初始化吗？"></a>函数体内部声明一个string变量，未进行初始化，会进行默认初始化吗？</h5><p>在c++中，如果你在函数体内部声明一个<code>std::string</code>变量而不进行初始化，该变量会被默认初始化。对于<code>std::string</code>，默认初始化意味着会创建一个空字符串。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    <span class="comment">// ..... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>s</code> 被默认初始化为一个空字符串。当你尝试打印 <code>s</code> 或者获取 <code>s.length()</code> 时，你会发现<code>s</code>是一个空字符串。</p>
<p>注意这与内置类型如<code>int</code>、<code>float</code>等不同，这些类型如果没有明确初始化，它们的值是未定义的。</p>
<h6 id="string属于内置类型吗？"><a href="#string属于内置类型吗？" class="headerlink" title="string属于内置类型吗？"></a><span style="color:black">string属于内置类型吗？</span></h6><p>是的，<code>string</code> 类型不属于内置类型。<code>std::string</code> 是 C++ 标准库中的一个类，它是对字符数组（C 风格字符串）的封装，提供了更加方便、安全的字符串操作功能。</p>
<p>内置类型（也称为基本类型或原始类型）是编程语言中预定义的、最基本的数据类型，例如 <code>int</code>、<code>float</code>、<code>double</code>、<code>char</code> 等。这些类型通常直接映射到计算机硬件上的表示，所以操作起来非常高效。</p>
<p>相比之下，<code>std::string</code> 是一个类，其对象由多个数据成员和成员函数组成，提供了对字符串的各种操作。虽然 <code>std::string</code> 不是内置类型，但它在 C++ 中被广泛使用，因为它提供了比 C 风格字符串更方便和安全的方式来处理字符串。</p>
<h5 id="pragma-once的作用和-ifndef一样么"><a href="#pragma-once的作用和-ifndef一样么" class="headerlink" title="#pragma once的作用和#ifndef一样么"></a><code>#pragma once</code>的作用和<code>#ifndef</code>一样么</h5><p>是的，<code>#pragma once</code> 和 <code>#ifndef</code>（加上对应的 <code>#define</code> 和 <code>#endif</code>）都用于防止头文件的重复包含。它们的作用相似，但实现方式有所不同。</p>
<ol>
<li><p><code>#pragma once</code>：<br><code>#pragma once</code> 是一种编译器指令，用于确保头文件只被包含一次。当编译器遇到 <code>#pragma once</code> 时，它会记录已经包含了该头文件，从而避免重复包含。这种方法简洁易懂，只需在头文件的开头添加一行代码。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// header.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 声明和定义</span></span><br></pre></td></tr></table></figure>

<p>请注意，<code>#pragma once</code> 不是 C++ 标准的一部分，但大多数现代编译器都支持它。</p>
</li>
<li><p><code>#ifndef</code>，<code>#define</code> 和 <code>#endif</code>：<br>这是一种被称为“包含保护”的技术，通过预处理器指令来防止头文件的重复包含。首先使用 <code>#ifndef</code> 检查一个特定的宏是否已定义，如果未定义，则使用 <code>#define</code> 定义宏，并将头文件的内容包含在 <code>#ifndef</code> 和 <code>#endif</code> 之间。</p>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// header.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 声明和定义</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// HEADER_H</span></span></span><br></pre></td></tr></table></figure>

<p>这种方法是 C++ 标准的一部分，因此具有更好的可移植性。</p>
</li>
</ol>
<p>总的来说，<code>#pragma once</code> 和 <code>#ifndef</code> 都可以防止头文件的重复包含，但实现方式不同。在实际项目中，你可以根据编译器支持和代码可移植性的需求来选择其中一种方法。</p>
<p>总结一下上面的：作用是一样的，关于<code>ifndef</code>的具体细节可以去看<code>C++ primer</code>第68页的有关介绍。</p>
<h5 id="C-分离式编译"><a href="#C-分离式编译" class="headerlink" title="C++分离式编译"></a>C++分离式编译</h5><p>举例一个简单情况：</p>
<p>我在<code>Chapter6.h</code>头文件中声明了<code>fact</code>函数，在<code>fact.cpp</code>文件中定义了<code>fact</code>函数，并在<code>factMain.cpp</code>文件中使用了<code>fact</code>函数，为什么在<code>factMain.cpp</code>文件中，只需要引入<code>Chapter6.h</code>头文件就可以调用到<code>fact</code>函数，<code>Chapter6.h</code>头文件里不是只有一个声明吗？</p>
<p>解答：</p>
<p><code>Chapter6.h</code> 头文件中只有 <code>fact</code> 函数的声明。然而，这就是在 C++ 中分离声明和定义的好处。你在头文件中声明函数（告诉编译器有一个名为 <code>fact</code> 的函数存在），然后在一个源文件（例如 <code>fact.cpp</code>）中定义该函数（提供函数的具体实现）。这样，其他源文件（例如 <code>factMain.cpp</code>）可以通过包含相应的头文件来获取函数的声明，从而能够调用该函数。</p>
<p>在编译阶段，编译器会分别编译 <code>fact.cpp</code> 和 <code>factMain.cpp</code>，并生成相应的对象文件（例如 <code>fact.o</code> 和 <code>factMain.o</code>）。在 <code>fact.cpp</code> 中定义的 <code>fact</code> 函数的具体实现会在 <code>fact.o</code> 中。</p>
<p>然后在链接阶段，链接器会把所有的对象文件连接在一起，形成一个可执行文件。链接器会解决所有未解决的符号引用，例如在 <code>factMain.o</code> 中对 <code>fact</code> 函数的调用。因为 <code>fact</code> 函数在 <code>fact.o</code> 中定义了，所以链接器能够找到它，并正确地设置引用。</p>
<p>因此，尽管 <code>Chapter6.h</code> 头文件中只有 <code>fact</code> 函数的声明，但只要 <code>fact</code> 函数在其他地方被定义，那么在 <code>factMain.cpp</code> 中就可以通过包含 <code>Chapter6.h</code> 来调用 <code>fact</code> 函数。</p>
<h5 id="为什么不可以同时用const和static修饰成员函数。详细解释一下"><a href="#为什么不可以同时用const和static修饰成员函数。详细解释一下" class="headerlink" title="为什么不可以同时用const和static修饰成员函数。详细解释一下"></a>为什么不可以同时用<code>const</code>和<code>static</code>修饰成员函数。详细解释一下</h5><p>在<code>C++</code>中，<code>const</code>和<code>static</code>都可以用于修饰成员函数，但它们有不同的含义，并且不能同时应用于同一个成员函数。下面我们来详细了解一下：</p>
<ol>
<li><p><code>const</code>成员函数：如果一个成员函数被声明为<code>const</code>，那么它就不能修改对象的任何非静态数据成员或者调用任何非<code>const</code>成员函数。在<code>const</code>成员函数中，关键字<code>const</code>是在参数列表之后声明的。<code>const</code>成员函数可以被任何类型的对象调用，无论是<code>const</code>还是非<code>const</code>对象。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nonConstMethod</span><span class="params">()</span> </span>&#123; <span class="comment">/* 可以修改对象的状态 */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">constMethod</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="comment">/* 不能修改对象的状态 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>static</code> 成员函数：<code>static</code> 成员函数与类的对象无关，不需要对象就可以调用。它不能访问类的非静态成员（包括数据成员和成员函数），因为非静态成员都是与特定对象关联的，而 <code>static</code> 成员函数与任何对象都无关。</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123; <span class="comment">/* 不能访问非静态成员 */</span> &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span> </span>&#123; <span class="comment">/* 可以访问非静态成员 */</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这就是为什么不能同时用 <code>const</code> 和 <code>static</code> 修饰成员函数的原因：<code>const</code> 成员函数是基于对象的，它不能改变对象的状态，但可以访问对象的状态。而 <code>static</code> 成员函数是不基于对象的，它不能访问对象的状态。因此，<code>const</code> 和 <code>static</code> 在这里是冲突的，不能同时用于同一个成员函数。</p>
<h6 id="如果一个成员函数被声明为-const，那么它就不能修改对象的任何非静态数据成员或者调用任何非-const-成员函数。能举个例子吗？解释的更通俗一点"><a href="#如果一个成员函数被声明为-const，那么它就不能修改对象的任何非静态数据成员或者调用任何非-const-成员函数。能举个例子吗？解释的更通俗一点" class="headerlink" title="如果一个成员函数被声明为 const，那么它就不能修改对象的任何非静态数据成员或者调用任何非 const 成员函数。能举个例子吗？解释的更通俗一点"></a><span style="color:black">如果一个成员函数被声明为 const，那么它就不能修改对象的任何非静态数据成员或者调用任何非 const 成员函数。能举个例子吗？解释的更通俗一点</span></h6><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() : <span class="built_in">data</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123; ++data; &#125;  <span class="comment">// 非const成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> data; &#125;  <span class="comment">// const成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">tryToModify</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        <span class="comment">// ++data;  // 这里将导致编译错误，因为不能在const成员函数中修改非静态数据成员</span></span><br><span class="line">        <span class="comment">// increment();  // 这里也将导致编译错误，因为不能在const成员函数中调用非const成员函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个类中，<code>increment()</code> 是一个非 <code>const</code> 成员函数，它可以修改对象的状态。<code>getValue()</code> 是一个 <code>const</code> 成员函数，它不能修改对象的状态，只能返回对象的状态。</p>
<p><code>tryToModify()</code> 也是一个 <code>const</code> 成员函数，试图在其中修改 <code>data</code> 或者调用 <code>increment()</code> 都会导致编译错误，因为这些操作都会改变对象的状态，而 <code>const</code> 成员函数不允许这样做。</p>
<p>通俗来说，<code>const</code> 成员函数就像一个诺言，它承诺我不会改变对象的状态。这样，你就可以放心地把对象传给这个函数，知道这个函数不会做任何坏事。这在编程中是非常有用的，因为它可以帮助你避免一些常见的错误，并使你的代码更容易理解和维护。</p>
<h6 id="static-成员函数与类的对象无关，不需要对象就可以调用。这句话怎么理解呢？不需要对象如何调用呢？直接传参吗？能举个例子吗"><a href="#static-成员函数与类的对象无关，不需要对象就可以调用。这句话怎么理解呢？不需要对象如何调用呢？直接传参吗？能举个例子吗" class="headerlink" title="static 成员函数与类的对象无关，不需要对象就可以调用。这句话怎么理解呢？不需要对象如何调用呢？直接传参吗？能举个例子吗"></a><span style="color:black">static 成员函数与类的对象无关，不需要对象就可以调用。这句话怎么理解呢？不需要对象如何调用呢？直接传参吗？能举个例子吗</span></h6><p><code>static</code> 成员函数是与类本身相关联的，而不是与类的特定实例（即对象）相关联。因此，你不需要创建一个类的实例就可以调用 <code>static</code> 成员函数。你可以直接使用类名和作用域解析运算符 <code>::</code> 来调用 <code>static</code> 成员函数。</p>
<p>下面是一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Calling static method&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass::<span class="built_in">staticMethod</span>();  <span class="comment">// 不需要创建MyClass的实例就可以调用staticMethod</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们没有创建 <code>MyClass</code> 的实例就直接调用了 <code>staticMethod</code>。这是因为 <code>staticMethod</code> 是一个 <code>static</code> 成员函数，它与类本身相关联，而不是与类的特定实例相关联。</p>
<p>注意，<code>static</code> 成员函数不能访问类的非 <code>static</code> 成员（包括数据成员和成员函数），因为非 <code>static</code> 成员都是与特定对象关联的，而 <code>static</code> 成员函数与任何对象都无关。这也是为什么 <code>static</code> 成员函数不能有 <code>this</code> 指针的原因。</p>
<h5 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h5><p>在用户未自定义拷贝构造函数的情况下，系统会调用默认的拷贝构造函数，系统默认的拷贝构造函数执行浅拷贝。当数据成员中没有指针时，浅拷贝是可行的。</p>
<p>但当数据成员中出现指针时，如果依旧使用默认的拷贝构造函数，就会出现调用两次析构函数，造成悬空指针问题。</p>
<p>深拷贝与浅拷贝的区别就在于深拷贝会在<strong>堆内存中另外申请空间来储存数据</strong>，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。</p>
<h5 id="问了一个很愚蠢的问题：我发现在定义一个类的时候，构造函数会对private里的类似于int，string和指针等类型显式或隐式的初始化，而一些函数只给出了声明，函数为什么不用给出定义？"><a href="#问了一个很愚蠢的问题：我发现在定义一个类的时候，构造函数会对private里的类似于int，string和指针等类型显式或隐式的初始化，而一些函数只给出了声明，函数为什么不用给出定义？" class="headerlink" title="问了一个很愚蠢的问题：我发现在定义一个类的时候，构造函数会对private里的类似于int，string和指针等类型显式或隐式的初始化，而一些函数只给出了声明，函数为什么不用给出定义？"></a>问了一个很愚蠢的问题：我发现在定义一个类的时候，构造函数会对private里的类似于int，string和指针等类型显式或隐式的初始化，而一些函数只给出了声明，函数为什么不用给出定义？</h5><p>在<code>C++</code>中，类的定义通常分为两部分：声明和定义。声明是告诉编译器某个东西（例如变量、函数、类等）的存在，而定义则提供了这个东西的实际实现或分配了它的内存。</p>
<p>在类的定义中，构造函数对数据成员进行初始化，这是构造函数的主要目的。对于简单类型如<code>int</code>、<code>string</code>或者指针，可以在构造函数中显式初始化，也可以使用默认的初始化（对于类类型，调用其默认构造函数；对于内置类型，如果它们是静态存储期的对象，则进行值初始化，即初始化为0，否则不进行初始化）。</p>
<p>对于成员函数，只需要在类定义中给出声明，这是因为我们通常希望将函数的定义（实现）放在类定义之外，例如在一个<code>.cpp</code>文件中。这样可以将接口（即类的声明）与实现（即函数的定义）分离，使代码更清晰，易于理解和维护。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MyClass.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a);  <span class="comment">// 构造函数声明</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span></span>;  <span class="comment">// 成员函数声明</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyClass.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">MyClass::<span class="built_in">MyClass</span>(<span class="type">int</span> a) : <span class="built_in">data</span>(a) &#123;&#125;  <span class="comment">// 构造函数定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::foo</span><span class="params">()</span> </span>&#123;  <span class="comment">// 成员函数定义</span></span><br><span class="line">    std::cout &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，也可以直接在类定义中提供成员函数的定义。这通常在函数体很短，或者希望函数被内联（<code>inline</code>）时这样做：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a) : <span class="built_in">data</span>(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; data &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>foo</code>函数会自动被编译器视为内联函数，可以减少函数调用开销，但可能增加代码大小。</p>
<h4 id="数组不允许拷贝和赋值"><a href="#数组不允许拷贝和赋值" class="headerlink" title="数组不允许拷贝和赋值"></a>数组不允许拷贝和赋值</h4><p>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> a2[] = a;	<span class="comment">//错误，不允许使用一个数组初始化另一个数组</span></span><br><span class="line">a2 = a;			<span class="comment">//错误，不能把一个数组直接赋值给另外一个数组</span></span><br></pre></td></tr></table></figure>



<h4 id="标准库函数begin-和end"><a href="#标准库函数begin-和end" class="headerlink" title="标准库函数begin()和end()"></a>标准库函数begin()和end()</h4><p>数组毕竟不是类类型，因此这两个函数不是成员函数，正确的使用形式是把数组作为他们的参数传入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"><span class="type">int</span>* beg = <span class="built_in">begin</span>(ia);	<span class="comment">//指向ia首元素的指针</span></span><br><span class="line"><span class="type">int</span>* last = <span class="built_in">end</span>(ia);	<span class="comment">//指向ia尾元素的下一位置的指针</span></span><br></pre></td></tr></table></figure>





<h5 id="创建一个vector容器存放string类型的对象"><a href="#创建一个vector容器存放string类型的对象" class="headerlink" title="创建一个vector容器存放string类型的对象"></a>创建一个<code>vector</code>容器存放<code>string</code>类型的对象</h5><p>1、首先我们确定一下这个类要实现哪些功能，初步设计包括三个：</p>
<ul>
<li>实现<code>push_back</code>向容器尾后迭代器指定位置添加元素；</li>
<li>实现<code>size</code>获取容器中存放元素个数的功能；</li>
<li>实现<code>capacity</code>获取容器当前最大容量的功能；</li>
</ul>
<p>同时，可以想到以上三个要在<code>public</code>里实现，作为对外的接口。</p>
<p>2、要实现以上这些功能（拷贝控制函数那些后面再实现）需要哪些变量呢？</p>
<ul>
<li><p>在一开始，我们需要获得一个原始内存，在这里我们采用一个<code>allocator</code>来获得原始内存；</p>
</li>
<li><p>三个指针，分别指向<code>vector</code>容器的首元素、最后一个实际元素之后的位置、分配的内存末尾之后的位置；</p>
</li>
</ul>
<p>3、拷贝控制函数的实现需要哪些工具函数</p>
<p>为了方便各种拷贝控制函数的实现，我们需要实现一些工具函数。拿拷贝构造函数举例来说，我们需要对一个<code>vector</code>容器对象进行拷贝，在拷贝构造函数里直接调用工具函数肯定会使得整个代码结构更加清晰明朗。</p>
<ul>
<li><code>alloc_n_copy</code>：分配内存，并拷贝一个给定范围中的元素；</li>
<li><code>free</code>：销毁构造的元素并释放内存；</li>
<li><code>chk_n_alloc</code>：保证<code>StrVec</code>至少有容纳一个新元素的空间。如果没有空间添加新元素，<code>chk_n_alloc</code>会调用<code>reallocate</code>来分配更多内存；</li>
<li><code>reallocate</code>在内存用完时为<code>StrVec</code>分配新内存；</li>
</ul>
<h5 id="我决定先实现StrVec类的拷贝构造函数"><a href="#我决定先实现StrVec类的拷贝构造函数" class="headerlink" title="我决定先实现StrVec类的拷贝构造函数"></a>我决定先实现StrVec类的拷贝构造函数</h5><p>我们可以将拷贝构造函数设想为将一个vector容器里的所有string拷贝到另一个vector里面。可以简单思考一下，在实现拷贝构造函数时最先遇到的两个问题：</p>
<ul>
<li>既然我要拷贝到另外一个vector里面，那我要如何分配这个新vector的空间？</li>
<li>分配的新空间应该多大呢？</li>
</ul>
<p>在分配空间时我们需要使用到c++里的模板类allocator（后面我会给出有关介绍），</p>
<h4 id="返回类型-函数名-形参列表-const-函数体，请问这个const作用是什么"><a href="#返回类型-函数名-形参列表-const-函数体，请问这个const作用是什么" class="headerlink" title="返回类型+函数名+形参列表+const+函数体，请问这个const作用是什么"></a>返回类型+函数名+形参列表+<code>const</code>+函数体，请问这个<code>const</code>作用是什么</h4><p>在 <code>C++</code>中，函数后面的 <code>const</code> 关键字用于说明函数是一个常量成员函数。这意味着该函数不能修改它所在类的任何非静态成员变量的值。换句话说，常量成员函数不能修改对象的状态。</p>
<p>例如，考虑以下类定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        x = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>getValue()</code> 是一个常量成员函数，因为它后面有 <code>const</code> 关键字。这意味着 <code>getValue()</code> 函数不能修改 <code>MyClass</code> 对象的任何成员变量的值（在这个例子中是 <code>x</code>）。如果你尝试在 <code>getValue()</code> 函数中修改 <code>x</code> 的值，编译器会报错。</p>
<p>常量成员函数通常用于定义不应改变对象状态的操作。这有助于提高代码的安全性和易读性，因为读者可以明确知道哪些函数不会修改对象的状态。</p>
<p>另外，常量成员函数可以在常量对象上调用，非常量成员函数则不能。这使得你可以在需要保证对象不被修改的情况下，仍然可以调用其上的一些成员函数。</p>
<h5 id="常量成员函数可以在常量对象上调用，非常量成员函数则不能。这句话的意思是常量对象不能调用非常量成员函数？"><a href="#常量成员函数可以在常量对象上调用，非常量成员函数则不能。这句话的意思是常量对象不能调用非常量成员函数？" class="headerlink" title="常量成员函数可以在常量对象上调用，非常量成员函数则不能。这句话的意思是常量对象不能调用非常量成员函数？"></a>常量成员函数可以在常量对象上调用，非常量成员函数则不能。这句话的意思是常量对象不能调用非常量成员函数？</h5><p>常量对象（即被 <code>const</code> 修饰的对象）只能调用常量成员函数。这是因为常量对象一旦初始化，其值就不能再被改变。因此，为了保证常量对象的状态不被改变，编译器禁止在常量对象上调用可能会改变对象状态的非常量成员函数。</p>
<p>举一个例子，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">x</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x; &#125;    <span class="comment">// 常量成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; x = val; &#125;   <span class="comment">// 非常量成员函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">const</span> MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;   <span class="comment">// 声明一个常量对象</span></span><br><span class="line">    std::cout &lt;&lt; obj.<span class="built_in">getValue</span>() &lt;&lt; std::endl;  <span class="comment">// 合法，因为getValue是常量成员函数</span></span><br><span class="line">    obj.<span class="built_in">setValue</span>(<span class="number">20</span>);  <span class="comment">// 非法，编译错误。因为setValue是非常量成员函数，不能在常量对象上调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>obj</code> 是一个常量对象。尽管 <code>setValue()</code> 是 <code>MyClass</code> 的一个成员函数，但你不能在 <code>obj</code> 上调用它，因为 <code>setValue()</code> 可能会改变对象的状态，这违反了 <code>obj</code> 是常量的事实。但你可以在 <code>obj</code> 上调用 <code>getValue()</code>，因为它是一个常量成员函数，不会改变对象的状态。</p>
<p>总结：常量对象不能调用非常量成员函数，非常量对象可以调用常量成员函数。（<code>c++ primer p231</code>：引入<code>const</code>成员函数）</p>
<h4 id="封装定义"><a href="#封装定义" class="headerlink" title="封装定义"></a>封装定义</h4><p>封装是指保护类的成员不被随意访问的能力，通过把类的实现细节设置为<code>private</code>，我们就能完成类的封装，实现类的接口与实现分离。</p>
<p>封装的两个重要优点：</p>
<p>1、用户代码不会无意间破坏封装对象的状态；</p>
<p>2、被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码；</p>
<h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><p>类允许其他类或者函数访问它的非公有成员（私有成员），方法是将其他类或者函数定义成友元，使用关键字<code>friend</code></p>
<p>注意：</p>
<p>友元只能出现在类定义的内部，在类内出现的具体位置不受约束。友元不是类的成员，不受它所在区域访问控制级别的约束。</p>
<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>右值引用主要用来解决两个问题：</p>
<p>1、临时对象非必要的昂贵的拷贝操作</p>
<p>2、在模板函数中如何按照参数的实际类型进行转发</p>
<p>在<code>c++11</code>中所有的值必属于左值、将亡值和纯右值之一。</p>
<p>右值引用绑定了右值，让临时右值的生命周期延长了，可以利用这个特点做一些性能优化，即避免临时对象的拷贝构造和析构</p>
<p>右值引用类型既可能是左值也可能是右值，如<code>T&amp;&amp; t</code>，这里的t既可能是左值也可能是右值。如下所示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; t)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>); <span class="comment">//t是右值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>(x); <span class="comment">//t是左值</span></span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/qicosmos/p/4283455.html">贴一个超级详细的连接</a></p>
]]></content>
  </entry>
  <entry>
    <title>单例懒汉模式</title>
    <url>/2023/08/25/%E5%8D%95%E4%BE%8B%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>话不多说，直接上代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//双重检查锁定模式</span></span><br><span class="line">    <span class="comment">//这样做的目的是，如果实例已经被创建，可以避免每次加锁解锁的操作，提高性能</span></span><br><span class="line">    <span class="comment">//但看文字可能不好理解，这里给出不是双重检查锁定模式就好理解了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    static Singleton&amp; getInstance()&#123;</span></span><br><span class="line"><span class="comment">        std::lock_guard&lt;std::mutex&gt; lock(mutex_);</span></span><br><span class="line"><span class="comment">        if(instance_ == nullptr)&#123;</span></span><br><span class="line"><span class="comment">            instance_ = new Singleton();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return *instance_;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    这种写法性能非常低下，因为每次调用instance()都会加锁释放锁，而这个步骤只有在第一次new Singleton()才是有必要的。</span></span><br><span class="line"><span class="comment">    只要p被创建出来了，不管多少线程同时访问，使用if (p == nullptr) 进行判断都是足够的（只是读操作，不需要加锁），没有线程安全问题，</span></span><br><span class="line"><span class="comment">    加了锁之后反而存在性能问题。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance_ == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(instance_ == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                instance_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *instance_;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::mutex mutex_;</span><br><span class="line">    <span class="type">static</span> Singleton *instance_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::mutex Singleton::mutex_;</span><br><span class="line">Singleton* Singleton::instance_ = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>



<p><strong>问题</strong></p>
<p>构造析构为什么要私有</p>
<p>解答：</p>
<p>在单例模式中，构造函数和析构函数被设置为私有的原因是为了确保满足单例模式的核心要求：系统中某个类只能存在一个实例。</p>
<p>通过将构造函数和析构函数设为私有，我们可以确保以下几点：</p>
<ol>
<li><p><strong>外部无法实例化</strong>：由于构造函数是私有的，这意味着不能在类的外部直接创建该类的实例。这确保了实例的创建只能通过单例类提供的某些特定方法（如<code>getInstance</code>）来完成，从而控制实例的数量。</p>
</li>
<li><p><strong>禁止复制</strong>：单例模式要确保只有一个实例存在，所以我们不希望该类的对象被复制。将构造函数设为私有可以防止复制构造，但为了进一步确保不被复制，我们通常还需要禁止拷贝构造函数和拷贝赋值操作符（通过<code>= delete</code>）。</p>
</li>
<li><p><strong>外部无法销毁</strong>：将析构函数设为私有可以确保外部代码无法直接删除单例对象。通常，单例对象在程序结束时自动销毁，或者单例类提供了一个专门的方法来手动销毁它。</p>
</li>
<li><p><strong>继承控制</strong>：由于构造函数和析构函数是私有的，这也意味着这个类不能被继承（因为派生类的构造函数需要调用基类的构造函数）。</p>
</li>
</ol>
<p>综上所述，将构造函数和析构函数设为私有是为了确保满足单例模式的设计原则，即系统中该类只有一个实例，并提供对该实例的全局访问点。</p>
]]></content>
  </entry>
  <entry>
    <title>对象的优化</title>
    <url>/2023/10/22/%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>一、拷贝构造、赋值运算符重载的相关知识</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> a = <span class="number">10</span>): <span class="built_in">ma</span>(a) &#123; cout &lt;&lt; <span class="string">&quot;Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test &amp;t): <span class="built_in">ma</span>(t.ma) &#123; cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    Test&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Test &amp;t)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">        ma = t.ma;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test t1;</span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(t1)</span></span>;</span><br><span class="line">    Test t3 = t1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Test(20)显式生成临时对象 生存周期：所在的语句</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    c++编译器对于对象构造的优化：</span></span><br><span class="line"><span class="comment">    用临时对象生成新对象的时候，临时对象就不产生了，直接构造新对象就可以了。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Test t4 = <span class="built_in">Test</span>(<span class="number">20</span>); <span class="comment">// Test t4(20)没有区别的!</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    t4 = t2; <span class="comment">// t4已经存在，这是赋值</span></span><br><span class="line">    t4 = <span class="built_in">Test</span>(<span class="number">30</span>); <span class="comment">// t4.operator=(const Test &amp;t)</span></span><br><span class="line">    t4 = (Test)<span class="number">30</span>; <span class="comment">// int -&gt; Test,强制转换编译器会看有没有合适的构造函数</span></span><br><span class="line">    t4 = <span class="number">30</span>; <span class="comment">// 隐式生成临时对象 隐式类型转换，注意如果30换成一个char类型变量，那就不行了，因为没有对应的构造	  函数。</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Test *p = &amp;<span class="built_in">Test</span>(<span class="number">40</span>); <span class="comment">// p指向的是一个已经析构的临时对象</span></span><br><span class="line">    <span class="type">const</span> Test &amp;ref = <span class="built_in">Test</span>(<span class="number">50</span>);</span><br><span class="line">    <span class="comment">// 使用引用引用一个临时变量，临时变量的周期就变为了变量的生命周期</span></span><br><span class="line">    <span class="comment">// 自己思考为引用给变量起了一个别名，在引用的生命周期内，就可以继续访问这个临时变量了</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> a = <span class="number">5</span>, <span class="type">int</span> b = <span class="number">5</span>): <span class="built_in">ma</span>(a), <span class="built_in">mb</span>(b)&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test(int, int)&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">const</span> Test &amp;src): <span class="built_in">ma</span>(src.ma), <span class="built_in">mb</span>(src.mb)&#123; </span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test(const Test&amp;)&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Test &amp;src)&#123;</span><br><span class="line">        ma = src.ma;</span><br><span class="line">        mb = src.mb;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator=&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123; cout &lt;&lt; <span class="string">&quot;~Test()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> ma;</span><br><span class="line">    <span class="type">int</span> mb;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;  <span class="comment">//1. Test(int , int)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;  <span class="comment">//3. Test(int , int)</span></span><br><span class="line">    Test t3 = t2; <span class="comment">// 4.Test(const Test&amp;)</span></span><br><span class="line">    <span class="type">static</span> Test t4 = <span class="built_in">Test</span>(<span class="number">30</span>, <span class="number">30</span>); <span class="comment">//5. Test(int, int)</span></span><br><span class="line">    t2 = <span class="built_in">Test</span>(<span class="number">40</span>, <span class="number">40</span>); <span class="comment">//6.Test(int, int), operetor=, ~Test()</span></span><br><span class="line">    t2 = (Test)(<span class="number">50</span>, <span class="number">50</span>); <span class="comment">//7.Test(int, int), operetor=, ~Test()</span></span><br><span class="line">    t2 = <span class="number">60</span>; <span class="comment">//8.Test(int, int), operetor=, ~Test()</span></span><br><span class="line">    Test *p1 = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">70</span>, <span class="number">70</span>); <span class="comment">// 9.Test(int, int),堆上需要显式释放</span></span><br><span class="line">    Test *p2 = <span class="keyword">new</span> Test[<span class="number">2</span>]; <span class="comment">// 10.Test(int, int), Test(int, int)</span></span><br><span class="line">    Test *p3 = &amp;<span class="built_in">Test</span>(<span class="number">80</span>, <span class="number">80</span>); <span class="comment">//11.Test(int, int), ~Test()</span></span><br><span class="line">    <span class="type">const</span> Test &amp;p4 = <span class="built_in">Test</span>(<span class="number">90</span>, <span class="number">90</span>); <span class="comment">//12.Test(int, int)</span></span><br><span class="line">    <span class="keyword">delete</span> p1; <span class="comment">// 13.~Test()</span></span><br><span class="line">    <span class="keyword">delete</span> []p2; <span class="comment">// 14. ~Test(), ~Test()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Test <span class="title">t5</span><span class="params">(<span class="number">100</span>, <span class="number">100</span>)</span></span>;  <span class="comment">//2. Test(int , int)</span></span><br><span class="line"><span class="comment">// 注意，t4的析构最晚，它在数据段，需要等程序结束。</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2023/05/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="tips：为什么快速排序算法把基准元素名称定义为pivot"><a href="#tips：为什么快速排序算法把基准元素名称定义为pivot" class="headerlink" title="tips：为什么快速排序算法把基准元素名称定义为pivot"></a>tips：为什么快速排序算法把基准元素名称定义为pivot</h5><p>在快速排序算法中，”<code>pivot</code>“（基准元素）是一个用来将数据集分割成两部分的元素。所有比基准元素小的元素都被放到它的左边，而所有比它大的元素都被放到它的右边。这就是为什么它被称为 “<code>pivot</code>“（枢轴），因为它在排序过程中起到了中心轴的作用，就像一个旋转门或者天平的支点那样。</p>
<p>在一次快速排序的分割操作中，我们从数组的一端开始，将所有比<code>pivot</code>小的元素放到左边，比<code>pivot</code>大的元素放到右边。这个过程称为分区操作（<code>partitioning</code>）。经过分区操作后，<code>pivot</code>元素会位于数组的某个位置，它左边的所有元素都不大于它，它右边的所有元素都不小于它，所以它就到了排序后应该在的位置。</p>
<p>然后我们可以递归地对<code>pivot</code>左边的元素和右边的元素分别进行快速排序，这样整个数组就会变得有序。</p>
<p>所以，<code>pivot</code>元素在快速排序中起到了关键的作用，它是算法的核心部分。</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>以下是一个C++的快速排序实现示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序的一次划分操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];   <span class="comment">// 选择最右边的元素作为基准元素</span></span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = low; j &lt;= high<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[j] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i+<span class="number">1</span>], arr[high]);</span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> pi = <span class="built_in">partition</span>(arr, low, high);   <span class="comment">// 执行一次划分操作</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, low, pi - <span class="number">1</span>);   <span class="comment">// 对左侧子数组递归执行快速排序</span></span><br><span class="line">        <span class="built_in">quickSort</span>(arr, pi + <span class="number">1</span>, high);  <span class="comment">// 对右侧子数组递归执行快速排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array: \n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个程序中，<code>partition</code>函数是快速排序的核心，它实现了一次划分操作。我们首先选择一个基准元素（这里选择的是数组最右侧的元素），然后将所有比基准元素小的元素移动到数组的左侧，比基准元素大的元素移动到数组的右侧。</p>
<p><code>quickSort</code>函数是一个递归函数，它首先调用<code>partition</code>函数进行一次划分操作，然后对基准元素左侧和右侧的子数组分别递归调用<code>quickSort</code>函数进行排序。这个过程会一直递归下去，直到子数组的大小为1或0，此时子数组已经是有序的，递归结束。</p>
<h5 id="在实现代码时犯了一个小错误"><a href="#在实现代码时犯了一个小错误" class="headerlink" title="在实现代码时犯了一个小错误"></a>在实现代码时犯了一个小错误</h5><p>在<code>partition</code>函数实现时，最后一步的交换过程中，应该是<code>swap(arr[i+1], arr[high])</code>，而我第一次实现时写成了<code>swap(arr[i+1], pivot)</code>。为什么这样不行呢？貌似看起来是合理的，因为我们在一开始就有语句：<code>int pivot = arr[high];</code>但是恰巧问题就是出现在了这里，因为我们要交换的是<code>vector</code>容器里的元素，我们在实现<code>int pivot = arr[high];</code>这个语句时<code>pivot</code>只是拿到了<code>arr[high]</code>的值，因此我们并没有实际交换<code>arr[i+1]</code>和<code>arr[high]</code>，所以排序后的结果肯定是错的。（因此，定义成这样<code>int&amp; pivot = arr[high]</code>，就可以这样写：<code>swap(arr[i+1], pivot)</code>）</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序是一种基于堆的排序算法。它使用了一种叫做堆的数据结构。堆有两种类型：最大堆和最小堆。最大堆的特性是父节点的值大于或等于其所有子节点的值，最小堆的特性是父节点的值小于或等于其所有子节点的值。</p>
<p>堆排序的基本步骤如下：</p>
<ol>
<li>建立最大堆：将待排序序列构造成一个最大堆，这样就能保证整个序列的最大值就是堆顶的根节点。</li>
<li>交换数据：将根节点与最后一个元素交换位置，然后断开（排除）最后一个元素。</li>
<li>重建最大堆：通过调整使剩余元素重新构成最大堆。</li>
<li>重复步骤2~3，直到整个序列有序。</li>
</ol>
<p>这里挂一个讲堆排序很好的博客，一定要耐心阅读！<a href="%5B(92%E6%9D%A1%E6%B6%88%E6%81%AF">引用链接</a> 堆排序详细图解（通俗易懂）_右大臣的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_51609435/article/details/122982075">https://blog.csdn.net/weixin_51609435/article/details/122982075</a>))</p>
<h5 id="堆排序c-实现"><a href="#堆排序c-实现" class="headerlink" title="堆排序c++实现"></a>堆排序c++实现</h5><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> n, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> largest = i;   <span class="comment">//从largest往下开始建立大根堆，暂不考虑largset往上的数据</span></span><br><span class="line">	<span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">		largest = left;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">		largest = right;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(arr[i], arr[largest]);</span><br><span class="line">		<span class="built_in">heapify</span>(arr, n, largest);    </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">		<span class="built_in">heapify</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; arr = &#123; <span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	<span class="built_in">heapSort</span>(arr);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> a : arr) &#123;</span><br><span class="line">		cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="自己初步实现时没有彻底弄明白堆排序，所以有如下这个问题"><a href="#自己初步实现时没有彻底弄明白堆排序，所以有如下这个问题" class="headerlink" title="自己初步实现时没有彻底弄明白堆排序，所以有如下这个问题"></a>自己初步实现时没有彻底弄明白堆排序，所以有如下这个问题</h5><p>为什么第一次需要</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">		<span class="built_in">heapify</span>(arr, n, i);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>而从<code>i=n-1</code>开始，就直接 <code>heapify(arr, i, 0); </code>就没有<code>i=n/2-1</code>的这个过程</p>
<p>这是因为我们在开始的时候是在创建最大堆。在创建最大堆的过程中，我们需要从最后一个非叶子节点（即 <code>n / 2 - 1</code>）开始，然后向前遍历到根节点（即 <code>0</code>），对每个节点进行下沉操作，确保其满足最大堆的性质。这是创建最大堆的过程。</p>
<p>然后，我们进入排序的步骤，每次将当前最大的元素（即堆顶元素）与当前堆的最后一个元素交换，然后断开最后一个元素（即排除最后一个元素，使堆的大小减小1），然后再将新的堆顶元素进行下沉操作，确保剩余元素还是一个最大堆。这个过程一直持续到整个堆的元素都被排除，即整个数组都被排序。</p>
<p>因此，在排序的过程中，我们不需要再从 <code>n / 2 - 1</code> 开始了，因为除了堆顶元素以外，其他元素都满足最大堆的性质，所以我们只需要将新的堆顶元素进行下沉操作即可，也就是 <code>heapify(arr, i, 0);</code>。</p>
]]></content>
  </entry>
  <entry>
    <title>日志模块设计</title>
    <url>/2023/08/25/%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p><strong>本篇文章主要参考如下文章，主要是对代码做一个较为详尽的解释</strong></p>
<p>参考链接：<a href="https://blog.csdn.net/qq_46495964/article/details/122952567">https://blog.csdn.net/qq_46495964/article/details/122952567</a></p>
<p><strong>前言：</strong><br>日志系统在程序运行中有着非常大的作用，用于记录程序的运行情况，在程序出错后查看日志，方便地定位出错的大概范围。在设计日志系统之前，先考虑一下日志需要输出什么信息呢？什么信息才是有用的信息，都知道写日志是一种对文件的<code>io</code>操作，所以尽可能避免输出没用的信息。<br><strong>有用的信息：关键变量的值、运行的位置（哪个文件、哪个函数、哪一行）、时间、线程号、进程号等等。</strong></p>
<h4 id="日志系统的设计"><a href="#日志系统的设计" class="headerlink" title="日志系统的设计"></a>日志系统的设计</h4><ol>
<li><p>日志的级别</p>
<p>在测试、调试、交付等场景需要输出不同的级别日志。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//常见的日志级别</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">LOGLEVEL</span></span><br><span class="line">&#123;</span><br><span class="line">	LOG_LEVEL_NONE,</span><br><span class="line">	LOG_LEVEL_ERROR,     <span class="comment">// error</span></span><br><span class="line">	LOG_LEVEL_WARNING,   <span class="comment">// warning</span></span><br><span class="line">	LOG_LEVEL_DEBUG,     <span class="comment">// debug</span></span><br><span class="line">	LOG_LEVEL_INFO,      <span class="comment">// info	</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>日志的输出地</p>
<p>日志输出的地方可能不同，终端、控制台、UI界面、文件等等都有。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">LOGTARGET</span></span><br><span class="line">&#123;</span><br><span class="line">	LOG_TERM      = <span class="number">0x00</span>,</span><br><span class="line">	LOG_FILE      = <span class="number">0x01</span>,</span><br><span class="line">	LOG_UI        = <span class="number">0x10</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>日志的作用域</p>
<p>日志做到什么时候都可以输出，可作用于全程序文件，考虑到多线程情况下，必须保证日志的输出需要得到线程安全的保障，所以需要一个<strong>全局且唯一的日志器</strong>。使用设计模式中的<strong>单例模式—–日志器</strong></p>
</li>
</ol>
<h4 id="C-版本的日志系统的实现"><a href="#C-版本的日志系统的实现" class="headerlink" title="C++版本的日志系统的实现"></a>C++版本的日志系统的实现</h4><p><strong>Logger.h</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这是一个基本的线程安全日志系统的头文件，其目的是为应用程序提供日志功能。以下是对这个头文件的详细解释：</span><br><span class="line"></span><br><span class="line">1. **预处理指令和宏**:</span><br><span class="line">    - `<span class="comment">#ifndef`, `#define`, 和 `#endif` 用于保证头文件只被包含一次，避免重复定义。</span></span><br><span class="line">    - `<span class="comment">#define` 宏定义了三个日志级别：`LogInfo`, `LogWarning`, 和 `LogError`。这些宏都使用了变参（`...`），允许用户为日志提供自定义的格式和参数。这些宏捕获了日志消息的来源（文件、行号和函数）并将其添加到日志队列中。</span></span><br><span class="line"></span><br><span class="line">2. **类定义：Logger**</span><br><span class="line">    - 是一个单例类，这意味着整个程序中只能有一个实例。这通过私有的默认构造函数、删除的复制构造函数和赋值运算符来实现。</span><br><span class="line">    - `GetInstance()` 方法提供了对单例实例的访问。</span><br><span class="line">    - `SetFileName()` 允许设置日志文件的名称。</span><br><span class="line">    - `Start()` 和 `Stop()` 用于启动和停止日志线程。</span><br><span class="line">    - `AddToQueue()` 是用于将新的日志消息添加到日志队列的方法。</span><br><span class="line">    - `threadfunc()` 是日志线程的工作函数，它持续从日志队列中读取消息并写入文件。</span><br><span class="line"></span><br><span class="line">3. **类的私有成员**:</span><br><span class="line">    - `filename_`: 存储日志文件的名称。</span><br><span class="line">    - `fp_`: 用于文件操作的文件指针。请注意，在所给代码中，`FILE` 的声明被注释掉了，你需要包含 `&lt;cstdio&gt;` 或者直接使用 C++ 的文件流类（如 `std::ofstream`）。</span><br><span class="line">    - `spthread_`: 一个智能指针，指向日志线程。</span><br><span class="line">    - `mutex_`: 用于保护日志队列和其他共享资源，确保多线程访问时的线程安全。</span><br><span class="line">    - `cv_`: 条件变量，用于通知日志线程有新的消息到来。</span><br><span class="line">    - `exit_`: 一个标志，指示日志线程何时退出。</span><br><span class="line">    - `queue_`: 存储待处理日志消息的队列。</span><br><span class="line"></span><br><span class="line">4. **注释**: </span><br><span class="line">    - 提供了关于该文件的基本信息，如文件名称和日期。</span><br><span class="line"></span><br><span class="line">总之，这个日志系统设计的思路是：</span><br><span class="line">1. 用户调用预定义的宏添加日志消息。</span><br><span class="line">2. 日志消息被添加到一个线程安全的队列。</span><br><span class="line">3. 一个独立的日志线程从队列中取出消息并写入文件。</span><br><span class="line"></span><br><span class="line">这种设计允许应用程序非阻塞地添加日志消息，而将I/O操作留给专门的线程，从而提高应用程序的性能。</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 日志类头文件, Logger.h</span></span><br><span class="line"><span class="comment"> *  2022.02.1</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __LOGGER_H__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LOGGER_H__</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//struct FILE;</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LogInfo(...)        Logger::GetInstance().AddToQueue(<span class="string">&quot;INFO&quot;</span>, __FILE__, __LINE__, __PRETTY_FUNCTION__, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LogWarning(...)     Logger::GetInstance().AddToQueue(<span class="string">&quot;WARNING&quot;</span>, __FILE__, __LINE__, __PRETTY_FUNCTION__, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LogError(...)       Logger::GetInstance().AddToQueue(<span class="string">&quot;ERROR&quot;</span>, __FILE__, __LINE__, __PRETTY_FUNCTION__, __VA_ARGS__)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Logger&amp; <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SetFileName</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddToQueue</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszLevel, <span class="type">const</span> <span class="type">char</span>* pszFile, <span class="type">int</span> lineNo, <span class="type">const</span> <span class="type">char</span>* pszFuncSig, <span class="type">char</span>* pszFmt, ...)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Logger</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Logger</span>(<span class="type">const</span> Logger&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    Logger&amp; <span class="keyword">operator</span> =(Logger&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">threadfunc</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string                     filename_;</span><br><span class="line">    FILE*                           fp_&#123;&#125;;</span><br><span class="line">    std::shared_ptr&lt;std::thread&gt;    spthread_;</span><br><span class="line">    std::mutex                      mutex_;</span><br><span class="line">    std::condition_variable         cv_;            <span class="comment">//有新的日志到来的标识</span></span><br><span class="line">    <span class="type">bool</span>                            exit_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    std::list&lt;std::string&gt;          queue_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//!__LOGGER_H__</span></span></span><br></pre></td></tr></table></figure>



<p>Logger.cpp</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这是日志类的实现文件`Logger.cpp`。它对`Logger.h`中定义的函数进行了具体的实现。我将分步解释这个文件的内容：</span><br><span class="line"></span><br><span class="line">1. **<span class="comment">#include语句**: 引入了所需的头文件，其中`Logger.h`是之前你展示的日志类的头文件，其他的是C和C++标准库中的头文件。</span></span><br><span class="line"></span><br><span class="line">2. **GetInstance方法**: 实现了单例模式的核心功能。通过使用局部静态对象`logger`，它确保只创建一次`Logger`类的实例。</span><br><span class="line"></span><br><span class="line">3. **SetFileName方法**: 允许用户设置日志文件的名称。</span><br><span class="line"></span><br><span class="line">4. **Start方法**: </span><br><span class="line">    - 如果用户没有提供日志文件名，它会生成一个默认的日志文件名，该文件名包含当前的日期和时间。</span><br><span class="line">    - 尝试打开日志文件以写入和读取。</span><br><span class="line">    - 创建一个新线程来处理日志消息。</span><br><span class="line"></span><br><span class="line">5. **Stop方法**: </span><br><span class="line">    - 设置`exit_`标志为`<span class="literal">true</span>`。</span><br><span class="line">    - 通过条件变量通知日志线程。</span><br><span class="line">    - 等待日志线程结束。</span><br><span class="line"></span><br><span class="line">6. **AddToQueue方法**: </span><br><span class="line">    - 使用变长参数列表格式化日志消息。</span><br><span class="line">    - 生成一个包含日期、时间、日志级别、线程ID、源文件名、行号、函数签名和日志消息的完整日志字符串。</span><br><span class="line">    - 使用互斥锁将完整的日志字符串添加到队列。</span><br><span class="line">    - 通过条件变量通知日志线程有新的消息到来。</span><br><span class="line"></span><br><span class="line">7. **threadfunc方法**:</span><br><span class="line">    - 日志线程的核心功能。</span><br><span class="line">    - 检查文件指针是否为空。</span><br><span class="line">    - 在`exit_`为`<span class="literal">false</span>`的情况下，循环处理日志消息。</span><br><span class="line">    - 使用互斥锁和条件变量等待新的消息到来。</span><br><span class="line">    - 当有新的消息时，从队列中取出并写入日志文件。</span><br><span class="line">    - 如果设置了退出标志并且队列为空，线程将退出。</span><br><span class="line"></span><br><span class="line">总体上，这是一个简单但功能完整的日志系统实现。它使用了多线程，互斥锁和条件变量来确保线程安全，并使日志操作与应用程序的其他部分异步进行，从而提高了性能。</span><br><span class="line"></span><br><span class="line">然而，也有一些可以进一步优化或改进的地方：</span><br><span class="line">1. 在`Start()`中，文件是以<span class="string">&quot;wt+&quot;</span>模式打开的，这意味着如果文件已经存在，它会被覆盖。如果希望在现有文件中追加日志，则应使用<span class="string">&quot;at+&quot;</span>。</span><br><span class="line">2. 代码中没有明确的错误处理或异常处理策略。例如，如果`fopen`失败或`std::thread`创建失败时。</span><br><span class="line">3. 在`threadfunc`中，当队列不为空时，每处理一个消息就会刷新文件，这可能影响性能。可以考虑在队列中有多个消息时，一次性写入多个消息，然后再刷新。</span><br><span class="line">4. 可能会考虑添加一个`Rotate`功能，当日志文件大小超过某个限制时，自动将当前日志文件重命名，并创建一个新的日志文件。</span><br><span class="line">5. 为了提高性能，可以考虑使用双缓冲技术，这样可以减少互斥锁的争用。</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 日志类实现文件, Logger.cpp</span></span><br><span class="line"><span class="comment"> *  2022.02.1</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">Logger&amp; <span class="title">Logger::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Logger logger;</span><br><span class="line">    <span class="keyword">return</span> logger;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::SetFileName</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    filename_ = filename;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Logger::Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (filename_.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">tm</span>* t = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line">        <span class="type">char</span> timestr[<span class="number">64</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="built_in">sprintf</span>(timestr, <span class="string">&quot;%04d%02d%02d%02d%02d%02d.imserver.log&quot;</span>, t-&gt;tm_year + <span class="number">1900</span>, t-&gt;tm_mon + <span class="number">1</span>, t-&gt;tm_mday, t-&gt;tm_hour, t-&gt;tm_min, t-&gt;tm_sec);</span><br><span class="line">        filename_ = timestr;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    fp_ = <span class="built_in">fopen</span>(filename_.<span class="built_in">c_str</span>(), <span class="string">&quot;wt+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp_ == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    spthread_.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">thread</span>(std::<span class="built_in">bind</span>(&amp;Logger::threadfunc, <span class="keyword">this</span>)));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::Stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    exit_ = <span class="literal">true</span>;</span><br><span class="line">    cv_.<span class="built_in">notify_one</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//等待时间线程结束</span></span><br><span class="line">    spthread_-&gt;<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::AddToQueue</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pszLevel, <span class="type">const</span> <span class="type">char</span>* pszFile, <span class="type">int</span> lineNo, <span class="type">const</span> <span class="type">char</span>* pszFuncSig, <span class="type">char</span>* pszFmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> msg[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    va_list vArgList;                            </span><br><span class="line">    <span class="built_in">va_start</span>(vArgList, pszFmt);</span><br><span class="line">    <span class="built_in">vsnprintf</span>(msg, <span class="number">256</span>, pszFmt, vArgList);</span><br><span class="line">    <span class="built_in">va_end</span>(vArgList);</span><br><span class="line"> </span><br><span class="line">    <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span>* tmstr = <span class="built_in">localtime</span>(&amp;now);</span><br><span class="line">    <span class="type">char</span> content[<span class="number">512</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(content, <span class="string">&quot;[%04d-%02d-%02d %02d:%02d:%02d][%s][0x%04x][%s:%d %s]%s\n&quot;</span>,</span><br><span class="line">                tmstr-&gt;tm_year + <span class="number">1900</span>,</span><br><span class="line">                tmstr-&gt;tm_mon + <span class="number">1</span>,</span><br><span class="line">                tmstr-&gt;tm_mday,</span><br><span class="line">                tmstr-&gt;tm_hour,</span><br><span class="line">                tmstr-&gt;tm_min,</span><br><span class="line">                tmstr-&gt;tm_sec,</span><br><span class="line">                pszLevel,</span><br><span class="line">                std::this_thread::<span class="built_in">get_id</span>(),</span><br><span class="line">                pszFile,</span><br><span class="line">                lineNo,</span><br><span class="line">                pszFuncSig,</span><br><span class="line">                msg);</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        queue_.<span class="built_in">emplace_back</span>(content);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    cv_.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::threadfunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fp_ == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (!exit_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//写日志</span></span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">while</span> (queue_.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (exit_)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">            cv_.<span class="built_in">wait</span>(guard);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//写日志</span></span><br><span class="line">        <span class="type">const</span> std::string&amp; str = queue_.<span class="built_in">front</span>();</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">fwrite</span>((<span class="type">void</span>*)str.<span class="built_in">c_str</span>(), str.<span class="built_in">length</span>(), <span class="number">1</span>, fp_);</span><br><span class="line">        <span class="built_in">fflush</span>(fp_);</span><br><span class="line">        queue_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ol>
<li><p>Stop方法: 设置exit_标志为true。 通过条件变量通知日志线程。 等待日志线程结束 </p>
<p><strong>请问这里为什么需要通知日志线程</strong></p>
<p>解答：在<code>Logger</code>类的实现中，日志线程的工作是从队列中获取日志消息并将其写入文件。为了实现这个功能，它在队列为空时通过<code>cv_.wait(guard)</code>进入休眠状态，等待新的日志消息的到来。</p>
<p>当你调用<code>Stop</code>方法时，你希望日志线程能够尽快结束。但有一种情况需要考虑：当<code>Stop</code>被调用时，队列可能仍然是空的，这意味着日志线程可能处于<code>cv_.wait(guard)</code>的休眠状态。</p>
<p>在这种情况下，即使你设置了<code>exit_</code>标志为<code>true</code>，日志线程仍然不会醒来检查这个标志，因为它正在等待新的日志消息到来。</p>
<p>为了确保日志线程能够醒来、检查<code>exit_</code>标志并正确地退出，你需要在<code>Stop</code>方法中通过<code>cv_.notify_one()</code>通知日志线程。这样，日志线程将被唤醒，然后它可以检查<code>exit_</code>标志，并根据该标志的值决定是否退出。</p>
<p>总之，通知日志线程是为了确保它可以从<code>cv_.wait(guard)</code>中醒来，然后检查退出条件并安全地退出。</p>
</li>
<li><p>这个程序没有设计线程来将新的日志信息加入队列吗</p>
<p>从提供的代码来看，日志系统中只设计了一个专门的日志线程（在<code>Logger::Start()</code>方法中启动），其任务是从队列中提取日志消息并将其写入文件。此外，并没有为添加新日志消息到队列专门设计线程。</p>
<p>当你希望写入日志时，只需在你的主程序或任何其他线程中调用<code>LogInfo()</code>, <code>LogWarning()</code>, 或 <code>LogError()</code>这样的宏。这些宏内部会调用<code>Logger::AddToQueue()</code>，该方法将日志消息格式化并加入到队列中。这种设计的优点是简单且高效，因为它允许多个线程在运行时无缝地向日志系统添加消息，而无需额外的线程。</p>
<p>但值得注意的是，<code>Logger::AddToQueue()</code>使用了互斥锁<code>mutex_</code>来保证多个线程同时向队列添加消息时的线程安全。这意味着，即使多个线程同时调用日志宏，<code>Logger::AddToQueue()</code>中的代码仍然是线程安全的。</p>
<p>总的来说，这个日志系统的设计考虑到了多线程环境，允许多个线程同时添加日志消息，但它并没有专门设置一个线程来完成这项任务，而是允许主程序或其他任何线程来直接调用添加日志的宏。</p>
<p>自己的话：你自己程序在运行的时候是不是有多个线程，这些线程就是负责啥时候要调用<code>LogInfo()</code>, <code>LogWarning()</code>, 或 <code>LogError()</code>这样的宏。所以当然不需要额外的线程来操作加入队列操作，只需要一个带锁函数即可。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>C++头文件保护符</title>
    <url>/2023/04/20/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="头文件保护符定义"><a href="#头文件保护符定义" class="headerlink" title="头文件保护符定义"></a>头文件保护符定义</h2><p>头文件保护符（Header guards）的主要作用是防止头文件在同一个编译单元中被多次包含。这可以避免因多次包含相同的头文件导致的编译错误，例如重复定义类、函数或变量。头文件保护符是通过使用预处理器指令 <code>#ifndef</code>、<code>#define</code> 和 <code>#endif</code> 实现的。</p>
<p><code>#define</code>: 把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否定义；</p>
<p><code>#ifdef</code>: 当且仅当变量已定义时为真；</p>
<p><code>#ifndef</code>: 当且仅当变量未定义时为真；</p>
<p>注意：<code>ifdef</code> 和 <code>ifndef</code> 一旦检查结果为真，则执行后续程序直至遇到 <code>endif</code> 为止。</p>
<h2 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h2><p>假设我们有一个名为 <code>my_class.h</code> 的头文件，其中定义了一个名为 <code>MyClass</code> 的类：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// my_class.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_CLASS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_CLASS_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print_hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// MY_CLASS_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个头文件中，我们使用了头文件保护符。<code>#ifndef MY_CLASS_H</code> 检查一个名为 <code>MY_CLASS_H</code> 的宏是否已被定义。如果尚未定义，编译器会继续处理 <code>#define MY_CLASS_H</code>，将 <code>MY_CLASS_H</code> 定义为宏，并包含 <code>MyClass</code> 的定义。<code>#endif</code> 结束了这个条件编译块。</p>
<p>现在，假设我们有一个名为 <code>main.cpp</code> 的源文件，它包含了 <code>my_class.h</code>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_class.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_class.h&quot;</span> <span class="comment">// 这里再次包含了同一个头文件，但是没有问题，因为有头文件保护符</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">print_hello</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>main.cpp</code> 中，我们包含了 <code>my_class.h</code> 头文件两次。如果没有头文件保护符，这将导致 <code>MyClass</code> 类被重复定义，从而引发编译错误。由于我们使用了头文件保护符，当第二次尝试包含 <code>my_class.h</code> 时，<code>MY_CLASS_H</code> 宏已经被定义，因此 <code>#ifndef MY_CLASS_H</code> 的条件为 false，<code>MyClass</code> 的定义不会再次被包含。</p>
<p>这个简单的例子展示了头文件保护符如何防止头文件在同一个编译单元中被多次包含，从而避免了编译错误。</p>
]]></content>
      <tags>
        <tag>C++</tag>
        <tag>include ifndef</tag>
        <tag>include define</tag>
        <tag>include endif</tag>
      </tags>
  </entry>
  <entry>
    <title>构造函数</title>
    <url>/2023/04/22/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="对象的副本"><a href="#对象的副本" class="headerlink" title="对象的副本"></a>对象的副本</h2><p>在 C++ 中，一个对象的副本是指创建了原始对象的一个拷贝，这个拷贝具有与原始对象相同的属性和状态。换句话说，副本是源对象的一个独立副本，它们的值相同，但是<code>它们在内存中占用不同的空间</code>。</p>
<p>创建对象副本的过程通常称为拷贝构造。当我们创建一个新对象时，如果使用另一个已经存在的对象作为模板，那么新对象就是原始对象的一个副本。通常，这会涉及调用拷贝构造函数。</p>
<p>以下是一个简单的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a) : <span class="built_in">x</span>(a) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) : <span class="built_in">x</span>(other.x) &#123;&#125; <span class="comment">// 拷贝构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 使用构造函数创建一个对象</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(obj1)</span></span>; <span class="comment">// 使用拷贝构造函数创建 obj1 的一个副本</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj1.x = &quot;</span> &lt;&lt; obj1.x &lt;&lt; std::endl; <span class="comment">// 输出：obj1.x = 10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj2.x = &quot;</span> &lt;&lt; obj2.x &lt;&lt; std::endl; <span class="comment">// 输出：obj2.x = 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们有一个名为 <code>MyClass</code> 的类，它具有一个整数成员变量 <code>x</code>。我们为 <code>MyClass</code> 提供了一个构造函数和一个拷贝构造函数。在 <code>main</code> 函数中，我们首先使用构造函数创建了一个名为 <code>obj1</code> 的对象，然后使用拷贝构造函数创建了 <code>obj1</code> 的一个副本，名为 <code>obj2</code>。<code>obj2</code> 是 <code>obj1</code> 的副本，因为它具有与 <code>obj1</code> 相同的属性（在这种情况下，是 <code>x</code> 的值）。</p>
<p>请注意，尽管 <code>obj1</code> 和 <code>obj2</code> 具有相同的值，但它们在内存中是独立的。这意味着更改其中一个对象的状态不会影响另一个对象。</p>
<h2 id="拷贝构造函数通常不应该是explicit的"><a href="#拷贝构造函数通常不应该是explicit的" class="headerlink" title="拷贝构造函数通常不应该是explicit的"></a>拷贝构造函数通常不应该是explicit的</h2><p>在 C++ 中，<code>explicit</code> 关键字用于指定构造函数或类型转换操作不应该进行隐式类型转换。换句话说，<code>explicit</code> 可以防止在需要显式构造的情况下发生隐式类型转换。</p>
<p>当我们说 “拷贝构造函数通常不应该是 <code>explicit</code> 的” 时，意味着拷贝构造函数应该允许隐式类型转换，以方便编译器在需要时自动执行拷贝构造。</p>
<p>拷贝构造函数允许隐式转换的原因是因为它们在很多情况下被编译器隐式调用，例如：</p>
<ol>
<li>将一个对象作为函数参数传递时。</li>
<li>从函数返回一个对象时。</li>
<li>使用赋值运算符初始化一个对象时。</li>
</ol>
<p>在这些情况下，如果拷贝构造函数被声明为 <code>explicit</code>，则可能会导致编译错误，因为编译器不能隐式调用拷贝构造函数。</p>
<p>以下是一个例子，说明为什么拷贝构造函数不应该是 <code>explicit</code> 的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> a) : <span class="built_in">x</span>(a) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">const</span> MyClass&amp; other)</span> : x(other.x) &#123;</span>&#125; <span class="comment">// explicit 拷贝构造函数（不推荐）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">some_function</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... do something ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这行代码会导致编译错误，因为拷贝构造函数是 explicit 的，编译器不能隐式调用它。</span></span><br><span class="line">    <span class="built_in">some_function</span>(obj1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们将拷贝构造函数声明为 <code>explicit</code>，这导致了编译错误。当我们尝试将 <code>obj1</code> 传递给 <code>some_function</code> 时，编译器无法隐式调用拷贝构造函数，因此会报错。为了避免这种情况，拷贝构造函数通常应该允许隐式类型转换，不应该被声明为 <code>explicit</code>。</p>
<h3 id="如果不想上面这个报错，也不去掉explicit，应该怎么做"><a href="#如果不想上面这个报错，也不去掉explicit，应该怎么做" class="headerlink" title="如果不想上面这个报错，也不去掉explicit，应该怎么做"></a>如果不想上面这个报错，也不去掉explicit，应该怎么做</h3><p>如果您希望保留 <code>explicit</code> 关键字并避免编译错误，您需要显式地调用拷贝构造函数。在这种情况下，可以使用以下方法：</p>
<ol>
<li>使用花括号 <code>&#123;&#125;</code> 或圆括号 <code>()</code> 显式地创建一个临时对象并传递给 <code>some_function</code>。</li>
<li>使用 <code>static_cast</code> 来显式地创建一个副本。</li>
</ol>
<p>以下是两种方法的示例：</p>
<p>方法 1：使用花括号 <code>&#123;&#125;</code> 或圆括号 <code>()</code> 显式地创建一个临时对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用花括号显式地调用拷贝构造函数</span></span><br><span class="line">    <span class="built_in">some_function</span>(MyClass&#123;obj1&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 或者，使用圆括号显式地调用拷贝构造函数</span></span><br><span class="line">    <span class="built_in">some_function</span>(<span class="built_in">MyClass</span>(obj1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法 2：使用 <code>static_cast</code> 来显式地创建一个副本。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 static_cast 显式地调用拷贝构造函数</span></span><br><span class="line">    <span class="built_in">some_function</span>(<span class="built_in">static_cast</span>&lt;MyClass&gt;(obj1));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这些示例中，我们显式地调用了拷贝构造函数，因此编译器不再需要隐式地调用它。这使得代码能够正常编译和运行，尽管拷贝构造函数被声明为 <code>explicit</code>。</p>
<h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a><code>static_cast</code></h4><p><code>static_cast</code> 是 C++ 中一种用于执行编译时类型转换的操作符。它可以在相关类型之间进行转换，例如将指针或引用的类型从基类转换为派生类，将枚举类型转换为整数，或在数值类型（如 int、float、double 等）之间进行转换。与 C 风格的强制类型转换相比，<code>static_cast</code> 提供了更严格的类型检查，因此更安全。</p>
<p>以下是使用 <code>static_cast</code> 的一些示例：</p>
<ol>
<li>在数值类型之间进行转换：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(i); <span class="comment">// 将 int 类型转换为 double 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将枚举类型转换为整数：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Color c = RED;</span><br><span class="line">    <span class="type">int</span> color_code = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(c); <span class="comment">// 将枚举类型转换为 int 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在类层次结构中进行向上转换（从派生类到基类）：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived *derived_ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    Base *base_ptr = <span class="built_in">static_cast</span>&lt;Base*&gt;(derived_ptr); <span class="comment">// 将 Derived* 类型转换为 Base* 类型</span></span><br><span class="line">    <span class="keyword">delete</span> derived_ptr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>static_cast</code> 不能转换无关的类型，例如将 <code>void*</code> 转换为其他类型的指针，或将非类类型转换为类类型。对于这些情况，可以使用其他类型的转换操作符，如 <code>reinterpret_cast</code> 或 <code>dynamic_cast</code>。注意：<code>double d = (int) i</code>即为C中的强制类型转换。</p>
<h4 id="static-cast-提供了更严格的类型检查是如何体现的"><a href="#static-cast-提供了更严格的类型检查是如何体现的" class="headerlink" title="static_cast 提供了更严格的类型检查是如何体现的"></a>static_cast 提供了更严格的类型检查是如何体现的</h4><p><code>static_cast</code> 提供更严格类型检查的体现主要在于它在编译时执行类型检查，而不是在运行时。这意味着，如果类型转换不安全或不正确，编译器将在编译期间发出错误或警告，而不是在运行时导致未定义行为。</p>
<p>以下是一些<code>static_cast</code>类型检查的例子：</p>
<ol>
<li><p>在数值类型之间进行转换时，<code>static_cast</code> 会检查转换是否合理。例如，将一个 <code>double</code> 转换为 <code>int</code> 会丢失小数部分，但这种转换仍然是明确的，因此编译器允许它。然而，如果转换可能导致数据损失或无法执行，编译器将发出警告或错误。</p>
</li>
<li><p>在类层次结构中进行向上转换（从派生类到基类）时，<code>static_cast</code> 会确保两个类之间存在继承关系。例如，将一个 <code>Derived*</code> 转换为 <code>Base*</code> 是允许的，前提是 <code>Derived</code> 类真正继承自 <code>Base</code> 类。如果这两个类没有继承关系，编译器将发出错误。</p>
</li>
</ol>
<p>与 C 风格的强制类型转换相比，<code>static_cast</code> 更安全，因为 C 风格的强制类型转换不会进行类型检查。例如，您可以使用 C 风格的强制类型转换将一个 <code>float</code> 指针转换为一个 <code>int</code> 指针，尽管这样做可能导致未定义行为。使用 <code>static_cast</code> 进行此类转换会导致编译错误。</p>
<p>总之，<code>static_cast</code> 在编译时进行类型检查，确保转换是明确的、安全的且合理的。这使得它比 C 风格的强制类型转换更安全。然而，应谨慎使用 <code>static_cast</code>，并且只在确信转换是安全的情况下使用，因为它仍然可能导致数据损失或其他问题，尤其是在数值类型转换和向下转换（从基类到派生类）时。在这些情况下，应考虑使用其他类型转换操作符，如 <code>dynamic_cast</code> 或 <code>reinterpret_cast</code>。</p>
<h4 id="为什么输出color-code是0呢"><a href="#为什么输出color-code是0呢" class="headerlink" title="为什么输出color_code是0呢"></a>为什么输出color_code是0呢</h4><p>在您提供的代码示例中，<code>color_code</code> 的值为 0，因为 <code>Color</code> 枚举中的 <code>RED</code> 成员被隐式地赋予了整数值 0。C++ 中的枚举成员会从 0 开始递增地分配整数值，除非您明确地为它们指定其他值。因此，在这个例子中，<code>Color</code> 枚举成员的整数值如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED, GREEN, BLUE &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>RED</code> 的值为 0</li>
<li><code>GREEN</code> 的值为 1</li>
<li><code>BLUE</code> 的值为 2</li>
</ul>
<p>当您将 <code>c</code> 赋值为 <code>RED</code> 并将其转换为 <code>int</code> 类型时，<code>color_code</code> 变量将接收整数值 0，因为这是 <code>RED</code> 枚举成员对应的值。这就是为什么 <code>color_code</code> 的输出值为 0 的原因。</p>
<h4 id="如何赋值其他值呢"><a href="#如何赋值其他值呢" class="headerlink" title="如何赋值其他值呢"></a>如何赋值其他值呢</h4><p>在 C++ 中，您可以为枚举成员显式分配整数值。为此，只需在枚举成员后使用等号 (&#x3D;) 并指定所需的整数值。以下是一个示例，说明如何为 <code>Color</code> 枚举的成员分配自定义整数值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123; RED = <span class="number">3</span>, GREEN = <span class="number">7</span>, BLUE = <span class="number">10</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们将 <code>RED</code> 的值设为 3，<code>GREEN</code> 的值设为 7，而 <code>BLUE</code> 的值设为 10。现在，当您将枚举成员转换为整数类型时，它们将具有这些显式分配的值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Color c = RED;</span><br><span class="line">    <span class="type">int</span> color_code = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(c); <span class="comment">// 将枚举类型转换为 int 类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Color code for RED: &quot;</span> &lt;&lt; color_code &lt;&lt; std::endl; <span class="comment">// 输出：Color code for RED: 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>color_code</code> 的值为 3，因为我们为 <code>RED</code> 枚举成员分配了整数值 3。</p>
<h2 id="合成拷贝构造函数和拷贝构造函数有什么不同吗"><a href="#合成拷贝构造函数和拷贝构造函数有什么不同吗" class="headerlink" title="合成拷贝构造函数和拷贝构造函数有什么不同吗"></a>合成拷贝构造函数和拷贝构造函数有什么不同吗</h2><p>拷贝构造函数和合成拷贝构造函数的主要区别在于它们的来源和行为。拷贝构造函数是用户自定义的，而合成拷贝构造函数是编译器自动生成的。</p>
<ol>
<li>拷贝构造函数（User-defined copy constructor）：<br>当您在类中显式地定义一个拷贝构造函数时，就是创建了一个用户自定义的拷贝构造函数。这意味着您可以根据需要自定义拷贝行为。例如，您可能需要执行深拷贝以避免潜在的浅拷贝问题。自定义拷贝构造函数的例子如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户自定义的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass &amp;other) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(*other.data); <span class="comment">// 深拷贝</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>合成拷贝构造函数（Synthesized copy constructor）：<br>当您没有在类中显式地定义拷贝构造函数时，编译器会自动生成一个合成拷贝构造函数。合成拷贝构造函数执行成员逐个拷贝，即：对于类类型的成员，调用其拷贝构造函数；对于内置类型的成员，直接进行值拷贝。需要注意的是，合成拷贝构造函数执行的是浅拷贝，这可能导致潜在的内存问题（例如，当类包含指针成员时）。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译器自动生成的合成拷贝构造函数</span></span><br><span class="line">    <span class="comment">// MyClass(const MyClass &amp;other) = default;</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>总之，拷贝构造函数和合成拷贝构造函数的主要区别在于：拷贝构造函数是用户自定义的，可以自定义拷贝行为；合成拷贝构造函数是编译器自动生成的，执行逐个成员的拷贝。如果类中没有显式地定义拷贝构造函数，编译器将自动生成一个合成拷贝构造函数。如果您需要自定义拷贝行为（例如执行深拷贝），则应在类中显式地定义拷贝构造函数。</p>
<h2 id="拷贝初始化除了在使用-x3D-定义变量时会发生，还有什么情况下会发生"><a href="#拷贝初始化除了在使用-x3D-定义变量时会发生，还有什么情况下会发生" class="headerlink" title="拷贝初始化除了在使用&#x3D;定义变量时会发生，还有什么情况下会发生"></a>拷贝初始化除了在使用&#x3D;定义变量时会发生，还有什么情况下会发生</h2><p>拷贝初始化不仅在使用等号 <code>=</code> 定义变量时会发生，还会在以下几种情况下发生：</p>
<ol>
<li>作为函数参数传递对象时：<br>当将对象作为函数参数传递时，如果参数是按值传递的（即不是引用或指针），则会发生拷贝初始化。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass a;</span><br><span class="line">    <span class="built_in">foo</span>(a); <span class="comment">// 拷贝初始化：将 a 作为参数传递给函数 foo</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>从函数返回对象时：<br>当从函数返回一个对象时，会发生拷贝初始化。这通常涉及到返回值优化（RVO），在许多情况下，编译器会优化这个过程，避免不必要的拷贝。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">create_object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> obj; <span class="comment">// 拷贝初始化：从函数返回一个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass b = <span class="built_in">create_object</span>(); <span class="comment">// 拷贝初始化：接收从函数返回的对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用花括号 <code>&#123;&#125;</code> 或圆括号 <code>()</code> 初始化对象时：<br>当用另一个对象初始化新对象时，如果使用花括号 <code>&#123;&#125;</code> 或圆括号 <code>()</code>，也会发生拷贝初始化。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass c;</span><br><span class="line">    <span class="function">MyClass <span class="title">d</span><span class="params">(c)</span></span>; <span class="comment">// 拷贝初始化：使用圆括号初始化对象</span></span><br><span class="line">    MyClass e&#123;c&#125;; <span class="comment">// 拷贝初始化：使用花括号初始化对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>初始化列表中的成员初始化：<br>当在类的构造函数的初始化列表中初始化成员对象时，也会发生拷贝初始化。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AnotherClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyClass obj;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AnotherClass</span>(<span class="type">const</span> MyClass &amp;other_obj) : <span class="built_in">obj</span>(other_obj) &#123;</span><br><span class="line">        <span class="comment">// 拷贝初始化：在初始化列表中初始化成员对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass f;</span><br><span class="line">    <span class="function">AnotherClass <span class="title">g</span><span class="params">(f)</span></span>; <span class="comment">// 拷贝初始化：将 f 传递给 AnotherClass 的构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上各种情况下，都可能发生拷贝初始化。然而，需要注意的是，编译器通常会尽可能地优化这些拷贝操作，以提高程序的性能。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
        <tag>拷贝构造函数</tag>
        <tag>合成拷贝构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title>第三篇博客</title>
    <url>/2023/04/27/%E7%AC%AC%E4%B8%89%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="赋值运算符为什么必须定义为成员函数"><a href="#赋值运算符为什么必须定义为成员函数" class="headerlink" title="赋值运算符为什么必须定义为成员函数"></a>赋值运算符为什么必须定义为成员函数</h2><p>在C++中，赋值运算符（&#x3D;）通常需要被定义为类的成员函数，而不能是友元函数或非成员函数。这是因为以下几个原因：</p>
<ol>
<li><p>语法限制：在C++中，某些运算符（如赋值运算符、下标运算符、函数调用运算符等）只能作为成员函数来重载，而不能作为非成员函数。这是C++语言本身的规定，设计者这样规定是为了让这些运算符的行为更接近其内建类型的原生行为。</p>
</li>
<li><p>保持语义一致性：赋值运算符用于将一个对象的值赋给另一个对象。将赋值运算符定义为成员函数，有助于保持与内建类型的赋值操作一致的语义。此外，成员函数可以访问类的私有成员，这使得赋值操作可以在内部完成，而无需暴露类的实现细节。</p>
</li>
<li><p>自动处理自赋值情况：当赋值运算符被定义为成员函数时，如果发生自赋值（如a &#x3D; a），编译器可以更容易地识别这种情况并进行优化。如果将赋值运算符定义为非成员函数，处理自赋值情况可能会更加困难。</p>
</li>
<li><p>提供默认赋值运算符：如果在类中没有显式地定义赋值运算符，编译器会自动生成一个默认的赋值运算符。这个默认的赋值运算符会执行逐成员（逐个数据成员）的赋值操作。默认的赋值运算符是一个成员函数，可以满足大多数场景的需求。如果你需要自定义赋值运算符，定义成员函数是最直接的方式。</p>
</li>
</ol>
<p>总之，将赋值运算符定义为成员函数，有助于保持与内建类型的赋值操作一致的语义，简化自赋值情况的处理，并允许访问类的私有成员。这些原因使得赋值运算符作为成员函数更加合适。</p>
<h2 id="给出定义成成员函数和非成员函数的例子，以及如果是编译器自动生成的，默认赋值是怎么赋值的，都给出例子"><a href="#给出定义成成员函数和非成员函数的例子，以及如果是编译器自动生成的，默认赋值是怎么赋值的，都给出例子" class="headerlink" title="给出定义成成员函数和非成员函数的例子，以及如果是编译器自动生成的，默认赋值是怎么赋值的，都给出例子"></a>给出定义成成员函数和非成员函数的例子，以及如果是编译器自动生成的，默认赋值是怎么赋值的，都给出例子</h2><p>首先，我们给出一个成员函数和非成员函数的简单示例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">memberFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nonMemberFunction</span><span class="params">(MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    obj.x = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成员函数</span></span><br><span class="line">    obj.<span class="built_in">memberFunction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用非成员函数</span></span><br><span class="line">    <span class="built_in">nonMemberFunction</span>(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例展示了如何使用成员函数和非成员函数来操作类的公共数据成员。请注意，这个示例没有涉及运算符重载，只是展示了成员函数和非成员函数的基本概念。</p>
<p>接下来，我们讨论编译器自动生成的默认赋值运算符。当你没有为类显式定义赋值运算符时，编译器会生成一个默认的赋值运算符。默认赋值运算符会执行逐成员赋值，即逐个拷贝源对象的数据成员到目标对象。这里有一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point p1;</span><br><span class="line">    p1.x = <span class="number">3</span>;</span><br><span class="line">    p1.y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    Point p2;</span><br><span class="line">    p2.x = <span class="number">0</span>;</span><br><span class="line">    p2.y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用编译器生成的默认赋值运算符</span></span><br><span class="line">    p2 = p1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果：3, 4</span></span><br><span class="line">    std::cout &lt;&lt; p2.x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; p2.y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们没有为<code>Point</code>类显式定义赋值运算符。然而，当我们执行<code>p2 = p1</code>时，编译器生成的默认赋值运算符会被调用。默认赋值运算符会将<code>p1</code>的数据成员逐个拷贝到<code>p2</code>，所以在赋值操作之后，<code>p2.x</code>和<code>p2.y</code>分别是3和4。</p>
<h2 id="如果把MyClass类里的x定义成private，那么非成员函数传入的obj的x还能被赋值吗，你能详细展开讲讲这些问题吗"><a href="#如果把MyClass类里的x定义成private，那么非成员函数传入的obj的x还能被赋值吗，你能详细展开讲讲这些问题吗" class="headerlink" title="如果把MyClass类里的x定义成private，那么非成员函数传入的obj的x还能被赋值吗，你能详细展开讲讲这些问题吗"></a>如果把MyClass类里的x定义成private，那么非成员函数传入的obj的x还能被赋值吗，你能详细展开讲讲这些问题吗</h2><p>如果将<code>MyClass</code>类中的数据成员<code>x</code>定义为<code>private</code>，则非成员函数将无法直接访问和修改它。以下是修改后的类定义和示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">memberFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x = <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个访问x的接口</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供一个修改x的接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> newX)</span> </span>&#123;</span><br><span class="line">        x = newX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">nonMemberFunction</span><span class="params">(MyClass&amp; obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// obj.x = 42; // 错误！无法访问私有成员</span></span><br><span class="line">    obj.<span class="built_in">setX</span>(<span class="number">42</span>); <span class="comment">// 使用公共接口修改x</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用成员函数</span></span><br><span class="line">    obj.<span class="built_in">memberFunction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用非成员函数</span></span><br><span class="line">    <span class="built_in">nonMemberFunction</span>(obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>x</code>现在是私有成员，我们不能在类外部直接访问它。这种情况下，我们需要为<code>MyClass</code>提供公共接口（如<code>getX()</code>和<code>setX()</code>），以便在类外部获取和修改<code>x</code>的值。在这个示例中，我们在<code>nonMemberFunction()</code>中使用了<code>setX()</code>方法来修改<code>x</code>的值，而不是直接访问私有成员。</p>
<p>私有成员的主要目的是封装和隐藏类的实现细节。这样，你可以更自由地修改类的内部实现，而不影响使用该类的代码。通过将数据成员设置为私有并提供公共接口，你可以控制类外部对数据成员的访问和修改，从而确保类的正确使用和数据的完整性。</p>
<h3 id="x2F-obj-x-x3D-42-x2F-x2F-错误！无法访问私有成员-obj-setX-42-x2F-x2F-使用公共接口修改x-这个意思是：虽然不能直接对x进行修改，但obj仍然有x这个属性，那么obj的x属性值是多少呢？obj不是拥有它吗？我的理解有误吗"><a href="#x2F-obj-x-x3D-42-x2F-x2F-错误！无法访问私有成员-obj-setX-42-x2F-x2F-使用公共接口修改x-这个意思是：虽然不能直接对x进行修改，但obj仍然有x这个属性，那么obj的x属性值是多少呢？obj不是拥有它吗？我的理解有误吗" class="headerlink" title="&#x2F; obj.x &#x3D; 42; &#x2F;&#x2F; 错误！无法访问私有成员    obj.setX(42); &#x2F;&#x2F; 使用公共接口修改x 这个意思是：虽然不能直接对x进行修改，但obj仍然有x这个属性，那么obj的x属性值是多少呢？obj不是拥有它吗？我的理解有误吗"></a>&#x2F; obj.x &#x3D; 42; &#x2F;&#x2F; 错误！无法访问私有成员    obj.setX(42); &#x2F;&#x2F; 使用公共接口修改x 这个意思是：虽然不能直接对x进行修改，但obj仍然有x这个属性，那么obj的x属性值是多少呢？obj不是拥有它吗？我的理解有误吗</h3><p>是的，你的理解是正确的。<code>MyClass</code>对象<code>obj</code>仍然具有数据成员<code>x</code>，但是由于<code>x</code>是私有的，所以在类的外部不能直接访问或修改它。这就是封装的概念。尽管<code>x</code>是私有的，但它仍然是<code>MyClass</code>对象的一部分。这意味着当你创建一个<code>MyClass</code>对象时，<code>x</code>也会作为对象的一部分被创建。</p>
<p>在上述示例中，当我们创建<code>MyClass</code>对象<code>obj</code>时，<code>x</code>的初始值是未定义的（因为我们没有为<code>x</code>提供初始值）。在调用<code>obj.memberFunction()</code>后，<code>x</code>的值被设置为42。然后，当我们调用<code>nonMemberFunction(obj)</code>时，我们不能直接访问<code>x</code>，但可以通过公共接口<code>setX()</code>来修改<code>x</code>的值。这里，我们再次将<code>x</code>的值设置为42。</p>
<p>所以，在<code>nonMemberFunction()</code>执行之后，<code>obj</code>的<code>x</code>属性值仍然是42。虽然我们不能直接访问<code>x</code>，但通过公共接口<code>getX()</code>，我们可以获取<code>x</code>的值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;obj.x = &quot;</span> &lt;&lt; obj.<span class="built_in">getX</span>() &lt;&lt; std::endl; <span class="comment">// 输出：obj.x = 42</span></span><br></pre></td></tr></table></figure>

<p>总之，<code>obj</code>确实拥有私有成员<code>x</code>，但在类的外部不能直接访问或修改它。为了在类外部操作<code>x</code>，我们需要使用类提供的公共接口。</p>
<h2 id="此外，成员函数可以访问类的私有成员，这使得赋值操作可以在内部完成，而无需暴露类的实现细节。如果不是成员函数就会暴露细节吗？给个例子"><a href="#此外，成员函数可以访问类的私有成员，这使得赋值操作可以在内部完成，而无需暴露类的实现细节。如果不是成员函数就会暴露细节吗？给个例子" class="headerlink" title="此外，成员函数可以访问类的私有成员，这使得赋值操作可以在内部完成，而无需暴露类的实现细节。如果不是成员函数就会暴露细节吗？给个例子"></a>此外，成员函数可以访问类的私有成员，这使得赋值操作可以在内部完成，而无需暴露类的实现细节。如果不是成员函数就会暴露细节吗？给个例子</h2><p>当赋值操作涉及类的私有成员时，使用成员函数可以确保不会暴露类的实现细节。如果尝试使用非成员函数来实现赋值操作，我们需要提供访问私有成员的接口，这可能会破坏封装。让我们用一个例子来说明这个问题。</p>
<p>首先，考虑以下<code>MyClass</code>定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> initialX) : <span class="built_in">x</span>(initialX) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员赋值运算符</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x = other.x; <span class="comment">// 可以直接访问私有成员</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了一个成员赋值运算符。因为这是一个成员函数，所以它可以直接访问<code>other</code>对象的私有成员<code>x</code>。这样，我们不需要提供额外的接口来访问<code>x</code>，可以保持封装。</p>
<p>现在，假设我们尝试使用非成员函数来实现赋值操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> initialX) : <span class="built_in">x</span>(initialX) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供访问x的接口</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供修改x的接口</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> newX)</span> </span>&#123;</span><br><span class="line">        x = newX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非成员赋值运算符</span></span><br><span class="line">MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp; lhs, <span class="type">const</span> MyClass&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (&amp;lhs == &amp;rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无法直接访问私有成员，需要使用公共接口</span></span><br><span class="line">    lhs.<span class="built_in">setX</span>(rhs.<span class="built_in">getX</span>());</span><br><span class="line">    <span class="keyword">return</span> lhs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们试图使用非成员函数实现赋值运算符。然而，由于非成员函数无法直接访问私有成员，我们必须提供公共接口<code>getX()</code>和<code>setX()</code>来访问和修改<code>x</code>。这暴露了类的实现细节，并可能破坏封装。</p>
<p>需要注意的是，这个例子中的非成员赋值运算符尝试重载等号运算符（&#x3D;），然而，实际上在C++中赋值运算符（&#x3D;）必须被定义为类的成员函数，不能作为非成员函数。这个例子只是用来说明如果使用非成员函数来实现类似赋值操作的情况，可能会导致封装的破坏。</p>
<h2 id="类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值，这句话如何理解"><a href="#类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值，这句话如何理解" class="headerlink" title="类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值，这句话如何理解"></a>类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值，这句话如何理解</h2><p>这句话的意思是，对于某些类，编译器生成的合成拷贝赋值运算符可能不适用，或者类的设计者希望禁止对象之间的赋值操作。在这种情况下，合成拷贝赋值运算符会被显式地删除或声明为私有，从而阻止用户对该类的对象执行赋值操作。</p>
<p>当类中包含不可复制的资源（如文件句柄、互斥锁等）或类的实例应该保持唯一时（如单例模式），通常需要禁止类的对象之间的赋值操作。让我们通过一个例子来说明这个概念。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyableResource</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有拷贝构造函数</span></span><br><span class="line">    <span class="built_in">NonCopyableResource</span>(<span class="type">const</span> NonCopyableResource&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有拷贝赋值运算符</span></span><br><span class="line">    NonCopyableResource&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyableResource&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NonCopyableResource</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了一个<code>NonCopyableResource</code>类，它具有私有的拷贝构造函数和拷贝赋值运算符。因为这两个函数是私有的，所以在类的外部不能使用它们。这样，我们就阻止了该类对象之间的拷贝和赋值操作。</p>
<p>从C++11开始，我们可以更明确地禁止拷贝构造函数和拷贝赋值运算符，方法是将它们声明为<code>= delete</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NonCopyableResource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NonCopyableResource</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝构造函数</span></span><br><span class="line">    <span class="built_in">NonCopyableResource</span>(<span class="type">const</span> NonCopyableResource&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除拷贝赋值运算符</span></span><br><span class="line">    NonCopyableResource&amp; <span class="keyword">operator</span>=(<span class="type">const</span> NonCopyableResource&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方法更清晰地表明了拷贝构造函数和拷贝赋值运算符是被禁止的。当试图对这个类的对象执行拷贝或赋值操作时，编译器会报错。</p>
<p>总之，当类的对象不应该被复制或赋值时，可以通过将拷贝构造函数和拷贝赋值运算符声明为私有或删除它们来禁止这些操作。这样可以确保类的对象在程序中具有正确的行为。</p>
<h2 id="如果拷贝赋值运算符不是出于禁止拷贝的目的，他会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，为啥static不能赋值过去，是因为他的存储位置吗"><a href="#如果拷贝赋值运算符不是出于禁止拷贝的目的，他会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，为啥static不能赋值过去，是因为他的存储位置吗" class="headerlink" title="如果拷贝赋值运算符不是出于禁止拷贝的目的，他会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，为啥static不能赋值过去，是因为他的存储位置吗"></a>如果拷贝赋值运算符不是出于禁止拷贝的目的，他会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，为啥static不能赋值过去，是因为他的存储位置吗</h2><p>是的，你的理解是正确的。当拷贝赋值运算符执行时，它会将右侧运算对象的每个非static成员逐一赋值给左侧运算对象的对应成员。static成员变量的赋值不涉及到拷贝赋值运算符，因为它们不属于类的单个实例。</p>
<p>static成员变量属于类本身，而不是类的对象。它们在内存中的存储位置与类的实例对象不同。实际上，所有类的实例共享同一个static成员变量。因此，当你修改一个类实例的static成员变量时，这个修改会影响所有类实例。这就是为什么在拷贝赋值操作中，不需要拷贝static成员变量的原因。</p>
<p>以下是一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> nonStaticMember;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticMember;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> nonStaticValue) : <span class="built_in">nonStaticMember</span>(nonStaticValue) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化static成员变量</span></span><br><span class="line"><span class="type">int</span> MyClass::staticMember = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改static成员变量</span></span><br><span class="line">    MyClass::staticMember = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值操作</span></span><br><span class="line">    obj1 = obj2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果：20, 42</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj1: &quot;</span> &lt;&lt; obj1.nonStaticMember &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; MyClass::staticMember &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 输出结果：20, 42</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;obj2: &quot;</span> &lt;&lt; obj2.nonStaticMember &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; MyClass::staticMember &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>MyClass</code>具有一个非static成员变量<code>nonStaticMember</code>和一个static成员变量<code>staticMember</code>。当我们执行拷贝赋值操作<code>obj1 = obj2</code>时，只有<code>nonStaticMember</code>被拷贝，而<code>staticMember</code>保持不变。这是因为<code>staticMember</code>属于类本身，而不是类的实例。</p>
<h2 id="哪些情况下指针所指的对象会随着指针的销毁而销毁，哪些情况下不会？指针指向的对象没了，指针就没了吗？"><a href="#哪些情况下指针所指的对象会随着指针的销毁而销毁，哪些情况下不会？指针指向的对象没了，指针就没了吗？" class="headerlink" title="哪些情况下指针所指的对象会随着指针的销毁而销毁，哪些情况下不会？指针指向的对象没了，指针就没了吗？"></a>哪些情况下指针所指的对象会随着指针的销毁而销毁，哪些情况下不会？指针指向的对象没了，指针就没了吗？</h2><p>指针和指针所指向的对象是两个不同的概念。指针是一种变量，它存储了对象在内存中的地址。当指针被销毁时，它所指向的对象不会自动销毁。同样，当指针所指向的对象被销毁时，指针本身也不会自动销毁。它们的生命周期是独立的。</p>
<ol>
<li><p>指针所指向的对象会随着指针的销毁而销毁的情况：<br>实际上，没有这样的情况。当指针被销毁时，它所指向的对象不会自动销毁。只有当你显式地销毁指针所指向的对象时，对象才会被销毁。</p>
</li>
<li><p>指针指向的对象没了，指针就没了吗？<br>不是这样的。当指针所指向的对象被销毁时，指针本身不会自动销毁。指针仍然存在，但它现在指向的是一个已经销毁的对象，也就是所谓的悬空指针（dangling pointer）。在这种情况下，访问该悬空指针可能导致未定义行为，因为它可能指向无效的内存区域。</p>
</li>
</ol>
<p>以下是一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>); <span class="comment">// 动态分配内存，p指向该内存区域</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> p; <span class="comment">// 销毁p所指向的对象，释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// p没有被销毁，但现在是一个悬空指针，因为它指向的对象已经被销毁</span></span><br><span class="line">    <span class="comment">// 访问p可能导致未定义行为</span></span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; *p &lt;&lt; std::endl; // 不安全！不要这样做</span></span><br><span class="line"></span><br><span class="line">    p = <span class="literal">nullptr</span>; <span class="comment">// 将悬空指针设置为nullptr，避免未定义行为</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免未定义行为，当销毁指针所指向的对象后，通常将指针设置为<code>nullptr</code>。这样，即使指针没有被销毁，也不会指向一个无效的内存区域。</p>
<h2 id="HasPtr-const-HasPtr-amp-rhs-this-gt-i-x3D-rhs-i-this-gt-ps-x3D-amp-rhs-ps-和下面这个-HasPtr-const-HasPtr-amp-rhs-this-gt-i-x3D-rhs-i-ps-x3D-new-string-rhs-ps-从拷贝构造函数的实现意义层面来说，有区别吗？是不是都是拷贝了ps指向的对象，而不是拷贝ps本身"><a href="#HasPtr-const-HasPtr-amp-rhs-this-gt-i-x3D-rhs-i-this-gt-ps-x3D-amp-rhs-ps-和下面这个-HasPtr-const-HasPtr-amp-rhs-this-gt-i-x3D-rhs-i-ps-x3D-new-string-rhs-ps-从拷贝构造函数的实现意义层面来说，有区别吗？是不是都是拷贝了ps指向的对象，而不是拷贝ps本身" class="headerlink" title="HasPtr(const HasPtr&amp; rhs) { 	this-&gt;i &#x3D; rhs.i; 	this-&gt;ps &#x3D; &amp;(*rhs.ps); } 和下面这个 HasPtr(const HasPtr&amp; rhs) { 	this-&gt;i &#x3D; rhs.i; 	ps &#x3D; new string(*rhs.ps); } 从拷贝构造函数的实现意义层面来说，有区别吗？是不是都是拷贝了ps指向的对象，而不是拷贝ps本身"></a>HasPtr(const HasPtr&amp; rhs) { 	this-&gt;i &#x3D; rhs.i; 	this-&gt;ps &#x3D; &amp;(*rhs.ps); } 和下面这个 HasPtr(const HasPtr&amp; rhs) { 	this-&gt;i &#x3D; rhs.i; 	ps &#x3D; new string(*rhs.ps); } 从拷贝构造函数的实现意义层面来说，有区别吗？是不是都是拷贝了ps指向的对象，而不是拷贝ps本身</h2><p>这两个拷贝构造函数的实现在语义层面上有很大的区别。</p>
<p>第一个拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;i = rhs.i;</span><br><span class="line">    <span class="keyword">this</span>-&gt;ps = &amp;(*rhs.ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个拷贝构造函数的实现仅仅是将<code>rhs</code>对象的<code>ps</code>成员的地址赋值给当前对象的<code>ps</code>成员。这意味着，两个<code>HasPtr</code>对象的<code>ps</code>成员指向同一个<code>string</code>对象。在这种情况下，我们说这是一种浅拷贝（shallow copy）。浅拷贝可能导致资源管理问题，如在析构函数中释放同一个对象两次。</p>
<p>第二个拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">HasPtr</span>(<span class="type">const</span> HasPtr&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;i = rhs.i;</span><br><span class="line">    ps = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个拷贝构造函数的实现不仅将<code>rhs</code>对象的<code>ps</code>成员的值复制给当前对象的<code>ps</code>成员，还为当前对象的<code>ps</code>成员创建了一个新的<code>string</code>对象。这样，两个<code>HasPtr</code>对象的<code>ps</code>成员指向两个不同的、相互独立的<code>string</code>对象。在这种情况下，我们说这是一种深拷贝（deep copy）。深拷贝通常可以避免资源管理问题，因为每个对象都有自己独立的资源副本。</p>
<p>所以，从拷贝构造函数的实现意义层面来说，这两个实现有很大的区别。第一个实现是浅拷贝，可能导致资源管理问题；而第二个实现是深拷贝，可以避免这些问题。在实际编程中，根据具体需求选择合适的拷贝策略是很重要的。</p>
<h2 id="include-class-HasPtr-public-HasPtr-const-std-string-amp-s-x3D-std-string-ps-new-std-string-s-i-0-x2F-HasPtr-const-HasPtr-amp-rhs-this-gt-i-x3D-rhs-i-this-gt-ps-x3D-amp-rhs-ps-x2F-HasPtr-delete-ps-private-std-string-ps-int-i-HasPtr-f-HasPtr-hp-HasPtr-ret-x3D-hp-return-ret-int-main-HasPtr-p-“hello-world”-f-p-HasPtr-q-p-return-0-这里我有一个疑问，f函数的返回值是HasPtr类型，为什么我在main函数里调用f不需要使用HasPtr类型的对象来接受它的返回值呢"><a href="#include-class-HasPtr-public-HasPtr-const-std-string-amp-s-x3D-std-string-ps-new-std-string-s-i-0-x2F-HasPtr-const-HasPtr-amp-rhs-this-gt-i-x3D-rhs-i-this-gt-ps-x3D-amp-rhs-ps-x2F-HasPtr-delete-ps-private-std-string-ps-int-i-HasPtr-f-HasPtr-hp-HasPtr-ret-x3D-hp-return-ret-int-main-HasPtr-p-“hello-world”-f-p-HasPtr-q-p-return-0-这里我有一个疑问，f函数的返回值是HasPtr类型，为什么我在main函数里调用f不需要使用HasPtr类型的对象来接受它的返回值呢" class="headerlink" title="#include  class HasPtr { public: HasPtr(const std::string &amp;s &#x3D; std::string()): ps(new std::string(s)), i(0) {} 	&#x2F;HasPtr(const HasPtr&amp; rhs) { 	this-&gt;i &#x3D; rhs.i; 	this-&gt;ps &#x3D; &amp;(rhs.ps); }&#x2F; 	~HasPtr() { delete ps; } private: std::string ps; int i; }; HasPtr f(HasPtr hp) { HasPtr ret &#x3D; hp; return ret; } int main() { HasPtr p(“hello world”); f(p); HasPtr q(p); 	return 0; } 这里我有一个疑问，f函数的返回值是HasPtr类型，为什么我在main函数里调用f不需要使用HasPtr类型的对象来接受它的返回值呢"></a>#include <iostream> class HasPtr { public: HasPtr(const std::string &amp;s &#x3D; std::string()): ps(new std::string(s)), i(0) {} 	&#x2F;<em>HasPtr(const HasPtr&amp; rhs) { 	this-&gt;i &#x3D; rhs.i; 	this-&gt;ps &#x3D; &amp;(<em>rhs.ps); }</em>&#x2F; 	~HasPtr() { delete ps; } private: std::string</em> ps; int i; }; HasPtr f(HasPtr hp) { HasPtr ret &#x3D; hp; return ret; } int main() { HasPtr p(“hello world”); f(p); HasPtr q(p); 	return 0; } 这里我有一个疑问，f函数的返回值是HasPtr类型，为什么我在main函数里调用f不需要使用HasPtr类型的对象来接受它的返回值呢</iostream></h2><p>在这个例子中，当你调用<code>f(p)</code>时，即使没有为<code>f</code>函数的返回值指定一个<code>HasPtr</code>类型的对象来接收它，C++编译器仍然会处理这种情况。在没有指定接收返回值的情况下，编译器会创建一个临时<code>HasPtr</code>对象，用于接收<code>f</code>函数的返回值。这个临时对象会在表达式结束后立即销毁。</p>
<p>这就是为什么你不需要显式地使用一个<code>HasPtr</code>对象来接收<code>f</code>函数的返回值。然而，为了避免潜在的性能损失和资源浪费，通常建议你在调用返回对象的函数时指定一个接收返回值的变量。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">HasPtr <span class="title">p</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line">    HasPtr r = <span class="built_in">f</span>(p);  <span class="comment">// 使用HasPtr对象r来接收f函数的返回值</span></span><br><span class="line">    <span class="function">HasPtr <span class="title">q</span><span class="params">(p)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，你可以避免创建和销毁临时对象，从而提高程序的性能。</p>
<h2 id="为什么需要拷贝操作的类也需要赋值操作，反之亦然，这句话是什么意思"><a href="#为什么需要拷贝操作的类也需要赋值操作，反之亦然，这句话是什么意思" class="headerlink" title="为什么需要拷贝操作的类也需要赋值操作，反之亦然，这句话是什么意思"></a>为什么需要拷贝操作的类也需要赋值操作，反之亦然，这句话是什么意思</h2><p>这句话的意思是，当你为一个类实现拷贝操作（拷贝构造函数）时，通常也需要实现赋值操作（拷贝赋值运算符），反之亦然。这是因为拷贝操作和赋值操作通常在语义上是相似的，而且在实际使用中经常会一起出现。实现一个而不实现另一个可能导致类的行为不一致或不完整。</p>
<p>拷贝构造函数和拷贝赋值运算符的主要区别在于它们的用途：</p>
<ol>
<li>拷贝构造函数（Copy Constructor）：当创建一个新对象并用另一个已存在的对象初始化它时，会调用拷贝构造函数。典型的情况包括：将一个对象作为参数传递给函数、从函数返回一个对象、初始化列表等。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyClass obj1;</span><br><span class="line"><span class="function">MyClass <span class="title">obj2</span><span class="params">(obj1)</span></span>;  <span class="comment">// 调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拷贝赋值运算符（Copy Assignment Operator）：当两个已经存在的对象之间进行赋值操作时，会调用拷贝赋值运算符。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MyClass obj1;</span><br><span class="line">MyClass obj2;</span><br><span class="line">obj2 = obj1;  <span class="comment">// 调用拷贝赋值运算符</span></span><br></pre></td></tr></table></figure>

<p>在许多情况下，拷贝构造函数和拷贝赋值运算符需要执行相似的操作（如深拷贝）。实现两者可以确保类在各种情况下都能正确地处理拷贝和赋值操作。这就是为什么“需要拷贝操作的类也需要赋值操作，反之亦然”的原因。如果仅实现其中之一，可能会导致类在某些情况下无法正确地执行拷贝或赋值操作，从而引发问题。</p>
<p>当然可以。让我们通过一个简单的示例来说明仅实现拷贝构造函数而不实现拷贝赋值运算符可能导致的问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> std::string&amp; s) : <span class="built_in">data</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(s)) &#123;&#125;</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) : <span class="built_in">data</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>(*other.data)) &#123;&#125; <span class="comment">// 拷贝构造函数实现了深拷贝</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; <span class="keyword">delete</span> data; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="string">&quot;world&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MyClass <span class="title">obj3</span><span class="params">(obj1)</span></span>; <span class="comment">// 使用拷贝构造函数，执行正确</span></span><br><span class="line"></span><br><span class="line">    obj2 = obj1; <span class="comment">// 这里使用默认的拷贝赋值运算符，执行浅拷贝</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们实现了<code>MyClass</code>的拷贝构造函数，它执行深拷贝。但是，我们没有实现拷贝赋值运算符。因此，在赋值操作（如<code>obj2 = obj1;</code>）时，编译器会生成一个默认的拷贝赋值运算符，该运算符执行浅拷贝。</p>
<p>问题出现在这个默认的拷贝赋值运算符上。因为它执行浅拷贝，<code>obj2</code>和<code>obj1</code>的<code>data</code>成员将指向同一个<code>std::string</code>对象。当<code>main</code>函数结束时，<code>obj1</code>和<code>obj2</code>的析构函数都将被调用，它们都会尝试删除同一个<code>std::string</code>对象。这将导致未定义行为，可能会导致程序崩溃。</p>
<p>如果我们为<code>MyClass</code>同时实现拷贝构造函数和拷贝赋值运算符，并确保它们都执行深拷贝，就可以避免这个问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 其他成员函数 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符实现了深拷贝</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::string* newData = <span class="keyword">new</span> std::<span class="built_in">string</span>(*other.data);</span><br><span class="line">        <span class="keyword">delete</span> data;</span><br><span class="line">        data = newData;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string* data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，无论是使用拷贝构造函数还是拷贝赋值运算符，<code>MyClass</code>对象都将正确地执行深拷贝，从而避免了资源管理问题。</p>
<h2 id="你这个例子并没有解释为什么二者需要同时定义啊，比如第一个程序，我不执行赋值对拷贝构造也没影响啊"><a href="#你这个例子并没有解释为什么二者需要同时定义啊，比如第一个程序，我不执行赋值对拷贝构造也没影响啊" class="headerlink" title="你这个例子并没有解释为什么二者需要同时定义啊，比如第一个程序，我不执行赋值对拷贝构造也没影响啊"></a>你这个例子并没有解释为什么二者需要同时定义啊，比如第一个程序，我不执行赋值对拷贝构造也没影响啊</h2><p>抱歉，我的示例可能没有充分解释为什么两者需要同时定义。请允许我通过另一个例子来解释这个问题。</p>
<p>假设你有一个类，它表示一个动态分配的二维数组，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> rows, <span class="type">int</span> cols)</span><br><span class="line">        : <span class="built_in">rows</span>(rows), <span class="built_in">cols</span>(cols), <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[rows * cols]) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">const</span> Matrix&amp; other)</span><br><span class="line">        : <span class="built_in">rows</span>(other.rows), <span class="built_in">cols</span>(other.cols), <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[rows * cols]) &#123;</span><br><span class="line">        std::<span class="built_in">copy</span>(other.data, other.data + rows * cols, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Matrix</span>() &#123; <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 其他成员函数 ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> rows, cols;</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们实现了<code>Matrix</code>的拷贝构造函数，它执行深拷贝。然而，我们没有实现拷贝赋值运算符。因此，编译器会生成一个默认的拷贝赋值运算符，执行浅拷贝。</p>
<p>现在，假设你需要执行以下操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Matrix <span class="title">m1</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Matrix <span class="title">m2</span><span class="params">(<span class="number">3</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设有一个函数，它需要一个Matrix对象作为参数，并返回一个Matrix对象</span></span><br><span class="line">Matrix result = <span class="built_in">some_function</span>(m1);</span><br><span class="line"></span><br><span class="line">m2 = result; <span class="comment">// 使用默认的拷贝赋值运算符</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了两个<code>Matrix</code>对象，它们具有不同的尺寸。然后我们调用一个函数<code>some_function</code>，它返回一个<code>Matrix</code>对象。接下来，我们将<code>result</code>对象赋值给<code>m2</code>。这里，编译器会使用默认的拷贝赋值运算符，它执行浅拷贝。</p>
<p>问题在于，默认的拷贝赋值运算符无法处理不同尺寸的矩阵。由于它执行浅拷贝，<code>m2</code>的<code>data</code>指针将简单地指向<code>result</code>的<code>data</code>，而不会调整其大小。这将导致错误的行为，因为<code>m2</code>现在引用了一个与其原始大小不匹配的数组。此外，原始<code>m2</code>的<code>data</code>指针已经丢失，导致内存泄漏。</p>
<p>为了解决这个问题，我们需要同时实现拷贝构造函数和拷贝赋值运算符，以确保它们都执行深拷贝，并正确处理不同尺寸的矩阵。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 其他成员函数 ...</span></span><br><span class="line"></span><br><span class="line">    Matrix&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Matrix&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>* newData = <span class="keyword">new</span> <span class="type">int</span>[other.rows * other.cols];</span><br><span class="line">        std::<span class="built_in">copy</span>(other.data, other.data + other.rows * other.cols, newData);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        data = newData;</span><br><span class="line">        rows = other.rows;</span><br><span class="line">        cols = other.cols;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>自制服务器1</title>
    <url>/2023/04/24/%E8%87%AA%E5%88%B6%E6%9C%8D%E5%8A%A1%E5%99%A81/</url>
    <content><![CDATA[<h2 id="服务端—客户端通信大致流程"><a href="#服务端—客户端通信大致流程" class="headerlink" title="服务端—客户端通信大致流程"></a>服务端—客户端通信大致流程</h2><ul>
<li><p>服务端创建一个监听套接字（对创建的监听套接字进行判断，是否创建成功，返回非负整数则代表创建成功，返回-1代表创建失败），调用函数<code>socket()</code>。在<code>linux</code>系统中一切皆文件，每个文件都有一个整数类型的文件描述符。<code>socket()</code>也是一个文件，也有文件描述符。使用<code>socket()</code>函数创建套接字以后，返回值就是一个int类型的文件描述符。</p>
<p>在<code>linux</code>下使用<code>&lt;sys/socket.h&gt;</code>头文件中<code>socket()</code>函数来创建套接字，函数原型为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，第一个参数<code>af</code>为地址族<code>（Address Family）</code>，也就是<code>IP</code>地址类型，常用的<code>IP</code>地址类型有<code>AF_INET</code>和<code>AF_INET6</code>。<code>AF</code>是<code>”Address Family“</code>的简写，<code>INET</code>是<code>”Internet“</code>的简写。<code>AF_INET</code>表示<code>IPv4</code>地址，例如<code>127.0.0.1</code>；<code>AF_INET6</code>表示<code>IPv6</code>地址，例如<code>1030::C9B4:FF12:48AA:1A2B</code>。<code>127.0.0.1</code>是一个特殊的<code>IP</code>地址，表示本机地址。</p>
<p>第二个参数<code>type</code>为数据传输方式&#x2F;套接字类型，常用的有<code>SOCK_STREAM</code>（流格式套接字&#x2F;面向连接的套接字）和<code>SOCK_DGRAM</code>（数据报套接字&#x2F;无连接的套接字）。</p>
<p>第三个参数<code>protocol</code>表示传输协议，常用的有<code>IPPROTO_TCP</code>和<code>IPPTOTO_UDP</code>，即所谓的：<code>TCP</code>和<code>UDP</code>。</p>
</li>
</ul>
<p>我们经常会看见别人程序里创建套接字如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>很多人可能会好奇为什么第三个参数会设置为0？其实既满足<code>IP</code>地址类型为：<code>AF_INET</code>又满足套接字类型为：<code>SOCK_STREAM/SOCK_DGRAM</code>的只有<code>TCP/UDP</code>，系统会自动推演出来应该使用什么协议，此时则可以将<code>protocol</code>设置为0。</p>
<h5 id="lt-semaphore-h-gt-头文件"><a href="#lt-semaphore-h-gt-头文件" class="headerlink" title="&lt;semaphore.h&gt;头文件"></a>&lt;semaphore.h&gt;头文件</h5><p>&lt;semphore.h&gt;头文件是POSIX标准中定义的一个头文件，用于提供信号量的函数和数据类型。</p>
<p>信号量是一种用于提供不同进程或线程之间进行同步或者互斥的简单抽象。通常，信号量被用来限制对特定资源的访问，这在多线程和多进程环境中非常有用。</p>
<p>在<code>&lt;semaphore.h&gt;</code>头文件中，定义了以下的函数：</p>
<ul>
<li><code>sem_init()</code>：初始化一个未命名的信号量</li>
<li><code>sem_destroy()</code>：销毁一个未命名的信号量</li>
<li><code>sem_open()</code>：打开一个命名信号量，如果该信号量不存在，则创建一个</li>
<li><code>sem_close()</code>：关闭一个命名信号量</li>
<li><code>sem_unlink()</code>：删除一个命名信号量</li>
<li><code>sem_post()</code>：增加（解锁）信号量的值</li>
<li><code>sem_wait()</code>：减少（锁定）信号量的值，如果信号量的值为0，则调用该函数的线程会阻塞，直到信号量的值大于0</li>
<li><code>sem_trywait()</code>：尝试减少信号量的值，如果信号量的值为0，则立即返回错误，而不会阻塞</li>
<li><code>sem_getvalue()</code>：获取信号量的当前值</li>
</ul>
<h5 id="为什么要转换为sockaddr"><a href="#为什么要转换为sockaddr" class="headerlink" title="为什么要转换为sockaddr"></a>为什么要转换为<code>sockaddr</code></h5><p>所有专用<code>socket</code>地址（以及<code>sockaddr_storage</code>）类型的变量在实际使用时都需要转换为通用<code>socket</code>地址类型<code>sockaddr</code>（强制转换即可），因为所有<code>socket</code>编程接口使用的地址参数的类型都是<code>sockaddr</code>。</p>
<h5 id="网络服务中的三种端口：知名端口、注册端口、动态或私有端口"><a href="#网络服务中的三种端口：知名端口、注册端口、动态或私有端口" class="headerlink" title="网络服务中的三种端口：知名端口、注册端口、动态或私有端口"></a>网络服务中的三种端口：知名端口、注册端口、动态或私有端口</h5><p>服务端口（<code>Service Port</code>）是计算机网络中，网络服务使用的网络端口。这些端口通常被分为三个范围：知名端口、注册端口和动态或私有端口。</p>
<p>知名端口（<code>Well-Known Ports</code>）是从0到1023的端口号。它们通常被系统进程或者管理员级别的进程使用。这些端口通常关联到一些广泛使用的网络服务，例如：</p>
<ul>
<li><code>HTTP</code>：端口80</li>
<li><code>HTTPS</code>：端口443</li>
<li><code>FTP</code>：端口20和21</li>
<li><code>SSH</code>：端口22</li>
<li><code>Telnet</code>：端口23</li>
<li><code>DNS</code>：端口53</li>
<li><code>SMTP</code>：端口25</li>
<li><code>POP3</code>：端口110</li>
<li><code>IMAP</code>：端口143</li>
</ul>
<p>由于这些服务广泛地被用于许多网络应用，所以这些端口号被称为“知名端口”。这些端口的分配和维护由互联网号码分配局（<code>Internet Assigned Numbers Authority</code>，简称<code>IANA</code>）进行。</p>
<p>需要注意的是，除了这些知名端口，其他的端口也可以被任何应用程序使用，只要它们具备了适当的权限和配置。对于某些特定的应用程序，开发者可能会选择在1024-49151的范围内选择一个注册端口（<code>Registered Ports</code>），或者在49152–65535的范围内选择一个动态或私有端口（<code>Dynamic or Private Ports</code>）。</p>
<h5 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a><code>signal</code>函数</h5><p>在网络编程中，<code>signal</code>函数是一个非常重要的函数，它被用于设置处理特定信号的函数。</p>
<p>信号（<code>signal</code>）是一种在 <code>Unix</code> 系统（包括 <code>Linux</code>）中用于进程间通信的方式。它类似于一个异步的中断，当一个进程接收到一个信号时，操作系统会暂停该进程的正常执行流程，并去执行与该信号关联的处理函数。</p>
<p><code>signal</code>函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> signum, <span class="type">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>这个函数接收两个参数：</p>
<ol>
<li><p><code>signum</code>：这是一个整数，表示信号的类型。例如，<code>SIGINT</code>表示中断信号（通常是用户按下了<code>Ctrl+C</code>），<code>SIGABRT</code>表示一个异常条件，等等。</p>
</li>
<li><p><code>handler</code>：这是一个函数指针，指向用于处理这个信号的函数。处理函数的原型应该为<code>void func(int)</code>，也就是说，它应该是一个接收整数参数并且没有返回值的函数。你可以提供自己的处理函数，也可以使用两个预定义的值：<code>SIG_IGN</code>表示忽略这个信号，<code>SIG_DFL</code>表示使用系统默认的处理方式。</p>
</li>
</ol>
<p><code>signal</code>函数的返回值是一个函数指针，它指向之前设置的处理函数（如果有的话）。如果函数执行失败，那么返回的将是<code>SIG_ERR</code>。</p>
<p>需要注意的是，<code>signal</code>函数并不是 <code>POSIX</code> 标准的一部分，不同的系统可能会有不同的行为。在进行跨平台编程时，通常建议使用<code>sigaction</code>函数代替<code>signal</code>，因为<code>sigaction</code>提供了更多的控制选项，并且它的行为在不同的系统上更加一致。</p>
<p><code>SIGINT</code>、<code>SIGABRT</code>等都是预定义的宏，这些宏在<code>signal.h</code>或者其他相关的头文件中定义，它们的值是整数。例如，在许多系统中，<code>SIGINT</code>的值是2，但这个值并不是在所有系统中都一样。</p>
<p>这些宏名（例如<code>SIGINT</code>）只是为了在代码中更好地表示不同的信号，使得代码更易于理解。实际上，当我们在代码中写<code>SIGINT</code>时，编译器会将其替换为对应的整数值。</p>
<p>所以，当我们调用<code>signal(SIGINT, handler)</code>时，我们实际上是在说：“我想将处理<code>SIGINT</code>信号的函数设置为<code>handler</code>。”这里的<code>SIGINT</code>在被编译器处理后，就是一个整数值，代表了中断信号。</p>
<h5 id="telnet命令"><a href="#telnet命令" class="headerlink" title="telnet命令"></a><code>telnet</code>命令</h5><p><code>telnet</code>是一个网络协议和一个用于在互联网或局域网上执行此协议的命令行工具。它基于文本，主要用于远程管理网络设备和运行服务器端应用。然而，请注意，由于<code>telnet</code>不提供任何加密的方式，所以任何通过<code>telnet</code>发送的数据，包括密码，都是明文的，因此它已经被认为是不安全的，并且在许多新的系统和设备中已经被<code>SSH（Secure Shell）</code>所取代。</p>
<p>基本的<code>telnet</code>命令的语法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet [host] [port]</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><p><code>host</code>：这是你想要连接的远程主机的IP地址或主机名。例如，如果你想要连接到位于<code>192.168.1.1</code>的主机，你可以输入<code>telnet 192.168.1.1</code>。</p>
</li>
<li><p><code>port</code>：这是你想要连接到的远程服务的端口号。这个参数是可选的，如果你不提供，<code>telnet</code>会默认连接到端口23，这是Telnet协议的标准端口。例如，如果你想要测试一个位于<code>192.168.1.1</code>的主机的80端口（通常是HTTP服务器），你可以输入<code>telnet 192.168.1.1 80</code>。</p>
</li>
</ul>
<p>在<code>telnet</code>连接建立之后，你可以输入任何文本并按Enter键发送。当你想要断开连接时，你可以输入特殊的<code>telnet</code>命令，这通常是<code>Ctrl+]</code>（输入<code>Ctrl</code>和<code>]</code>键），然后输入<code>quit</code>。</p>
<h4 id="webServer服务器整体描述"><a href="#webServer服务器整体描述" class="headerlink" title="webServer服务器整体描述"></a>webServer服务器整体描述</h4><p>本项目主要目的就是对浏览器的链接请求进行处理并给予相应响应。对于请求的处理，系统整体运行流程为：主线程对I&#x2F;O进行监听，获取I&#x2F;O请求后把请求放入请求队列，等待工作线程处理。工作线程对于请求的处理（HTTP报文的解析）主要采用状态机思想来解析HTTP报文的解析。</p>
<h4 id="多路I-x2F-O复用"><a href="#多路I-x2F-O复用" class="headerlink" title="多路I&#x2F;O复用"></a>多路I&#x2F;O复用</h4><p>多路 I&#x2F;O 复用的基本概念是，一个进程使用一个线程来监控多个文件描述符（通常是套接字描述符），当其中任何一个文件描述符准备好进行读或写操作时，该线程就可以进行相应的处理。这样，一个线程就可以同时处理多个 I&#x2F;O 事件，提高了系统的并发性。常用的多路 I&#x2F;O 复用的系统调用有 <code>select</code>、<code>poll</code>、<code>epoll</code>。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p><code>select</code>是Unix&#x2F;Linux系统下的一种I&#x2F;O多路复用机制。它允许应用程序监视多个文件描述符，等待一个或多个描述符成为就绪状态，以进行I&#x2F;O操作（例如读或写）。这是一种异步I&#x2F;O模型，因为你不需要阻塞等待单个I&#x2F;O操作的完成。</p>
<p><code>select</code>的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><code>nfds</code>：需要监视的文件描述符数量，通常设置为所监视文件描述符中的最大值加1。</li>
<li><code>readfds</code>：需要监视读状态的文件描述符集合。</li>
<li><code>writefds</code>：需要监视写状态的文件描述符集合。</li>
<li><code>exceptfds</code>：需要监视异常状态的文件描述符集合。</li>
<li><code>timeout</code>：等待就绪的最长时间。如果设为NULL，则表示无限等待。</li>
</ul>
<p><code>select</code>函数返回准备好的文件描述符的数量，如果超时则返回0，如果出错则返回-1。</p>
<p><code>fd_set</code>是一种数据结构，用于存储文件描述符集合。你可以使用以下的宏来操作这个集合：</p>
<ul>
<li><code>FD_ZERO(fd_set *fdset)</code>: 清除一个文件描述符集合。</li>
<li><code>FD_SET(int fd, fd_set *fdset)</code>: 添加一个新的文件描述符到集合中。</li>
<li><code>FD_CLR(int fd, fd_set *fdset)</code>: 从集合中移除一个文件描述符。</li>
<li><code>FD_ISSET(int fd, fd_set *fdset)</code>: 检查集合中的一个文件描述符是否就绪。</li>
</ul>
<p>注意，在调用<code>select</code>函数后，这些集合会被修改，只包含那些状态发生变化（即准备好进行读或写操作）的文件描述符。因此，如果你想要在一个循环中重复使用<code>select</code>，你需要在每次调用<code>select</code>前重新设置这些集合。</p>
<p>虽然<code>select</code>在一些场景下非常有用，但是它有一些已知的限制，例如最大的文件描述符数量（通常是1024），以及处理大量文件描述符时的效率问题。在这些情况下，你可能需要使用其他的I&#x2F;O多路复用机制，例如<code>poll</code>或<code>epoll</code>。</p>
<h5 id="tip：这是一种异步I-x2F-O模型，因为你不需要阻塞等待单个I-x2F-O操作的完成。"><a href="#tip：这是一种异步I-x2F-O模型，因为你不需要阻塞等待单个I-x2F-O操作的完成。" class="headerlink" title="tip：这是一种异步I&#x2F;O模型，因为你不需要阻塞等待单个I&#x2F;O操作的完成。"></a>tip：这是一种异步I&#x2F;O模型，因为你不需要阻塞等待单个I&#x2F;O操作的完成。</h5><p>当我们说一个I&#x2F;O操作是“阻塞”的，这意味着执行这个操作的线程或进程在操作完成之前会被挂起。例如，如果你在一个阻塞的套接字上执行读操作，而这个套接字当前并没有接收到任何数据，那么执行读操作的线程就会被挂起，直到有数据到达。在这个过程中，线程不能做任何其他的事情。</p>
<p>相反，“非阻塞”的I&#x2F;O操作意味着即使操作不能立即完成，执行这个操作的线程或进程也不会被挂起。例如，如果你在一个非阻塞的套接字上执行读操作，而这个套接字当前并没有接收到任何数据，那么读操作会立即返回一个错误，而线程可以继续做其他的事情。</p>
<p>I&#x2F;O多路复用（例如select、poll或epoll）提供了一种异步的I&#x2F;O模型。在这个模型中，你可以同时监视多个文件描述符，并在任何一个描述符准备好进行I&#x2F;O操作时得到通知。这样，你就可以在等待I&#x2F;O操作的同时做其他的事情，或者同时处理多个I&#x2F;O操作。这就是为什么我们说这是一个“异步”的模型：你不需要为每个I&#x2F;O操作分别阻塞等待。</p>
<p>例如，在上述select的例子中，服务器可以同时处理多个客户端的请求。当任何一个客户端的套接字准备好进行读操作（即有数据到达）时，select函数就会返回，然后服务器可以读取这个套接字上的数据。在这个过程中，服务器并不需要为每个客户端分别阻塞等待。</p>
<p>通俗解释一下：</p>
<p>你想从你家到县城去，阻塞方式是：你去车站等车，等车期间你哪也不能去，就干等到车来；非阻塞方式，你在家等车，这期间你想干啥就干啥，等车来了，司机会滴喇叭，跟你说快上车。</p>
<h4 id="让我们通过一个简单的服务器代码示例来进一步理解select的使用。这个示例是一个TCP回显服务器，它使用select来同时处理多个客户端的连接和请求。"><a href="#让我们通过一个简单的服务器代码示例来进一步理解select的使用。这个示例是一个TCP回显服务器，它使用select来同时处理多个客户端的连接和请求。" class="headerlink" title="让我们通过一个简单的服务器代码示例来进一步理解select的使用。这个示例是一个TCP回显服务器，它使用select来同时处理多个客户端的连接和请求。"></a>让我们通过一个简单的服务器代码示例来进一步理解<code>select</code>的使用。这个示例是一个TCP回显服务器，它使用<code>select</code>来同时处理多个客户端的连接和请求。</h4><p>这是一个非常基础的示例，它没有处理一些可能的错误情况，例如文件描述符耗尽，以及<code>select</code>的最大文件描述符限制。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    listen(listen_fd, MAX_CLIENTS);</span><br><span class="line"></span><br><span class="line">    fd_set read_fds;</span><br><span class="line">    <span class="type">int</span> max_fd = listen_fd;</span><br><span class="line">    <span class="type">int</span> clients[MAX_CLIENTS] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        FD_ZERO(&amp;read_fds);</span><br><span class="line">        FD_SET(listen_fd, &amp;read_fds);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clients[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                FD_SET(clients[i], &amp;read_fds);</span><br><span class="line">                <span class="keyword">if</span> (clients[i] &gt; max_fd) &#123;</span><br><span class="line">                    max_fd = clients[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        select(max_fd + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listen_fd, &amp;read_fds)) &#123;</span><br><span class="line">            <span class="type">int</span> client_fd = accept(listen_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (clients[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    clients[i] = client_fd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clients[i] &gt; <span class="number">0</span> &amp;&amp; FD_ISSET(clients[i], &amp;read_fds)) &#123;</span><br><span class="line">                <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">                <span class="type">int</span> len = read(clients[i], buffer, BUFFER_SIZE - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Received from client: %s\n&quot;</span>, buffer);</span><br><span class="line">                    write(clients[i], buffer, len);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    close(clients[i]);</span><br><span class="line">                    clients[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序首先创建一个监听套接字，然后进入一个无限循环，在循环中调用<code>select</code>函数等待新的连接或者已连接的客户端的请求。每次循环都会重新设置文件描述符集合，添加监听套接字以及所有已连接的客户端的套接字。</p>
<p>如果<code>select</code>函数返回并指示监听套接字已经准备好（有新的连接请求），程序就接受新的连接，并把新的客户端套接字添加到客户端数组中。</p>
<p>如果<code>select</code>函数返回并指示某个客户端套接字已经准备好（有新的数据到达），程序就</p>
<p>读取这个套接字上的数据，然后回显（即原样返回）这些数据。如果读取操作返回0或负值（表示连接已经关闭或出错），程序就关闭这个套接字，并把它从客户端数组中移除。</p>
<p>这个示例展示了如何使用<code>select</code>处理多个客户端的连接和请求。然而在实际的程序中，你需要处理更多的问题，例如<code>select</code>的最大文件描述符限制，以及文件描述符耗尽的问题。在处理大量连接时，你可能需要考虑使用其他的I&#x2F;O多路复用技术，例如<code>poll</code>或<code>epoll</code>。</p>
<h5 id="max-fd到底有啥作用呢？select函数第一个参数我为啥感觉没啥作用呢？"><a href="#max-fd到底有啥作用呢？select函数第一个参数我为啥感觉没啥作用呢？" class="headerlink" title="max_fd到底有啥作用呢？select函数第一个参数我为啥感觉没啥作用呢？"></a>max_fd到底有啥作用呢？select函数第一个参数我为啥感觉没啥作用呢？</h5><p><code>select</code>函数的第一个参数，即<code>nfds</code>，表示需要监视的文件描述符的范围，它的值应该是所有文件描述符中最大的那个加1。</p>
<p>为什么需要最大文件描述符呢？</p>
<p>原因是<code>select</code>函数在内部实现时会遍历所有的文件描述符，从0到<code>nfds - 1</code>。**<code>select</code>函数将检查这个范围内的每一个文件描述符，看看它是否在<code>readfds</code>、<code>writefds</code>或<code>exceptfds</code>集合中，并且它的状态是否发生了变化（即是否准备好进行读、写或者是否有异常）**。</p>
<p>实际上，<code>select</code>不关心文件描述符是否连续，它只是检查你指定的范围内的每一个文件描述符。因此，如果你的程序中最大的文件描述符是10，那么你就应该把<code>nfds</code>设为11，即使你的程序并没有使用文件描述符0到9。</p>
<p>在设置<code>nfds</code>时，使用最大文件描述符加1是一个优化的选择。如果你把<code>nfds</code>设得过大，<code>select</code>函数就会浪费时间去检查那些并不存在的文件描述符。反之，如果你把<code>nfds</code>设得过小，<code>select</code>函数就会忽略那些超出范围的文件描述符，即使它们在<code>readfds</code>、<code>writefds</code>或<code>exceptfds</code>集合中，并且状态发生了变化。</p>
<p>因此，<code>max_fd</code>在这里的作用就是帮助我们正确地设置<code>select</code>函数的<code>nfds</code>参数，以便让<code>select</code>函数高效地监视我们关心的所有文件描述符。</p>
<h5 id="代码里面貌似自始至终也没体现select函数的作用，因为连select函数的返回值都没用上，就好比现在select现在监听1-2-3-4-5-6这6个文件描述符，假设5准备就绪了，我怎么知道5准备就绪了呢，在你的代码貌似并没有体现出来"><a href="#代码里面貌似自始至终也没体现select函数的作用，因为连select函数的返回值都没用上，就好比现在select现在监听1-2-3-4-5-6这6个文件描述符，假设5准备就绪了，我怎么知道5准备就绪了呢，在你的代码貌似并没有体现出来" class="headerlink" title="代码里面貌似自始至终也没体现select函数的作用，因为连select函数的返回值都没用上，就好比现在select现在监听1 2 3 4 5 6这6个文件描述符，假设5准备就绪了，我怎么知道5准备就绪了呢，在你的代码貌似并没有体现出来"></a>代码里面貌似自始至终也没体现select函数的作用，因为连select函数的返回值都没用上，就好比现在select现在监听1 2 3 4 5 6这6个文件描述符，假设5准备就绪了，我怎么知道5准备就绪了呢，在你的代码貌似并没有体现出来</h5><p>实际上，当<code>select</code>函数返回后，我们可以通过检查<code>read_fds</code>集合来确定哪些文件描述符已经准备就绪。</p>
<p>具体来说，如果<code>FD_ISSET(fd, &amp;read_fds)</code>为真，那么就表示<code>fd</code>已经准备好进行读操作。在我的示例代码中，这个检查分别在处理监听套接字和客户端套接字时进行。</p>
<p>如果<code>select</code>函数指示监听套接字已经准备好（有新的连接请求），那么我们就接受新的连接：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (FD_ISSET(listen_fd, &amp;read_fds)) &#123;</span><br><span class="line">    <span class="type">int</span> client_fd = accept(listen_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 添加新的客户端到 clients 数组...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>select</code>函数指示某个客户端套接字已经准备好（有新的数据到达），那么我们就读取这个套接字上的数据：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (clients[i] &gt; <span class="number">0</span> &amp;&amp; FD_ISSET(clients[i], &amp;read_fds)) &#123;</span><br><span class="line">        <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">        <span class="type">int</span> len = read(clients[i], buffer, BUFFER_SIZE - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 处理读取到的数据...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例代码的目的是展示<code>select</code>函数如何用于处理多个连接和请求。在实际的应用中，你可能还需要处理更多的情况，例如写就绪和异常，以及<code>select</code>函数的返回值（表示已经准备就绪的文件描述符的数量）。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>有了select的基础，理解poll起来就方便一点啦。<code>poll</code>函数是另一种I&#x2F;O多路复用的技术。与<code>select</code>相比，它的主要优点是没有文件描述符的数量限制，而且API使用起来可能更加直观。<code>poll</code>函数使用一个<code>pollfd</code>结构体数组，其中每个结构体都包含一个文件描述符和一些标志位，表示我们对哪些事件感兴趣（例如POLLIN表示我们对读事件感兴趣）。</p>
<p>下面是一个简单的使用<code>poll</code>的服务器代码示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    listen(listen_fd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">clients</span>[<span class="title">MAX_CLIENTS</span>];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">        clients[i].fd = <span class="number">-1</span>; <span class="comment">// -1表示该位置没有使用</span></span><br><span class="line">        clients[i].events = POLLIN; <span class="comment">// 对读事件感兴趣</span></span><br><span class="line">    &#125;</span><br><span class="line">    clients[<span class="number">0</span>].fd = listen_fd; <span class="comment">// 监听套接字始终在clients[0]的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> nready = poll(clients, MAX_CLIENTS, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clients[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">            <span class="comment">// 监听套接字准备好了，表示有新的连接请求</span></span><br><span class="line">            <span class="type">int</span> client_fd = accept(listen_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 将新的连接添加到clients数组中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (clients[i].fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    clients[i].fd = client_fd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clients[i].fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (clients[i].revents &amp; (POLLIN | POLLERR)) &#123;</span><br><span class="line">                <span class="comment">// 客户端套接字准备好了，表示有数据可以读取</span></span><br><span class="line">                <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">                <span class="type">int</span> len = read(clients[i].fd, buffer, BUFFER_SIZE - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 连接已经关闭或出错，将该客户端从数组中移除</span></span><br><span class="line">                    close(clients[i].fd);</span><br><span class="line">                    clients[i].fd = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 将接收到的数据回显给客户端</span></span><br><span class="line">                    write(clients[i].fd, buffer, len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，服务器使用<code>poll</code>函数同时监视所有连接的客户端套接字。每次当<code>poll</code>函数返回时，服务器会检查哪些套接字已经准备好进行I&#x2F;O操作，并相应地处理它们。</p>
<h5 id="clients-0-revents-amp-POLLIN这个代表啥意思"><a href="#clients-0-revents-amp-POLLIN这个代表啥意思" class="headerlink" title="clients[0].revents &amp; POLLIN这个代表啥意思"></a>clients[0].revents &amp; POLLIN这个代表啥意思</h5><p>这是在检查<code>poll</code>函数返回后哪些文件描述符发生了事件。</p>
<p><code>clients[0].revents &amp; POLLIN</code>这个表达式使用了位运算符<code>&amp;</code>来检查<code>revents</code>字段的某个特定位（在这个例子中是<code>POLLIN</code>位）是否被设置。如果结果非零，那么说明<code>POLLIN</code>事件发生了，也就是说对应的文件描述符已经准备好进行读操作。</p>
<p>这里的<code>POLLIN</code>是一个常量，表示可以从文件描述符中读取数据。<code>revents</code>字段则是<code>poll</code>函数返回后设置的，表示在调用<code>poll</code>函数期间，哪些事件发生了。</p>
<p>如果<code>clients[0].revents &amp; POLLIN</code>为真，那么就表示监听套接字已经准备好，我们可以从这个套接字上接受新的连接。</p>
<h5 id="这个能不能给出一个实例，不太理解"><a href="#这个能不能给出一个实例，不太理解" class="headerlink" title="这个能不能给出一个实例，不太理解"></a>这个能不能给出一个实例，不太理解</h5><p>当然可以，让我们试着用一个简单的例子来理解这个概念。</p>
<p>首先，我们要知道<code>POLLIN</code>和<code>revents</code>都是整型（int）变量，也就是说，它们都可以表示为二进制数。</p>
<p>假设<code>POLLIN</code>的值是4，也就是二进制的<code>100</code>，而<code>revents</code>的值是5，也就是二进制的<code>101</code>。</p>
<p>我们用<code>&amp;</code>（位运算符AND）来对这两个值进行操作，得到的结果是<code>100</code>，也就是4，非零值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  POLLIN:  100 (二进制)</span><br><span class="line">  revents: 101 (二进制)</span><br><span class="line">----------------------</span><br><span class="line">  结果:    100 (二进制) = 4 (十进制)</span><br></pre></td></tr></table></figure>

<p>这个结果是非零的，所以<code>if (clients[0].revents &amp; POLLIN)</code>的判断结果是真。这就表示<code>revents</code>的<code>POLLIN</code>位被设置了，也就是说，对应的文件描述符已经准备好进行读操作了。</p>
<p>如果<code>revents</code>的值是2（二进制<code>010</code>），那么结果就是零：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  POLLIN:  100 (二进制)</span><br><span class="line">  revents: 010 (二进制)</span><br><span class="line">----------------------</span><br><span class="line">  结果:    000 (二进制) = 0 (十进制)</span><br></pre></td></tr></table></figure>

<p>这个结果是零，所以<code>if (clients[0].revents &amp; POLLIN)</code>的判断结果是假。这就表示<code>revents</code>的<code>POLLIN</code>位没有被设置，也就是说，对应的文件描述符还没有准备好进行读操作。</p>
<p>所以，这个表达式就是在检查<code>revents</code>是否表示文件描述符已经准备好进行读操作。</p>
<h5 id="recv函数"><a href="#recv函数" class="headerlink" title="recv函数"></a><code>recv</code>函数</h5><p>在<code>socket</code>编程中，<code>recv</code>函数的返回值有以下三种情况：</p>
<ol>
<li><p>当<code>recv</code>函数返回0时，表示连接已经关闭，也就是说，另一端已经执行了<code>close</code>操作。</p>
</li>
<li><p>当<code>recv</code>函数返回-1时，表示接收数据时发生了错误，你可以通过检查全局变量<code>errno</code>来确定具体的错误类型。在非阻塞模式下，如果没有可读取的数据，<code>recv</code>函数也会返回-1，并且<code>errno</code>会被设置为<code>EAGAIN</code>或者<code>EWOULDBLOCK</code>。</p>
</li>
<li><p>如果返回值大于0，表示成功接收到了数据。</p>
</li>
</ol>
<p>在你给出的代码中，<code>if (ret &lt;= 0)</code>这个判断语句实际上就是在处理以上的前两种情况。也就是说，如果连接已经关闭，或者在接收数据时发生了错误，就关闭<code>socket</code>。</p>
<p>在你的例子中，<code>ret=0</code>实际上并不是代表LT模式下未响应此事件，而是表示对端关闭了连接。因此，关闭这个<code>socket</code>是合理的，因为这个连接已经没有用了。即使接收缓冲区里还有未读取的数据，这些数据也无法被发送到已经关闭的对端，所以就没有必要保持这个<code>socket</code>打开了。</p>
]]></content>
      <tags>
        <tag>c++</tag>
        <tag>Linux</tag>
        <tag>webServer</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2023/11/10/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>2023-11-10</p>
<p>并查集：<a href="https://blog.csdn.net/YSJ367635984/article/details/113504723">https://blog.csdn.net/YSJ367635984/article/details/113504723</a></p>
<span id="more"></span>

<p>C++代码实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisjointSets</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DisjointSets</span>();</span><br><span class="line">    ~<span class="built_in">DisjointSets</span>();</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findParentNode</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unionSetNode</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; parent;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DisjointSets::<span class="built_in">DisjointSets</span>(): <span class="built_in">count</span>(<span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; ++i)&#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DisjointSets::~<span class="built_in">DisjointSets</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">int DisjointSets::findParentNode(int x)&#123;</span></span><br><span class="line"><span class="comment">    if(x != parent[x])&#123;</span></span><br><span class="line"><span class="comment">        findParentNode(parent[x]);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return x;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化版本的并查集，减小以后查找时间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DisjointSets::findParentNode</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x != parent[x])&#123;</span><br><span class="line">        <span class="comment">// 找一次x只是压缩一次，多找几次就会导致父节点为根节点</span></span><br><span class="line">        parent[x] = parent[parent[x]];</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DisjointSets::unionSetNode</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> parent_x = <span class="built_in">findParentNode</span>(x);</span><br><span class="line">    <span class="type">int</span> parent_y = <span class="built_in">findParentNode</span>(y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(parent_x == parent_y) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    parent[parent_y] = parent_x;</span><br><span class="line">    </span><br><span class="line">    --count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>计算机网络八股文</title>
    <url>/2023/05/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A1%E6%96%87/</url>
    <content><![CDATA[<p>1、HTTP常见的状态码</p>
<ul>
<li>1XX	提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</li>
<li>2XX    成功，报文已经成功收到并被正确处理；</li>
<li>3XX    重定向，资源位置发生变动，需要客户端重新发送请求；</li>
<li>4XX    客户端错误，请求报文有误，服务器无法处理；</li>
<li>5XX    服务器错误。服务器在处理请求时内部发生了错误；</li>
</ul>
<p>2、HTTP请求和响应的各自组成部分</p>
<p>HTTP通信协议由请求（Request）和响应（Response）两部分构成。每个请求和响应都由头部和主体组成，其中头部包含了各种元数据，而主体则包含了实际的内容（如果有的话）。</p>
<h5 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h5><p>HTTP请求包括以下字段：</p>
<ol>
<li><p><strong>请求行（Request Line）</strong>：请求行包括HTTP方法（比如GET、POST、PUT、DELETE等）、请求的URI、以及HTTP版本。</p>
</li>
<li><p><strong>请求头（Request Headers）</strong>：请求头包含了一系列的字段，每个字段都提供了一些关于请求的元数据。常见的请求头包括：</p>
<ul>
<li>Host: 请求的目标主机名和端口号。</li>
<li>User-Agent: 发起请求的用户代理的信息，通常包括浏览器类型、版本、操作系统等信息。</li>
<li>Accept: 客户端可以处理的MIME类型。</li>
<li>Accept-Language: 客户端接受的语言。</li>
<li>Accept-Encoding: 客户端接受的内容编码，比如gzip。</li>
<li>Cookie: 客户端存储的用于服务器识别的cookie。</li>
<li>Content-Type: 如果请求包含了主体，这个字段描述了主体的MIME类型。</li>
<li>Content-Length: 如果请求包含了主体，这个字段描述了主体的长度。</li>
</ul>
</li>
<li><p><strong>请求主体（Request Body）</strong>：不是所有的请求都包含主体。比如GET和HEAD请求就没有主体。但是POST和PUT请求通常会有主体，包含了要发送给服务器的数据。</p>
</li>
</ol>
<h5 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h5><p>HTTP响应包括以下字段：</p>
<ol>
<li><strong>状态行（Status Line）</strong>：状态行包括HTTP版本、状态码（比如200表示成功，404表示未找到等），以及状态描述。</li>
<li><strong>响应头（Response Headers）</strong>：响应头包含了一系列的字段，每个字段都提供了一些关于响应的元数据。常见的响应头包括：<ul>
<li>Server: 发送响应的服务器的信息。</li>
<li>Content-Type: 响应主体的MIME类型。</li>
<li>Content-Length: 响应主体的长度。</li>
<li>Content-Encoding: 响应主体的内容编码，比如gzip。</li>
<li>Set-Cookie: 服务器想要设置在客户端的cookie。</li>
<li>Last-Modified: 资源的最后修改日期。</li>
<li>ETag: 资源的版本标识。</li>
</ul>
</li>
<li><strong>响应主体（Response Body）</strong>：响应的主体包含了服务器返回的数据，比如HTML页面、图片、JSON数据等。</li>
</ol>
<p>3、完整的HTTP请求和响应展示</p>
<p>让我们来看一下一对典型的HTTP请求和响应。</p>
<h5 id="HTTP请求示例"><a href="#HTTP请求示例" class="headerlink" title="HTTP请求示例"></a>HTTP请求示例</h5><p>假设你在浏览器中访问 <code>http://www.example.com</code>，你的浏览器可能会发送如下的GET请求：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">Accept-Language: en-US,en;q=0.9</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<h5 id="HTTP响应示例"><a href="#HTTP响应示例" class="headerlink" title="HTTP响应示例"></a>HTTP响应示例</h5><p>对于上述的请求，服务器可能会返回如下的响应：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">HTTP/1.1</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">Date:</span> <span class="string">Mon,</span> <span class="number">23</span> <span class="string">May</span> <span class="number">2023 22:38:34 </span><span class="string">GMT</span></span><br><span class="line"><span class="attr">Server:</span> <span class="string">Apache/2.4.1</span> <span class="string">(Unix)</span></span><br><span class="line"><span class="attr">Last-Modified:</span> <span class="string">Sat,</span> <span class="number">20</span> <span class="string">May</span> <span class="number">2023 18:56:51 </span><span class="string">GMT</span></span><br><span class="line"><span class="attr">ETag:</span> <span class="string">&quot;2dcd3-2c-54b5a5e68b177&quot;</span></span><br><span class="line"><span class="attr">Accept-Ranges:</span> <span class="string">bytes</span></span><br><span class="line"><span class="attr">Content-Length:</span> <span class="number">44</span></span><br><span class="line"><span class="attr">Vary:</span> <span class="string">Accept-Encoding</span></span><br><span class="line"><span class="attr">Content-Type:</span> <span class="string">text/html</span></span><br><span class="line"></span><br><span class="line"><span class="string">&lt;html&gt;&lt;body&gt;&lt;h1&gt;It</span> <span class="string">works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<p>这个响应表示请求成功（状态码是200），服务器返回了一个简单的HTML页面作为响应主体。响应头还包含了一些其他的信息，比如服务器类型（Apache），最后修改日期，内容长度，内容类型等。</p>
<p>希望这些示例可以帮助你更好地理解HTTP请求和响应！</p>
<p>4、TCP的KeepAlive和HTTP的Keep-Alive</p>
<p>TCP的KeepAlive和HTTP的Keep-Alive虽然名字类似，但实际上是两个不同级别的概念，分别在TCP和HTTP协议层级中起作用。</p>
<p><strong>TCP的KeepAlive</strong>：</p>
<p>TCP的KeepAlive是一个底层的、可选的机制，其目的是为了检测和维护处于空闲状态的TCP连接。一旦启用，如果在特定的时间间隔内（通常在数小时）没有任何数据在TCP连接上进行交换，那么发送方就会发送一个KeepAlive数据包到接收方，而无需传输任何应用级别的数据。接收方需要对这个数据包做出响应。如果发送方在一定时间内没有收到响应，它将重发KeepAlive数据包，一般会尝试多次。如果仍然没有收到响应，发送方将假设连接已经断开，并将其关闭。</p>
<p><strong>HTTP的Keep-Alive</strong>：</p>
<p>HTTP的Keep-Alive是在HTTP 1.1引入的，用来允许单一的TCP连接被多个HTTP请求&#x2F;响应共享，而不是每个请求&#x2F;响应都重新建立一个新的连接。这显著提高了网络通信的效率，因为建立和关闭TCP连接需要时间和资源。</p>
<p>在HTTP 1.0中，每个HTTP请求&#x2F;响应都需要一个新的TCP连接，这被称为非持久连接。而在HTTP 1.1中，默认启用了Keep-Alive，也就是说默认使用持久连接，除非明确指定”Connection: close”。</p>
<p>当使用HTTP Keep-Alive时，HTTP请求的头部会包含一个”Connection: keep-alive”字段，这告诉服务器客户端希望保持连接以便发送更多的请求。服务器的响应也会包含一个”Connection: keep-alive”字段，这表示服务器同意保持连接。</p>
<p>总的来说，这两个概念都关于连接的维护，但是工作在不同的层级。TCP的KeepAlive主要是为了检测和处理僵死连接，而HTTP的Keep-Alive则是为了提高效率，通过复用已存在的TCP连接来发送多个HTTP请求&#x2F;响应。</p>
<p><strong>队头阻塞</strong></p>
<p>这里涉及到一个小概念需要说一下：可以想象，当我们开启Keep-Alive时，我们无需像以前那样，先发送A请求，等待服务器回应，再发送B请求…..一直如此运作下去。我们可以发送A请求后，无需等待服务器响应，紧接着发送B请求。但是服务器还是按照顺序响应，先响应A请求，完成后再响应B请求。其实这里很明显感觉到会有问题，如果迟迟收不到A响应，后面的响应就更收不到了，就会造成所谓的<strong>队头阻塞</strong>问题。</p>
<p><strong>在使用HTTP长连接时，如果一个客户端完成了一个HTTP请求后不在发起请求，此时这个TCP连接一直占用不就会导致浪费资源吗？</strong></p>
<p>对没错，所以为了避免资源浪费的情况，web 服务软件一般都会提供 <code>keepalive_timeout</code> 参数，用来指定 HTTP 长连接的超时时间。</p>
<p>比如设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会<strong>启动一个定时器</strong>，如果客户端在完后一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，<strong>定时器的时间一到，就会触发回调函数来释放该连接。</strong></p>
<p><strong>传输层协议有哪些</strong></p>
<p><code>UDP</code>和<code>TCP</code>协议；</p>
<p><strong><code>TCP</code>协议的特点</strong></p>
<p>面向连接的：采用<code>TCP</code>协议通信的双方必须通过三次握手建立连接才能开始数据的读写。完成数据交换以后，通信双方都必须断开连接，以释放内核的资源。</p>
<p>面向字节流的：当用户消息通过<code>TCP</code>协议传输时，<code>TCP</code>模块先将这些消息放入<code>TCP</code>发送缓冲区，发送的时候消息可能会被操作系统分组成多个<code>TCP</code>报文。注意，当我们调用<code>send</code>函数的时候，消息并没有真正被发送出去，只是被拷贝到了操作系统内核协议栈中。何时被真正发送，取决于<strong>发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件</strong>。</p>
<p>可靠的：1、<code>TCP</code>采用发送应答机制，即<code>TCP</code>发送端发送每一个<code>TCP</code>报文段都要接收到对方的应答，才认为这个<code>TCP</code>报文段传输成功；2、<code>TCP</code>协议采用超时重传机制，发送端发送一个<code>TCP</code>报文段之后，开启定时器，如果在规定时间内没有接收到应答，则重传此<code>TCP</code>报文段；3、因为<code>TCP</code>报文段最终是以<code>IP</code>数据报发送的，<code>IP</code>数据报到达接受方的时候可能乱序、重复，TCP协议还会对接收到的TCP报文段重排、整理，再交付给应用层。</p>
<p><strong>描述TCP头部结构的大致组成部分</strong></p>
<p>16位源端口号、16位目标端口号、32位序号、32位确认号、4位头部长度、6位保留、6位标志位、16位窗口大小、16位校验和、16位紧急指针</p>
<p><strong>简述各部分作用</strong></p>
<p>源端口号代表的是是从发送端的哪一个端口发送出来的，目的端口号代表的是发送给接收端上层应用程序的哪一个端口。</p>
<p><code>TCP</code>报文段的序号值等于系统初始化的某个随机值<code>ISN</code>加上该报文段在字节流中的偏移（偏移值）。</p>
<p>确认号就是接收到的<code>TCP</code>报文段的序号值加1。</p>
<p>4位头部长度代表<code>TCP</code>报文段整个头部长度有多少个<code>32bit</code>字（四字节）。</p>
<p>6位标志位分别为：<code>URG</code>（紧急指针是否有效）、<code>ACK</code>（确认号）、<code>PSH</code>（接收端应立即从<code>TCP</code>接收缓冲区中读走数据）、<code>RST</code>（表示要求对方重新建立连接）、<code>SYN</code>（请求建立一个连接）、<code>FIN</code>（通知对方本端要关闭连接）。</p>
<p>16位窗口大小是流量控制的一个手段，他告诉对方本端的<code>TCP</code>接收缓冲区还能容纳多少字节的数据。</p>
<p>16位校验和由发送端填充，接收端采取<code>CRC</code>算法对接收到的<code>TCP</code>报文段验证。</p>
<p><strong>TCP连接的建立和关闭</strong></p>
<p>首先，通过数据展示一下三次握手：</p>
<p>发送端：<code>seq 12345 (SYN)</code>     ————-      接收端：<code>seq 56789 (SYN)</code>  <code>ack 12346</code>    ————-   发送端：<code>ack 56790</code></p>
<p>接下来是四次握手，假设发送端首先发出了断开连接请求</p>
<p>发：<code>seq 12346</code>, <code>ack 56790</code> <code>(FIN)</code> —— 收：<code>ack 12347</code> —— 收：<code>seq 56790</code>, <code>ack 12347</code> <code>(FIN)</code> ——- 发：<code>ack 56791</code>  </p>
<p>实际上，四次握手中的收的第一次确认报文段可以省略，因为下一次收的TCP报文段里包含了<code>ack</code>。其实第一个<code>ack</code>是否应该出现取决于<code>TCP</code>的延迟确认特性。</p>
<p><strong>TCP状态转移</strong></p>
<p>服务器处于被动等待客户连接，可以简单描述一下当有客户端请求连接时，该连接服务器端的状态变化为：</p>
<p><code>LISTEN</code> ————- <code>SYN RCVD</code> —————– <code>ESTABLISHED</code>.</p>
<p>当客户端主动关闭连接时，服务器端状态变化为：</p>
<p><code>CLOSE_WAIT</code> ————– <code>LAST_ACK</code>.</p>
<p>请求连接时，客户端状态变化为，考虑<code>connect</code>系统调用成功</p>
<p><code>SYN_SENT</code> ————- <code>ESTABLISHED</code></p>
<p>注意，<code>connect</code>系统调用失败有三个原因：</p>
<p>1、<code>connect</code>连接的目标端口不存在（未被任何线程监听）</p>
<p>2、<code>connect</code>试图连接的端口处在<code>TIME_WAIT</code>状态</p>
<p>3、没有收到服务器端的应答报文</p>
<p><code>connect</code>调用失败则返回<code>CLOSE</code>状态。</p>
<p>客户端请求关闭时，客户端状态变化为</p>
<p><code>FIN_WAIT_1</code> ———- <code>(FIN_WAIT_2)</code> ————– <code>TIME_WAIT</code></p>
<p><strong>TIME_WAIT状态好好看看书的3.4.2节，讲的很好</strong></p>
<p><strong>复位报文段</strong></p>
<p><strong>什么情况下接收端会回复复位报文段？</strong></p>
<p>1、发送端访问一个不存在的窗口。</p>
<p>2、发送端访问的服务器端的窗口仍处于<code>TIME_WAIT</code>状态。</p>
<p>3、半打开状态向连接发送数据，会收到复位报文段。</p>
<p><strong>收到复位报文段应该如何处理呢</strong></p>
<p>收到复位报文段的机器应该断开连接或者重新发起连接。</p>
<p><strong>半打开状态</strong></p>
<p>假设现在服务器端（或者客户端）关闭或者异常终止了连接，客户端（或者服务器端）并没有接收到结束报文段，依旧保持连接状态，就称为半打开连接状态。如果此时客户端（或者服务器端）向此连接发送数据，会收到一个复位报文段的回应报文。</p>
<p><strong>关于<code>MSS</code>的计算</strong></p>
<p>首先需要了解两个名词，一个是<code>MTU</code>（<code>MaxMaximum Transmission Unit</code>）是指网络传输中最大的数据包大小，<code>MSS</code>（<code>Maximum Segment Size</code>）是指<code>TCP</code>协议中数据段的最大大小。在<code>TCP</code>协议中，<code>MSS</code>是由<code>MTU</code>减去<code>IP</code>和<code>TCP</code>头部的长度得出的。</p>
<p><code>IP</code>头部的长度通常为20个字节，<code>TCP</code>头部的长度通常为20个字节，所以<code>MSS</code>的计算方法为：</p>
<p><code>MSS</code>&#x3D; <code>MTU</code> - <code>IP</code>头部长度 - <code>TCP</code>头部长度</p>
<p>因此，在<code>MTU</code>为16436字节的情况下，<code>MSS</code>的计算公式为：</p>
<p><code>MSS</code> &#x3D; 16436 - 20 - 20 &#x3D; 16396</p>
<p>其中，20是<code>IP</code>头部和<code>TCP</code>头部的长度之和，这是因为<code>IP</code>和<code>TCP</code>协议都需要使用头部来传递各种控制信息，如源地址、目标地址、端口号、序列号、确认号等。因此，在<code>TCP</code>协议中，<code>MSS</code>是<code>MTU</code>减去<code>IP</code>和<code>TCP</code>头部长度的结果。</p>
]]></content>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/2023/10/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>DiaDSP</title>
    <url>/2024/10/22/DiaDSP/</url>
    <content><![CDATA[<h3 id="Differentially-Private-Distributed-Optimization-via-State-and-Direction-Perturbation-in-Multiagent-Systems"><a href="#Differentially-Private-Distributed-Optimization-via-State-and-Direction-Perturbation-in-Multiagent-Systems" class="headerlink" title="Differentially Private Distributed Optimization via State and Direction Perturbation in Multiagent Systems"></a>Differentially Private Distributed Optimization via State and Direction Perturbation in Multiagent Systems</h3><span id="more"></span>
<h4 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h4><p><a href="https://differential-privacy.cn/">Differential privacy</a> <i class="fa fa-external-link"></i></p>
<h4 id="Prerequisite-Knowledge"><a href="#Prerequisite-Knowledge" class="headerlink" title="Prerequisite Knowledge"></a>Prerequisite Knowledge</h4><p>What is state perturbation ?</p>
<ul>
<li>State perturbation refers to the intentional modification of an agent’s current state by introducing randomness or noise.</li>
</ul>
<p>What is differential privacy ?</p>
<ul>
<li>Differential privacy is a formal framework designed to ensure the privacy of individual’s data. <a href="https://arxiv.org/pdf/1401.2596">Achieving differential privacy requires that any change in the statistics of the messages</a>.<i class="fa fa-external-link"></i></li>
</ul>
<p>What is direction perturbation ?</p>
<p>Direction perturbation involves introducing randomness or noise into the direction of the optimization process in a distributed algorithm. This technique modifies the gradient or update direction that agents use when adjusting their parameters during optimization.<br>By perturbing the direction, the algorithm can maintain privacy by making it more challenging for other agents or observers to infer the true gradient information, thereby protecting individual agents’ objective functions. Additionally, direction perturbation can help enhance the robustness of the optimization process and contribute to convergence properties, particularly in scenarios where privacy is a critical concern.</p>
<p>What is differential privacy ?</p>
<p>In simple terms, Laplace noise refers to a random variable that follows a Laplace distribution. The probability density function of Laplace noise is represented as follows:<br>$$f(x \mid \mu, b) = \frac{1}{2b} e^{-\frac{|x-\mu|}{b}}.$$<br>Now, let us introduce the concept of $\epsilon$-differential privacy. Consider a mapping network $\mathbf{A}$ and two sibling datasets $\mathbf{D}$ and $\mathbf{D^{\prime}}$. Note that $\mathbf{D}$ and $\mathbf{D’}$ differ by at most one data point. The mathematical condition for the mapping network $\mathbf{A}$ to satisfy $\epsilon$-differential privacy is as follows<br>$$\operatorname{Pr}\left[A(\mathbf{D})=O\right] \leq e^{\varepsilon} \operatorname{Pr}\left[A\left(\mathbf{D^{\prime}}\right)=O\right].$$<br>The proof is provided here: <a href="https://blog.csdn.net/A13526_/article/details/121300367">$\epsilon$-differential privacy proof</a>.<i class="fa fa-external-link"></i></p>
<p>$x \in \mathbb{R}^u$ represents local observation.</p>
<p>$\mathbf{x} \in \mathbb{R}^{n \times u},$ The rows of $\mathbf{x}$ represent the local observation of each agent $i$.</p>
<p>$\min \sum_{i=1}^{n} f_{i}(x_{i})$ represents the objective function, associated with four properties as below</p>
<ol>
<li><p>$\textit{Existence}$ : </p>
<p>$$\mathbf{x}^{*}= \mathbf{1} \left( x^{*} \right)^{T} \text{ and } \sum_{i=1}^{n} \nabla f_{i} \left( x^{*} \right) = 0.$$</p>
</li>
<li></li>
</ol>
<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>The article focuses on the distributed optimization problem in multi-agent system, where the objective is to minimize the sum of cost functions. It demonstrates that achieving both convergence and differential privacy is impossible through state perturbation in existing algorithms. The authors propose a new algorithm called DiaDSP, which utilizes both state and direction perturbations with decaying Laplace noise to ensure differential privacy. Unlike many prior methods that require diminishing step sizes for convergence, DiaDSP converges in mean and almost surely with a constant step size. The authors establish conditions for linear convergence under strong convexity of the cost functions and R-linear convergence with Lipschitz gradients. The authors also analyze the trade-off between privacy and convergence accuracy and validate their findings through simulations in a sensor fusion context.</p>
<h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><h4 id="Problem-Formulation"><a href="#Problem-Formulation" class="headerlink" title="Problem Formulation"></a>Problem Formulation</h4><p>The objectives of this article are twofold:</p>
<ol>
<li>Design a fully distributed update rule $h(\cdot)$ and a noise adding mechanism $g(\cdot)$ only based on local information to solve the DO problem $\min \sum_{i=1}^{n} f_{i}(x_{i})$ while preserving the differential privacy.</li>
<li>Characterize the trade-off between the accuracy of convergence and the level of differential privacy.</li>
</ol>
<p>Notes:</p>
<ol>
<li>The update rule can be represented in a compact form as follows: $$\mathbf{x}(k + 1) = h(\mathbf{x}(k), \mathbf{z}(k), \textbf(A), \mathcal{F}).$$</li>
<li>The attacker has access to all the transmitted messages, which are usually masked by noise $\zeta(k)$, i.e.,<br>$$\mathbf{z}(k) = g(\mathbf{x}(k), \zeta(k)).$$</li>
<li>The privacy level of $\epsilon$-differential privacy is generally determined by $\epsilon$. The smaller $\epsilon$ is, the higher the privacy level. In other words, it becomes more challenging to distinguish between the two target functions when $\epsilon$ is small.</li>
</ol>
<h4 id="DiaDSP-Algorithm"><a href="#DiaDSP-Algorithm" class="headerlink" title="DiaDSP Algorithm"></a>DiaDSP Algorithm</h4><p>A. Motivation: An Impossibility Result</p>
<p>Summary: The result shows that the convergence and differential privacy cannot be guaranteed simultaneously for any global exact DO algorithm.</p>
<p>Proof of Proposition 1 (convergence ($\surd$))</p>
<p>$\mathbf{x}^{(l)}(k) \rightarrow$ the convergence point by $\mathbf{x}_{l}^{\infty}$. Hence, there is $\delta^{*} &gt; 0$, satisfying $\big| g(\mathbf{x}_{1}^{*}, \mathbf{0}) - g(\mathbf{x}_{2}^{*}, \mathbf{0})\big|_{\textit{F}}$ We set an upper threshold $\frac{\delta^{*}}{3}$. Therefore, there exists $k_{\delta^{*}}^{(l)} &gt; 0$ such that $\big| \mathbf{z}^{l}(k) - g(\mathbf{x}_{l}^{*}, \mathbf{0})\big| &lt; \frac{\delta^{*}}{3}.$<br>$$\big| z^{(1)}(k) - z^{(2)}(k)| \geq |g(x_1^{*}, 0) - g(x_2^{*}, 0)| - |g(x_1^{*}, 0) - z^{(1)}(k)| - |g(x_2^{*}, 0) - z^{(2)}(k)\big|.$$<br>$$|a + b + c| \geq |b| - |a| - |c|.$$<br>$$a = z^{(1)}(k) - g(x_1^{*}, 0), \quad b = g(x_1^{*}, 0) - g(x_2^{*}, 0), \quad c = g(x_2^{*}, 0) - z^{(2)}(k).$$<br>$$|z^{(1)}(k) - z^{(2)}(k)| \geq |g(x_1^{*}, 0) - g(x_2^{*}, 0)| - |z^{(1)}(k) - g(x_1^{*}, 0)| - |g(x_2^{*}, 0) - z^{(2)}(k)|.$$<br>$$|z^{(1)}(k) - z^{(2)}(k)| \geq |g(x_i^{*}, 0) - g(x_2^{*}, 0)| - \frac{2\delta^{*}}{3}.$$</p>
<p>B. Development of DiaDSP</p>
<p>We employ the combine-then-adapt strategy for each agent $i$, which is expressed as $$x_{i}(k+1) = \sum_{j=1}^{n} a_{ij} x_{j}(k) - \alpha_{i} y_{i}(k).$$ This formula is analogous to the parameter update mechanism in neural networks. $x_i(k)$ can be considered as the transition between different states. $y_i(k)$  is regarded as the gradient of the cost function. Therefore, $y_i(k)$ is supposed to have the same direction as $\sum_{i=1}^{n} \nabla f_i(x_i(k)).$ One advantage of adopting the GT method is that the iterations $$x_{i}(k+1) = \sum_{j=1}^{n} a_{ij} x_{j}(k) - \alpha_{i} y_{i}(k).$$ and $$y_i(k+1) = \sum_{j=1}^{n} a_{ij} y_j(k) + \nabla f_i(x_i(k+1)) - \nabla f_i(x_i(k)).$$ share the same network and we do not need to generate another network for the GT iteration. The reason is that they have the same input dimension and both update around the gradient of the cost function with respect to $f_i(x_i(k))$.</p>
<h4 id="Convergence-Analysis-of-DiaDSP"><a href="#Convergence-Analysis-of-DiaDSP" class="headerlink" title="Convergence Analysis of DiaDSP"></a>Convergence Analysis of DiaDSP</h4><p>This section mainly include three key points:</p>
<ol>
<li>Analyze the convergence of DiaDSP</li>
<li>Prove the R-linear convergence of DiaDSP</li>
<li>Determine the optimal step size</li>
</ol>
<p>Differential Privacy</p>
<p>Simulations</p>
<p>Conclusion</p>
<p>Questions and Insights</p>
<ol>
<li>What is R-linear convergence ?</li>
</ol>

    <style>
    #refplus, #refplus li{ 
        padding:0;
        margin:0;
        list-style:none;
    }；
    </style>
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>
    <script>
    document.querySelectorAll(".refplus-num").forEach((ref) => {
        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');
        let refel = document.querySelector(refid);
        let refnum = refel.dataset.num;
        let ref_content = refel.innerText.replace(`[${refnum}]`,'');
        tippy(ref, {
            content: ref_content,
        });
    });
    </script>
    ]]></content>
      <categories>
        <category>Scholarly Reads</category>
      </categories>
      <tags>
        <tag>Distributed Optimization Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>DRL Algorithms</title>
    <url>/2024/10/30/DRL-Algorithms/</url>
    <content><![CDATA[<p>在深度强化学习中，(\mathbb{E}_{S}[V(S, \theta)]) 表示对状态 (S) 的期望值。虽然 (S) 是状态，具体理解上可以这样考虑：</p>
<ol>
<li><p><strong>状态的分布</strong>：在强化学习中，状态 (S) 是随机变量，它遵循一个分布 (p(S))，该分布反映了状态在环境中的出现概率。这个分布可以是初始状态分布，也可以是策略执行时经过各个状态的访问分布。我们可以理解为期望值 (\mathbb{E}_{S}[V(S, \theta)]) 是对状态分布 (p(S)) 的加权平均。</p>
</li>
<li><p><strong>求期望的含义</strong>：当我们求 (\mathbb{E}_{S}[V(S, \theta)]) 时，实际上是在所有可能的状态上计算一个加权平均值，即把每个状态的价值函数 (V(S, \theta)) 按其出现的概率 (p(S)) 来进行加权。这种期望值通常用于估计模型在整个状态空间上的表现。</p>
</li>
<li><p><strong>样本估计</strong>：在实际中，这种期望值可以通过采样实现，比如通过从 (p(S)) 中采样得到一系列状态 (\{S_i\})，然后计算这些状态上 (V(S, \theta)) 的平均值来逼近 (\mathbb{E}_{S}[V(S, \theta)])。</p>
</li>
</ol>
<p>综上，(\mathbb{E}_{S}[V(S, \theta)]) 是对状态空间中的每个状态价值的加权平均，权重来自状态的分布 (p(S))。这种方法在强化学习中帮助我们通过全局状态分布来评估价值函数，从而更有效地训练模型。</p>
<p>随机梯度是对期望的蒙特卡洛近似</p>
<p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030002933171.png" alt="image-20241030002933171"></p>
<p>通常来说，J(\theta)是一个很复杂的函数，而L(\theta | \theta_{old})是一个相对简单的函数</p>
<p>构建L的方法多种多样，可以是J的二阶泰勒展开，也可以是J的蒙特卡洛近似</p>
<p>要maximization，即相当于求解一个带置信域约束的最优化问题，求解速度没有梯度上升和随机梯度上升算法快</p>
<p>但置信域算法强在比这两种算法表现稳定，哪怕最优化问题求解不是很准确。</p>
<p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030003652735.png" alt="image-20241030003652735"></p>
<p>J(\theta) = E_{S}[V_{\pi}(S)]中对S求期望，相当于消除了S，只剩下策略网络参数\theta</p>
<p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030004813870.png" alt="image-20241030004813870"></p>
<p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030005237667.png" alt="image-20241030005237667"></p>
<p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030005401769.png" alt="image-20241030005401769"></p>
<p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030010211366.png" alt="image-20241030010211366"></p>
<p><img src="Users\zcl\AppData\Roaming\Typora\typora-user-images\image-20241030010802155.png" alt="image-20241030010802155"></p>
<p>第四步需要内层循环求解最大化问题，第四步两个超参数，一个\delta，一个学习步长。</p>
]]></content>
  </entry>
  <entry>
    <title>强化学习综述</title>
    <url>/2025/04/16/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="多智能体强化学习通信方法综述"><a href="#多智能体强化学习通信方法综述" class="headerlink" title="多智能体强化学习通信方法综述"></a>多智能体强化学习通信方法综述</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>通信是协调多个智能体行为、拓宽它们对环境的认识以及支持它们协作的有效机制。在多智能体深度强化学习（MADRL）领域，智能体可以通过通信来提高整体学习性能并实现其目标。智能体可以与所有智能体或特定智能体组通信，或者根据特定约束条件进行通信。随着 MADRL 通信（Comm-MADRL）研究工作的不断增多，目前缺乏一种系统性和结构化的方法来区分和分类现有的 Comm-MADRL 方法。在本文中，我们回顾了 Comm-MADRL 领域的最新研究成果，并考虑了在设计和开发多智能体强化学习系统中可能发挥作用的通信的各个方面。考虑到这些方面，我们提出了 9 个维度，沿着这些维度可以对 Comm-MADRL 方法进行分析、开发和比较。通过将现有工作投射到多维空间中，我们发现了一些有趣的趋势。 我们还通过探索可能性的组合，提出了一些设计未来 Comm-MADRL 系统的创新方向。</p>
<h3 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h3><p>许多现实场景，如自动驾驶<sup>[1]</sup>、传感器网络[2]、机器人[3]和游戏[4, 5]，都可以建模为多智能体系统。这些多智能体系统可以通过多智能体强化学习（MARL）技术进行设计和开发，以学习单个智能体的行为，这些行为可以是合作，竞争，或者它们的混合体。由于智能体通常分布在环境中，它们只能访问局部观察而不是环境的完整状态，因此在多智能体强化学习（MARL）中，部分可观测性成为一个基本假设[6-8]。此外，MARL 还面临着非平稳问题[9]，因为每个智能体都面临着受其他智能体变化和适应策略影响的动态环境。通信被视为解决 MARL 中部分可观测性和非平稳问题的关键手段。智能体可以交流个人信息，例如观察、意图、经验或派生特征，从而对环境有更全面的了解，这反过来又使他们能够做出明智的决策[9, 10]。</p>
<p>由于深度学习[11]及其在强化学习[12]中的应用最近的成功，多智能体深度强化学习（MADRL）近年来取得了巨大成就，其中智能体可以处理高维数据，并在大状态和动作空间中具有泛化能力[7, 8]。我们注意到，大量研究工作集中在具有通信的学习任务上，这些任务旨在通过通信和共享信息来学习解决特定领域的任务，如导航、交通和视频游戏。据我们所知，目前还没有涵盖多智能体深度强化学习（Comm-MADRL）中关于具有通信的学习任务最新工作的综述文献。早期的综述考虑了通信在多智能体强化学习（MARL）中的作用，但将其视为预定义的，而不是学习主题[13-15]。大多数 Comm-MADRL 综述仅涵盖少量研究工作，没有提出一个精细的分类系统来比较和分析它们。在合作场景中，Hernandez-Leal 等人 [16] 使用学习通信来表示学习通信协议的领域，以促进智能体的合作。我们发现的唯一一份将一些早期工作分类到 Comm-MADRL 的综述来自 Gronauer 和 Diepold [17]，它基于区分消息是否被所有智能体、一组智能体或智能体网络接收。然而，Comm-MADRL 的其他方面，如消息类型和训练范式，对于通信至关重要，可以帮助描述现有的通信协议，却被忽略了。因此，关于具有通信的学习任务的近期综述中，所审查的论文相当有限，提出的分类过于狭窄，无法区分 Comm-MADRL 中的现有工作。另一方面，还有一个密切相关的研究领域，即涌现语言/通信，它也通过各种强化学习技术考虑通过学习通信。[18] 与 Comm-MADRL 不同，涌现语言研究的主要目标是学习一种符号语言。然而，涌现语言研究的一部分工作追求一个额外的目标，即利用可学习的符号语言来提高任务级别的性能。值得注意的是，这些研究成果尚未被现有 Comm-MADRL 综述所涵盖，但被纳入我们的调查，称为具有涌现语言的认知任务。总之，我们的调查在范围上与涌现语言的调查重叠（即在具有涌现语言的认知任务中），但我们的调查关注不同的主要目标（即实现特定领域的任务，而不是学习符号语言）。我们进一步在第 2.2 节中阐明具有通信和学习涌现语言的学习任务之间的区别。</p>
<p>在我们的调查论文中，我们通过关注通信如何被利用来提高多智能体深度强化学习技术的性能，回顾了 Comm-MADRL 文献。具体来说，我们专注于可学习的通信协议，这些协议与强调通过深度强化学习技术开发动态和自适应通信的近期工作相一致，包括学习何时、如何以及与谁进行通信。通过对近期 Comm-MADRL 文献的全面回顾，我们提出了一种系统性和结构化的分类方法，旨在区分和分类各种 Comm-MADRL 方法。这种方法还将为新的 Comm-MADRL 系统的设计和进步提供指导。假设我们计划为当前领域任务开发一个 Comm-MADRL 系统。从何时、如何以及与谁进行通信的问题开始，系统可以从多个方面进行描述。智能体需要学习何时进行通信、与谁进行通信、传达什么信息、如何整合接收到的信息，最后，通过通信可以实现哪些学习目标。 我们提出了 9 个维度，对应于 Comm-MADRL 系统的独特方面：控制目标、通信约束、通信者类型、通信策略、传递消息、消息组合、内部整合、学习方法以及训练方案。这些维度构成了 Comm-MADRL 系统的骨架，可用于全面分析和深入了解设计的 Comm-MADRL 方法。通过将最近的 Comm-MADRL 方法映射到这个多维结构中，我们不仅提供了对该领域当前技术水平的洞察，还确定了设计未来 Comm-MADRL 系统的一些重要方向。</p>
<p>本文剩余部分的结构如下。第 2 节讨论了多智能体强化学习的预备知识，以及关于通信的现有扩展和近期调查的详细比较。第 3 节，我们提出了我们的建议维度，解释了如何将近期的工作按每个维度的类别进行分组。第 4 节，我们讨论了文献中发现的趋势，并受建议维度驱动，提出了该研究领域的可能研究方向。第 5 节，我们总结了本文的结论。</p>
<h3 id="2-背景"><a href="#2-背景" class="headerlink" title="2. 背景"></a>2. 背景</h3><p>在本节中，我们首先提供关于多智能体强化学习的必要背景知识。然后，我们展示如何将多智能体强化学习扩展到考虑智能体之间的通信。最后，我们介绍并比较了涉及通信的近期调查，从中我们可以直接看到我们填补现有调查中空白的原因。</p>
<h4 id="2-1-多智能体强化学习"><a href="#2-1-多智能体强化学习" class="headerlink" title="2.1 多智能体强化学习"></a>2.1 多智能体强化学习</h4><p>现实世界的应用通常包含多个在环境中运行的智能体。智能体通常被认为是自主的，并且需要学习策略以实现其目标。多智能体环境可以根据环境是否完全可观测、智能体的目标如何相关联等因素以多种方式形式化[6]。其中，部分可观测随机博弈（POSG）[19, 20]是最灵活的形式化之一。POSG 由一个元组定义，其中 I 是（有限）智能体集合，按{1, …, n}索引，S 是环境状态集合，𝜌是状态空间 S 上的初始状态分布，A 是智能体 i 可用的动作集合，O 是智能体 i 的观察集合。我们表示联合动作空间为 A = ×A，智能体联合观察空间为 O = ×O。因此，P ∶ S × A → Δ(S)表示从状态 s ∈ S 到新状态 s∈ S 的转移概率，给定智能体的联合动作⃗ a = ⟨a, …, a ⟩，其中⃗ a ∈ A。当环境过渡到新状态 s 时，给定联合动作⃗</p>
<p>a 根据观察概率函数 O ∶ S × A → Δ(O)确定。然后，每个智能体根据其自身的奖励函数 R∶ S × A × S → ℝ获得即时奖励。与联合动作和观察类似，我们可以将⃗ r = ⟨r, …, r⟩表示为联合奖励。如果智能体的奖励函数恰好相同，即它们具有相同的目标，那么对于每个时间步，r= r= … = r 都成立。在这种情况下，POSG 简化为 Dec-POMDP [6]。如果每个时间步的状态可以从智能体的当前观察集中唯一确定，即 s ≡⃗ o，则 Dec-POMDP 简化为 Dec-MDP。如果每个智能体都知道真实的环境状态，则 Dec-MDP 简化为多智能体 MDP。如果智能体集合中只有一个智能体，即 I = {1}，则多智能体 MDP 简化为 MDP，而 DecPOMDP 简化为 POMDP。由于部分可观测性，MARL 方法通常使用每个智能体的观察-动作历史𝜏= {o , a, o, …, o }直到时间步 t 来近似环境状态。请注意，为了简化，时间步 t 通常被省略。</p>
<p>在多智能体强化学习环境中，智能体可以以去中心化或中心化的方式学习其策略。在去中心化学习中（例如，去中心化 Q 学习[21, 22]），n 个智能体的多智能体强化学习问题被分解为 n 个去中心化的单智能体问题，其中每个智能体通过将所有其他智能体视为环境的一部分来学习自己的策略[23, 24]。在这样的去中心化设置中，每个智能体学习的策略取决于其局部观察和历史。去中心化学习的一个主要问题是环境的所谓非平稳性，即每个智能体在一个其他智能体同时探索和学习的环境中学习。中心化学习可以训练所有智能体的单个联合策略或中心化的价值函数，以促进 n 个去中心化策略的学习。虽然中心化（联合）学习消除了或减轻了部分可观察性和非平稳性问题，但它面临着联合行动（和观察）空间随着智能体数量及其行动的指数级扩展的挑战。 想要深入了解多智能体强化学习（MARL）中使用的各种训练方案，我们推荐阅读[17]的全面综述，该综述为策略的训练和执行提供了宝贵的见解。根据策略是从值函数导出还是直接学习，多智能体强化学习方法可以分为基于值的方法和基于策略的方法。这两种方法在通信多智能体深度强化学习（Comm-MADRL）中得到了广泛的应用。</p>
<h5 id="基于值"><a href="#基于值" class="headerlink" title="基于值"></a>基于值</h5><p>在多智能体情况下，基于值的方法借鉴了单智能体案例中的许多想法。作为最流行的基于值的方法之一，分布式 Q 学习为每个智能体学习一个局部 Q 函数。在智能体共享共同奖励的协作设置中，智能体 i 的更新规则如下：<br>其中 r 是共享奖励，ais 是下一个状态 s 中具有最高 Q 值的动作。在部分可观察环境中，环境状态不是完全可观察的，通常由每个代理的个体观察或历史记录来代替。每个状态-动作对的 Q 值根据 TD 误差逐步更新。这个误差，即 r + 𝛾 maxQ(s, a) − Q(s, a )，表示基于 Bellman 方程[25]的新估计（即 r + 𝛾 maxQ(s, a)）和当前估计（即 Q(s, a)）之间的差异。由于状态和动作空间可能太大，难以频繁遇到以进行准确估计，因此函数逼近方法，如深度神经网络，已经变得流行，为价值或策略模型赋予在离散和连续状态和动作上的泛化能力[12]。例如，深度 Q 网络（DQN）[12]最小化从采样奖励计算的新估计与参数化 Q 函数的当前估计之间的差异。在基于 DQN 的方法中，方程 1 中的 Q 函数表示为 Q(s, a ;𝜃)，它依赖于可学习的参数𝜃。 然而，基于价值的集中式学习方法学习一个联合 Q 函数 Q(s,⃗ a;𝜃)与参数𝜃。然而，这种方法在代理数量增加时难以扩展。值分解方法[26-29]是流行的多智能体强化学习（MARL）方法，可以将联合 Q 函数分解以实现高效的训练。这些方法也广泛应用于 Comm-MADRL 的研究工作中[30-32]。在部分可观察环境中，线性值分解方法将基于历史的联合 Q 函数分解如下：<br>其中，联合 Q 函数基于所有代理的联合历史，并基于个体历史分解为局部 Q 函数。权重 w 可以是固定值[26, 28]或受特定约束的可学习参数[29]。优势函数也可以替换上述方程中的 Q 函数以减少方差[33]。</p>
]]></content>
  </entry>
  <entry>
    <title>VDN</title>
    <url>/2025/04/17/VDN/</url>
    <content><![CDATA[<h2 id="用于协作式多智能体学习的价值分解网络"><a href="#用于协作式多智能体学习的价值分解网络" class="headerlink" title="用于协作式多智能体学习的价值分解网络"></a>用于协作式多智能体学习的价值分解网络</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>我们研究了具有单个联合奖励信号的协作式多智能体强化学习问题。这类学习问题很困难，因为通常有很大的动作和观察组合空间。在完全集中式和去中心化的方法中，我们发现了虚假奖励的问题和一种我们称之为 “惰性代理” 问题的现象，这是由于部分可观察性而出现的。我们通过使用一种新的价值分解网络架构来训练单个代理来解决这些问题，该架构学习将团队价值函数分解为代理价值函数。我们在一系列部分可观察的多智能体领域进行了实验评估，并表明学习这种价值分解会带来卓越的结果，特别是当与权重共享、角色信息和信息通道相结合时。</p>
<hr>
<p><sup><a href="#fn_什么是单个联合奖励信号的协作式多智能体强化学习问题" id="reffn_什么是单个联合奖励信号的协作式多智能体强化学习问题">什么是单个联合奖励信号的协作式多智能体强化学习问题</a></sup>: </p>
<p>首先，协作式多智能体强化学习（Cooperative MARL）是指多个智能体共同合作完成一个任务，他们的目标一致，共享奖励或各自有奖励，但这里提到的是单个联合奖励信号，所以应该是所有智能体共享同一个奖励。那单个联合奖励信号是什么意思呢？可能是指所有智能体的行为共同影响一个全局奖励，比如团队胜利或任务完成。比如足球游戏里的多个球员，进球了大家都有同样的奖励，被进球了都扣分。这种情况下，每个智能体的行为都会影响整个团队的奖励，但每个智能体可能需要自己学习策略，或者有集中式的训练。接下来需要解释协作式MARL的基本概念，然后结合单个联合奖励来展开。可能需要比较一下其他情况，比如每个智能体有独立奖励的情况，或者竞争式MARL。然后说明这种单个联合奖励带来的挑战和常见解决方法。挑战可能包括信用分配问题，因为所有智能体共享同一个奖励，难以确定每个个体的贡献。比如在团队游戏中，某个关键动作可能由某个智能体做出，但奖励是大家共享的，其他智能体如何知道该动作的重要性？这时候可能需要某种方法来分配信用，比如COMA算法中的反事实基线，或者VDN、QMIX这类值分解的方法。另外，还需要提到环境的部分可观测性，每个智能体可能只能看到局部信息，这会影响决策。还有策略的协调问题，如何让多个智能体的策略在分散执行时保持一致，可能需要集中式训练、分散式执行的框架。常见的方法可能包括值分解网络（VDN, QMIX），这些方法通过分解联合Q值到个体Q值，从而在训练时利用全局信息，执行时每个智能体根据自己的Q值行动。还有Actor-Critic方法，如MADDPG，虽然每个智能体有自己的策略，但Critic可能会用到全局信息进行训练。另外，可能需要提到信用分配的具体技术，比如差异奖励（Difference Rewards），即每个智能体的奖励基于其贡献与全局奖励的关系，或者利用反事实基线来评估某个智能体是否存在时的奖励差异。总结的话，单个联合奖励的协作式MARL问题需要解决信用分配、环境复杂性、策略协调等问题，常用方法有值分解、集中训练分散执行、信用分配技术等。这样用户应该能理解这个问题的定义、挑战和解决思路了。</p>
<hr>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>我们考虑合作式多智能体强化学习（MARL）问题[，, , ]，其中多个学习智能体需要共同优化随时间累积的单一奖励信号——即<strong>团队奖励</strong>。每个智能体只能访问自身的“局部”观测信息，并负责从其自身的动作集中选择动作。协作式MARL问题出现在诸如协调自动驾驶车辆和/或交通信号系统、优化由多个交互组件组成的工厂生产效率等应用中。更广泛地说，随着AI智能体的普及，它们必须学会协作以实现共同目标。</p>
<p>尽管某些实际应用可能需要局部自治，但原则上合作式MARL问题可以通过<strong>集中式</strong>方法处理，即将问题简化为单智能体强化学习（RL），通过拼接观测空间和组合动作空间进行学习。然而，我们证明集中式方法在相对简单的协作式MARL问题上始终失败。我们设计了一个简单实验：集中式方法会学习到低效的策略，仅有一个智能体活跃，而另一个变得“懒惰”。这是因为当一个智能体学习到有用策略时，第二个智能体因探索行为可能妨碍前者并导致团队奖励下降，从而被抑制学习。</p>
<p><sup><a href="#fn_" id="reffn_"></a></sup>: </p>
<p>另一种方法是训练<strong>独立学习者</strong>以优化团队奖励。然而，由于每个智能体的环境动态会随着其他智能体行为的变化而改变，每个智能体实际上面临非稳态学习问题[]。此外，由于单个智能体的视角是部分可观测的，它们可能接收到来自队友（未被观测的）行为的虚假奖励信号。这种无法解释自身观测奖励的缺陷使得朴素独立RL通常无法成功：例如[]表明，独立Q学习器无法区分队友的探索与环境本身的随机性，甚至无法解决一个看似简单的2智能体、无状态、3×3动作的问题。而一般的Dec-POMDP问题已被证明是难解的[, ]。尽管本文聚焦于双智能体协作，但需注意独立学习者和集中式方法的问题会随智能体数量增加而恶化，因为此时大多数奖励与个体无关，而集中式方法的动作空间会指数级膨胀。</p>
<p>改进独立学习者的方法之一是设计更直接关联个体观测的局部奖励函数。然而，即使在单智能体场景中，奖励塑形也极为困难，仅有一小类塑形奖励函数能保证与真实目标的最优性一致[, ]。本文旨在探索更通用的自主解决方案，即通过学习分解团队价值函数。</p>
<p>我们提出一种新型的<strong>可学习加性价值分解</strong>方法，通过对个体智能体的价值函数进行线性组合。具体而言，价值分解网络（VDN）旨在通过反向传播团队Q值的梯度到表示个体价值函数的深度神经网络中，从而从团队奖励信号中学习最优的线性价值分解。这种加性分解的动机是避免独立学习者中出现的虚假奖励信号。每个智能体隐式学习到的价值函数仅依赖于局部观测，因此更易训练。该方法还缓解了[]中强调的独立学习的协调问题，因为它在训练时以集中方式学习，而部署时智能体可独立运行。</p>
<p>此外，我们结合权重共享、角色信息和信息通道等近期被证明可提升样本效率与降低内存需求的技术[, , ]，对所提出的智能体进行增强。但本文的核心比较集中在三种架构：基于个体的价值分解、独立学习者和集中式方法。我们在一系列新颖的双智能体协作场景中对这些技术的组合进行了实验与基准测试。结果表明，价值分解方法在性能上显著优于集中式或完全独立的学习者，且结合附加技术后，其表现更是大幅领先。</p>
<hr>
<p><sup><a href="#fn_备注" id="reffn_备注">备注</a></sup>: </p>
<p>集中式学习的缺点是随着智能体数量的增加，动作空间指数级增长；<br>独立式学习的缺点是每个智能体面临的是非稳态环境，学习不稳定还会影响其他智能体的学习；<br>因此，本文推出了一种可学习加性价值分解方法。换句话说就是如何将团队奖励（团队Q值）进行合理分解</p>
<hr>
<h4 id="2-3-多智能体强化学习"><a href="#2-3-多智能体强化学习" class="headerlink" title="2.3 多智能体强化学习"></a>2.3 多智能体强化学习</h4><p>如果我们将(\bar{h} := (h^1, h^2, …, h^d))定义为智能体历史记录的元组（其中每个(h^i)表示第(i)个智能体的历史），则联合策略通常是一个映射(\pi : \mathcal{H}^d \to \mathcal{P}(\mathcal{A}^d))。此映射基于所有智能体的联合历史(\bar{h})，输出联合动作空间(\mathcal{A}^d)上的概率分布。  </p>
<p>不过，我们特别关注一类特殊的策略：对于任意历史(\bar{h})，其输出的分布(\pi(\bar{h}))在(\mathcal{P}(\mathcal{A})^d)中具有<strong>独立分量</strong>。即，每个智能体的动作分布仅依赖于联合历史(\bar{h})，但各智能体的动作选择在概率上是相互独立的。因此，这类策略可表示为(\pi : \mathcal{H}^d \to \mathcal{P}(\mathcal{A})^d)。  </p>
<p>唯一的例外是使用最朴素的集中式智能体（即<strong>联合动作学习者</strong>）时，此时策略直接操作组合动作空间（(\mathcal{A}^d)），输出的分布属于(\mathcal{P}(\mathcal{A}^d))。  </p>
<hr>
<p><sup><a href="#fn_备注" id="reffn_备注">备注</a></sup>: </p>
<p>这段文字定义了多智能体强化学习（MARL）中的联合策略，并比较了两种不同的策略形式：</p>
<h3 id="核心概念解释"><a href="#核心概念解释" class="headerlink" title="核心概念解释"></a>核心概念解释</h3><ol>
<li><p><strong>智能体历史元组</strong>：<br>用(\bar{h} := (h^1, h^2, …, h^d))表示所有智能体的历史记录集合，其中(h^i)是第(i)个智能体的历史（包含其观测和动作序列）。</p>
</li>
<li><p><strong>联合策略的一般形式</strong>：<br>联合策略通常定义为映射(\pi : \mathcal{H}^d \to \mathcal{P}(\mathcal{A}^d))，即基于所有智能体的联合历史(\bar{h})，输出一个联合动作空间(\mathcal{A}^d)上的概率分布。  </p>
<ul>
<li>(\mathcal{H}^d)：所有智能体历史记录的联合空间。  </li>
<li>(\mathcal{P}(\mathcal{A}^d))：所有可能的联合动作的概率分布集合。  </li>
</ul>
</li>
<li><p><strong>独立分量的联合策略</strong>：<br>作者特别考虑一种特殊形式：对于任何联合历史(\bar{h})，策略输出的分布(\pi(\bar{h}))在(\mathcal{P}(\mathcal{A})^d)中具有<strong>独立分量</strong>。这意味着：  </p>
<ul>
<li>每个智能体的动作选择仅依赖于联合历史(\bar{h})，但动作之间的概率分布是独立的。  </li>
<li>数学上可分解为(\pi(\bar{h}) = (\pi^1(\bar{h}), \pi^2(\bar{h}), …, \pi^d(\bar{h})))，其中每个(\pi^i(\bar{h}) \in \mathcal{P}(\mathcal{A}))表示第(i)个智能体的局部策略。  </li>
<li><strong>优势</strong>：避免了组合动作空间的复杂性，同时仍能利用全局历史信息进行决策。</li>
</ul>
</li>
<li><p><strong>例外：集中式联合动作学习者</strong>：<br>当使用“最朴素的集中式智能体”时，策略直接操作组合动作空间（combinatorial action space），即联合动作学习者（joint action learners）。  </p>
<ul>
<li>此时，策略输出的分布(\pi(\bar{h}))属于(\mathcal{P}(\mathcal{A}^d))，需考虑所有智能体动作的联合分布，而非独立分量。  </li>
<li><strong>问题</strong>：动作空间维度随智能体数量(d)指数增长（(\mathcal{A}^d)），导致计算和训练复杂度极高。</li>
</ul>
</li>
</ol>
<h3 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a>关键区别</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>策略类型</strong></th>
<th><strong>输入</strong></th>
<th><strong>输出分布</strong></th>
<th><strong>特点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>独立分量联合策略</td>
<td>联合历史(\bar{h})</td>
<td>(\mathcal{P}(\mathcal{A})^d)</td>
<td>动作分布独立，利用全局信息但保持动作解耦，复杂度线性增长（(d \times \</td>
<td>\mathcal{A}\</td>
<td>)）。</td>
</tr>
<tr>
<td>集中式联合动作学习者</td>
<td>联合历史(\bar{h})</td>
<td>(\mathcal{P}(\mathcal{A}^d))</td>
<td>动作分布耦合，需建模联合动作，复杂度指数增长（(\</td>
<td>\mathcal{A}\</td>
<td>^d)），难以扩展。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="实际意义"><a href="#实际意义" class="headerlink" title="实际意义"></a>实际意义</h3><ul>
<li><strong>独立分量策略</strong>：适用于需要平衡全局协调与计算效率的场景，例如价值分解网络（VDN）等算法，通过共享观测历史但独立选择动作，缓解组合爆炸问题。  </li>
<li><strong>集中式联合动作学习者</strong>：尽管理论上能直接优化全局最优策略，但因动作空间过大，仅适用于智能体数量极少或动作空间极小的任务，实际应用受限。</li>
</ul>
<p>这一区分为后续讨论集中式方法在复杂任务中的失败（如动作空间爆炸、探索效率低）以及独立学习者或价值分解方法的优势奠定了基础。</p>
<hr>
<h3 id="三、深度强化学习（Deep-RL）架构用于合作型多智能体强化学习（Coop-MARL）"><a href="#三、深度强化学习（Deep-RL）架构用于合作型多智能体强化学习（Coop-MARL）" class="headerlink" title="三、深度强化学习（Deep-RL）架构用于合作型多智能体强化学习（Coop-MARL）"></a>三、深度强化学习（Deep-RL）架构用于合作型多智能体强化学习（Coop-MARL）</h3><p>减少可学习参数数量的一个方法是在代理之间共享某些网络权重。权重共享还引发了代理不变性的概念，这对于避免懒惰代理问题是有用的。</p>
<hr>
<p><sup><a href="#fn_备注" id="reffn_备注">备注</a></sup>: </p>
<p>首先，提到“减少可学习参数数量的方法之一是共享智能体之间的某些网络权重”。这里的“可学习参数”指的是神经网络中的权重，共享权重意味着不同的智能体使用相同的权重参数，而不是每个智能体都有自己独立的参数。这样可以减少整体的参数数量，从而降低模型的复杂度和训练所需的计算资源。</p>
<p>接下来，提到“权重共享还产生了智能体不变性的概念，这对避免懒惰智能体问题很有用”。“智能体不变性”应该是指通过共享权重，不同智能体在功能上变得相似或一致，从而避免某些智能体变得不活跃（即“懒惰智能体问题”）。</p>
<hr>
<h3 id="VDN代码实现"><a href="#VDN代码实现" class="headerlink" title="VDN代码实现"></a>VDN代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">VDN类由五个函数组成：init, learn, get_inputs, get_q_values, init_hidden, save_model;</span><br><span class="line">其中，初始化init包括：智能体数量，状态空间，观察空间，输入维度，动作空间，四种神经网络，是否使用GPU，是否加载已存在模型，初始化相同网络参数，初始化需要优化网络参数个数，初始化优化器，初始化隐藏元。</span><br><span class="line">输入维度不等于观察空间原因：当args.last_action为<span class="literal">True</span>时，输入中会加入上一个时间步的动作信息</span><br><span class="line">四种神经网络分别为：每个agent选择动作的网络，每个agent的目标网络，VDN累加Q值的网络，VDN目标网络</span><br><span class="line">网络参数优化器：注意网络参数优化器是针对哪些网络参数进行反向传递优化，这对于VDN算法的实现很重要</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>ATTENTION-GUIDED CONTRASTIVE ROLE REPRESENTATIONS FOR MULTI-AGENT REINFORCEMENT LEARNING</title>
    <url>/2025/05/15/ATTENTION-GUIDED-CONTRASTIVE-ROLE-REPRESENTATIONS-FOR-MULTI-AGENT-REINFORCEMENT-LEARNING/</url>
    <content><![CDATA[<p>摘要：<br>1、受角色与智能体行为模式之间相关性的启发，我们提出了一种名为 Attention-guided COntrastive Role representation learning for MARL（ACORM）的新型框架</p>
<blockquote id="fn_注释">
<sup>注释</sup>. 不同类型的角色具有不同类型的行为模式，比如有的偏向于拆塔，有的偏向于生产资源等等。作者应该是考虑利用不同角色与之对应的行为模式建立关系<a href="#reffn_注释" title="Jump back to footnote [注释] in the text."> &#8617;</a>
</blockquote>
<hr>
<p>2、引入互信息最大化来形式化角色表示学习，推导出一个对比学习目标，并简洁地近似负样本的分布</p>
<blockquote id="fn_注释">
<sup>注释</sup>. 1. <strong>Mutual Information Maximization（互信息最大化）</strong>：互信息是信息论中的一个概念，用于衡量两个随机变量之间的相关性。最大化互信息意味着让模型学习到的角色表示（role representations）与智能体的行为模式尽可能相关。这可能意味着通过优化互信息，使角色的表示能够更好地捕捉到不同角色之间的行为差异。2. <strong>Formalize Role Representation Learning（形式化角色表示学习）</strong>：这里“形式化”指的是将角色表示的学习过程转化为数学框架或优化问题。通过互信息最大化，将角色表示的学习转化为一个明确的优化目标，使得角色表示能够系统地学习到有用的特征。3. <strong>Derive a Contrastive Learning Objective（推导对比学习目标）</strong>：对比学习是一种自监督学习方法，通过比较正样本对和负样本对来学习表示。在这里，作者可能将互信息最大化转化为对比损失函数，通过对比不同角色或行为模式，使得相似的行为在表示空间中更接近，不同的更远。4. <strong>Concisely Approximate the Distribution of Negative Pairs（简洁地近似负样本对的分布）</strong>：对比学习中需要生成负样本对，但直接采样所有可能的负样本可能计算量大。这里“简洁地近似”可能指通过某种方法有效生成或选择负样本，减少计算复杂度，同时保持对比学习的有效性。<a href="#reffn_注释" title="Jump back to footnote [注释] in the text."> &#8617;</a>
</blockquote>
<hr>
<p>3、利用注意力机制提示全局状态关注价值分解中学习到的角色表示，隐式地引导智能体在技能型角色空间中进行协调，以产生更具表现力的信用分配。</p>
<blockquote id="fn_注释">
<sup>注释</sup>. 总的来说，还是解决信用分配问题？<a href="#reffn_注释" title="Jump back to footnote [注释] in the text."> &#8617;</a>
</blockquote>
<hr>
<p>引言</p>
<p>1、主要思想是学习一个紧凑的角色表征，以捕捉智能体的复杂行为模式，并使用该角色表征来促进智能体之间的行为异质性、知识迁移和熟练协调。首先，我们将学习目标形式化为角色与其表征之间的互信息最大化，以在给定智能体行为的情况下最大限度地减少角色不确定性，同时最大限度地保留与角色无关的信息。我们引入了一种对比学习方法来优化 infoNCE 损失，即互信息的下界。为了简洁地近似负样本的分布，我们通过将智能体的轨迹编码到潜在空间中来提取智能体行为，并定期根据其潜在嵌入将所有智能体划分为几个集群，来自不同集群的点被配对为负样本。其次，在集中式训练期间，我们采用注意力机制来提示全局状态关注价值分解中学习到的角色表征。 注意力机制在技能角色空间中隐式地指导智能体协调，从而在角色出现时产生更丰富的信用分配。</p>
]]></content>
  </entry>
  <entry>
    <title>BYZANTINE ROBUST COOPERATIVE MULTI-AGENT REINFORCEMENT LEARNING AS A BAYESIAN GAME</title>
    <url>/2025/05/15/BYZANTINE-ROBUST-COOPERATIVE-MULTI-AGENT-REINFORCEMENT-LEARNING-AS-A-BAYESIAN-GAME/</url>
    <content><![CDATA[<p>本片文章主要是依据历史经验来判断出干扰者，目标是合作方在最坏对抗干扰下，寻求最优策略<br>\begin{equation} \label{eq:ex_ante_equilibrium}<br>(\pi_{<em>}^{EA}(\cdot|H), \hat{\pi}_{</em>}^{EA}(\cdot|H, \theta)) \in \arg \max_{\pi(\cdot|H)} \mathbb{E}_{p(\theta)} \left[ \min_{\hat{\pi}(\cdot|H, \theta)} V_{\theta}(s) \right]<br>\end{equation}</p>
]]></content>
  </entry>
  <entry>
    <title>Multi-Agent AI</title>
    <url>/2025/06/22/Multi-Agent-AI/</url>
    <content><![CDATA[<ol>
<li><p>引言</p>
<p>q1：多智能体强化学习系统特点</p>
<p>智能体数量非单个</p>
<p>智能体之间存在一定联系：合作、对抗、合作+对抗（多智能体多动机）</p>
<p>智能体不仅需要考虑到环境，还需要考虑到其他智能体的行动</p>
<p>学习环境动态变化</p>
</li>
<li><p>博弈论</p>
<p>minmax</p>
<p>nash equilibrium</p>
<p><img src="png1.png" alt="1"></p>
<p><img src="image-20250622215001166.png" alt="1-2"></p>
<p><img src="image-20250622215250842.png" alt="1-3"></p>
<p>上图说明了制定出合理的策略需要智能体之间communication</p>
<p><img src="image-20250622215526657.png" alt="1-4"></p>
<p>局部最优并不代表全局最优</p>
<p><img src="image-20250622221246041.png" alt="1-5"></p>
<p><img src="image-20250622221913906.png" alt="1-6"></p>
<p>对彼此的最佳对策被称为纳什均衡</p>
<p><img src="image-20250622222258083.png" alt="1-7"></p>
<p>纳什均衡可以有多个</p>
<p><img src="image-20250622222540677.png" alt="1-8"></p>
<p>博弈定义</p>
<p><img src="image-20250622223016230.png" alt="1-9"></p>
<p>占优策略：对于一个玩家来说，拥有一个策略a，不论其他玩家选择任何策略，选择策略a都会使得他的效用u最大，这个策略a就被称为占优策略</p>
<p><img src="image-20250622223222044.png" alt="1-10"></p>
<p>n-玩家纳什均衡定义</p>
<p>q2：是不是所有博弈情况都存在纳什均衡？</p>
</li>
<li><p>混合策略纳什均衡</p>
<p><img src="image-20250622225345099.png" alt="1-11"></p>
</li>
</ol>
<h2 id="2-1-重复博弈"><a href="#2-1-重复博弈" class="headerlink" title="2.1 重复博弈"></a>2.1 重复博弈</h2><p><img src="image-20250623201854412.png" alt="2-1"></p>
<ul>
<li><p>为什么要研究重复博弈？</p>
<p>生活中我们参与的许多战略互动都是持续进行的，比如，我们会与相同的人重复互动等。重复博弈理论提供了一个框架用以研究这种重复行为</p>
</li>
</ul>
<p><img src="image-20250623202222337.png" alt="2-2"></p>
<ul>
<li>重复博弈定义：同一个基础博弈（阶段博弈）被相同的参与者多次重复进行。换句话说，在重复博弈中，一个标准式博弈被同样的参与者反复进行。</li>
</ul>
<p><img src="image-20250623202435065.png" alt="2-3"></p>
<ul>
<li><p>惩罚的威胁：</p>
<p>惩罚的威胁是理解重复博弈引入折扣因子的关键概念。基本思想是参与者可能会因为<strong>“惩罚”的“威胁”</strong>而被阻止利用其短期优势，这种威胁的直观效果就是会降低其长期收益。</p>
<p>通过未来惩罚的威胁来维持合作。参与者在做决策时不仅要考虑当前收益，还要考虑背叛行为可能招致的未来惩罚，从而在长期利益考量下选择合作而非短期的机会主义行为。</p>
</li>
</ul>
<p><img src="image-20250623202916496.png" alt="2-4"></p>
<ul>
<li><p>重复博弈：囚徒困境</p>
<p>在单次博弈中，背叛是占优策略，但在重复博弈中，未来惩罚的威胁可能使合作成为可能。这为分析现实中的长期合作关系提供了理论基础。</p>
</li>
</ul>
<p><img src="image-20250623203105804.png" alt="2-5"></p>
<ul>
<li><p>囚徒困境有一个唯一的纳什均衡：每个参与者都选D（背叛）</p>
</li>
<li><p>现在引入冷酷触发策略：</p>
<ul>
<li><p>只要对方参与者选择C，就选择C；</p>
</li>
<li><p>如果在任何时期对方参与者选择D，那么在<strong>此后的每个时期</strong>都选择D</p>
</li>
</ul>
</li>
<li><p>另一个参与者应该怎么做？</p>
<ul>
<li>只要她对未来收益的重视程度与当前收益相比不是太小，她最好在每个时期都选择C</li>
</ul>
</li>
<li><p>冷酷触发策略的工作原理：通过”一旦背叛，永远惩罚”的威胁来维持合作。关键在于参与者对未来收益的重视程度（贴现因子）必须足够高，使得长期合作的收益超过短期背叛的收益。</p>
</li>
</ul>
<p><img src="image-20250623203455003.png" alt="2-6"></p>
<ul>
<li>每次都选择C的策略是应对冷酷触发策略最好的策略</li>
<li>为什么？<ul>
<li>如果她在每个时期都选择C，那么每个时期的结果都是(C,C)，她在每个时期获得收益2</li>
<li>如果她在某个时期转向D，那么她在该时期获得收益3，在此后的每个时期获得收益1</li>
<li>然而，只要她对未来收益的重视程度与当前收益相比不是太小，收益流(3,1,1,…)对她来说比收益流(2,2,2,…)更差 • 因此她最好在每个时期都选择C</li>
</ul>
</li>
<li>为什么冷酷触发策略能够维持合作：虽然背叛能带来一次性的更高收益（3 vs 2），但随后的永久惩罚（每期收益1）使得总体收益低于持续合作（每期收益2）。关键条件是参与者必须足够重视未来收益。</li>
</ul>
<p><img src="image-20250623203658761.png" alt="2-7"></p>
<ul>
<li>这张幻灯片指出了重复博弈中的多重均衡问题。除了通过冷酷触发策略维持的合作均衡外，还存在”总是背叛”的均衡。在这种均衡中，由于对方无论如何都会背叛，自己也最好选择背叛，这与单次囚徒困境的结果相同。这说明重复博弈可能存在多个纳什均衡，既有合作的也有非合作的。</li>
</ul>
<p><img src="image-20250623203835329.png" alt="2-8"></p>
<ul>
<li><p>两个关键问题：</p>
<ul>
<li><p><strong>耐心程度的量化</strong>：要维持合作均衡，参与者需要多重视未来收益？这涉及贴现因子的临界值计算。</p>
</li>
<li><p><strong>均衡结果的多样性</strong>：除了完全合作(C,C)和完全背叛(D,D)之外，还有哪些策略组合和结果可以构成纳什均衡？</p>
</li>
</ul>
</li>
</ul>
<p><img src="image-20250623204324562.png" alt="2-9"></p>
<p><img src="image-20250623204526705.png" alt="2-10"></p>
<ul>
<li>通过冷酷触发策略结合折扣因子来解释折扣因子的边界取值。分别是一直选择合作（C）以及中途换选择（D），分别计算其策略收益，最后比较收益值，即可计算出折扣因子的边界值。</li>
<li><strong>当δ &lt; 1/2时，”一直背叛”是纳什均衡</strong>：<ul>
<li>无论δ值如何，”一直背叛”策略<strong>总是纳什均衡</strong>：<ul>
<li>如果玩家1总是背叛，玩家2的最佳响应是总是背叛（因为如果玩家2合作，支付为0；如果背叛，支付为1）。</li>
<li>同样，如果玩家2总是背叛，玩家1的最佳响应也是总是背叛。</li>
<li>支付为每期(1,1)，现值为11−δ1−<em>δ</em>1。</li>
<li>没有玩家能通过单方面改变策略（如尝试合作）获得更高支付，因为合作会被立即剥削（支付0），且未来收益折现后不足以补偿。</li>
</ul>
</li>
<li>这个均衡总是存在，但它导致<strong>帕累托低效的结果</strong>（支付(1,1)低于合作时的(2,2)）。</li>
</ul>
</li>
</ul>
<p><img src="image-20250623204705478.png" alt="2-11"></p>
<p><img src="image-20250623204723342.png" alt="2-12"></p>
<ul>
<li>有限步惩罚策略与“以牙还牙”策略计算折扣因子边界值思想与冷酷触发策略计算类似，这里不再详细解释。</li>
</ul>
<h2 id="2-2-扩展形式博弈"><a href="#2-2-扩展形式博弈" class="headerlink" title="2.2 扩展形式博弈"></a>2.2 扩展形式博弈</h2><p><img src="image-20250623210315029.png" alt="2-13"></p>
<ul>
<li><p>上述内容对比了策略型博弈和扩展式博弈的核心区别，并定义了一种特定类型的扩展式博弈<strong>（多阶段可观测行动博弈）</strong>。以下是我对关键点的理解：</p>
<ol>
<li><p><strong>核心区别 (Sequentiality &amp; Information):</strong></p>
<ul>
<li><strong>策略型博弈 (战略式博弈):</strong> 强调<strong>同时决策</strong>。玩家在不知道对手选择的情况下做出一次性决策（如石头剪刀布、静态 Cournot 模型）。收益矩阵是其主要表示形式。</li>
<li><strong>扩展式博弈 (扩展式):</strong> 强调<strong>行动的先后顺序 (序列性)</strong> 和<strong>信息结构</strong>。玩家在不同时间点行动，并且后行动的玩家可能（但不一定）能观察到先行动玩家的选择（如象棋、动态 Stackelberg 模型、序贯议价）。博弈树是其核心表示工具。</li>
</ul>
</li>
<li><p><strong>关注类型 (Multi-stage with Observed Actions):</strong></p>
<ul>
<li><strong>多阶段 (Multi-stage):</strong> 博弈过程被划分为不同的阶段。</li>
<li><strong>可观测行动 (Observed Actions):</strong> 这是定义中<strong>最关键的信息假设</strong>。它意味着在每个阶段开始时，<strong>所有玩家都完全知道之前所有阶段中所有玩家选择的所有行动</strong>。这被称为<strong>完美信息 (Perfect Information)</strong>，但PPT的表述更一般化，因为它允许同一阶段内的玩家<strong>同时行动 (Simultaneous Moves)</strong>。</li>
<li><strong>完美信息 vs. 可观测行动：</strong> “完美信息”通常指在<em>每个决策点</em>，玩家确切知道之前发生的<em>所有</em>行动（即知道整个历史，知道当前处于哪个决策节点）。PPT定义的“具有可观测行动的多阶段博弈”在阶段之间是完美信息的（玩家知道之前所有阶段的所有行动），但在一个阶段内部，如果存在同时行动，则在该阶段内行动时，玩家可能不知道同阶段其他玩家的<em>即时</em>选择（但在下一阶段开始前，这些行动会被揭示）。这比严格的“完美信息”博弈（要求每个决策点都无同时行动且完全知晓历史）范围更广。</li>
</ul>
</li>
<li><p><strong>表示工具 (Game Trees):</strong></p>
<ul>
<li>博弈树是表示扩展式博弈最直观的方式。树根代表起点，树枝代表玩家可能的行动，树节点代表决策点（轮到哪个或哪些玩家行动），树叶代表终点（对应收益/结果）。</li>
<li>它天然地刻画了<strong>行动顺序</strong>和可能的<strong>路径 (历史)</strong>。</li>
</ul>
</li>
<li><p><strong>关键概念 (Histories):</strong></p>
<ul>
<li><strong>历史记录 (Histories)</strong> 是扩展式博弈模型中的<strong>基础构件</strong>。一个历史就是一个从博弈开始到某个时间点为止，所有玩家按顺序采取的行动的序列。</li>
<li>每个决策点（博弈树节点）都对应一个<strong>唯一的历史</strong>，该历史描述了到达该节点所经过的路径。</li>
<li>玩家的<strong>信息集 (Information Sets)</strong> 通常由其无法区分的一组历史（节点）来定义。但在PPT定义的“具有可观测行动的多阶段博弈”中，由于行动完全可观测，每个信息集通常只包含一个节点（即玩家总是确切知道自己处于哪个决策点），除非在同一个阶段内存在同时行动（此时玩家可能不知道同阶段对手的<em>即时</em>选择）。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><img src="image-20250623211203839.png" alt="2-14"></p>
<ul>
<li><p><strong>玩家角色：</strong></p>
<ul>
<li><strong>玩家1 - 进入者 (Entrant):</strong> 考虑是否进入一个新市场（通常是一个已有在位企业的市场）。</li>
<li><strong>玩家2 - 在位者 (Incumbent):</strong> 是市场现有的主导企业，对进入者的行动做出反应。</li>
</ul>
</li>
<li><p><strong>行动顺序与信息：</strong></p>
<ul>
<li>这是一个<strong>序贯博弈</strong>：玩家1先行动，玩家2后行动。</li>
<li><strong>关键信息假设：</strong> 玩家2在做出决策（容纳还是斗争）之前，<strong>完全观察到了玩家1的选择</strong>（进入或不进入）。这意味着玩家2知道博弈进行到了哪个决策点（即玩家1选了哪个行动）。</li>
<li>这符合之前定义的“<strong>具有可观测行动</strong>”的多阶段博弈。在这里，只有一个阶段玩家1行动，紧接着一个阶段玩家2行动，且玩家2的行动是基于完全知晓玩家1行动的情况下做出的。</li>
</ul>
</li>
<li><p><strong>博弈树表示：</strong></p>
<ul>
<li>这个例子非常适合用<strong>博弈树</strong>来表示：<ul>
<li><strong>根节点 (Root):</strong> 玩家1的决策点（进入 / 不进入）。</li>
<li><strong>中间节点 (Decision Nodes):</strong> 玩家1选择“进入”后，会到达玩家2的决策点（容纳 / 斗争）。玩家1选择“不进入”后，博弈直接结束。</li>
<li><strong>叶节点 / 终点节点 (Terminal Nodes / Leaves):</strong> 代表博弈结束的点，标有收益向量 ((x, y))。每个叶节点对应一个<strong>完整的历史</strong>（行动序列）和最终的收益结果。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>收益：</strong></p>
<ul>
<li>收益 ((x, y)) 的具体数值决定了博弈的结果和均衡。虽然没有给出具体数字，但典型的设定可能是：<ul>
<li><code>(不进入)</code>: 进入者收益为0（无成本无收入），在位者收益较高（维持垄断利润）。</li>
<li><code>(进入, 容纳)</code>: 进入者获得正利润（但低于垄断利润），在位者利润下降（但仍为正，因为共享市场）。</li>
<li><code>(进入, 斗争)</code>: 进入者亏损（因在位者发起价格战等），在位者也亏损（价格战成本）。虽然进入者损失可能更大，但斗争通常对双方都不利，是两败俱伤的结果。</li>
</ul>
</li>
<li>玩家2（在位者）的决策取决于哪种行动（容纳或斗争）在给定玩家1已进入的前提下，能给他带来更高的收益 (y)。</li>
</ul>
</li>
<li><p>要分析这个博弈的均衡（例如，子博弈精炼纳什均衡），就需要具体设定收益值，并逆向归纳求解玩家2在观察到“进入”后的最优反应，以及玩家1预测到玩家2的最优反应后，最初是否选择“进入”。</p>
</li>
</ul>
<p><img src="image-20250623212809384.png" alt="2-15"></p>
<ul>
<li>扩展型博弈的一些基本符号定义</li>
</ul>
<p><img src="image-20250623213442013.png" alt="2-16"></p>
<ul>
<li><p><strong>纯策略 (Pure Strategy):</strong></p>
<ul>
<li>在扩展式博弈中，纯策略不仅仅是玩家在博弈开始时的一个单一选择。它是一个<strong>完整的行动计划</strong>。</li>
<li>策略必须规定玩家在<strong>博弈的每一个可能阶段 (k)</strong>，面对<strong>每一个可能到达该阶段的历史路径 (hᵏ ∈ Hᵏ)</strong> 时，他会选择哪个可用的行动 (sᵢᵏ(hᵏ) ∈ Sᵢ(hᵏ)。</li>
<li><strong>为什么需要这么复杂？</strong> <ul>
<li>因为博弈是序贯的，并且玩家在决策时可能面临不同的局面（由不同的历史 hᵏ 描述）。一个完整的策略必须说明玩家在 <em>所有可能遇到的情况</em> 下会怎么做，即使某些情况在博弈实际进行中可能不会发生（如果玩家遵循这个策略的话）。</li>
</ul>
</li>
<li>形式上，玩家 i 的策略 sᵢ 是一个<strong>函数集合</strong> {sᵢ⁰, sᵢ¹, …, sᵢᴷ}，其中每个函数 sᵢᵏ 将阶段 k 的<em>历史集合 Hᵏ</em> 映射到该玩家在该历史下<em>可用的行动集合 Sᵢ(Hᵏ)</em> 中的一个具体行动。</li>
</ul>
</li>
<li><p><strong>策略组合生成博弈路径:</strong></p>
<ul>
<li>当所有玩家都选定他们的纯策略 (s₁, s₂, …, sₗ) 后，博弈的实际进行路径就被唯一确定了。</li>
<li>路径是通过<strong>递归应用</strong>所有玩家的策略函数来生成的：<ul>
<li><strong>阶段 0:</strong> 从初始历史 h⁰ = ∅ 开始。所有玩家根据他们的策略 sᵢ⁰(∅) 选择行动，形成行动组合 a⁰ = (s₁⁰(∅), s₂⁰(∅), …, sₗ⁰(∅))。阶段 0 后的历史变为 h¹ = a⁰。</li>
<li><strong>阶段 1:</strong> 面对历史 h¹ = a⁰。所有玩家根据他们的策略 sᵢ¹(a⁰) 选择行动，形成行动组合 a¹ = (s₁¹(a⁰), s₂¹(a⁰), …, sₗ¹(a⁰))。阶段 1 后的历史变为 h² = (a⁰, a¹)。</li>
<li><strong>后续阶段:</strong> 以此类推，直到最终阶段 K。阶段 K 后的历史 hᴷ⁺¹ = (a⁰, a¹, …, aᴷ) 就是终端历史。</li>
</ul>
</li>
<li>策略组合 s <strong>完全决定了</strong>终端历史 hᴷ⁺¹。</li>
</ul>
</li>
<li><p><strong>收益 (Payoffs):</strong></p>
<ul>
<li>玩家的收益取决于博弈的最终<strong>结果 (outcome)</strong>，即终端历史 hᴷ⁺¹。</li>
<li>每个玩家 i 有一个<strong>效用函数 (utility function)</strong> uᵢ，该函数将每个可能的终端历史 hᴷ⁺¹ 映射到一个实数，表示玩家 i 在该结果下获得的收益（或效用）。</li>
<li>由于策略组合 s 决定了终端历史 hᴷ⁺¹，因此我们也可以说策略组合 s 决定了每个玩家的收益，记作 uᵢ(s)。uᵢ(s) 本质上是 uᵢ 在由 s 决定的那个特定终端历史 hᴷ⁺¹ 上的取值。</li>
</ul>
</li>
<li><p>扩展式博弈中的核心概念：</p>
<ul>
<li><strong>纯策略:</strong> 是玩家针对<strong>所有可能历史</strong>制定的完整应变计划，表现为一组映射函数 {sᵢᵏ}，每个函数为特定阶段 k 的每个可能历史 hᵏ 指定一个行动。</li>
<li><strong>策略组合决定路径:</strong> 当所有玩家选定策略后，博弈的路径（行动序列 a⁰, a¹, …, aᴷ）和最终的终端历史 hᴷ⁺¹ 就被策略函数递归地、确定性地生成。</li>
<li><strong>收益定义在结果上:</strong> 玩家的收益由终端历史（博弈的最终结果）决定。效用函数 uᵢ 量化了玩家对每个可能结果的偏好。策略组合 s 通过决定终端历史 hᴷ⁺¹ 来间接决定每个玩家的收益 uᵢ(s)。</li>
</ul>
</li>
<li><p>理解纯策略的这种“完备应变计划”性质对于分析扩展式博弈的均衡（如子博弈精炼纳什均衡）至关重要，因为它要求玩家即使在“偏离均衡路径”的历史下（即如果博弈意外地到达了那里），也要指定一个行动。</p>
</li>
</ul>
<p><img src="image-20250623214724248.png" alt="2-17"></p>
<ul>
<li><strong>关键总结 (PPT最后一句):</strong></li>
</ul>
<blockquote>
<p>一个玩家的策略规定了该玩家在其<strong>轮到行动的每一个历史</strong>（例如，玩家2在<code>&#123;C&#125;</code>之后或<code>&#123;D&#125;</code>之后）处所选择的行动。</p>
</blockquote>
<ul>
<li>玩家 1 的策略只需要规定在唯一的历史 <code>∅</code> 处选择 <code>C</code> 或 <code>D</code>。</li>
<li>玩家 2 的策略必须规定在 <em>两个</em> 可能的历史 <code>&#123;C&#125;</code> 和 <code>&#123;D&#125;</code> 处分别选择什么行动（<code>E/F</code> 和 <code>G/H</code> 的组合）。</li>
</ul>
<p><img src="image-20250624002522709.png" alt="2-18"></p>
<ul>
<li>在给定的扩展式博弈及其转换后的标准式（策略型）博弈中，策略组合（L, RL）不是纳什均衡（Nash equilibrium）。以下基于提供的收益矩阵和纳什均衡的定义，逐步解释原因。</li>
</ul>
<ul>
<li><p><strong>博弈的收益矩阵</strong>：</p>
<p>| 玩家1 \ 玩家2 | LL   | LR   | RL   | RR   |<br>| ——————- | —— | —— | —— | —— |<br>| <strong>L</strong>         | 3,2  | 3,2  | 2,3  | 2,3  |<br>| <strong>R</strong>         | 4,1  | 0,1  | 4,1  | 0,1  |</p>
</li>
<li><p><strong>玩家2的策略含义</strong>（RL策略）：</p>
<ul>
<li>RL = 如果玩家1选择L，则玩家2选择R；如果玩家1选择R，则玩家2选择L。</li>
</ul>
</li>
<li><p><strong>策略组合（L, RL）的含义</strong>：</p>
<ul>
<li>玩家1选择L。</li>
<li>玩家2选择RL策略（因此，当玩家1选L时，玩家2选R）。</li>
<li>实际发生的行动路径：玩家1选L → 玩家2选R。</li>
<li>对应收益：从收益矩阵中，行L、列RL的单元格为（2,3），即玩家1收益为2，玩家2收益为3。</li>
</ul>
</li>
<li><h3 id="纳什均衡的定义"><a href="#纳什均衡的定义" class="headerlink" title="纳什均衡的定义"></a>纳什均衡的定义</h3><ul>
<li>纳什均衡要求：在给定其他玩家的策略下，没有任何一个玩家能通过单方面改变自己的策略而获得更高的收益。也就是说：</li>
<li>玩家1的策略必须是对玩家2策略的最优响应（best response）。</li>
<li>玩家2的策略必须是对玩家1策略的最优响应。<br>如果任何一个玩家有激励偏离当前策略，则该组合不是纳什均衡。</li>
</ul>
</li>
<li><h3 id="为什么（L-RL）不是纳什均衡？"><a href="#为什么（L-RL）不是纳什均衡？" class="headerlink" title="为什么（L, RL）不是纳什均衡？"></a>为什么（L, RL）不是纳什均衡？</h3><p>在策略组合（L, RL）下，玩家1有激励单方面改变策略。具体分析如下：</p>
</li>
</ul>
<ol>
<li><p><strong>给定玩家2的策略RL，玩家1的收益比较</strong>：</p>
<ul>
<li>如果玩家1保持选择L（当前策略）：<ul>
<li>玩家2的RL策略规定：当玩家1选L时，玩家2选R。</li>
<li>因此，收益为（2,3），玩家1获得收益<strong>2</strong>。</li>
</ul>
</li>
<li>如果玩家1单方面改为选择R：<ul>
<li>玩家2的RL策略规定：当玩家1选R时，玩家2选L（因为RL策略在玩家1选R时对应选L）。</li>
<li>因此，行动路径为（R, L），收益为（4,1）（从收益矩阵的行R、列RL单元格可得）。</li>
<li>玩家1获得收益<strong>4</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>玩家1的激励分析</strong>：</p>
<ul>
<li>玩家1的收益从<strong>2</strong>（选L）变为<strong>4</strong>（选R），收益增加（4 &gt; 2）。</li>
<li>因此，玩家1有严格激励（strict incentive）偏离策略L，改为选择R。因为收益更高，且这是单方面改变（玩家2的策略RL保持不变）。</li>
</ul>
</li>
<li><p><strong>玩家2的响应（虽不必要，但完整性分析）</strong>：</p>
<ul>
<li>在（L, RL）下，玩家2的收益为3（给定玩家1选L，玩家2选R）。</li>
<li>如果玩家1保持选L，玩家2改变策略（如改为LL、LR或RR）：<ul>
<li>例如，改为LL：当玩家1选L时，玩家2选L，收益为2（行L、列LL单元格为（3,2），玩家2收益2 &lt; 3）。</li>
<li>改为LR：当玩家1选L时，玩家2选L，收益为2（行L、列LR单元格为（3,2），玩家2收益2 &lt; 3）。</li>
<li>改为RR：当玩家1选L时，玩家2选R，收益为3（与当前相同）。</li>
<li>因此，玩家2无严格激励偏离RL（因为改变策略要么收益降低，要么不变），但这不是关键，因为玩家1的偏离已足够破坏均衡。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><h3 id="为什么PPT中列出的（R-RL）是纳什均衡，而（L-RL）不是？"><a href="#为什么PPT中列出的（R-RL）是纳什均衡，而（L-RL）不是？" class="headerlink" title="为什么PPT中列出的（R, RL）是纳什均衡，而（L, RL）不是？"></a>为什么PPT中列出的（R, RL）是纳什均衡，而（L, RL）不是？</h3><ul>
<li><p><strong>（R, RL）是纳什均衡</strong>（如PPT所列）：</p>
<ul>
<li>玩家1选R，玩家2选RL（当玩家1选R时，玩家2选L）。</li>
<li>收益为（4,1）。</li>
<li>给定玩家2的RL策略，玩家1：选R收益4，选L收益2（因为如果玩家1选L，玩家2选R，收益2），4 &gt; 2，因此玩家1无激励偏离。</li>
<li>给定玩家1选R，玩家2：任何改变（如改为LL、LR或RR），在玩家1选R时收益均为1（无严格增加），因此玩家2无激励偏离。</li>
<li>所以（R, RL）满足纳什均衡条件（弱均衡）。</li>
</ul>
</li>
<li><p><strong>（L, RL）不是纳什均衡</strong>：</p>
<ul>
<li>如上所述，玩家1有严格激励偏离L到R，因此不满足“无玩家有激励偏离”的条件。</li>
</ul>
</li>
</ul>
</li>
<li><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>（L, RL）不是纳什均衡，因为玩家1可以通过单方面改变策略（从L到R）将收益从2提高到4。</strong> 给定玩家2的RL策略，玩家1选择L不是最优响应。</li>
<li>这体现了纳什均衡的核心要求：每个玩家的策略必须是对其他玩家策略的最优响应。在扩展式博弈中，这种分析也揭示了为什么有些策略组合在标准式中看似可行，但因动态不一致而被排除（如这里玩家1的偏离激励）。</li>
</ul>
</li>
</ul>
<p><img src="image-20250624003714695.png" alt="2-19"></p>
<p>这张PPT探讨了进入博弈的均衡合理性，通过扩展式和标准式表示揭示了纳什均衡的局限性。以下是详细分析：</p>
<hr>
<h3 id="博弈结构与收益"><a href="#博弈结构与收益" class="headerlink" title="博弈结构与收益"></a>博弈结构与收益</h3><h4 id="扩展式表示（博弈树）："><a href="#扩展式表示（博弈树）：" class="headerlink" title="扩展式表示（博弈树）："></a>扩展式表示（博弈树）：</h4><ul>
<li><strong>玩家1（进入者）</strong>：先行动，选择：<ul>
<li><strong>In</strong>（进入市场）</li>
<li><strong>Out</strong>（不进入市场）→ 收益 (1,2)</li>
</ul>
</li>
<li><strong>玩家2（在位者）</strong>：观察到进入者行动后选择：<ul>
<li><strong>A</strong>（容纳）→ 收益 (2,1)</li>
<li><strong>F</strong>（斗争）→ 收益 (0,0)</li>
</ul>
</li>
</ul>
<h4 id="标准式表示（收益矩阵）："><a href="#标准式表示（收益矩阵）：" class="headerlink" title="标准式表示（收益矩阵）："></a>标准式表示（收益矩阵）：</h4><div class="table-container">
<table>
<thead>
<tr>
<th>进入者 \ 在位者</th>
<th>容纳 (A)</th>
<th>斗争 (F)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>进入 (In)</strong></td>
<td>(2,1)</td>
<td>(0,0)</td>
</tr>
<tr>
<td><strong>不进入 (Out)</strong></td>
<td>(1,2)</td>
<td>(1,2)</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="纳什均衡分析"><a href="#纳什均衡分析" class="headerlink" title="纳什均衡分析"></a>纳什均衡分析</h3><ol>
<li><p><strong>(In, A)</strong>：</p>
<ul>
<li>进入者收益：2（若改为Out，收益1&lt;2）→ <strong>无偏离激励</strong></li>
<li>在位者收益：1（若改为F，收益0&lt;1）→ <strong>无偏离激励</strong><br>✅ <strong>是纳什均衡</strong></li>
</ul>
</li>
<li><p><strong>(Out, F)</strong>：</p>
<ul>
<li>进入者收益：1（若改为In，在位者选F则收益0&lt;1）→ <strong>无偏离激励</strong></li>
<li>在位者收益：2（无论选A或F，收益均为2）→ <strong>无偏离激励</strong><br>✅ <strong>是纳什均衡（弱均衡）</strong></li>
</ul>
</li>
</ol>
<hr>
<h3 id="均衡合理性检验"><a href="#均衡合理性检验" class="headerlink" title="均衡合理性检验"></a>均衡合理性检验</h3><h4 id="为什么-Out-F-不合理？"><a href="#为什么-Out-F-不合理？" class="headerlink" title="为什么 (Out, F) 不合理？"></a>为什么 <strong>(Out, F)</strong> 不合理？</h4><p>尽管 <strong>(Out, F)</strong> 是纳什均衡，但它在动态博弈中<strong>不可信</strong>（缺乏子博弈精炼性）：</p>
<ol>
<li><p><strong>在位者的空威胁</strong>：</p>
<ul>
<li>在位者声称“若你进入，我会斗争（F）”，但若进入者真的选择 <strong>In</strong>：<ul>
<li>在位者选 <strong>A</strong> 收益为 <strong>1</strong></li>
<li>在位者选 <strong>F</strong> 收益为 <strong>0</strong>（更差）<br>→ 理性在位者实际会选择 <strong>A</strong>，而非 <strong>F</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>进入者的理性决策</strong>：</p>
<ul>
<li>进入者知道在位者的威胁不可信（一旦进入，在位者必选 <strong>A</strong>）。</li>
<li>因此进入者应选择 <strong>In</strong>（收益2 &gt; 选Out的收益1）。</li>
</ul>
</li>
</ol>
<h4 id="逆向归纳验证："><a href="#逆向归纳验证：" class="headerlink" title="逆向归纳验证："></a>逆向归纳验证：</h4><ol>
<li>若进入者选 <strong>In</strong>，在位者在子博弈中：<ul>
<li>选 <strong>A</strong> → 收益 <strong>1</strong></li>
<li>选 <strong>F</strong> → 收益 <strong>0</strong><br>→ 最优选择是 <strong>A</strong>。</li>
</ul>
</li>
<li>进入者预判：<ul>
<li>选 <strong>In</strong> → 收益 <strong>2</strong>（因在位者会选A）</li>
<li>选 <strong>Out</strong> → 收益 <strong>1</strong><br>→ 最优选择是 <strong>In</strong>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><div class="table-container">
<table>
<thead>
<tr>
<th>均衡</th>
<th>合理性</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>(In, A)</strong></td>
<td>✅ 合理</td>
<td>威胁可信，符合序贯理性</td>
</tr>
<tr>
<td><strong>(Out, F)</strong></td>
<td>❌ 不合理</td>
<td>依赖不可信的空威胁（动态不一致）</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>核心问题</strong>：纳什均衡在扩展式博弈中可能包含<strong>不可信威胁</strong>，需通过<strong>子博弈精炼纳什均衡</strong>（逆向归纳法）剔除不合理的均衡。</li>
<li><strong>本例唯一合理均衡</strong>：<strong>(In, A)</strong>，即进入者进入，在位者容纳。</li>
</ul>
<p><img src="image-20250624004513150.png" alt="2-20"></p>
<ul>
<li>回顾匹配硬币博弈（matching pennies game）的两阶段扩展式版本。</li>
<li>在这个博弈中，存在两个<strong>真子博弈（proper subgames）</strong> 以及博弈本身（它也是一个子博弈），因此总共有<strong>三个子博弈</strong>。</li>
</ul>
<blockquote>
<p><strong>定义：</strong> 在一个（完美信息）博弈树中，<strong>每一个节点</strong>，连同从该节点到达之后所剩余的博弈部分，被称为一个<strong>子博弈（subgame）</strong>。<br>即，每一个<strong>非终端历史（non-terminal history）</strong> ( h ) 都对应一个子博弈。</p>
</blockquote>
<hr>
<p><strong>关键概念理解：</strong></p>
<ol>
<li><p><strong>子博弈 (Subgame):</strong></p>
<ul>
<li>子博弈是<strong>原博弈的一部分</strong>，它起始于博弈树中的<strong>某个单一决策节点</strong>（该节点代表一个特定的非终端历史 ( h^k )），并<strong>包含该节点之后的所有后续决策节点、行动分支和终端节点</strong>。</li>
<li>它本身必须构成一个<strong>完整的、独立的博弈</strong>，拥有明确的起点（该决策节点）、后续行动规则和最终收益。</li>
<li>子博弈继承了原博弈的所有规则（玩家、行动、信息、收益函数）。</li>
</ul>
</li>
<li><p><strong>非终端历史 (Non-terminal History):</strong></p>
<ul>
<li>指那些<strong>不是博弈最终结果</strong>的历史 ( h^k )（即 ( k &lt; K+1 )，其中 ( K+1 ) 是终端历史的索引）。</li>
<li>每个这样的历史 ( h^k ) 都标志着博弈进行到了一个<strong>尚未结束的决策点</strong>。</li>
<li><strong>关键联系：</strong> 每个非终端历史 ( h^k ) 都<strong>唯一确定了一个子博弈的起始点</strong>。这个子博弈就是从历史 ( h^k ) 所对应的那个决策节点开始的剩余游戏部分。</li>
</ul>
</li>
<li><p><strong>子博弈的数量:</strong></p>
<ul>
<li>在<strong>完美信息（perfect information）</strong> 博弈（即每个信息集只包含一个节点）中，子博弈的数量等于<strong>非终端决策节点的数量</strong>。</li>
<li>示例中提到匹配硬币两阶段博弈有<strong>三个子博弈</strong>：<ul>
<li><strong>子博弈 1：</strong> 起始于<strong>玩家1的第一个决策节点</strong>（对应初始历史 ( h^0 = \emptyset )）。<strong>这就是整个博弈本身。</strong></li>
<li><strong>子博弈 2：</strong> 起始于<strong>玩家2在玩家1选择“正面”之后的决策节点</strong>（对应历史 ( h^1 = (Heads) )）。</li>
<li><strong>子博弈 3：</strong> 起始于<strong>玩家2在玩家1选择“反面”之后的决策节点</strong>（对应历史 ( h^1 = (Tails) )）。</li>
</ul>
</li>
<li>后两个是<strong>真子博弈（proper subgames）</strong>，因为它们严格包含在原博弈之内且不等于原博弈。</li>
</ul>
</li>
<li><p><strong>为什么子博弈概念重要？</strong></p>
<ul>
<li><strong>均衡精炼：</strong> 子博弈概念是定义<strong>子博弈精炼纳什均衡（Subgame Perfect Nash Equilibrium, SPNE）</strong> 的核心。SPNE 要求均衡策略不仅在原博弈上构成纳什均衡，而且在<strong>每一个可能的子博弈</strong>上也构成纳什均衡。这旨在剔除那些依赖<strong>不可信威胁或承诺</strong>的纳什均衡（例如之前进入博弈中的 <code>(Out, F)</code> 均衡）。</li>
<li><strong>分析工具：</strong> 子博弈结构使得我们可以使用<strong>逆向归纳法（backward induction）</strong> 来求解完美信息有限博弈的 SPNE。我们从最小的子博弈（最接近终点的）开始求解，将其解（收益或最优行动）代入其父节点，再逐步倒推回根节点。</li>
<li><strong>模块化分析：</strong> 允许将大型复杂博弈分解为更小的、可管理的子部分进行分析。</li>
</ul>
</li>
<li><p><strong>子博弈求解方法解析</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/199055190">https://zhuanlan.zhihu.com/p/199055190</a></p>
</li>
</ol>
<h2 id="2-3-势博弈"><a href="#2-3-势博弈" class="headerlink" title="2.3 势博弈"></a>2.3 势博弈</h2><p><img src="image-20250624194410787.png" alt="2-21"></p>
<ul>
<li><strong>请注意，对于所有厂商 i 和所有 q−i&gt;0 的情况：</strong><ul>
<li>ui(qi,q−i)−ui(qi′,q−i)&gt;0 <strong>当且仅当 (iff)</strong> Φ(qi,q−i)−Φ(qi′,q−i)&gt;0 ，此条件对于所有 qi,qi′&gt;0 均成立。</li>
<li>说明：<ul>
<li>这条关键的陈述指出，在其他厂商产量不变的情况下，厂商 i 从产量 qi′ 转换到 qi 能否增加自身利润，与这个转换能否增加函数 Φ 的值，两者是完全等价的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这张PPT的核心思想是为古诺竞争模型引入一个称为<strong>“势函数”(Potential Function)</strong> 的概念，并证明此模型是一个<strong>“势博弈”(Potential Game)</strong>。</p>
<ol>
<li><p>什么是古诺竞争？</p>
<p>这是一个经典的经济学模型，描述了在一个寡占市场中，几家厂商如何进行产量竞争。每家厂商都假设其竞争对手的产量是固定的，然后选择能让自己利润最大化的产量。当所有厂商都达到一个状态，即没有任何一家厂商可以单方面改变产量来增加自己的利润时，市场就达到了纳什均衡 (Nash Equilibrium)。</p>
</li>
<li><p>为什么要引入奇怪的函数 Φ？</p>
<p>支付函数 ui 非常直观，它就是厂商 i 的利润。然而，函数 Φ 看起来很抽象，它将“所有厂商产量的乘积”与“单位利润”相乘，并没有直接的经济学意义。</p>
<p>它的真正价值在于其数学性质。投影片的最后一条结论揭示了这个性质：任何单一厂商 i 调整策略 (产量 qi) 所带来的自身利润变化方向，都和函数 Φ 的变化方向完全一致。</p>
</li>
<li><p>这意味着什么？(核心理解)</p>
<p>这意味着，原本一个复杂的多人博弈问题（每个厂商都在最大化自己的 ui），可以被转化为一个相对简单的<strong>“寻找单一函数 Φ 最大值”</strong>的问题。</p>
<ul>
<li><strong>简化分析</strong>：我们不再需要同时追踪 I 个不同厂商的利润函数，只需要分析一个共同的“势函数”Φ 即可。</li>
<li><strong>保证均衡存在</strong>：在势博弈中，势函数 Φ 的局部最大值点对应着该博弈的纳什均衡。因为一个有界的连续函数必然存在最大值，这就为证明古诺均衡的存在性提供了一条优雅的路径。</li>
<li><strong>收敛性</strong>：势博弈还有一个重要特性，即如果玩家们轮流进行“最优反应”（每次都选择当下能让自己利润最大化的策略），这个过程最终一定会收敛到一个纳什均衡。函数 Φ 就像一个山坡，玩家们的每一步调整都像是在爬坡，最终必然会走到一个山顶（均衡点）。</li>
</ul>
</li>
</ol>
<p><img src="image-20250624200511139.png" alt="2-22"></p>
<p>这两张PPT分别介绍了<strong>序数势博弈</strong>和<strong>精确势博弈</strong>。</p>
<ol>
<li><p>与“序数势”的核心区别</p>
<p>理解“精确势”的关键在于将其与上一张幻灯片中的“序数势”进行对比：</p>
<ul>
<li><strong>序数势 (Ordinal Potential)</strong>：只要求参与者收益变化的<strong>方向</strong>与势函数变化的<strong>方向</strong>一致。<ul>
<li>通俗地说：“只要我换策略能多赚钱，<code>Φ</code> 的值就一定会变大。” 它不关心你多赚了1块钱还是100块钱。</li>
</ul>
</li>
<li><strong>精确势 (Exact Potential)</strong>：要求参与者收益变化的<strong>确切数值</strong>与势函数变化的<strong>确切数值</strong>完全相等。<ul>
<li>通俗地说：“如果我换策略能多赚10块钱，<code>Φ</code> 的值就也必须不多不少，正好增加10。”</li>
</ul>
</li>
</ul>
</li>
<li><p>更严格的条件</p>
<p>显然，“精确势”是一个比“序数势”严格得多的条件。如果一个博弈是精确势博弈，那么它必然也是一个序数势博弈（因为如果两个改变量的数值相等，它们的正负号必然相同）。但反过来不成立，很多序数势博弈并不能满足精确势的苛刻条件。</p>
</li>
<li><p>指正幻灯片中的笔误</p>
<p>需要指出，幻灯片的最后一行存在一个明显的笔误。它写着 “G is called an exact potential game if it admits an ordinal potential.”（如果一个博弈拥有一个序数势，它就被称为一个精确势博弈）。这在逻辑上是错误的。</p>
<ul>
<li><strong>正确表述应为</strong>：“如果一个博弈 G 拥有一个<strong>精确势函数 (exact potential)</strong>，那么它就被称为一个<strong>精确势博弈</strong>。”</li>
</ul>
</li>
</ol>
<p><img src="image-20250624201207684.png" alt="2-23"></p>
<p>这张幻灯片通过一个具体的2x2矩阵博弈（囚徒困境的一个变体）的例子，非常直观地展示了“势函数”是如何运作的。这张幻灯片的核心目的是让我们<strong>验证</strong>所给出的矩阵 <code>P</code> 是否真的是博弈 <code>G</code> 的一个势函数。</p>
<p>我们可以通过检验定义来验证。让我们看看当某个参与者单方面改变策略时，他个人收益的变化量是否与势函数 <code>P</code> 的变化量相匹配。</p>
<p><strong>1. 验证过程</strong></p>
<p>我们分别检查行参与者（玩家1）和列参与者（玩家2）的决策。</p>
<ul>
<li><p><strong>检验玩家1（行选择者）</strong></p>
<ul>
<li><p>当玩家2选择“左”时</p>
<p>：玩家1在“上”（收益1）和“下”（收益0）之间选择。</p>
<ul>
<li>收益变化: u1(上, 左)−u1(下, 左)=1−0=1</li>
<li>势函数变化: P(上, 左)−P(下, 左)=4−3=1</li>
<li>两者<strong>完全相等</strong>。</li>
</ul>
</li>
<li><p>当玩家2选择“右”时</p>
<p>：玩家1在“上”（收益9）和“下”（收益6）之间选择。</p>
<ul>
<li>收益变化: u1(上, 右)−u1(下, 右)=9−6=3</li>
<li>势函数变化: P(上, 右)−P(下, 右)=3−0=3</li>
<li>两者<strong>完全相等</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>检验玩家2（列选择者）</strong></p>
<ul>
<li><p>当玩家1选择“上”时</p>
<p>：玩家2在“左”（收益1）和“右”（收益0）之间选择。</p>
<ul>
<li>收益变化: u2(上, 左)−u2(上, 右)=1−0=1</li>
<li>势函数变化: P(上, 左)−P(上, 右)=4−3=1</li>
<li>两者<strong>完全相等</strong>。</li>
</ul>
</li>
<li><p>当玩家1选择“下”时</p>
<p>：玩家2在“左”（收益9）和“右”（收益6）之间选择。</p>
<ul>
<li>收益变化: u2(下, 左)−u2(下, 右)=9−6=3</li>
<li>势函数变化: P(下, 左)−P(下, 右)=3−0=3</li>
<li>两者<strong>完全相等</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>2. 结论</strong></p>
<p>由于<strong>任何</strong>参与者单方面改变策略所带来的收益变化，都<strong>精确地等于</strong>势函数 <code>P</code> 中对应数值的变化，因此，矩阵 <code>P</code> 是博弈 <code>G</code> 的一个<strong>精确势函数 (exact potential function)</strong>。这个博弈 <code>G</code> 是一个<strong>精确势博弈</strong>。</p>
<p><strong>3. 势函数的威力：寻找纳什均衡</strong></p>
<p>这个例子的美妙之处在于，它展示了势函数如何简化均衡的寻找过程。寻找博弈 <code>G</code> 的纯策略纳什均衡，现在等价于寻找势函数矩阵 <code>P</code> 的“稳定点”。</p>
<p>观察势函数矩阵 P：</p>
<p>P=(4330)</p>
<p>矩阵中的最大值是4，位于（上，左）位置。让我们看看这个点是否稳定：</p>
<ul>
<li>如果从 <code>P=4</code>（上，左）出发，玩家1单方面移到“下”，<code>P</code>的值会从4变成3，他不会移动。</li>
<li>如果从 <code>P=4</code>（上，左）出发，玩家2单方面移到“右”，<code>P</code>的值会从4变成3，他也不会移动。</li>
</ul>
<p>因为没有任何一方有动机从（上，左）这个位置离开，所以它是一个纳什均衡。这对应于原博弈 <code>G</code> 中的（1,1）这个结果。这个例子清晰地表明，<strong>势函数的局部最大值（在此例中也是全局最大值）对应着博弈的一个纳什均衡</strong>。这正是势函数在博弈分析中的核心价值。</p>
<p><img src="image-20250624201541524.png" alt="2-24"></p>
<p>有限序数势博弈的结果是有限的，势函数会为每一个博弈策略赋予一个值，因此必然存在一个最大值，这个最大值就是纳什均衡点。</p>
<p><img src="image-20250624202953517.png" alt="2-25"></p>
<h4 id="1-核心结论"><a href="#1-核心结论" class="headerlink" title="1. 核心结论"></a>1. 核心结论</h4><p>结论是最后一条：当厂商 <code>i</code> 单方面将自己的产量从 <code>q&#39;_i</code> 变为 <code>q_i</code> 时，他<strong>个人利润的变化量</strong>，与我们构造的那个看起来很复杂的函数 <code>Φ*</code> 的<strong>变化量是完全相等的</strong>。这正是“精确势函数”的定义。</p>
<h4 id="2-数学证明（为什么这个结论成立？）"><a href="#2-数学证明（为什么这个结论成立？）" class="headerlink" title="2. 数学证明（为什么这个结论成立？）"></a>2. 数学证明（为什么这个结论成立？）</h4><p><img src="image-20250624203148105.png" alt="2-26"></p>
<p>最后比较两个Δ即可</p>
<p><img src="image-20250624204837963.png" alt="2-27"></p>
<p><strong>标题：有限序数势博弈中的简单动态 (Simple Dynamics in Finite Ordinal Potential Games)</strong></p>
<p>定义 (Definition)</p>
<p>策略空间 S 中的一条路径 (path) 是一个策略向量序列 (s0,s1,⋯)，其中任意两个连续的策略只在一个坐标上不同（即，每一次恰好只有一名参与者改变了他的策略）。</p>
<p>一条<strong>改进路径 (improvement path)</strong> 是一条路径 (s0,s1,⋯)，它满足：</p>
<ul>
<li>uik(sk)&lt;uik(sk+1)，其中策略 sk 和 sk+1 在第 ik 个坐标上不同。换句话说，对于那个改变了策略的参与者来说，他的收益得到了改善。</li>
</ul>
<p>一条改进路径可以被认为是<strong>“短视参与者” (myopic players)</strong> 动态生成的结果。</p>
<hr>
<p>这张幻灯片将我们的视角从静态的“均衡分析”转向了动态的“演化过程分析”。它为我们描述“一个博弈是如何一步步演变的”提供了正式的语言。这对于理解系统如何达到稳定状态至关重要。</p>
<h4 id="1-“路径”与“改进路径”的通俗解释"><a href="#1-“路径”与“改进路径”的通俗解释" class="headerlink" title="1. “路径”与“改进路径”的通俗解释"></a>1. “路径”与“改进路径”的通俗解释</h4><ul>
<li><strong>路径 (Path)</strong>：你可以把它想象成一盘棋的“棋谱”或一个游戏的“回合记录”。它记录了博弈状态是如何一步步变化的，其核心规则是<strong>“一次只动一个”</strong>。在 sk 这一步，只有一名参与者会改变他的行动，从而进入 sk+1 状态。这是一种分析动态过程的合理简化。</li>
<li><strong>改进路径 (Improvement Path)</strong>：这是一种特殊的、由理性驱动的路径。它不仅记录了系统的演变，还说明了<strong>为什么</strong>会这样演变。每一步的发生，都是因为某个参与者发现“如果我单方面改变策略，我的收益会立刻增加”，于是他就这么做了。这完美地描述了那些只顾眼前利益的参与者的行为。</li>
</ul>
<h4 id="2-“短视参与者”-Myopic-Players-的概念"><a href="#2-“短视参与者”-Myopic-Players-的概念" class="headerlink" title="2. “短视参与者” (Myopic Players) 的概念"></a>2. “短视参与者” (Myopic Players) 的概念</h4><p>这是理解“改进路径”背后行为动机的关键。</p>
<ul>
<li><strong>“短视”</strong>意味着参与者们并不深谋远虑，他们不会去预测对手的对手的反应。</li>
<li>他们的决策逻辑非常简单：“在当前这个局面下，我有没有一个别的选择能让我马上赚得更多？”</li>
<li>如果答案是“有”，那么某个参与者就会采取行动，从而推动整个系统沿着“改进路径”向前走一步。这个过程可以被看作是一系列“更优反应 (better response)”的链式反应。</li>
</ul>
<h4 id="3-为什么要在势博弈中讨论这个？（核心洞见）"><a href="#3-为什么要在势博弈中讨论这个？（核心洞见）" class="headerlink" title="3. 为什么要在势博弈中讨论这个？（核心洞见）"></a>3. 为什么要在势博弈中讨论这个？（核心洞见）</h4><p>定义这些概念的最终目的，是为了引出势博弈最强大的性质之一：<strong>动态收敛性</strong>。</p>
<p>我们可以设想一下：</p>
<ol>
<li><strong>在普通博弈中</strong>：一条“改进路径”可能会没完没了地走下去，甚至可能陷入一个循环（比如A动、B动、C动，结果又回到了A动之前的局面），永远无法达到一个稳定的纳什均衡。</li>
<li><strong>但在势博弈中</strong>：奇迹发生了。我们知道，在势博弈中，只要某个参与者 <code>i</code> 的收益 <code>uᵢ</code> 增加了，全局的势函数 <code>Φ</code> 的值也<strong>必须增加</strong>。</li>
<li>因此，在势博弈里，<strong>每一条“改进路径”都必然是一条“势函数 <code>Φ</code> 值不断增加的路径”</strong>。</li>
<li>在一个<strong>有限</strong>博弈中，势函数 <code>Φ</code> 的可能取值是有限的，它必然有一个最大值。<code>Φ</code> 的值不可能无限地增加下去。</li>
</ol>
<p><strong>结论</strong>：在有限势博弈中，任何“改进路径”走不了几步就<strong>必然会停止</strong>。它会在哪里停下呢？它会停在一个任何人都无法再单方面改善自己收益的地方——而这个地方，根据定义，<strong>就是一个纯策略纳什均衡</strong>。</p>
<p><img src="image-20250624205950398.png" alt="2-28"></p>
<p><strong>标题：有限精确势博弈的特征描述 (Characterization of Finite Exact Potential Games)</strong></p>
<ul>
<li><p>对于一条有限路径 γ=(s0,s1,…,sN)，我们令：</p>
<p>I(γ)=i=1∑N(umi(si)−umi(si−1))</p>
<p>其中，mi 指代在路径的第 i 步改变其策略的参与者。</p>
</li>
<li><p>如果 s0=sN，则路径 γ=(s0,…,sN) 是<strong>闭合的 (closed)</strong>。如果在此外对于每一个 0≤l&lt;k≤N−1 都有 sl\\=sk，那么它就是一条<strong>简单闭合路径 (simple closed path)</strong>。</p>
</li>
</ul>
<p>定理 (Theorem)</p>
<p>一个博弈 G 是一个精确势博弈，当且仅当对于所有有限简单闭合路径 γ，都有 I(γ) = 0。此外，只检验长度为4的简单闭合路径就足够了。</p>
<hr>
<p>这个数学定理，它为我们提供了一个<strong>“试金石”</strong>，用来检验任何一个有限博弈到底是不是一个“精确势博弈”，而无需我们去猜测或构造那个势函数 <code>Φ</code>。</p>
<p><img src="image-20250624211206447.png" alt="2-29"></p>
<p><strong>标题：网络拥堵博弈 (Network Congestion Games)</strong></p>
<ul>
<li>一个包含 n 个用户的<strong>有向图 (directed graph)</strong> G=(V,E)，</li>
<li>图 G 中的每一条<strong>边 (edge)</strong> e 都有一个<strong>延迟函数 (delay function)</strong> fₑ，</li>
<li>用户 i 的<strong>策略 (Strategy)</strong> 是选择一条从<strong>起点 (source)</strong> sᵢ 到<strong>终点 (destination)</strong> tᵢ 的<strong>路径 (path)</strong> Aᵢ，</li>
<li>一条路径的延迟是该路径上所有边的延迟之和，</li>
<li>每个用户都想通过选择最佳路径来<strong>最小化 (minimize)</strong> 其自身的延迟。</li>
</ul>
<hr>
<p>这张幻灯片介绍了一类在现实世界中应用极其广泛的博弈模型——<strong>网络拥堵博弈</strong>。这是理解交通堵塞、互联网数据包路由、供应链物流等众多问题的核心理论框架。</p>
<h4 id="1-博弈的核心要素"><a href="#1-博弈的核心要素" class="headerlink" title="1. 博弈的核心要素"></a>1. 博弈的核心要素</h4><p>这个模型非常直观，它完美地捕捉了“拥堵”现象的本质：</p>
<ul>
<li><strong>参与者 (Players)</strong>：n 个用户（比如，n 位司机）。</li>
<li><strong>策略 (Strategies)</strong>：每个司机可以选择的路线（例如，从家 <code>sᵢ</code> 到公司 <code>tᵢ</code> 的不同路径）。</li>
<li><strong>成本 (Cost)</strong>：每个司机在路上花费的时间，即“延迟”。</li>
</ul>
<p>这个博弈最关键、最有趣的地方在于成本（延迟）的计算方式。一条路（边 <code>e</code>）的延迟<code>fₑ</code><strong>不是一个固定的数，而是一个函数</strong>。它的值取决于有多少人同时在使用这条路。</p>
<h4 id="2-博弈的内在冲突"><a href="#2-博弈的内在冲突" class="headerlink" title="2. 博弈的内在冲突"></a>2. 博弈的内在冲突</h4><p>每个司机都想自私地选择一条“最快”的路。但正是因为所有人都这么想，才导致了问题的产生：</p>
<ul>
<li>如果有一条近路看起来最快，所有司机可能都会涌向这条路。</li>
<li>结果，这条路变得极度拥堵，它的延迟函数 <code>fₑ(x)</code> 因为 <code>x</code>（用户数）变得很大而给出一个非常高的延迟值。</li>
<li>这条所谓的“最快”的路，实际上可能比其他更长但无人问津的路要慢得多。</li>
</ul>
<p><strong>每个人的最优选择都依赖于其他所有人的选择</strong>。我的决策影响你的成本，你的决策也影响我的成本。这就是博弈的核心所在。</p>
<h4 id="3-与“势博弈”的深刻联系（核心洞见）"><a href="#3-与“势博弈”的深刻联系（核心洞见）" class="headerlink" title="3. 与“势博弈”的深刻联系（核心洞见）"></a>3. 与“势博弈”的深刻联系（核心洞见）</h4><p>这个模型最惊人的特性是，<strong>网络拥堵博弈是“精确势博弈”的经典范例</strong>。这是由学者 Rosenthal 在1973年发现的里程碑式成果。</p>
<p>存在一个全局的势函数 Φ（通常称为罗森塔尔势函数），它能够完美地刻画整个系统的动态。这个势函数的定义方式非常巧妙：</p>
<p><img src="image-20250624211304691.png" alt="2-30"></p>
<p>其中，xe 是当前选择了边 e 的总用户数。这个公式的含义是，把网络中每一条边的“从第1个用户到第 xe 个用户的延迟依次加起来”，然后再把所有边的这个值汇总。</p>
<p>可以被严格证明：<strong>当任何一个用户 i 单方面改变自己的路径时，他个人延迟的变化量，与这个全局势函数 <code>Φ</code> 的变化量是完全相等的！</strong></p>
<h4 id="4-重要推论"><a href="#4-重要推论" class="headerlink" title="4. 重要推论"></a>4. 重要推论</h4><p>既然拥堵博弈是精确势博弈，那么我们之前讨论过的所有优美性质就都可以应用在这里：</p>
<ol>
<li><strong>均衡必然存在</strong>：任何一个网络拥堵博弈都<strong>至少存在一个纯策略纳什均衡</strong>。在交通模型里，这被称为“瓦德罗普均衡 (Wardrop equilibrium)”。这意味着，总会存在一种稳定的交通分配格局，在这种格局下，没有单个司机可以通过单方面改变路线来缩短自己的通勤时间。</li>
<li><strong>动态必然收敛</strong>：如果司机们是“短视的”（例如，每天根据昨天的路况尝试寻找更快的路），这个不断调整、学习的过程<strong>必然会收敛到一个稳定的均衡状态</strong>，而不会永久地混乱或振荡下去。</li>
</ol>
<h2 id="3-1-零和博弈及纳什均衡计算"><a href="#3-1-零和博弈及纳什均衡计算" class="headerlink" title="3.1 零和博弈及纳什均衡计算"></a>3.1 零和博弈及纳什均衡计算</h2><p><img src="image-20250624232921182.png" alt="3-1"></p>
<p><strong>练习：斯塔克尔伯格双寡头模型 (Exercise: The Stackelberg model of Duopoly)</strong></p>
<ul>
<li>斯塔克尔伯格双寡头模型 (1934):<ul>
<li>一个参与者，被称为主导者或<strong>领导者 (leader)</strong>，首先行动，并且该参与者的选择结果在另一位参与者（<strong>跟随者, follower</strong>）做出选择之前就已告知对方。</li>
<li>例如，通用汽车公司（General Motors）在美国历史上的某些时期，就曾在汽车行业中扮演了如此主导的角色。</li>
</ul>
</li>
</ul>
<p><em>（来源：Game Theory, Second Edition, 2014. Thomas S. Ferguson）</em></p>
<p><strong>标题：练习：斯塔克尔伯格双寡头模型</strong></p>
<ul>
<li>厂商1首先选择一个生产数量 q1，其单位成本为 c。</li>
<li>这个数量会被告知厂商2，然后厂商2再选择自己的生产数量 q2，其单位成本同样为 c。</li>
<li>之后，市场的单位价格 P 由以下公式决定： P(Q)={a−Q0if 0≤Q≤aif Q&gt;a=(a−Q)+ 其中 Q=q1+q2，并且 a 是一个常数。</li>
<li>参与者们获得如下支付（利润）： u1(q1,q2)=q1P(q1+q2)−cq1=q1(a−q1−q2)+−cq1 u2(q1,q2)=q2P(q1+q2)−cq2=q2(a−q1−q2)+−cq2 其中单位成本 c&lt;a。</li>
</ul>
<p>斯塔克尔伯格模型是产业组织理论中一个基石性的模型。它与我们之前讨论的古诺模型（Cournot model）最大的不同在于，它将“同时行动”改为了<strong>“序贯行动” (Sequential Moves)</strong>，从而引入了<strong>先手优势 (First-mover Advantage)</strong> 的概念。</p>
<h4 id="1-与古诺模型的根本区别"><a href="#1-与古诺模型的根本区别" class="headerlink" title="1. 与古诺模型的根本区别"></a>1. 与古诺模型的根本区别</h4><ul>
<li><strong>古诺模型</strong>：两家厂商<strong>同时</strong>决定产量，谁也不知道对方会生产多少，是一个静态的、猜对手心思的博弈。</li>
<li><strong>斯塔克尔伯格模型</strong>：两家厂商有明确的行动顺序。一家是“领导者”（先动），另一家是“跟随者”（后动）。领导者率先公布自己的产量，跟随者在<strong>观察到</strong>领导者的产量后再决定自己的最优产量。这是一个动态博弈。</li>
</ul>
<h4 id="2-如何求解？——-逆向归纳法-Backward-Induction"><a href="#2-如何求解？——-逆向归纳法-Backward-Induction" class="headerlink" title="2. 如何求解？—— 逆向归纳法 (Backward Induction)"></a>2. 如何求解？—— 逆向归纳法 (Backward Induction)</h4><p>对于这种有先后顺序的博弈，标准的解法是“逆向归纳”，即从后往前推。</p>
<p><strong>第一步：求解跟随者（厂商2）的问题</strong></p>
<p>我们先站在厂商2的角度。此时，厂商1的产量 q1 已经确定，是一个已知的数字。厂商2的目标是选择自己的产量 q2 来最大化自身利润 u2。</p>
<p>q2max u2(q1,q2)=q2(a−q1−q2)−cq2</p>
<p>为了求最大值，我们对 q2 求导并令其为0：</p>
<p>∂q2∂u2=a−q1−2q2−c=0</p>
<p>解出 q2，我们就得到了厂商2的反应函数 (Reaction Function)：</p>
<p>q2∗(q1)=2a−c−q1</p>
<p>这个函数告诉我们：不论领导者厂商1生产多少 (q1)，跟随者厂商2的最优应对策略是什么。</p>
<p><strong>第二步：求解领导者（厂商1）的问题</strong></p>
<p>厂商1非常“聪明”，它完全知道厂商2会如何根据它的 q1 来做出反应。因此，厂商1在做决策时，会把厂商2的反应函数直接代入自己的利润公式中，以此来预测自己选择不同 q1 的最终后果。</p>
<p>厂商1的利润函数变为：</p>
<p>u1(q1)=q1(a−q1−q2∗(q1))−cq1=q1(a−q1−2a−c−q1)−cq1</p>
<p>化简括号内的部分：</p>
<p>u1(q1)=q1(2a−c−q1)−cq1=2aq1−cq1−q12−cq1</p>
<p>厂商1的目标是选择 q1 来最大化这个新的利润函数。我们对 q1 求导并令其为0：</p>
<p>∂q1∂u1=2a−c−2q1=0⟹a−c−2q1=0</p>
<p>解出领导者厂商1的最优产量：</p>
<p>q1∗=2a−c</p>
<p><strong>第三步：得出最终均衡结果</strong></p>
<p>将厂商1的最优产量代入厂商2的反应函数，得到厂商2的产量：</p>
<p>q2∗=2a−c−q1∗=2a−c−(a−c)/2=2(a−c)/2=4a−c</p>
<p><strong>斯塔克尔伯格均衡解为：(领导者产量 q1∗=2a−c， 跟随者产量 q2∗=4a−c)</strong></p>
<h4 id="3-先手优势"><a href="#3-先手优势" class="headerlink" title="3. 先手优势"></a>3. 先手优势</h4><ul>
<li>在斯塔克尔伯格均衡中，领导者产量(2a−c)是跟随者(4a−c)的两倍。</li>
<li>我们可以对比一下古诺均衡的结果：在古诺模型中，两家厂商的产量相同，均为 3a−c。</li>
<li>比较可知：q1Stackelberg(2a−c)&gt;qCournot(3a−c)&gt;q2Stackelberg(4a−c)。</li>
<li>这意味着，通过率先行动并承诺一个较高的产量，领导者可以有效地“挤压”跟随者的市场空间，迫使跟随者选择一个较低的产量，从而为自己攫取更高的市场份额和利润。这就是<strong>先手优势</strong>的体现。</li>
</ul>
<p><img src="image-20250624233936853.png" alt="3-2"></p>
<p><strong>零和博弈 (Zero-Sum Games)</strong></p>
<p>极小化极大定理 (Minimax Theorem) (约翰·冯·诺伊曼, 1928):</p>
<p>对于每一个具有有限个纯策略的两人零和博弈，都存在一个适用于各方参与者的混合策略和一个价值 V，使得：</p>
<ul>
<li>给定参与者2的策略，参与者1可能获得的最佳支付为 V。</li>
<li>给定参与者1的策略，参与者2可能获得的最佳支付为 -V。</li>
</ul>
<p>策略存在的部分是<strong>纳什定理的一个特例</strong>，也是其先驱。</p>
<p>这基本上是说，参与者1可以保证自己获得<strong>至少 V</strong> 的支付，而参与者2可以保证自己获得<strong>至少 -V</strong> 的支付。如果双方都采取最优策略，这恰好就是他们将得到的结果。</p>
<p>它之所以被称为“极小化极大 (minimax)”，是因为参与者是通过一种试图<strong>最小化 (minimize) 对手可能获得的最大 (maximum) 支付</strong>的策略来获得这个价值的。我们稍后会再回到这一点。</p>
<p><strong>定义</strong>：价值 V 被称为该博弈的<strong>价值 (value)</strong>（或回报、支付）。</p>
<p><strong>例如</strong>：石头剪刀布的价值是0；假设参与者2采取最优策略（以1/3的概率出每一种手势），参与者1能期望获得的最好结果是0的支付。</p>
<hr>
<p>这张幻灯片介绍了博弈论的奠基性概念之一——<strong>两人零和博弈</strong>，以及该领域第一个里程碑式的定理——冯·诺伊曼的<strong>极小化极大定理</strong>。</p>
<h4 id="1-什么是零和博弈？"><a href="#1-什么是零和博弈？" class="headerlink" title="1. 什么是零和博弈？"></a>1. 什么是零和博弈？</h4><p>首先，零和博弈指的是在一个博弈中，所有参与者的收益（或亏损）加起来永远等于零。这意味着，<strong>一方的所得，必然是另一方的所失</strong>。这是一个纯粹冲突、完全竞争的模型，没有任何合作共赢的可能。经典的例子包括：</p>
<ul>
<li><strong>棋类游戏</strong>：如象棋、围棋，一方赢就是另一方输。</li>
<li><strong>石头剪刀布</strong>：一方赢一分，另一方就输一分。</li>
<li><strong>竞技体育</strong>：大多数只有两方对阵的比赛。</li>
</ul>
<h4 id="2-“极小化极大”定理的通俗解释"><a href="#2-“极小化极大”定理的通俗解释" class="headerlink" title="2. “极小化极大”定理的通俗解释"></a>2. “极小化极大”定理的通俗解释</h4><p>这个定理解决了一个核心问题：在这样你死我活的纯冲突中，“理性”的策略是什么？冯·诺伊曼给出了一个天才的答案，其思考逻辑如下：</p>
<p><strong>从参与者1（P1）的角度（最大化最小值, Maximin）</strong>：</p>
<ol>
<li>P1必须假设P2是完全理性的，并且会尽一切努力损害P1的利益。</li>
<li>P1会思考：“对于我可能采取的每一个策略，P2都会用对我最不利的方式来回应。我先列出每一种策略下，我最坏会得到什么结果（我的<strong>最小</strong>收益）。”</li>
<li>“然后，在所有这些‘最坏结果’中，我选择那个能让我得到最好结果的策略。”</li>
<li>这个过程，就是<strong>最大化自己的最小保证收益 (Maximize a minimum payoff)</strong>，简称 <strong>Maximin</strong>。</li>
</ol>
<p><strong>从参与者2（P2）的角度（极小化极大, Minimax）</strong>：</p>
<ol>
<li>P2同样假设P1会尽全力损害自己。</li>
<li>P2会思考：“对于P1的每一个策略，我最坏会损失多少（即P1能获得的最大收益）？”</li>
<li>“然后，我选择一个策略，能让P1可能获得的最大收益变得最小。”</li>
<li>这个过程，就是<strong>最小化自己的最大可能损失 (Minimize a maximum loss)</strong>，简称 <strong>Minimax</strong>。</li>
</ol>
<p><strong>定理的“奇迹”</strong>：冯·诺伊曼证明，对于任何两人零和博弈，P1通过“最大化最小值”策略能保证得到的收益 <code>V</code>，与P2通过“极小化极大”策略能保证让P1得到的收益 <code>V</code>，是<strong>完全同一个数值</strong>！这个 <code>V</code> 就是该博弈的“价值”。</p>
<p>这意味着，这类纯冲突博弈存在一个绝对理性的、稳定的解。双方的最佳策略将会在这个点上交汇。</p>
<h4 id="3-混合策略的重要性"><a href="#3-混合策略的重要性" class="headerlink" title="3. 混合策略的重要性"></a>3. 混合策略的重要性</h4><p>这个定理的成立，往往需要<strong>混合策略</strong>的引入，即以一定的概率随机地选择不同的行动。</p>
<ul>
<li>以“石头剪刀布”为例，如果你只出“石头”（一个纯策略），对手会立刻发现并一直出“布”来打败你。</li>
<li>你唯一能保证自己不输的策略，就是完全随机地出招（石头、剪刀、布各1/3概率）。</li>
<li>当你的对手也采取这种最优的混合策略时，你期望的平均收益就是0。因此，这个博弈的价值 <code>V=0</code>。</li>
</ul>
<p><img src="image-20250625000231647.png" alt="3-3"></p>
<p><strong>计算纳什均衡：两人零和博弈 (Computing Nash Equilibria: 2-person, Zero-Sum Games)</strong></p>
<ul>
<li>这个博弈没有纯策略纳什均衡。</li>
<li>根据纳什定理，它必然拥有一个<strong>混合策略</strong>纳什均衡。</li>
<li>我们该如何找到它呢？</li>
</ul>
<p><em>(注：这是一个两人零和博弈)</em></p>
<hr>
<p>这张幻灯片提出了一个核心问题：对于一个没有纯策略均衡的博弈，我们如何具体计算出它的混合策略纳什均衡？</p>
<p>下面是详细的计算步骤：</p>
<h4 id="第一步：验证不存在纯策略纳什均衡"><a href="#第一步：验证不存在纯策略纳什均衡" class="headerlink" title="第一步：验证不存在纯策略纳什均衡"></a>第一步：验证不存在纯策略纳什均衡</h4><p>我们可以通过“划线法”或“最优反应法”来快速验证。</p>
<ol>
<li>如果参与者2选择“列1”，参与者1的最优选择是“行2”（因为收益 +3 &gt; -2）。</li>
<li>如果参与者2选择“列2”，参与者1的最优选择是“行1”（因为收益 +3 &gt; -4）。</li>
<li>如果参与者1选择“行1”，参与者2的最优选择是“列1”（因为收益 +2 &gt; -3）。</li>
<li>如果参与者1选择“行2”，参与者2的最优选择是“列2”（因为收益 +4 &gt; -3）。</li>
</ol>
<p>我们发现，没有任何一个单元格是双方共同的最优选择，因此该博弈确实没有纯策略纳什均衡。</p>
<h4 id="第二步：设定混合策略"><a href="#第二步：设定混合策略" class="headerlink" title="第二步：设定混合策略"></a>第二步：设定混合策略</h4><p>在混合策略均衡中，核心思想是<strong>“无差异原则” (Indifference Principle)</strong>：每个参与者选择自己的混合策略（即概率），目的是让<strong>对方</strong>在自己的几个纯策略选择之间感到<strong>无所谓/无差异</strong>（即期望收益完全相等）。</p>
<ul>
<li>我们假设<strong>参与者1</strong>以概率 <strong>p</strong> 选择“行1”，以概率 <strong>(1-p)</strong> 选择“行2”。</li>
<li>我们假设<strong>参与者2</strong>以概率 <strong>q</strong> 选择“列1”，以概率 <strong>(1-q)</strong> 选择“列2”。</li>
</ul>
<h4 id="第三步：计算参与者1的混合策略-p"><a href="#第三步：计算参与者1的混合策略-p" class="headerlink" title="第三步：计算参与者1的混合策略 p"></a>第三步：计算参与者1的混合策略 p</h4><p>为了让<strong>参与者2</strong>感到无差异，参与者2选择“列1”的期望收益必须等于他选择“列2”的期望收益。</p>
<ul>
<li>参与者2选择“列1”的期望收益 E(列1) = p<em>(+2)+(1−p)</em>(−3)</li>
<li>参与者2选择“列2”的期望收益 E(列2) = p<em>(−3)+(1−p)</em>(+4)</li>
</ul>
<p>令 E(列1) = E(列2):</p>
<p>可得p=7/12</p>
<p>所以，参与者1的最优策略是：以 7/12 的概率选择“行1”，以 5/12 的概率选择“行2”。</p>
<h4 id="第四步：计算参与者2的混合策略-q"><a href="#第四步：计算参与者2的混合策略-q" class="headerlink" title="第四步：计算参与者2的混合策略 q"></a>第四步：计算参与者2的混合策略 q</h4><p>同样，为了让<strong>参与者1</strong>感到无差异，参与者1选择“行1”的期望收益必须等于他选择“行2”的期望收益。</p>
<ul>
<li>参与者1选择“行1”的期望收益 E(行1) = q<em>(−2)+(1−q)</em>(+3)</li>
<li>参与者1选择“行2”的期望收益 E(行2) = q<em>(+3)+(1−q)</em>(−4)</li>
</ul>
<p>令 E(行1) = E(行2):</p>
<p>q=7/12</p>
<p>所以，参与者2的最优策略是：以 7/12 的概率选择“列1”，以 5/12 的概率选择“列2”。</p>
<h4 id="第五步：结论与博弈的价值"><a href="#第五步：结论与博弈的价值" class="headerlink" title="第五步：结论与博弈的价值"></a>第五步：结论与博弈的价值</h4><ol>
<li><p><strong>混合策略纳什均衡</strong>：该博弈的唯一纳什均衡是：参与者1采取混合策略 ( 7/12 ,5/12)，参与者2采取混合策略 (7/12 ,5/12)。</p>
</li>
<li><p>博弈的价值 (Value of the Game)：在均衡状态下，参与者1的期望收益是多少？我们可以把 q = 7/12 代入 E(行1) 的公式中计算：</p>
<p>E(P1) = 1/12</p>
<p>因此，这个博弈对参与者1的<strong>价值是 +1/12</strong>，对参与者2的价值是 -1/12。这意味着，如果双方都采取最优的随机策略，长期来看，参与者1平均每次能赢1/12。</p>
</li>
</ol>
<p><strong>为什么目的是让对方在自己的几个纯策略选择之间感到无所谓/无差异？</strong></p>
<p>简单来说，<strong>让对方“无差异”并不是我们的最终目的，而是我们为了实现自身利益最大化，所必须达到的一个“结果”或“条件”。</strong></p>
<p>这是一种非常高明的策略思想，我们可以从三个层面来理解它：</p>
<hr>
<h3 id="1-核心思想：消除对方的确定性最优解"><a href="#1-核心思想：消除对方的确定性最优解" class="headerlink" title="1. 核心思想：消除对方的确定性最优解"></a>1. 核心思想：消除对方的确定性最优解</h3><p>在一个博弈中，如果你采取的策略让你的对手有一个明确的、唯一的“最优选择”，那你就输了一半。因为：</p>
<ol>
<li>一个理性的对手，一定会采取那个对他来说最优的选择。</li>
<li>这样一来，对手的行动就变得<strong>完全可以预测</strong>了。</li>
<li>一旦对手的行动是可预测的，你就可以反过来调整自己的策略，去专门“克制”他那个可预测的行动，从而让自己获利更多。</li>
<li>但这就产生了一个矛盾：如果你能调整策略获利更多，说明你最初的策略就不是最优的。</li>
</ol>
<p>这个矛盾循环说明，一个稳定的均衡状态，不应该让任何一方有“唯一的、确定的”最优解。而要做到这一点，你唯一的方法就是调整自己的策略组合（即概率 <code>p</code>），直到你的对手觉得“选A或选B，反正期望收益都一样，我无所谓了”。</p>
<p><strong>当你让对手“无所谓”时，你就消除了他行动的确定性，他才不得不也用一种随机的方式来对抗你。这才是对自己最有利的局面。</strong></p>
<hr>
<h3 id="2-反向思考：如果不让对方无差异会怎样？"><a href="#2-反向思考：如果不让对方无差异会怎样？" class="headerlink" title="2. 反向思考：如果不让对方无差异会怎样？"></a>2. 反向思考：如果不让对方无差异会怎样？</h3><p>我们用上一张幻灯片的例子来思考：</p>
<ul>
<li>你的策略是：以概率 <code>p</code> 出“行1”，概率 <code>(1-p)</code> 出“行2”。</li>
<li>假设你选择的 <code>p</code> 没有让对手无差异，而是让对手觉得<strong>“出‘列1’比出‘列2’的期望收益更高”</strong>。</li>
</ul>
<p>接下来会发生什么？</p>
<ol>
<li><strong>对手的反应</strong>：理性的对手会想：“既然出‘列1’更好，我为什么还要费事去随机出‘列2’呢？” 于是，他会100%地出“列1”。他的策略就不再是混合策略了。</li>
<li><strong>你的反应</strong>：你看到对手只会出“列1”，那你还会坚持你原来的概率 <code>p</code> 吗？当然不会！你会看支付矩阵的“列1”那一栏，发现你出“行1”收益是-2，出“行2”收益是+3。你显然会100%地出“行2”来应对他。</li>
</ol>
<p><strong>结论</strong>：你最初那个让对手“有差异”的策略 <code>p</code>，最终导致了你自己也想改变策略。这就说明，那个初始状态<strong>根本不稳定</strong>，因此<strong>不是纳什均衡</strong>。</p>
<p>唯一的稳定状态，就是你选择的概率 <code>p</code>，正好让对手觉得“出‘列1’和出‘列2’没差”，他没有理由偏向任何一方，所以他才愿意继续以一定概率 <code>q</code> 来混合他的策略。</p>
<hr>
<h3 id="3-一个直观的例子：点球大战"><a href="#3-一个直观的例子：点球大战" class="headerlink" title="3. 一个直观的例子：点球大战"></a>3. 一个直观的例子：点球大战</h3><p>想象一下足球比赛中的点球大战：</p>
<ul>
<li><strong>你的角色</strong>：踢球手。你可以选择踢左边或右边。</li>
<li><strong>对手的角色</strong>：守门员。他可以选择扑左边或右边。</li>
</ul>
<p>你的目标是什么？是让守门员<strong>对于“扑左还是扑右”感到无差异</strong>。</p>
<ul>
<li><strong>为什么？</strong> 如果你总喜欢踢左边（比如70%的概率），守门员就会发现这个规律，然后更倾向于扑向左边，这样你的进球率就会下降。你的行为变得“可预测”了。</li>
<li><strong>你的最优策略</strong>：你必须调整自己踢左边和右边的概率（比如各50%），使得守门员觉得“反正我扑左扑右，猜对的概率都一样，期望丢球数也一样，我无所谓了，只能瞎猜”。</li>
<li><strong>最终结果</strong>：只有当你成功地让守门员陷入“无所谓”的境地时，他才无法预测你的行动，你才能最大化你的进球率。</li>
</ul>
<p><strong>总结：</strong></p>
<p>在混合策略中，让对方“无所谓”，并不是一种善意的妥协，而是一种<strong>最顶级的进攻策略</strong>。它本质上是：</p>
<ul>
<li><strong>为了防止自己被预测和被针对。</strong></li>
<li><strong>为了迫使对方也必须采取不确定的、随机的策略来应对。</strong></li>
<li><strong>为了最终能在一个充满不确定性的稳定均衡中，保障自己获得最大化的期望收益。</strong></li>
</ul>
<p>所以，“让对方无差异”是<strong>你</strong>实现最优策略的<strong>必要条件</strong>，而不是你的目的本身。</p>
<h2 id="3-2-极大极小博弈"><a href="#3-2-极大极小博弈" class="headerlink" title="3.2 极大极小博弈"></a>3.2 极大极小博弈</h2><p><img src="image-20250625213116525.png" alt="3-4"></p>
<p>这张幻灯片用一个政治竞选的例子，构建了一个经典的两人零和博弈。它给出了问题设定，但没有给出解。核心任务就是根据这些信息，计算出这场博弈的均衡解以及博弈的价值。</p>
<h4 id="第一步：检查是否存在纯策略均衡"><a href="#第一步：检查是否存在纯策略均衡" class="headerlink" title="第一步：检查是否存在纯策略均衡"></a>第一步：检查是否存在纯策略均衡</h4><p>我们首先检查是否存在一个稳定的单元格，使得任何一方都不想单方面改变策略。</p>
<ol>
<li>如果列玩家（候选人2）选择“道德”，行玩家（候选人1）会选择“经济”（因为收益3 &gt; -2）。</li>
<li>如果列玩家选择“减税”，行玩家会选择“社会”（因为收益1 &gt; -1）。</li>
<li>如果行玩家选择“经济”，列玩家会选择“减税”（因为收益1 &gt; -3）。</li>
<li>如果行玩家选择“社会”，列玩家会选择“道德”（因为收益2 &gt; -1）。</li>
</ol>
<p>我们发现，不存在任何一个稳定的策略组合。例如，在（经济, 道德）这个组合，行玩家很满意，但列玩家会想换到“减税”策略以获得更好的收益。因此，<strong>该博弈没有纯策略纳什均衡</strong>。我们必须寻找混合策略均衡。</p>
<h4 id="第二步：计算混合策略纳什均衡"><a href="#第二步：计算混合策略纳什均衡" class="headerlink" title="第二步：计算混合策略纳什均衡"></a>第二步：计算混合策略纳什均衡</h4><p>我们将使用<strong>无差异原则</strong>来求解。</p>
<ul>
<li>设行玩家（候选人1）以概率 <strong>x</strong> 选择“经济”，以概率 <strong>(1-x)</strong> 选择“社会”。</li>
<li>设列玩家（候选人2）以概率 <strong>y</strong> 选择“道德”，以概率 <strong>(1-y)</strong> 选择“减税”。</li>
</ul>
<p><strong>A. 计算行玩家的策略 x</strong></p>
<p>行玩家需要选择一个概率 <code>x</code>，使得列玩家对于选择“道德”还是“减税”感到<strong>无差异</strong>（期望收益相等）。</p>
<ul>
<li>列玩家选择“道德”的期望收益 = x⋅(−3)+(1−x)⋅(2)</li>
<li>列玩家选择“减税”的期望收益 = x⋅(1)+(1−x)⋅(−1)</li>
</ul>
<p>令二者相等：</p>
<script type="math/tex; mode=display">-3x + 2 - 2x =  - 1 + x$$$$2 - 5x = 2x - 1$$$$3 = 7x$$x=73

所以，**候选人1的最优策略**是：以 **3/7** 的概率主打“经济”议题，以 **4/7** 的概率主打“社会”议题。

**B. 计算列玩家的策略 y**

同样，列玩家需要选择一个概率 `y`，使得行玩家对于选择“经济”还是“社会”感到**无差异**。

- 行玩家选择“经济”的期望收益 = y⋅(3)+(1−y)⋅(−1)
- 行玩家选择“社会”的期望收益 = y⋅(−2)+(1−y)⋅(1)

令二者相等：

$$3y - 1 + y = -2y + 1 - y$$$$4y - 1 = 1 - 3y$$$$7y = 2$$y=72

所以，**候选人2的最优策略**是：以 **2/7** 的概率主打“道德”议题，以 **5/7** 的概率主打“减税”议题。

#### 第三步：计算博弈的价值

博弈的价值（Value）就是指在双方都采取最优策略时，行玩家的期望收益。我们可以将 y = 2/7 代入行玩家的任一期望收益公式：

V=3y−1+y=4y−1=4⋅(72)−1=78−1=71

#### 结论

- **纳什均衡**：该博弈的唯一纳什均衡是，候选人1采取混合策略 (73,74)，候选人2采取混合策略 (72,75)。这意味着两位候选人都应该以特定的概率随机选择自己的竞选焦点，让对手无法预测。
- **博弈价值**：该博弈对行玩家（候选人1）的价值是 **+1/7**。在竞选这个议题上，如果双方都采取最理性的策略，**候选人1平均可以期望净赚 1/7 百万（约14万）的选民**。这表明在这个特定的战略矩阵中，候选人1拥有微弱的优势。

![3-5](image-20250625214139041.png)

备注：下面这段话有提到“这代表了**列玩家的理性反应**。由于这是一个零和博弈，列玩家的目标是让行玩家的收益尽可能小。”，结合上面一张PPT的最后一个恒等式，可知，由于这是零和博弈，行玩家收益最少等价于列玩家收益最大。

------



这张幻灯片从一个更形式化、更根本的角度，展示了作为“领导者”（被迫先宣布策略的一方）应该如何思考，并将这个问题转化为了一个标准的数学优化问题。最终，它揭示了一个关于零和博弈的深刻结论。

#### 1. Maximin 公式解读：“在最坏的情况里做到最好”

幻灯片给出的第一个公式 

maxmin(3x1−2x2,−x1+x2)

 是“最大化最小值 (Maximin)”思想的完美数学体现。我们来拆解它：

- **内部的两个表达式**：
  - 3x1−2x2：这是当列玩家选择“道德”时，行玩家的期望收益。
  - −x1+x2：这是当列玩家选择“减税”时，行玩家的期望收益。
- **min(...) 部分**：这代表了**列玩家的理性反应**。由于这是一个零和博弈，列玩家的目标是让行玩家的收益尽可能小。所以，当行玩家宣布了一个策略 (x1,x2) 后，列玩家会审视这两个可能的收益，并选择那个能让行玩家收益**更小 (min)** 的策略来应对。这代表了行玩家在宣布策略 (x1,x2) 后，所能得到的**最坏结果保证**。
- **max(...) 部分**：这代表了**行玩家的决策**。行玩家知道对手会这样针对他。所以，他在选择自己的策略 (x1,x2) 时，目标就是让这个“最坏的结果保证”变得尽可能好。也就是要**最大化 (max)** 那个最小的收益。

这整个公式的逻辑就是：“我（行玩家）要选择一个策略 (x1,x2)，来最大化‘在我宣布这个策略后，对手尽最大努力打压我，我能得到的那个保底收益’”。

#### 2. 线性规划的转换：从博弈论到标准数学优化

Max-min 问题在数学上直接求解不方便，但可以非常巧妙地转化为一个标准的**线性规划 (Linear Programming, LP)** 问题。

- 我们引入一个新变量 `z`，让它代表那个“保底收益”。
- 我们的目标是 `最大化 z`。
- 约束条件是什么？`z` 必须小于等于所有可能的结果。所以：
  - z≤3x1−2x2  (保底收益不能超过对手选“道德”时我的收益)
  - z≤−x1+x2  (保底收益不能超过对手选“减税”时我的收益)
- 再加上概率本身的基本约束 x1+x2=1 和 x1,x2≥0。

这样，我们就把一个博弈问题，变成了一个可以用标准算法（如单纯形法）求解的数学问题。

#### 3. 最终结论：结果与之前完全相同！

幻灯片最后指出，解这个线性规划得到的结果是 x1=3/7，x2=4/7，并且最优的保底收益 z=1/7。

这正是我们之前用“无差异原则”为**同时博弈**计算出的**纳什均衡解**和**博弈价值 V**！

为什么会这样？

这并非巧合，而是冯·诺伊曼极小化极大定理 (Minimax Theorem) 的直接体现。该定理的核心是：

Maximin=Minimax

- 我们这张幻灯片求解的“领导者-跟随者”问题，正是行玩家的 **Maximin（最大化最小值）** 问题。
- 我们之前求解的“同时博弈”问题，得到的是**Minimax（极小化极大值）** 均衡解。

这个定理保证了，在任何两人零和博弈中，这两个值是相等的。这意味着，**在两人零和博弈中，不存在先手优势或后手优势**。你提前公布策略，虽然给了对方信息，但你也可以利用这一点来选择一个最稳妥的策略；对方虽然能看到你的策略，但也只能在你设定的框架内做出反应。最终双方的力量会完美抵消，达到同一个均衡结果。

## 3.3 纳什均衡的线性规划解法

![3-6](image-20250625215726625.png)

这张幻灯片介绍了一个在线性规划乃至整个优化理论中，都极具美感和威力的核心概念——**对偶性**。它揭示了每个优化问题都存在一个“影子问题”或“镜像问题”，而理解这个镜像能为我们提供关于原问题全新的、深刻的洞察。

#### 1. 什么是对偶性？一个直观的例子

要理解对偶，与其陷入复杂的数学转换，不如看一个经济学例子：

- **原问题 (Primal Problem)**：
  - 想象你是一家工厂的老板，你要决定生产多少桌子和椅子，来**最大化你的总利润**。
  - 你面临一些**约束**：你拥有的木材、劳动力、设备时间都是有限的。
  - 这就是一个典型的线性规划问题：最大化一个目标（利润），同时满足一系列约束（资源）。
- **对偶问题 (Dual Problem)**：
  - 现在，想象一个商人想来收购你所有的资源（木材、劳动力、设备）。他想**最小化他的收购总成本**。
  - 但他面临一个**约束**：他为每种资源开出的“影子价格”组合，必须能让你觉得“卖掉资源比我自己生产产品更划算”。例如，生产一张桌子需要消耗的资源，他打包收购的价格，必须不能低于你自己生产这张桌子能获得的利润。
  - 这个商人的问题——在一定约束下最小化成本——就是你那个最大化利润问题的“对偶问题”。

#### 2. 对偶性的“魔力”：原问题与对偶问题的关系

对偶理论中有两个核心定理，它们揭示了原问题和对偶问题之间的奇妙关系：

1. **弱对偶定理 (Weak Duality)**：对偶问题的最优解，永远是原问题最优解的一个“界限”。在上面的例子里，就是说：商人收购资源的**最小成本**，必然**大于等于**工厂老板自己生产的**最大利润**。这很直观，因为如果收购成本低于你的利润，你肯定不会卖。

2. 强对偶定理 (Strong Duality)：在绝大多数情况下，这个“大于等于”实际上是**“完全等于”**！也就是说：

   工厂能实现的最大利润=商人收购资源的最小成本

   这是一个非常深刻的结论。它意味着，你资源的内在价值，恰好等于你能用它们创造的最大利润。对偶问题中的变量（资源的“影子价格”），精确地量化了每一种稀缺资源的边际价值。

#### 3. 对偶性与“零和博弈”的惊人联系

现在，我们可以把这个概念带回我们之前讨论的博弈论了。这正是引入对偶概念的关键所在。

- 在前几张幻灯片中，我们把**行玩家**的问题构建成了一个线性规划：**最大化**他的保底收益 `V`。这可以看作是我们的**原问题 (Primal)**。
- 那么，**列玩家**的问题是什么？列玩家的目标是**最小化**行玩家能获得的最大收益 `W`。我们同样可以把列玩家的这个问题也构建成一个线性规划。
- **最关键的结论是**：**列玩家的“最小化极大值”线性规划问题，恰好就是行玩家“最大化最小值”线性规划问题的对偶问题！**

因此，线性规划的“强对偶定理”（最大值 = 最小值），在零和博弈的语境下，就直接变成了冯·诺伊曼的“极小化极大定理”！

max(行玩家的保底收益)=min(列玩家的最大损失)Maximin=Minimax

**总结**：对偶性不仅是线性规划的强大工具，它还为博弈论的基石——极小化极大定理——提供了最坚实的数学证明。它优美地揭示了，一个参与者的最大化问题和其对手的最小化问题，实际上是同一个数学结构的两个不同侧面，如同一枚硬币的两面，其价值必然相等。

![3-7](image-20250625220404379.png)

线性规划对偶性实例。

![3-8](image-20250625220536283.png)

弱对偶性和强对偶性

## 3.4 线性互补问题

![3-9](image-20250625222636285.png)

**标题：计算两人一般和博弈的纳什均衡 (Computing Nash equilibria of two-player, general-sum games)**

- 不幸的是，寻找一个两人**一般和博弈 (general-sum game)** 的纳什均衡，**无法**被构建成一个线性规划问题。
  - — 两名参与者的利益不再是***完全\*对立的 (completely opposed)**。
  - — 然而，我们仍然可以将我们的问题表述为某种优化问题。

------

这张幻灯片标志着一个重要的转折点。从“零和博弈”进入了更普遍、也更复杂的“一般和博弈”（或称“非零和博弈”）的世界。幻灯片的核心信息是：之前强大而高效的线性规划（LP）工具，在这里失效了。

#### 1. 什么是一般和博弈？

一般和博弈指的是，在任何一个结果下，所有参与者的收益之和**不一定为零**。这意味着博弈的结果可以是双赢、双输，或者一方赢多、一方输少。参与者的关系不再是“你死我活”的纯粹冲突，而是**冲突与合作并存**。

- 经典例子1：囚徒困境

  如果两个囚犯都背叛对方，他们可能各判5年（总收益-10）。如果他们都保持沉默，可能各判1年（总收益-2）。这是一个双输的“负和”博弈。

- 经典例子2：性别大战 (Battle of the Sexes)

  一对情侣都想待在一起（合作），但一人想看歌剧，另一人想看球赛（冲突）。如果他们去同一个地方，双方都能获得高收益（比如（5,2）或（2,5）），总收益为7。如果去不同地方，则两人都很不开心（0,0），总收益为0。这是一个“正和”博弈。

#### 2. 为什么线性规划会失效？—— 对偶性的崩塌

这是理解这张幻灯片最关键的地方。线性规划之所以能在零和博弈中大显神威，是因为其背后优美的“对偶性”，而这种对偶性源于双方利益的**完全对立**。

- **在零和博弈中**：
  - 行玩家的目标是：最大化自己的收益 `u₁`。
  - 列玩家的目标是：最大化自己的收益 `u₂`。
  - 由于 `u₂ = -u₁`，所以列玩家“最大化`u₂`”就**等价于**“最小化`u₁`”。
  - 因此，行玩家的“最大化最小值 (Maximin)”问题和列玩家的“最小化极大值 (Minimax)”问题，形成了一对完美的数学**对偶**。它们就像一枚硬币的两面，可以用同一个线性规划框架来解决。
- **在一般和博弈中**：
  - `u₂` 不再等于 `-u₁`。
  - 列玩家的目标——最大化他自己的 `u₂`——与行玩家的收益 `u₁` **没有直接的、负相关的关系**。
  - 列玩家不再是处心积虑地要让行玩家的收益最小化，他只关心自己的收益。
  - 这样一来，那种“我之所得即你之所失”的完美对偶关系就**彻底崩塌**了。我们无法再构建出一个单一的线性规划问题来同时描述双方的决策并找到那个共同的解。

#### 3. 那问题变成了什么？

虽然不能用线性规划，但寻找纳什均衡依然是一个数学优化问题，只是变得更复杂了。

- 寻找两人一般和博弈的纳什均衡，在数学上等价于求解一个**线性互补问题 (Linear Complementarity Problem, LCP)**。这是一个比线性规划更复杂的数学结构。
- 从计算复杂性的角度看，求解两人零和博弈是“容易”的（属于 **P** 问题），而求解两人一般和博弈则被证明是**PPAD-完全 (PPAD-complete)** 问题。这通常被认为是一个“更难”的计算等级，意味着找到解需要更复杂的算法，计算效率也更低。

**总结**：从“零和”到“一般和”的转变，是博弈论中一次巨大的复杂性飞跃。它让我们失去了线性规划这个简洁高效的工具，迫使我们进入一个更困难的计算领域。这也反过来凸显了两人零和博弈及其“极小化极大定理”在理论上的简洁与优美。

![3-10](image-20250625223646101.png)

**标题：计算两人一般和博弈的纳什均衡**

- 我们首先考虑一个**内部的 (inner)** 或**完全混合的 (totally mixed)** 纳什均衡 (X∗,Y∗)，即对于所有的 i 和 j，都有 xi∗>0 以及 yj∗>0（所有的纯策略都以正概率被使用）。

- 让 ai 表示行玩家的支付矩阵A的各行，让 bj 表示列玩家的支付矩阵B的各列。

- 利用“**在一个纳什均衡策略的支持集(support)中，所有纯策略都产生相同的支付**”这一事实，并且该支付大于或等于支持集之外的策略的支付，我们得到：

  - aiy∗=aky∗,i,k=1,2,…,m.

  - (x∗)Tbj=(x∗)Tbk,j,k=1,2,…,n.

    (注：此处公式经过订正以符合标准表达)

    (绿色文字) 假设每个纯策略都以正概率被使用。

- 上述构成了一个可以被高效求解的线性方程组。

#### **下图内容**

- 然而，“每个策略都以正概率被使用”的假设是有限制性的。大多数博弈并不拥有完全混合的纳什均衡；对于它们而言：

- 我们计算一个有限两人博弈的所有纳什均衡：

  一个混合策略组合 (x∗,y∗) 是一个具有支持集 S1,S2 的纳什均衡，当且仅当：

  - u=aiy∗,∀i∈S1 （对于支持集内的策略i，收益都等于均衡收益u）
  - u≥aiy∗,∀i∈/S1 （对于支持集外的策略i，收益不高于u）
  - v=(x∗)Tbj,∀j∈S2 （对于支持集内的策略j，收益都等于均衡收益v）
  - v≥(x∗)Tbj,∀j∈/S2 （对于支持集外的策略j，收益不高于v）
  - xi∗=0,∀i∈/S1, yj∗=0,∀j∈/S2  （u, v 是NE中的收益值）

- 要让上述过程可行，我们需要找到正确的**支持集 (supports)**。我们需要遍历所有可能的支持集组合。由于存在 2n+2m 种不同的支持集，这会导致算法具有指数级的复杂度。

- **备注 (Remark)**：计算有限博弈的纳什均衡的**计算复杂度**，就在于**找到正确的支持集**。

------

这两张幻灯片讲述了一个关于“求解一般和博弈”的完整故事：从一个理想化的、简单的特例，到一个普遍的、困难的现实。

#### 1. 理想情况：完全混合均衡（上图）

幻灯片的上半部分描绘了一种“完美”的均衡状态，即**完全混合均衡**。在这种均衡里，每一个参与者都认为对手的所有可选策略都值得提防，因此自己的最优策略是给自己的每一个选项都分配一个**大于零**的概率。

- 为什么这种情况简单？

  因为它使得“无差异原则”可以应用到所有策略上。为了让对手混合他的所有策略，你必须让你的对手在选择他的任何一个策略时，期望收益都完全相等。

- 如何求解？

  这就产生了一个完整的线性方程组（m-1个关于行玩家收益的等式，n-1个关于列玩家收益的等式，再加上两个概率和为1的等式）。这是一个标准的、可以用我们熟悉的方法高效求解的数学问题。

然而，这种所有策略都被用上的“雨露均沾”式的均衡，在现实中非常罕见。

#### 2. 现实情况：寻找“支持集”（下图）

幻灯片的下半部分指出了残酷的现实：在绝大多数博弈中，通常都会有一些策略是“劣势策略”或“糟糕的选项”，一个理性的玩家是永远不会使用它们的（即使用概率为0）。

- **支持集 (Support)**：在一个混合策略中，那些**真正以正概率被使用的纯策略的集合**，被称为这个混合策略的“支持集”。
- **核心困难**：求解的关键困难在于，我们**事先并不知道**最终的均衡解中，到底哪些策略会是“优势策略”（在支持集里），哪些是“劣势策略”（在支持集外）。

这就引出了一个计算上的巨大难题，我喜欢称之为**“寻找嫌疑人”的困境**：

- **无差异原则**就像一个完美的“审讯工具”，只要你把正确的“嫌疑人”（支持集里的策略）找来，它就能告诉你每个人的详细“作案手法”（混合策略的精确概率）。
- **但问题是**，你不知道谁是真正的“嫌疑人”。你面对着所有可能的策略，不知道该把哪些策略纳入“无差异”的审讯中。

#### 3. “暴力搜索”算法及其指数级复杂度

理论上，我们可以用一种“暴力”的方法来找到所有均衡：

1. **猜测**：我们先猜一个可能的支持集组合。例如，“我猜行玩家只会用策略1和3，而列玩家只会用策略2和4”。
2. **求解**：基于这个猜测，我们建立一个只包含这些策略的线性方程组（即只让这些策略满足无差异原则）并求解。
3. **验证**：检查解出的结果是否是一个合法的纳什均衡。这包括两部分：
   - 解出的概率值是否都在0和1之间？
   - 对于那些我们**没猜**的“局外”策略，它们的期望收益是否真的**不优于**我们算出的均衡收益？（这是最关键的验证，确保没人想把局外策略拉进局内）。
4. **重复**：如果验证失败，就回到第一步，换一种支持集的猜测，然后重复整个过程，直到遍历完**所有可能的支持集组合**。

这个方法的致命缺陷在于，支持集的组合数量是**指数级增长**的。如果一个博弈双方各有20个策略，那么可能的支持集组合数量会是一个天文数字。这就是幻灯片所说的“指数级复杂度”。

**总结**：寻找一般和博弈的纳什均衡，其计算上的困难**不在于解方程**，而在于**找到应该用哪些策略来列方程**。这个“寻找正确支持集”的组合搜索过程，是该问题计算复杂度（PPAD-complete）的根源，也使其与可以通过线性规划轻松求解的两人零和博弈产生了本质的区别。

## 7.1 多智能体强化学习介绍及基本概念

![7-1](image-20250630205121221.png)

这张幻灯片指出了从单智能体学习（比如我们熟知的AlphaGo下围棋的早期版本）迈向多智能体学习（比如王者荣耀或星际争霸中的AI）时，所遇到的一个根本性的、质的困难。

#### 1. 核心困难：移动的靶心 (The Moving-Target Problem)

- **在单智能体学习中**：环境是**静止的**或有固定规律的。一个智能体（比如一个机器人）学习走路，它只需要掌握如何应对地板、墙壁等物理规律即可。这个“游戏规则”是不会变的。
- **在多智能体学习中**：情况发生了根本变化。对于任何一个智能体（我们称之为“我”）来说，**其他的智能体也是环境的一部分**。但问题是，这些“其他的智能体”本身也在学习、在进化、在改变他们的策略。
  - **一个生动的例子**：你学习如何开车上班最快。如果只有你一个人在学习，而其他人的路线每天都固定不变，这就是一个简单的单智能体问题。但现实是，成千上万的司机（其他智能体）每天也都在尝试新的路线来优化他们自己的通勤时间。你今天发现的“最优路线”，明天可能因为有几百个和你一样的人也发现了它而变得极度拥堵。
  - 你试图瞄准的那个“最优策略”的靶心，因为他人的学习而**不断地移动**。这就是多智能体学习的核心困难，学术上称为**“环境的非平稳性” (Non-stationarity)**。

#### 2. 为什么简单的Q学习会失效？

标准的单智能体强化学习算法（如Q学习）之所以能成功，是因为它们依赖于一个基本假设：**马尔可夫决策过程 (MDP)**，即环境是平稳的。这意味着，在同一个状态（State）下，采取同一个动作（Action），得到的奖励（Reward）和状态转移的概率应该是基本一致的。

但在多智能体环境中，这个假设被彻底打破了：

- **今天**：在路口（状态S），你选择直行（动作A），因为其他人都选择了右转，所以一路畅通，你获得了很高的奖励。你的Q表格会更新，认为`(S, A)`是个好选择。
- **明天**：在同一个路口（状态S），你根据昨天的经验再次选择直行（动作A）。但昨天和你一样选择直行的其他智能体也获得了高奖励，所以今天他们也选择直行。结果造成了交通堵塞，你得到了一个很低的奖励。你的Q表格又必须更新，认为`(S, A)`是个坏选择。

你的Q值会这样剧烈地来回震荡，可能永远无法收敛到一个稳定的策略，因为一个动作的“好”与“坏”不再是固定的，而是完全取决于其他智能体当前正在执行的策略。

#### 3. 与博弈论的联系

这个学习过程中的“不稳定”问题，正是我们在前面博弈论部分看到的“均衡”问题的动态体现。

- 多智能体学习的目标，往往就是让这群智能体通过学习和试错，最终能够收敛到整个博弈的**纳什均衡**。
- 幻灯片中的螺旋图可以这样理解：中心点是博弈的纳什均衡点。这条螺旋线代表了所有智能体的联合策略随着时间演变的轨迹。如果学习算法设计得好（例如，在**势博弈**中），这条轨迹就会像图中一样稳定地**收敛**到中心。
- 如果算法设计不当或者博弈本身就很“恶劣”（比如“石头剪刀布”），那么学习过程可能永远无法收敛，只会在策略空间中不停地“绕圈子”。

**总结**：多智能体学习的困难在于，每个智能体的学习过程都会改变其他智能体的学习环境，形成一个复杂且动态的“移动靶心”问题。简单地将单智能体算法直接套用，会因环境的“非平稳性”而失效。因此，现代多智能体学习研究的核心，就是设计出能够在这种动态博弈中稳定地学习、并最终收敛到纳什均衡等合理状态的算法。

![7-2](image-20250630205734872.png)

我们可以通过两个关键问题来区分这些模型：

1. **有几个决策者（智能体）？** 一个还是多个？
2. **有多少种情况（状态）？** 一种还是多种？

#### 1. 马尔可夫决策过程 (MDPs): 单人探索世界

- **特征**：**一个**智能体，**多个**状态。
- **核心问题**：一个独立的决策者，在一个可以变化的环境中，如何学习一系列的动作以最大化其长期回报。
- **通俗例子**：一个机器人学习走迷宫。机器人是**唯一的智能体**，迷宫中不同的位置就是**不同的状态**。机器人需要学习在每个位置（状态）下，应该朝哪个方向走（动作），才能最快找到出口（最大化回报）。
- **地位**：这是现代**单智能体强化学习 (Single-Agent Reinforcement Learning)** 的数学基石。我们熟知的AlphaGo下棋，本质上也可以看作是在一个极度复杂的MDP中寻找最优策略。

#### 2. 重复博弈 (Repeated Games): 多人重复同一场游戏

- **特征**：**多个**智能体，**一个**状态。
- **核心问题**：多个决策者，反复地玩**同一个**博弈。
- **通俗例子**：两家寡头公司，每个月都要决定自己的产品定价。每个月的定价博弈，其本身的收益矩阵都是一样的，所以可以看作是**单一状态**。但因为博弈是**重复**的，今天的决策会影响声誉，从而影响对手明天的决策。这就引入了如“以牙还牙 (Tit-for-Tat)”这样的动态策略。我们之前讨论的各种矩阵博弈（如囚徒困境、零和博弈），如果将它们连续玩很多次，就构成了重复博弈。

#### 3. 随机博弈 / 马尔可夫博弈 (Stochastic/Markov Games): 多人探索动态世界

- **特征**：**多个**智能体，**多个**状态。
- **核心问题**：多个决策者在一个动态变化的环境中共同决策，他们的联合行动会共同决定环境如何进入下一个状态。
- **通俗例子**：一场足球比赛。场上有**多个智能体**（双方队员）。球和所有队员在场上的位置，共同构成了一个**状态**。当大家做出动作（跑动、传球、射门）后，场上的局面会变成一个**新的状态**。在每个不同的状态下，球员们面临的“局部博弈”也是不同的。
- **地位**：这是最普适、最复杂的模型，它构成了**多智能体强化学习 (Multi-Agent Reinforcement Learning, MARL)** 的理论基础。

总结与联系：

这张图清晰地告诉我们，随机博弈是“集大成者”，它统一了另外两个模型：

- 当随机博弈的智能体数量减少到1个时，它就退化成了**MDP**。
- 当随机博弈的状态数量减少到1个时，它就退化成了**重复博弈**。

这与我们上一张幻灯片讨论的**“多智能体学习的困难”**完美地衔接了起来。我们所说的“环境的非平稳性”，正是因为我们身处**随机博弈**的框架中：对于“我”这个智能体而言，环境之所以看起来在不停变化，是因为环境的下一个状态不仅取决于我的行动，还取决于其他所有智能体的行动，而他们本身也在学习和改变。

![7-3](image-20250630214131295.png)

这张幻灯片提出了一个非常经典的任务：为任意一个 2x2 零和博弈找到通用的解法，即用矩阵中的参数 a,b,c,d 来表达博弈的价值和双方的最优策略。

我们将遵循幻灯片给出的两步计划来完成这个推导。

#### 步骤一：检验纯策略均衡（鞍点）

一个纯策略纳什均衡（在零和博弈中也称为“鞍点”）存在的条件是：**某一个收益值，既是其所在行的最小值，又是其所在列的最大值**。

我们可以通过比较行玩家的“最大化最小值（Maximin）”和列玩家的“最小化极大值（Minimax）”来判断：

- 行玩家的保底收益（最大最小值）: max(min(a,b),min(d,c))
- 列玩家的保底收益（最小极大值）: min(max(a,d),max(b,c))

如果这两个值相等，则存在纯策略均衡，该值就是博弈的价值。例如，如果 `a <= b` 并且 `a >= d`，那么 `a` 就是一个鞍点，（行1，列1）就是纯策略纳什均衡。

#### 步骤二：求解混合策略均衡（假设不存在鞍点）

如果不存在鞍点，那么双方的最优策略必然是混合策略。我们将使用**无差异原则**来求解。

- **策略设定**:

  - 行玩家以概率 **p** 选择“行1”，以概率 **(1-p)** 选择“行2”。
  - 列玩家以概率 **q** 选择“列1”，以概率 **(1-q)** 选择“列2”。

- 推导行玩家的策略 p:

  行玩家选择 p 的目的是让列玩家在“列1”和“列2”之间感到无差异。

  - 列玩家选择“列1”的期望收益（注意，要用列玩家的收益矩阵`-A`）：p(−a)+(1−p)(−d)

  - 列玩家选择“列2”的期望收益：p(−b)+(1−p)(−c)

    令二者相等：

    $$-ap - d(1-p) = -bp - c(1-p)$$$$-ap - d + dp = -bp - c + cp$$$$d - c = p(a - d - b + c) = p((a+c) - (b+d))</script><pre><code>解得行玩家的最优概率 p：

p∗=(a+c)−(b+d)d−c
</code></pre><ul>
<li><p>推导列玩家的策略 q:</p>
<p>列玩家选择 q 的目的是让行玩家在“行1”和“行2”之间感到无差异。</p>
<ul>
<li><p>行玩家选择“行1”的期望收益：q(a)+(1−q)(b)</p>
</li>
<li><p>行玩家选择“行2”的期望收益：q(d)+(1−q)(c)</p>
<p>令二者相等：</p>
<script type="math/tex; mode=display">aq + b(1-q) = dq + c(1-q)$$$$aq + b - bq = dq + c - cq$$$$b - c = q(d - a - c + b) = q((b+d) - (a+c))</script><p>解得列玩家的最优概率 q：</p>
<p>q∗=(b+d)−(a+c)b−c=(a+c)−(b+d)c−b</p>
</li>
</ul>
</li>
</ul>
<h4 id="推导博弈的价值-V"><a href="#推导博弈的价值-V" class="headerlink" title="推导博弈的价值 V"></a>推导博弈的价值 V</h4><p>博弈的价值 V 是在均衡状态下，行玩家的期望收益。我们可以将求得的 q* 代入行玩家的期望收益公式：</p>
<p>V=aq∗+b(1−q∗)=q∗(a−b)+bV=(a+c)−(b+d)c−b(a−b)+b</p>
<p>对上式进行通分并化简：</p>
<p>V=(a+c)−(b+d)(c−b)(a−b)+b((a+c)−(b+d))</p>
<script type="math/tex; mode=display">V = \frac{ac - bc - ab + b^2 + ab + bc - b^2 - bd}{(a+c) - (b+d)}$$分子中的 -bc, +bc, -ab, +ab, +b², -b² 项都相互抵消了，最终得到一个非常优美的公式：

V=(a+c)−(b+d)ac−bd

------

### 最终通解

对于一个不存在纯策略均衡的 2x2 零和博弈矩阵 A=(adbc)，其通解为：

1. 行玩家的最优混合策略 (p∗,1−p∗)：

   p∗=(a+c)−(b+d)d−c

2. 列玩家的最优混合策略 (q∗,1−q∗)：

   q∗=(a+c)−(b+d)c−b

3. 该博弈对行玩家的价值 V：

   V=(a+c)−(b+d)ac−bd

### 为什么行玩家是最大化最小值，而不是最小化极大值？

问得特别好！这正是理解零和博弈中双方战略思想的精髓所在。

简单来说，答案是：**因为他们的根本目标不同。**

- **行玩家的目标**：最大化自己的收益。
- **列玩家的目标**：最大化自己的收益，这在零和博弈中就等价于**最小化行玩家的收益**。

让我们一步一步地、站在**行玩家（Player 1）**的角度来思考他为什么必须是“最大化最小值 (Maximin)”。

### 1. 行玩家的思考过程：“我如何为最坏的情况做准备？”

行玩家是一个理性的决策者，他想让自己赚得尽可能多。但他知道两件事：

- 他的收益不只取决于自己，还取决于对手的选择。
- 他的对手（列玩家）的目标和他完全相反。他每多赚一块钱，就意味着对手要多亏一块钱。所以，对手会想尽一切办法让他赚得最少。

基于这个“对手会尽力坑我”的假设，行玩家必须采取一种非常谨慎和保守的策略。他的思考逻辑如下：

1. 审视自己的第一个选项（比如“行1”）：

   “如果我选择‘行1’，我的对手会怎么做？他会看遍‘行1’的所有结果，然后选择那个能让我收益最低的选项。所以，如果我出‘行1’，我能得到的保底收益就是这一行里的最小值。”

2. 审视自己的第二个选项（比如“行2”）：

   “同理，如果我选择‘行2’，理性的对手也会选择那一列来让我获得‘行2’里的最低收益。这个最小值就是我出‘行2’的保底收益。”

3. 做出最终决策：

   现在，行玩家手上有一份“保底收益清单”，清单上的每一项都对应着他选择某一行后，在最坏情况下能得到的最低收益。作为一个想最大化自己收益的人，他会看着这份“保底清单”，然后选择那个能提供**最高（Maximum）**保底收益的选项。

整个过程串起来就是：他先找出每一行的**最小值 (Minimum)**，然后在这些最小值中，选择一个**最大值 (Maximum)**。这就是**最大化最小值 (Maximin)**。

这是一种“在最坏的情况里，为自己争取最好的结果”的策略。

------

### 2. 为什么“最小化极大值 (Minimax)”是对手的策略？

现在我们换位思考，站到**列玩家（Player 2）**的角度。

1. **他的目标**：他的目标是最小化自己的损失，也就是最小化行玩家的收益。
2. **他的思考过程**：
   - **审视他的第一个选项（比如“列1”）**：“如果我出‘列1’，我的对手会怎么做？他会看遍‘列1’的所有结果，然后选择那个能让他自己收益**最高**的选项。所以，如果我出‘列1’，我可能遭受的**最大损失**（也就是行玩家的最大收益）就是这一列里的**最大值**。”
   - **审视他的第二个选项（比如“列2”）**：“同理，如果我出‘列2’，我可能遭受的最大损失就是‘列2’里的**最大值**。”
   - **做出最终决策**：现在，列玩家手上也有一份“最大损失清单”。作为一个想最小化自己损失的人，他会看着这份清单，然后选择那个能让他的**最大损失变得最小 (Minimum)** 的选项。

整个过程串起来就是：他先找出每一列的**最大值 (Maximum)**，然后在这些最大值中，选择一个**最小值 (Minimum)**。这就是**最小化极大值 (Minimax)**。

### 总结

|          | **行玩家 (Player 1)**            | **列玩家 (Player 2)**                    |
| -------- | -------------------------------- | ---------------------------------------- |
| **目标** | 最大化自己的收益                 | 最小化自己的损失（即最小化行玩家的收益） |
| **思想** | 在最坏的情况里为自己争取最好结果 | 让对手在最好的情况下也占不到太大便宜     |
| **策略** | **最大化最小值 (Maximin)**       | **最小化极大值 (Minimax)**               |

所以，行玩家之所以是“最大化最小值”，是因为他的出发点是**为自己求利**，同时假设对手会让他**利无可利**；而“最小化极大值”则是从对手的视角出发，目标是**让行玩家的利益最小化**。冯·诺依曼的惊人发现在于，在两人零和博弈中，这两种看似不同的思考路径，最终会指向同一个均衡解。

![7-4](image-20250630215303870.png)

这张幻灯片介绍了“序贯决策”框架中那个最普适、最强大的模型——**随机博弈（或称马尔可夫博弈）**。它完美地将我们之前讨论过的“矩阵博弈”和“马尔可夫决策过程(MDP)”融合在了一起，是理解现代**多智能体强化学习 (MARL)** 的理论基石。

#### 1. 集大成者：融合了博弈论与强化学习

我们可以这样理解随机博弈的构成：

- 它借鉴了**矩阵博弈 (Matrix Games)** 的核心思想：在任何一个时刻，都有**多个智能体**在进行策略互动。
- 它又借鉴了**马尔可夫决策过程 (MDPs)** 的核心思想：整个系统存在**多个状态**，环境会根据参与者的行动从一个状态转移到另一个状态。

**随机博弈 = 多智能体的MDP = 随状态变化的重复博弈**

#### 2. 图示解读：一场动态演变的博弈

这张图非常直观地展示了随机博弈是如何运作的。我们可以把它想象成一场动态的冒险游戏：

1. **身处状态**：假设你和你的对手（参与者1和2）当前身处“**状态1 (State 1)**”。
2. **进行博弈**：在这个状态下，你们必须玩“状态1”对应的那个2x2矩阵博弈。比如，你（P1）选择了“下”，对手（P2）选择了“右”。
3. **获得即时回报**：根据矩阵，这个`(下, 右)`的联合行动会给你们带来 `(1, 1)` 的即时回报。
4. **世界发生改变（状态转移）**：这是最关键的一步。你们的联合行动 `(下, 右)` 触发了状态转移。紫色的箭头告诉我们，接下来会发生什么：
   - 有 **40%** 的概率，你们会进入“**状态2**”。
   - 有 **60%** 的概率，你们会进入“**状态3**”。
5. **进入新博弈**：假设你们进入了“状态2”。现在，你们面对的是一个**全新的2x2矩阵博弈**，有着完全不同的收益规则。你们需要在这个新规则下再次决策，然后获得新的回报，并再次触发新的状态转移。

这个过程会一直持续下去。

#### 3. 参与者的目标：深谋远虑

在一个随机博弈中，一个理性的参与者不会只盯着当前这一轮的得失。他的决策必须是**深谋远虑**的。

- 例如，在“状态1”中，`(上, 左)`这个选择能立刻带来`(2, 2)`的高回报。但如果这个选择有90%的概率会让你转移到一个对你极其不利的“惩罚状态”，那你可能就不会选它。
- 反之，你可能会选择一个即时回报较低的行动，如果它有很大概率把你带到一个未来回报极高的“天堂状态”。
- 这就是**折扣回报 (discounted rewards)** 的作用。玩家的目标是最大化未来所有回报的“总现值”，即找到一个在**所有状态下**都最优的策略（Policy），而不仅仅是当前状态。

**总结**：随机博弈为我们描绘了一幅最接近真实世界复杂性的图景——多个决策者在不断变化的环境中持续互动。我们之前讨论的**多智能体学习（MAL）的困难**，例如“环境的非平稳性”，正是源于这个框架。对于任何一个智能体来说，环境之所以“不稳定”，就是因为状态的转移和回报不仅取决于自己的行动，还取决于其他所有同样在学习和适应的智能体的行动。

![7-5](image-20250630220528288.png)

**标题：随机博弈 vs. MDP (Stochastic Games vs. MDP)**

- 在一个随机博弈中，如果除了一个参与者之外的所有其他参与者都采取**固定的 (fixed)** 策略，那么对于剩下的那个智能体来说，这个问题就**退化 (reverts back)** 回了一个MDP。
  - — 这是因为，固定其他智能体的策略（即使这些策略是随机的），会使得状态转移变得**马尔可夫化 (Markovian)**，即只取决于剩下的那个参与者的行动。

------

这张幻灯片通过一个“思想实验”，精准地指出了**多智能体学习（MARL）与单智能体学习（RL）的根本区别到底在哪里**。它告诉我们，多智能体问题的核心困难，并不在于“有多个会动的个体”，而在于“有多个会**学习和适应**的个体”。

#### 1. 问题复杂性的根源：变化的“游戏规则”

我们之前讨论，多智能体学习之所以困难，是因为环境的“非平稳性”（Non-stationarity）。对于任何一个智能体“我”来说，其他的智能体都是环境的一部分。当其他智能体也在学习、也在改变他们的策略时，就相当于“我”所面对的游戏规则本身在不断变化，这让学习变得极为困难。

#### 2. “固定策略”意味着什么？—— 从“对手”到“自然规律”

这张幻灯片提出的“固定其他所有人的策略”这个条件，是问题的关键。这意味着什么呢？让我们用一个生动的例子来说明：

- 情景A：随机博弈 (Stochastic Game)

  你是一个新手出租车司机（剩下的那个智能体），在一个大城市里学习如何最快地接送客人。城里还有成千上万的老司机（其他智能体），他们经验丰富，每天都在根据实时路况、新闻、个人习惯等调整自己的路线。这是一个极度复杂的多智能体学习问题，因为你的“环境”（即其他司机的行为）每天都在变。

- 情景B：退化为MDP

  现在，假设奇迹发生，城里所有其他司机都被换成了简单的机器人。这些机器人的行为遵循一套永不改变的固定程序。例如：“在周一上午8点的A路口，这群机器人有70%会右转，30%会直行”。这个概率是固定的，机器人不会再学习或改变了。

在这个时刻，对于你（唯一的人类司机）来说，发生了什么？

其他司机不再是具有主观能动性的“对手”了，他们变成了城市交通中一个虽然是随机的、但却是稳定的、可预测的自然规律。

#### 3. “马尔可夫化”：游戏规则被重新稳定下来

一旦其他人的策略被固定，整个系统对于“我”来说，就重新满足了**马尔可夫性质**。

- 当“我”在某个路口（状态s），选择直行（动作a），下一分钟会到达哪里、会花多长时间（下一个状态s'），其概率 **p(s′∣s,a)** 现在只取决于“我”的动作`a`和那群机器人固定的行为模式。
- 这个转移概率**不再随时间变化**了，因为机器人的“想法”不会变。
- 于是，这个复杂的、不可预测的多智能体博弈，就**退化**成了一个经典的、可解的**单智能体马尔可夫决策过程（MDP）**。

总结：

这张幻灯片通过“固定他人策略”这一巧妙的设定，帮助我们隔离并识别了多智能体问题的“困难之源”。困难不在于环境中存在多个行动者，而在于这些行动者策略的动态演化。这个洞见是许多高级多智能体学习算法的基础，例如，有些算法就是通过“轮流学习”（一个学习，其他暂时固定）或者对其他智能体的策略进行建模和预测，来试图克服这种“非平稳性”带来的挑战。

![7-6](image-20250630222547667.png)

这张幻灯片将原本简单的单次博弈，升级成了一个更复杂、也更贴近现实的**双状态随机博弈 (Two-state Stochastic Game)**。这里的“纳什均衡”不再是单个的行动组合，而是一个**策略组合 (a profile of policies)**，即每个厂商在**每种状态下**应该如何行动的完整计划。

这个问题的解取决于一个幻灯片上未给出但至关重要的参数——**折扣因子 γ (discount factor)**，它代表了厂商对未来收益的重视程度。

#### 1. 分解两个“子博弈”

我们首先分析在每个状态下，只考虑当前一轮收益的“短视”均衡是什么。

- 在状态1（无税收）：

  正如我们上一题分析的，双方都有一个占优策略：“污染”。因此，该状态下的短视纳什均衡是 (污染, 污染)。但这个选择会带来一个后果：根据转移概率 (0,1)，游戏将100%转移到状态2（有税收）。

- 在状态2（有税收）：

  我们分析这个新的利润矩阵：

  - 对厂商1：如果厂商2选择“清洁”，厂商1会选“污染”(4>1)；如果厂商2选“污染”，厂商1还是会选“污染”(3>0)。**“污染”是厂商1的占优策略**。
  - 对厂商2：如果厂商1选择“清洁”，厂商2会选“污染”(5>2)；如果厂商1选“污染”，厂商2还是会选“污染”(4>1)。**“污染”也是厂商2的占优策略**。
  - 因此，该状态下的短视纳什均衡也是 **(污染, 污染)**。这个选择的后果是，游戏将**100%留在状态2**，继续被征税。

#### 2. 长期战略的困境：短视 vs. 远见

分析完子博弈后，真正的战略困境浮现了。我们以厂商1在**状态1**的决策为例：

- **短视的选择（选择“污染”）**：可以立刻获得很高的收益（如果对方也污染，能得6）。但代价是，从下一轮开始，将永远陷入低收益的“状态2”。
- **远见的选择（选择“清洁”）**：会牺牲掉一部分即时收益（如果对方也清洁，只能得4）。但好处是，游戏将**100%留在高收益的“状态1”**，未来每一轮都可以继续获得高收益。

厂商会如何选择，完全取决于他们有多“远视”，即折扣因子 `γ` 有多大。

#### 3. 可能存在的纳什均衡

这个随机博弈可能存在多个纳什均衡。

**均衡A：“悲观”的污染均衡**

- **策略**：无论在哪种状态，双方都选择“污染”。
- **分析**：如果对方的策略是“永远污染”，那么你最好的应对也是“永远污染”。因为如果你单方面选择“清洁”，在状态1你会获得更低的即时收益(3 vs 6)然后还是会进入状态2；在状态2你单方面“清洁”的收益(0 vs 3)也更低。因此，没有任何一方有单方面改变策略的动机。
- **结论**：**（策略1=污染, 策略2=污染）是一个纳什均衡**。在这个均衡下，厂商们第一轮在状态1获得(6,7)的收益，然后永久地陷入状态2，每轮获得(3,4)的收益。这是一个低效的、“双输”的均衡。

**均衡B：“合作”的清洁均衡**

- **策略**：双方约定，只要在状态1，就都选择“清洁”。

- **分析**：要让这个“君子协定”成为一个稳定的纳什均衡，就必须保证“背叛”是无利可图的。

  - **遵守协定**的收益流（以厂商1为例）：4+4γ+4γ2+⋯=1−γ4

  - **单方面背叛**的收益流：在状态1选择“污染”获得一次性的高收益7，但之后游戏进入状态2，双方陷入“永远污染”的均衡，后续每轮收益为3。其收益流为: 7+3γ+3γ2+⋯=7+1−γ3γ

  - 要让大家遵守协定，必须满足“遵守的收益 ≥ 背叛的收益”：

    1−γ4≥7+1−γ3γ

    4≥7(1−γ)+3γ⟹4≥7−4γ⟹4γ≥3⟹γ≥43

- **结论**：**如果厂商们对未来的重视程度足够高（即折扣因子 γ ≥ 3/4），那么双方在状态1都选择“清洁”也可以成为一个纳什均衡**。因为对未来的长期高收益的渴望，足以抑制住当前“背叛”以获取短期利益的诱惑。

**总结**：这个引入了税收和状态转移的随机博弈模型，比单次博弈要复杂和深刻得多。它的均衡不再是唯一的，而是可能存在多个——一个“坏”的均衡和一个“好”的均衡。系统最终会落入哪个均衡，取决于参与者对未来的耐心和期望（由`γ`体现）。这也为政府政策的设计提供了启示：一个好的制度，应该让“合作”的门槛（即所需的`γ`值）尽可能低，让参与者更容易达成对社会有利的结果。

![7-7](image-20250630223314800.png)

**标题：例子：“大冒险”游戏 (Example: the game of Dare)**

- 参与者1，**领导者 (the leader)**，和参与者2，**挑战者 (the challenger)**，同时选择“**放弃 (pass)**”或“**挑战 (dare)**”。

  - — 如果双方都选择“放弃”，支付为零（且游戏结束）。
  - — 如果参与者1“放弃”而参与者2“挑战”，参与者1赢得1。
  - — 如果参与者1“挑战”而参与者2“放弃”，参与者1赢得3。
  - — 如果双方都选择“挑战”，这个基础游戏将**角色互换**后重新进行。
    - (领导者变成挑战者，反之亦然)。
  - — 如果参与者们永远地持续“挑战”下去，则支付为零。

- 博弈矩阵 G:

  $$G = \bordermatrix{ & \text{放弃} & \text{挑战} \cr \text{放弃} & 0 & 1 \cr \text{挑战} & 3 & -G^T }</script><p>  其中 -Gᵀ 代表角色互换后的游戏。（它的矩阵是G矩阵的转置的负数。）-Gᵀ的价值是G的价值的负数。</p>
<hr>
<p>这张幻灯片描述了一个非常有趣的<strong>递归博弈 (recursive game)</strong>，它是一种特殊的<strong>随机博弈 (stochastic game)</strong>。这个博弈只有两个状态：“P1是领导者”和“P2是领导者”。当出现 (挑战, 挑战) 的结果时，游戏就在这两个状态之间切换。</p>
<h4 id="1-问题的核心：递归的价值"><a href="#1-问题的核心：递归的价值" class="headerlink" title="1. 问题的核心：递归的价值"></a>1. 问题的核心：递归的价值</h4><p>这个问题的精髓在于右下角的那个支付 <code>-Gᵀ</code>。</p>
<ul>
<li><p>让我们设这个博弈对于<strong>当前的领导者</strong>来说，其<strong>价值 (Value)</strong> 为 <strong>V</strong>。</p>
</li>
<li><p>那么，领导者的支付矩阵就可以写成：</p>
<p>G=(031Value(subgame))</p>
</li>
<li><p>当双方都选择“挑战”时，游戏进入子博弈。在这个子博弈中，原先的挑战者（P2）变成了新的领导者。由于游戏的对称性，这个子博弈对于<strong>新的领导者（P2）</strong>来说，价值也应该是 <strong>V</strong>。</p>
</li>
<li><p>既然对于新的领导者（P2）价值是 <code>V</code>，那么对于<strong>新的挑战者（也就是原来的P1）</strong>来说，价值就是 <strong>-V</strong>（因为是零和博弈）。</p>
</li>
<li><p>因此，原领导者（P1）的支付矩阵可以写成一个包含其自身价值 V 的形式：</p>
<p>G=(031−V)</p>
</li>
</ul>
<h4 id="2-求解博弈价值-V"><a href="#2-求解博弈价值-V" class="headerlink" title="2. 求解博弈价值 V"></a>2. 求解博弈价值 V</h4><p>现在，问题转化为了：求解这个特殊矩阵的价值 V，并且这个价值 V 必须等于它自身。</p>
<script type="math/tex; mode=display">V = \text{value} \begin{pmatrix} 0 & 1 \ 3 & -V \end{pmatrix}$$我们可以使用之前推导出的 2x2 零和博弈的通用价值公式：$$V = \frac{ac - bd}{(a+c) - (b+d)}$$其中，a=0, b=1, d=3, c=-V。代入公式：$$V = \frac{(0)(-V) - (1)(3)}{(0)+(-V) - (1)-(3)} = \frac{-3}{-V-4}$$现在我们得到了一个关于 V 的方程，求解它：

$$V(-V - 4) = -3$$$$-V^2 - 4V = -3$$$$V^2 + 4V - 3 = 0</script><p>这是一个一元二次方程。使用求根公式 </p>
<p>我们得到了两个可能的解：V1=7−2≈0.646 和 V2=−7−2≈−4.646。</p>
<h4 id="3-选择正确的解"><a href="#3-选择正确的解" class="headerlink" title="3. 选择正确的解"></a>3. 选择正确的解</h4><p>哪个才是这个博弈真正的价值呢？</p>
<p>我们看领导者的支付矩阵，他有一个“放弃”的选项。如果他选择“放弃”，最坏的结果是对手选择“挑战”，此时他的收益是1。这意味着，领导者至少可以为自己保证一个非负的收益。因此，一个负数（比如-4.646）不可能是这个博弈的理性价值。</p>
<p>所以，这个博弈对于领导者的价值是：根号7减去2</p>
<p><img src="image-20250630224225904.png" alt="7-8"></p>
<p>求解博弈G1和G2的价值：</p>
<p><img src="image-20250630224137356.png" alt="7-9"></p>
<h2 id="7-2-值迭代与策略迭代"><a href="#7-2-值迭代与策略迭代" class="headerlink" title="7.2 值迭代与策略迭代"></a>7.2 值迭代与策略迭代</h2><p><img src="image-20250701210516613.png" alt="7-10"></p>
<p>1、学习随机博弈中状态值函数贝尔曼方程推导</p>
<p>2、与单智能体MDP的关键区别</p>
<p>这个公式虽然形式上与单智能体MDP的贝尔曼方程很像，但幻灯片的最后一点指出了两个根本性的区别，这也是多智能体问题复杂性的根源：</p>
<ol>
<li><strong>价值是个人化的 (for each agent)</strong>：在MDP中，只有一个价值函数 <code>V(s)</code>。但在随机博弈中，<strong>每个参与者 <code>i</code> 都有自己的一套价值函数 Vi(s)</strong>。同一个状态 <code>s</code>，对我来说可能是天堂（Vi很高），对你来说可能却是地狱（Vj很低）。这体现了参与者之间合作与冲突并存的关系。</li>
<li><strong>价值依赖于联合策略 (on the joint policy)</strong>：这是最致命的区别。在MDP中，价值函数 Vπ(s) 只取决于我自己的策略 <code>π</code>。但在这里，Viπ(s) 的值不仅取决于我的策略 πi，还取决于<strong>其他所有人的策略</strong> π−i，因为是<strong>联合行动</strong>决定了回报和状态转移。<ul>
<li>这就导致了我们之前讨论的<strong>“非平稳性”</strong>或<strong>“移动靶心”</strong>问题。如果我的对手改变了他的策略，那么即使我的策略和当前状态都没变，我整个的价值函数 Vi(s) 也会跟着改变。我原以为很有价值的状态，可能因为对手策略的改变而突然变得一文不值。</li>
</ul>
</li>
</ol>
<p><img src="image-20250701211212340.png" alt="7-11"></p>
<p>这张幻灯片在重申了状态价值的定义之后，提出了一个关于它的非常重要的数学性质：<strong>有界性 (Boundedness)</strong>。这个性质是随机博弈能够被分析和求解的理论基础之一。</p>
<h4 id="1-核心思想：无限过程，有限价值"><a href="#1-核心思想：无限过程，有限价值" class="headerlink" title="1. 核心思想：无限过程，有限价值"></a>1. 核心思想：无限过程，有限价值</h4><p>这条结论的核心思想是：尽管一个随机博弈的过程可能永远持续下去，但从任何一个状态开始，任何一个参与者能够获得的<strong>总的“折扣”价值都不是无限的，而是一个有限的、有上限的数值</strong>。</p>
<p>幻灯片给出了这个上限的计算公式：1−γM。</p>
<ul>
<li><strong>M</strong>: 代表在整个游戏所有可能的情况下，任何参与者在<strong>单一一轮</strong>中所能获得的<strong>最大绝对收益</strong>。可以理解为这个游戏里“单次操作的最大奖励或最大惩罚（的绝对值）”。</li>
<li><strong>γ (gamma)</strong>: 是我们熟悉的折扣因子（0 &lt; γ &lt; 1），代表了我们对未来收益的耐心程度。</li>
</ul>
<h4 id="2-这个上限公式是怎么来的？（几何级数）"><a href="#2-这个上限公式是怎么来的？（几何级数）" class="headerlink" title="2. 这个上限公式是怎么来的？（几何级数）"></a>2. 这个上限公式是怎么来的？（几何级数）</h4><p>这个公式的推导非常直观，它基于我们熟知的等比数列（几何级数）求和。</p>
<ol>
<li><p>根据定义，状态价值是所有未来折扣回报的总和：</p>
<p>Viπ(s)=Eπ[r0+γr1+γ2r2+γ3r3+…]</p>
</li>
<li><p>在任何一步 <code>k</code>，我们能获得的即时回报 rk 的绝对值，都不可能超过定义好的最大单轮回报 <code>M</code>。即 ∣rk∣≤M。</p>
</li>
<li><p>因此，总价值 Viπ(s) 必然小于或等于一种最极端、最理想的情况：假设我们在未来的每一步，都能幸运地获得最大的正回报 M。</p>
<p>Viπ(s)≤M+γM+γ2M+γ3M+…</p>
</li>
<li><p>将 M 提取出来：</p>
<p>Viπ(s)≤M(1+γ+γ2+γ3+…)</p>
</li>
<li><p>括号里的部分是一个公比为 <code>γ</code> 的无穷等比数列。因为 <code>γ &lt; 1</code>，这个级数是收敛的，其和为 1−γ1。</p>
</li>
<li><p>因此，我们得到了最终的边界：</p>
<p>Viπ(s)≤1−γM</p>
</li>
</ol>
<h4 id="3-这个性质为什么重要？"><a href="#3-这个性质为什么重要？" class="headerlink" title="3. 这个性质为什么重要？"></a>3. 这个性质为什么重要？</h4><ol>
<li><strong>保证问题“有解”</strong>：这个有界性保证了我们要求解的状态价值函数是一个“行为良好”的函数，它的值不会发散到无穷大。这是所有后续分析和算法能够成立的数学前提。如果没有这个保证，我们可能都无法定义“最优策略”，因为所有策略的总回报都是无穷大，无法比较。</li>
<li><strong>为算法提供基础</strong>：在很多求解随机博弈的算法（例如价值迭代）中，这个边界可以用于初始化价值函数，或者作为算法收敛性的一个判断依据。它确保了算法的计算过程会在一个有限的数值空间内进行，最终能够稳定下来。</li>
</ol>
<p><strong>总结</strong>：这张幻灯片的核心是告诉我们，尽管随机博弈的博弈过程可能是无限的，但其价值是有限的。这个有界性不仅为问题的“可解性”提供了理论保障，也为实际的计算算法奠定了基础。</p>
<p><img src="image-20250701215722881.png" alt="7-12"></p>
<p><img src="image-20250701215827727.png" alt="7-13"></p>
<h4 id="结论与洞察"><a href="#结论与洞察" class="headerlink" title="结论与洞察"></a>结论与洞察</h4><p>这个例子深刻地揭示了<strong>短期利益与长期战略</strong>之间的权衡。</p>
<ul>
<li>从短期看，第1列对列玩家更有利（即时损失更小）。</li>
<li>但从长期看，第1列有更高的概率让游戏继续下去，这意味着他未来要持续地向行玩家支付价值为<code>v</code>的收益。而第2列能更快地结束游戏，从而“止损”。</li>
<li>最终的均衡策略显示，<strong>长期战略（避免未来损失）的重要性压倒了短期利益</strong>。因此，列玩家的最优策略是<strong>更频繁地选择那个能更快结束游戏的第2列</strong>，尽管它眼前的损失看起来更大。</li>
</ul>
<p><img src="image-20250702003904470.png" alt="7-14"></p>
<p><strong>标题：价值迭代 (Value Iteration)</strong></p>
<ul>
<li>夏普利证明了 vn(s) 会收敛到从s开始的随机博弈的<strong>真实价值 v(s)</strong>。<ul>
<li>— 首先，收敛是以<strong>指数速率 (exponential rate)</strong> 进行的：最大误差至少以 γn 的速度下降。</li>
<li>— 其次，在第 n+1 阶段的最大误差，至多是“<strong>从n到n+1阶段的最大变化量</strong>”乘以 γ/(1−γ)。</li>
</ul>
</li>
</ul>
<hr>
<p>这张幻灯片深入探讨了“价值迭代”算法的<strong>性能保证</strong>。它告诉我们，夏普利不仅证明了价值迭代这个方法是<strong>可行</strong>的（即最终能找到正确答案），更证明了它是<strong>高效</strong>和<strong>可靠</strong>的。这使得价值迭代从一个理论上的概念，变成了一个可以在实践中应用的强大工具。</p>
<h4 id="1-指数速率收敛：为什么说它“高效”？"><a href="#1-指数速率收敛：为什么说它“高效”？" class="headerlink" title="1. 指数速率收敛：为什么说它“高效”？"></a>1. 指数速率收敛：为什么说它“高效”？</h4><p>“指数速率收敛”听起来很抽象，但它的意思是，算法的精确度在每一步迭代后都会得到一个“质的飞跃”。</p>
<ul>
<li><strong>一个比喻</strong>：想象你在寻宝，宝藏在1公里外。有一个向导，你每走一步，他都会告诉你：“你现在离宝藏的距离，是你上一步距离的90%”。<ul>
<li>你的误差（与宝藏的距离）在每一步都会乘以一个固定的因子（0.9）。</li>
<li>第一次迭代后，误差是 1×0.9。</li>
<li>第二次迭代后，误差是 1×0.92。</li>
<li>第n次迭代后，误差是 1×0.9n。</li>
<li>误差以 0.9n 的速度急剧缩小，这就是指数级的衰减。</li>
</ul>
</li>
<li><strong>在价值迭代中</strong>：折扣因子 <code>γ</code> (一个小于1的数) 就扮演了这个“0.9”的角色。每迭代一次，我们估算的价值函数 vn(s) 与真实价值 v(s) 之间的最大误差，都会大致缩小一个 <code>γ</code> 倍。因为 <code>γ</code> 小于1，所以经过多次迭代后，误差会变得非常小，算法能很快地逼近真实解。这背后的数学原理是，夏普利证明了价值迭代的更新算子是一个<strong>压缩映射 (Contraction Mapping)</strong>。</li>
</ul>
<h4 id="2-误差边界：为什么说它“可靠”？"><a href="#2-误差边界：为什么说它“可靠”？" class="headerlink" title="2. 误差边界：为什么说它“可靠”？"></a>2. 误差边界：为什么说它“可靠”？</h4><p>第二点结论解决了一个非常实际的问题：“我怎么知道什么时候可以停止算法，并且保证我的答案足够精确了？”</p>
<ul>
<li><p><strong>面临的困境</strong>：我们希望我们的误差，即 <code>|我们的估算值 vₙ - 真实值 v*|</code>，小于一个我们能接受的阈值（比如0.001）。但问题是，我们并不知道那个神秘的“真实值 <code>v*</code>”到底是多少，所以无法直接计算这个误差。</p>
</li>
<li><p>夏普利提供的解决方案：他给出了一个可计算的误差上限。公式告诉我们：</p>
<p>真实的未知误差≤可计算的最大单步变化量×1−γγ</p>
<p>这里的“可计算的最大单-步变化量”指的是 ∣vn+1(s)−vn(s)∣max，也就是在你最近一次迭代中，所有状态的价值估算值变化最大的那一个。这个值我们在计算过程中是完全知道的。</p>
</li>
<li><p><strong>实际应用（停止条件）</strong>：</p>
<ol>
<li>我们设定一个目标精度 <code>ε</code>，比如我希望我的最终答案与真实值的误差不超过0.001。</li>
<li>根据公式，只要我们能让 <code>(可计算的最大单步变化量) * γ/(1-γ)</code> 这个上限小于 <code>ε</code>，那么真实的误差就一定小于 <code>ε</code>。</li>
<li>因此，我们的算法停止条件就变成了：<strong>持续迭代，直到我们观察到的最大单步变化量小于 ϵ⋅γ1−γ</strong>。</li>
<li>一旦满足这个条件，我们就可以放心地停止迭代，并宣布当前的估算值 vn+1 就是一个足够精确的解。</li>
</ol>
</li>
</ul>
<p><strong>总结</strong>：这张幻灯片从理论上为价值迭代算法的有效性提供了强有力的背书。<strong>指数速率收敛</strong>保证了它的计算速度，而<strong>实用的误差边界</strong>则为它在现实中的应用提供了可靠的停止准则，使其成为求解两人零和随机博弈的核心算法之一。</p>
<p><img src="image-20250702005255997.png" alt="7-15"></p>
<p><strong>为什么最小停止概率是0.5？</strong></p>
<h3 id="1-“最小停止概率是0-5”的来源分析"><a href="#1-“最小停止概率是0-5”的来源分析" class="headerlink" title="1. “最小停止概率是0.5”的来源分析"></a>1. “最小停止概率是0.5”的来源分析</h3><p>这个结论来自于对 G₁ 和 G₂ 两个矩阵中所有单元格的<strong>“持续概率”</strong>的分析。</p>
<p>在一个随机博弈的支付单元格中，形如 <code>“即时回报 + 概率 × 未来价值”</code> 的结构，那个<strong>概率</strong>就代表了游戏<strong>继续下去的可能性</strong>。而<strong>“停止概率”</strong>则等于 <strong>1 - 继续概率</strong>。</p>
<p>让我们来逐一检查两个矩阵中所有结果的“停止概率”：</p>
<p>对于博弈 G₁:</p>
<p>G(1)=(4+0.3G(1)1+0.4G(2)0+0.4G(2)3+0.5G(1))</p>
<ul>
<li>(行1, 列1): 继续概率是 0.3。 <strong>停止概率 = 1 - 0.3 = 0.7</strong></li>
<li>(行1, 列2): 继续概率是 0.4。 <strong>停止概率 = 1 - 0.4 = 0.6</strong></li>
<li>(行2, 列1): 继续概率是 0.4。 <strong>停止概率 = 1 - 0.4 = 0.6</strong></li>
<li>(行2, 列2): 继续概率是 0.5。 <strong>停止概率 = 1 - 0.5 = 0.5</strong></li>
</ul>
<p>对于博弈 G₂:</p>
<p>G(2)=(0+0.5G(1)−4−51+0.5G(2))</p>
<ul>
<li>(行1, 列1): 继续概率是 0.5。 <strong>停止概率 = 1 - 0.5 = 0.5</strong></li>
<li>(行1, 列2): 支付是-5（没有未来价值项）。继续概率是 0。<strong>停止概率 = 1 - 0 = 1</strong></li>
<li>(行2, 列1): 支付是-4。继续概率是 0。<strong>停止概率 = 1 - 0 = 1</strong></li>
<li>(行2, 列2): 继续概率是 0.5。<strong>停止概率 = 1 - 0.5 = 0.5</strong></li>
</ul>
<p>现在，我们把所有计算出的停止概率放在一起：{ 0.7, 0.6, 0.5, 1 }。</p>
<p>在所有这些可能性中，最小的那个值，就是 0.5。</p>
<p>这就是“最小停止概率是0.5”这句话的直接来源。</p>
<h3 id="2-这个数字为什么如此重要？"><a href="#2-这个数字为什么如此重要？" class="headerlink" title="2. 这个数字为什么如此重要？"></a>2. 这个数字为什么如此重要？</h3><p>这个“最小停止概率”反过来告诉了我们整个系统的<strong>“最大继续概率”</strong>。</p>
<ul>
<li>最小停止概率 = 0.5</li>
<li>最大继续概率 = 1 - 最小停止概率 = 1 - 0.5 = 0.5</li>
</ul>
<p>这个<strong>“最大继续概率”</strong>，可以被看作是整个随机博弈系统的<strong>有效折扣因子 γ (effective discount factor)</strong>。</p>
<p>为什么呢？</p>
<p>价值迭代算法的收敛速度，取决于其更新算子是不是一个“压缩映射”，而其“压缩程度”就由折扣因子γ决定。为了保证整个系统一定收敛，我们必须考虑最坏的情况。</p>
<ul>
<li><strong>收敛的最坏情况是什么？</strong> 就是收敛得最慢的情况。</li>
<li><strong>什么时候收敛得最慢？</strong> 就是“折扣”打得最少的时候，也就是游戏最不容易结束、<strong>继续下去的概率最大</strong>的时候。</li>
</ul>
<p>在这个博弈中，游戏继续下去的最大概率是0.5。因此，整个价值迭代算法的收敛速度就由这个0.5来决定。</p>
<ul>
<li><strong>收敛速率</strong>：因为有效折扣因子<code>γ</code>是0.5，所以算法的误差是以 (0.5)n 的指数速率下降的。</li>
<li><strong>误差边界</strong>：根据我们之前学过的误差边界公式 <code>真实误差 ≤ 最大单步变化量 × γ/(1-γ)</code>，代入<code>γ=0.5</code>，我们得到 <code>γ/(1-γ) = 0.5/0.5 = 1</code>。这意味着，真实的未知误差，不会超过我们在上一步迭代中能观测到的最大变化量。幻灯片中说v₆的误差至多是0.0002，就是基于这个原理计算出来的（从v₅到v₆的最大变化量约为0.0001，其上限0.0002是完全正确的）。</li>
</ul>
<p><strong>总结</strong>： “最小停止概率是0.5”这个结论，是通过分析所有可能结果得出的。它的真正意义在于，它为我们确定了整个动态系统的有效折扣因子 <code>γ=0.5</code>，从而为算法的<strong>收敛速度</strong>和<strong>误差分析</strong>提供了坚实的理论依据。</p>
]]></content>
  </entry>
</search>

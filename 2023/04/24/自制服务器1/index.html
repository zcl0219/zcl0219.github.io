<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar-16.png">
  <link rel="mask-icon" href="/images/emoji-smile.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zcl0219.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null,"show_result":true},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="服务端—客户端通信大致流程 服务端创建一个监听套接字（对创建的监听套接字进行判断，是否创建成功，返回非负整数则代表创建成功，返回-1代表创建失败），调用函数socket()。在linux系统中一切皆文件，每个文件都有一个整数类型的文件描述符。socket()也是一个文件，也有文件描述符。使用socket()函数创建套接字以后，返回值就是一个int类型的文件描述符。 在linux下使用&lt;sys">
<meta property="og:type" content="article">
<meta property="og:title" content="自制服务器1">
<meta property="og:url" content="http://zcl0219.github.io/2023/04/24/%E8%87%AA%E5%88%B6%E6%9C%8D%E5%8A%A1%E5%99%A81/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="服务端—客户端通信大致流程 服务端创建一个监听套接字（对创建的监听套接字进行判断，是否创建成功，返回非负整数则代表创建成功，返回-1代表创建失败），调用函数socket()。在linux系统中一切皆文件，每个文件都有一个整数类型的文件描述符。socket()也是一个文件，也有文件描述符。使用socket()函数创建套接字以后，返回值就是一个int类型的文件描述符。 在linux下使用&lt;sys">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-04-24T15:16:57.000Z">
<meta property="article:modified_time" content="2023-06-07T18:03:25.337Z">
<meta property="article:author" content="GGBond">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="webServer">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://zcl0219.github.io/2023/04/24/%E8%87%AA%E5%88%B6%E6%9C%8D%E5%8A%A1%E5%99%A81/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://zcl0219.github.io/2023/04/24/%E8%87%AA%E5%88%B6%E6%9C%8D%E5%8A%A1%E5%99%A81/","path":"2023/04/24/自制服务器1/","title":"自制服务器1"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>自制服务器1 | Hexo</title>
  







<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap" rel="stylesheet">

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E2%80%94%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">服务端—客户端通信大致流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#lt-semaphore-h-gt-%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="nav-number">1.0.0.1.</span> <span class="nav-text">&lt;semaphore.h&gt;头文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BD%AC%E6%8D%A2%E4%B8%BAsockaddr"><span class="nav-number">1.0.0.2.</span> <span class="nav-text">为什么要转换为sockaddr</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AB%AF%E5%8F%A3%EF%BC%9A%E7%9F%A5%E5%90%8D%E7%AB%AF%E5%8F%A3%E3%80%81%E6%B3%A8%E5%86%8C%E7%AB%AF%E5%8F%A3%E3%80%81%E5%8A%A8%E6%80%81%E6%88%96%E7%A7%81%E6%9C%89%E7%AB%AF%E5%8F%A3"><span class="nav-number">1.0.0.3.</span> <span class="nav-text">网络服务中的三种端口：知名端口、注册端口、动态或私有端口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#signal%E5%87%BD%E6%95%B0"><span class="nav-number">1.0.0.4.</span> <span class="nav-text">signal函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#telnet%E5%91%BD%E4%BB%A4"><span class="nav-number">1.0.0.5.</span> <span class="nav-text">telnet命令</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#webServer%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%B4%E4%BD%93%E6%8F%8F%E8%BF%B0"><span class="nav-number">1.0.1.</span> <span class="nav-text">webServer服务器整体描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AFI-x2F-O%E5%A4%8D%E7%94%A8"><span class="nav-number">1.0.2.</span> <span class="nav-text">多路I&#x2F;O复用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#select"><span class="nav-number">1.0.3.</span> <span class="nav-text">select</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#tip%EF%BC%9A%E8%BF%99%E6%98%AF%E4%B8%80%E7%A7%8D%E5%BC%82%E6%AD%A5I-x2F-O%E6%A8%A1%E5%9E%8B%EF%BC%8C%E5%9B%A0%E4%B8%BA%E4%BD%A0%E4%B8%8D%E9%9C%80%E8%A6%81%E9%98%BB%E5%A1%9E%E7%AD%89%E5%BE%85%E5%8D%95%E4%B8%AAI-x2F-O%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%8C%E6%88%90%E3%80%82"><span class="nav-number">1.0.3.1.</span> <span class="nav-text">tip：这是一种异步I&#x2F;O模型，因为你不需要阻塞等待单个I&#x2F;O操作的完成。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A9%E6%88%91%E4%BB%AC%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E6%9D%A5%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%90%86%E8%A7%A3select%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%82%E8%BF%99%E4%B8%AA%E7%A4%BA%E4%BE%8B%E6%98%AF%E4%B8%80%E4%B8%AATCP%E5%9B%9E%E6%98%BE%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E5%AE%83%E4%BD%BF%E7%94%A8select%E6%9D%A5%E5%90%8C%E6%97%B6%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%92%8C%E8%AF%B7%E6%B1%82%E3%80%82"><span class="nav-number">1.0.4.</span> <span class="nav-text">让我们通过一个简单的服务器代码示例来进一步理解select的使用。这个示例是一个TCP回显服务器，它使用select来同时处理多个客户端的连接和请求。</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#max-fd%E5%88%B0%E5%BA%95%E6%9C%89%E5%95%A5%E4%BD%9C%E7%94%A8%E5%91%A2%EF%BC%9Fselect%E5%87%BD%E6%95%B0%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E6%88%91%E4%B8%BA%E5%95%A5%E6%84%9F%E8%A7%89%E6%B2%A1%E5%95%A5%E4%BD%9C%E7%94%A8%E5%91%A2%EF%BC%9F"><span class="nav-number">1.0.4.1.</span> <span class="nav-text">max_fd到底有啥作用呢？select函数第一个参数我为啥感觉没啥作用呢？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E9%87%8C%E9%9D%A2%E8%B2%8C%E4%BC%BC%E8%87%AA%E5%A7%8B%E8%87%B3%E7%BB%88%E4%B9%9F%E6%B2%A1%E4%BD%93%E7%8E%B0select%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%9B%A0%E4%B8%BA%E8%BF%9Eselect%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E9%83%BD%E6%B2%A1%E7%94%A8%E4%B8%8A%EF%BC%8C%E5%B0%B1%E5%A5%BD%E6%AF%94%E7%8E%B0%E5%9C%A8select%E7%8E%B0%E5%9C%A8%E7%9B%91%E5%90%AC1-2-3-4-5-6%E8%BF%996%E4%B8%AA%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%EF%BC%8C%E5%81%87%E8%AE%BE5%E5%87%86%E5%A4%87%E5%B0%B1%E7%BB%AA%E4%BA%86%EF%BC%8C%E6%88%91%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%935%E5%87%86%E5%A4%87%E5%B0%B1%E7%BB%AA%E4%BA%86%E5%91%A2%EF%BC%8C%E5%9C%A8%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E8%B2%8C%E4%BC%BC%E5%B9%B6%E6%B2%A1%E6%9C%89%E4%BD%93%E7%8E%B0%E5%87%BA%E6%9D%A5"><span class="nav-number">1.0.4.2.</span> <span class="nav-text">代码里面貌似自始至终也没体现select函数的作用，因为连select函数的返回值都没用上，就好比现在select现在监听1 2 3 4 5 6这6个文件描述符，假设5准备就绪了，我怎么知道5准备就绪了呢，在你的代码貌似并没有体现出来</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#poll"><span class="nav-number">1.0.5.</span> <span class="nav-text">poll</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#clients-0-revents-amp-POLLIN%E8%BF%99%E4%B8%AA%E4%BB%A3%E8%A1%A8%E5%95%A5%E6%84%8F%E6%80%9D"><span class="nav-number">1.0.5.1.</span> <span class="nav-text">clients[0].revents &amp; POLLIN这个代表啥意思</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%99%E4%B8%AA%E8%83%BD%E4%B8%8D%E8%83%BD%E7%BB%99%E5%87%BA%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B%EF%BC%8C%E4%B8%8D%E5%A4%AA%E7%90%86%E8%A7%A3"><span class="nav-number">1.0.5.2.</span> <span class="nav-text">这个能不能给出一个实例，不太理解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#recv%E5%87%BD%E6%95%B0"><span class="nav-number">1.0.5.3.</span> <span class="nav-text">recv函数</span></a></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="GGBond"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">GGBond</p>
  <div class="site-description" itemprop="description">Doing the tough things sets winners apart from losers</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zcl0219.github.io/2023/04/24/%E8%87%AA%E5%88%B6%E6%9C%8D%E5%8A%A1%E5%99%A81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="GGBond">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="Doing the tough things sets winners apart from losers">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="自制服务器1 | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          自制服务器1
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-04-24 23:16:57" itemprop="dateCreated datePublished" datetime="2023-04-24T23:16:57+08:00">2023-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-06-08 02:03:25" itemprop="dateModified" datetime="2023-06-08T02:03:25+08:00">2023-06-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="服务端—客户端通信大致流程"><a href="#服务端—客户端通信大致流程" class="headerlink" title="服务端—客户端通信大致流程"></a>服务端—客户端通信大致流程</h2><ul>
<li><p>服务端创建一个监听套接字（对创建的监听套接字进行判断，是否创建成功，返回非负整数则代表创建成功，返回-1代表创建失败），调用函数<code>socket()</code>。在<code>linux</code>系统中一切皆文件，每个文件都有一个整数类型的文件描述符。<code>socket()</code>也是一个文件，也有文件描述符。使用<code>socket()</code>函数创建套接字以后，返回值就是一个int类型的文件描述符。</p>
<p>在<code>linux</code>下使用<code>&lt;sys/socket.h&gt;</code>头文件中<code>socket()</code>函数来创建套接字，函数原型为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，第一个参数<code>af</code>为地址族<code>（Address Family）</code>，也就是<code>IP</code>地址类型，常用的<code>IP</code>地址类型有<code>AF_INET</code>和<code>AF_INET6</code>。<code>AF</code>是<code>”Address Family“</code>的简写，<code>INET</code>是<code>”Internet“</code>的简写。<code>AF_INET</code>表示<code>IPv4</code>地址，例如<code>127.0.0.1</code>；<code>AF_INET6</code>表示<code>IPv6</code>地址，例如<code>1030::C9B4:FF12:48AA:1A2B</code>。<code>127.0.0.1</code>是一个特殊的<code>IP</code>地址，表示本机地址。</p>
<p>第二个参数<code>type</code>为数据传输方式&#x2F;套接字类型，常用的有<code>SOCK_STREAM</code>（流格式套接字&#x2F;面向连接的套接字）和<code>SOCK_DGRAM</code>（数据报套接字&#x2F;无连接的套接字）。</p>
<p>第三个参数<code>protocol</code>表示传输协议，常用的有<code>IPPROTO_TCP</code>和<code>IPPTOTO_UDP</code>，即所谓的：<code>TCP</code>和<code>UDP</code>。</p>
</li>
</ul>
<p>我们经常会看见别人程序里创建套接字如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> listenfd = <span class="built_in">socket</span>(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>很多人可能会好奇为什么第三个参数会设置为0？其实既满足<code>IP</code>地址类型为：<code>AF_INET</code>又满足套接字类型为：<code>SOCK_STREAM/SOCK_DGRAM</code>的只有<code>TCP/UDP</code>，系统会自动推演出来应该使用什么协议，此时则可以将<code>protocol</code>设置为0。</p>
<h5 id="lt-semaphore-h-gt-头文件"><a href="#lt-semaphore-h-gt-头文件" class="headerlink" title="&lt;semaphore.h&gt;头文件"></a>&lt;semaphore.h&gt;头文件</h5><p>&lt;semphore.h&gt;头文件是POSIX标准中定义的一个头文件，用于提供信号量的函数和数据类型。</p>
<p>信号量是一种用于提供不同进程或线程之间进行同步或者互斥的简单抽象。通常，信号量被用来限制对特定资源的访问，这在多线程和多进程环境中非常有用。</p>
<p>在<code>&lt;semaphore.h&gt;</code>头文件中，定义了以下的函数：</p>
<ul>
<li><code>sem_init()</code>：初始化一个未命名的信号量</li>
<li><code>sem_destroy()</code>：销毁一个未命名的信号量</li>
<li><code>sem_open()</code>：打开一个命名信号量，如果该信号量不存在，则创建一个</li>
<li><code>sem_close()</code>：关闭一个命名信号量</li>
<li><code>sem_unlink()</code>：删除一个命名信号量</li>
<li><code>sem_post()</code>：增加（解锁）信号量的值</li>
<li><code>sem_wait()</code>：减少（锁定）信号量的值，如果信号量的值为0，则调用该函数的线程会阻塞，直到信号量的值大于0</li>
<li><code>sem_trywait()</code>：尝试减少信号量的值，如果信号量的值为0，则立即返回错误，而不会阻塞</li>
<li><code>sem_getvalue()</code>：获取信号量的当前值</li>
</ul>
<h5 id="为什么要转换为sockaddr"><a href="#为什么要转换为sockaddr" class="headerlink" title="为什么要转换为sockaddr"></a>为什么要转换为<code>sockaddr</code></h5><p>所有专用<code>socket</code>地址（以及<code>sockaddr_storage</code>）类型的变量在实际使用时都需要转换为通用<code>socket</code>地址类型<code>sockaddr</code>（强制转换即可），因为所有<code>socket</code>编程接口使用的地址参数的类型都是<code>sockaddr</code>。</p>
<h5 id="网络服务中的三种端口：知名端口、注册端口、动态或私有端口"><a href="#网络服务中的三种端口：知名端口、注册端口、动态或私有端口" class="headerlink" title="网络服务中的三种端口：知名端口、注册端口、动态或私有端口"></a>网络服务中的三种端口：知名端口、注册端口、动态或私有端口</h5><p>服务端口（<code>Service Port</code>）是计算机网络中，网络服务使用的网络端口。这些端口通常被分为三个范围：知名端口、注册端口和动态或私有端口。</p>
<p>知名端口（<code>Well-Known Ports</code>）是从0到1023的端口号。它们通常被系统进程或者管理员级别的进程使用。这些端口通常关联到一些广泛使用的网络服务，例如：</p>
<ul>
<li><code>HTTP</code>：端口80</li>
<li><code>HTTPS</code>：端口443</li>
<li><code>FTP</code>：端口20和21</li>
<li><code>SSH</code>：端口22</li>
<li><code>Telnet</code>：端口23</li>
<li><code>DNS</code>：端口53</li>
<li><code>SMTP</code>：端口25</li>
<li><code>POP3</code>：端口110</li>
<li><code>IMAP</code>：端口143</li>
</ul>
<p>由于这些服务广泛地被用于许多网络应用，所以这些端口号被称为“知名端口”。这些端口的分配和维护由互联网号码分配局（<code>Internet Assigned Numbers Authority</code>，简称<code>IANA</code>）进行。</p>
<p>需要注意的是，除了这些知名端口，其他的端口也可以被任何应用程序使用，只要它们具备了适当的权限和配置。对于某些特定的应用程序，开发者可能会选择在1024-49151的范围内选择一个注册端口（<code>Registered Ports</code>），或者在49152–65535的范围内选择一个动态或私有端口（<code>Dynamic or Private Ports</code>）。</p>
<h5 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a><code>signal</code>函数</h5><p>在网络编程中，<code>signal</code>函数是一个非常重要的函数，它被用于设置处理特定信号的函数。</p>
<p>信号（<code>signal</code>）是一种在 <code>Unix</code> 系统（包括 <code>Linux</code>）中用于进程间通信的方式。它类似于一个异步的中断，当一个进程接收到一个信号时，操作系统会暂停该进程的正常执行流程，并去执行与该信号关联的处理函数。</p>
<p><code>signal</code>函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> signum, <span class="type">void</span> (*handler)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<p>这个函数接收两个参数：</p>
<ol>
<li><p><code>signum</code>：这是一个整数，表示信号的类型。例如，<code>SIGINT</code>表示中断信号（通常是用户按下了<code>Ctrl+C</code>），<code>SIGABRT</code>表示一个异常条件，等等。</p>
</li>
<li><p><code>handler</code>：这是一个函数指针，指向用于处理这个信号的函数。处理函数的原型应该为<code>void func(int)</code>，也就是说，它应该是一个接收整数参数并且没有返回值的函数。你可以提供自己的处理函数，也可以使用两个预定义的值：<code>SIG_IGN</code>表示忽略这个信号，<code>SIG_DFL</code>表示使用系统默认的处理方式。</p>
</li>
</ol>
<p><code>signal</code>函数的返回值是一个函数指针，它指向之前设置的处理函数（如果有的话）。如果函数执行失败，那么返回的将是<code>SIG_ERR</code>。</p>
<p>需要注意的是，<code>signal</code>函数并不是 <code>POSIX</code> 标准的一部分，不同的系统可能会有不同的行为。在进行跨平台编程时，通常建议使用<code>sigaction</code>函数代替<code>signal</code>，因为<code>sigaction</code>提供了更多的控制选项，并且它的行为在不同的系统上更加一致。</p>
<p><code>SIGINT</code>、<code>SIGABRT</code>等都是预定义的宏，这些宏在<code>signal.h</code>或者其他相关的头文件中定义，它们的值是整数。例如，在许多系统中，<code>SIGINT</code>的值是2，但这个值并不是在所有系统中都一样。</p>
<p>这些宏名（例如<code>SIGINT</code>）只是为了在代码中更好地表示不同的信号，使得代码更易于理解。实际上，当我们在代码中写<code>SIGINT</code>时，编译器会将其替换为对应的整数值。</p>
<p>所以，当我们调用<code>signal(SIGINT, handler)</code>时，我们实际上是在说：“我想将处理<code>SIGINT</code>信号的函数设置为<code>handler</code>。”这里的<code>SIGINT</code>在被编译器处理后，就是一个整数值，代表了中断信号。</p>
<h5 id="telnet命令"><a href="#telnet命令" class="headerlink" title="telnet命令"></a><code>telnet</code>命令</h5><p><code>telnet</code>是一个网络协议和一个用于在互联网或局域网上执行此协议的命令行工具。它基于文本，主要用于远程管理网络设备和运行服务器端应用。然而，请注意，由于<code>telnet</code>不提供任何加密的方式，所以任何通过<code>telnet</code>发送的数据，包括密码，都是明文的，因此它已经被认为是不安全的，并且在许多新的系统和设备中已经被<code>SSH（Secure Shell）</code>所取代。</p>
<p>基本的<code>telnet</code>命令的语法如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet [host] [port]</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><p><code>host</code>：这是你想要连接的远程主机的IP地址或主机名。例如，如果你想要连接到位于<code>192.168.1.1</code>的主机，你可以输入<code>telnet 192.168.1.1</code>。</p>
</li>
<li><p><code>port</code>：这是你想要连接到的远程服务的端口号。这个参数是可选的，如果你不提供，<code>telnet</code>会默认连接到端口23，这是Telnet协议的标准端口。例如，如果你想要测试一个位于<code>192.168.1.1</code>的主机的80端口（通常是HTTP服务器），你可以输入<code>telnet 192.168.1.1 80</code>。</p>
</li>
</ul>
<p>在<code>telnet</code>连接建立之后，你可以输入任何文本并按Enter键发送。当你想要断开连接时，你可以输入特殊的<code>telnet</code>命令，这通常是<code>Ctrl+]</code>（输入<code>Ctrl</code>和<code>]</code>键），然后输入<code>quit</code>。</p>
<h4 id="webServer服务器整体描述"><a href="#webServer服务器整体描述" class="headerlink" title="webServer服务器整体描述"></a>webServer服务器整体描述</h4><p>本项目主要目的就是对浏览器的链接请求进行处理并给予相应响应。对于请求的处理，系统整体运行流程为：主线程对I&#x2F;O进行监听，获取I&#x2F;O请求后把请求放入请求队列，等待工作线程处理。工作线程对于请求的处理（HTTP报文的解析）主要采用状态机思想来解析HTTP报文的解析。</p>
<h4 id="多路I-x2F-O复用"><a href="#多路I-x2F-O复用" class="headerlink" title="多路I&#x2F;O复用"></a>多路I&#x2F;O复用</h4><p>多路 I&#x2F;O 复用的基本概念是，一个进程使用一个线程来监控多个文件描述符（通常是套接字描述符），当其中任何一个文件描述符准备好进行读或写操作时，该线程就可以进行相应的处理。这样，一个线程就可以同时处理多个 I&#x2F;O 事件，提高了系统的并发性。常用的多路 I&#x2F;O 复用的系统调用有 <code>select</code>、<code>poll</code>、<code>epoll</code>。</p>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p><code>select</code>是Unix&#x2F;Linux系统下的一种I&#x2F;O多路复用机制。它允许应用程序监视多个文件描述符，等待一个或多个描述符成为就绪状态，以进行I&#x2F;O操作（例如读或写）。这是一种异步I&#x2F;O模型，因为你不需要阻塞等待单个I&#x2F;O操作的完成。</p>
<p><code>select</code>的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><code>nfds</code>：需要监视的文件描述符数量，通常设置为所监视文件描述符中的最大值加1。</li>
<li><code>readfds</code>：需要监视读状态的文件描述符集合。</li>
<li><code>writefds</code>：需要监视写状态的文件描述符集合。</li>
<li><code>exceptfds</code>：需要监视异常状态的文件描述符集合。</li>
<li><code>timeout</code>：等待就绪的最长时间。如果设为NULL，则表示无限等待。</li>
</ul>
<p><code>select</code>函数返回准备好的文件描述符的数量，如果超时则返回0，如果出错则返回-1。</p>
<p><code>fd_set</code>是一种数据结构，用于存储文件描述符集合。你可以使用以下的宏来操作这个集合：</p>
<ul>
<li><code>FD_ZERO(fd_set *fdset)</code>: 清除一个文件描述符集合。</li>
<li><code>FD_SET(int fd, fd_set *fdset)</code>: 添加一个新的文件描述符到集合中。</li>
<li><code>FD_CLR(int fd, fd_set *fdset)</code>: 从集合中移除一个文件描述符。</li>
<li><code>FD_ISSET(int fd, fd_set *fdset)</code>: 检查集合中的一个文件描述符是否就绪。</li>
</ul>
<p>注意，在调用<code>select</code>函数后，这些集合会被修改，只包含那些状态发生变化（即准备好进行读或写操作）的文件描述符。因此，如果你想要在一个循环中重复使用<code>select</code>，你需要在每次调用<code>select</code>前重新设置这些集合。</p>
<p>虽然<code>select</code>在一些场景下非常有用，但是它有一些已知的限制，例如最大的文件描述符数量（通常是1024），以及处理大量文件描述符时的效率问题。在这些情况下，你可能需要使用其他的I&#x2F;O多路复用机制，例如<code>poll</code>或<code>epoll</code>。</p>
<h5 id="tip：这是一种异步I-x2F-O模型，因为你不需要阻塞等待单个I-x2F-O操作的完成。"><a href="#tip：这是一种异步I-x2F-O模型，因为你不需要阻塞等待单个I-x2F-O操作的完成。" class="headerlink" title="tip：这是一种异步I&#x2F;O模型，因为你不需要阻塞等待单个I&#x2F;O操作的完成。"></a>tip：这是一种异步I&#x2F;O模型，因为你不需要阻塞等待单个I&#x2F;O操作的完成。</h5><p>当我们说一个I&#x2F;O操作是“阻塞”的，这意味着执行这个操作的线程或进程在操作完成之前会被挂起。例如，如果你在一个阻塞的套接字上执行读操作，而这个套接字当前并没有接收到任何数据，那么执行读操作的线程就会被挂起，直到有数据到达。在这个过程中，线程不能做任何其他的事情。</p>
<p>相反，“非阻塞”的I&#x2F;O操作意味着即使操作不能立即完成，执行这个操作的线程或进程也不会被挂起。例如，如果你在一个非阻塞的套接字上执行读操作，而这个套接字当前并没有接收到任何数据，那么读操作会立即返回一个错误，而线程可以继续做其他的事情。</p>
<p>I&#x2F;O多路复用（例如select、poll或epoll）提供了一种异步的I&#x2F;O模型。在这个模型中，你可以同时监视多个文件描述符，并在任何一个描述符准备好进行I&#x2F;O操作时得到通知。这样，你就可以在等待I&#x2F;O操作的同时做其他的事情，或者同时处理多个I&#x2F;O操作。这就是为什么我们说这是一个“异步”的模型：你不需要为每个I&#x2F;O操作分别阻塞等待。</p>
<p>例如，在上述select的例子中，服务器可以同时处理多个客户端的请求。当任何一个客户端的套接字准备好进行读操作（即有数据到达）时，select函数就会返回，然后服务器可以读取这个套接字上的数据。在这个过程中，服务器并不需要为每个客户端分别阻塞等待。</p>
<p>通俗解释一下：</p>
<p>你想从你家到县城去，阻塞方式是：你去车站等车，等车期间你哪也不能去，就干等到车来；非阻塞方式，你在家等车，这期间你想干啥就干啥，等车来了，司机会滴喇叭，跟你说快上车。</p>
<h4 id="让我们通过一个简单的服务器代码示例来进一步理解select的使用。这个示例是一个TCP回显服务器，它使用select来同时处理多个客户端的连接和请求。"><a href="#让我们通过一个简单的服务器代码示例来进一步理解select的使用。这个示例是一个TCP回显服务器，它使用select来同时处理多个客户端的连接和请求。" class="headerlink" title="让我们通过一个简单的服务器代码示例来进一步理解select的使用。这个示例是一个TCP回显服务器，它使用select来同时处理多个客户端的连接和请求。"></a>让我们通过一个简单的服务器代码示例来进一步理解<code>select</code>的使用。这个示例是一个TCP回显服务器，它使用<code>select</code>来同时处理多个客户端的连接和请求。</h4><p>这是一个非常基础的示例，它没有处理一些可能的错误情况，例如文件描述符耗尽，以及<code>select</code>的最大文件描述符限制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    listen(listen_fd, MAX_CLIENTS);</span><br><span class="line"></span><br><span class="line">    fd_set read_fds;</span><br><span class="line">    <span class="type">int</span> max_fd = listen_fd;</span><br><span class="line">    <span class="type">int</span> clients[MAX_CLIENTS] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        FD_ZERO(&amp;read_fds);</span><br><span class="line">        FD_SET(listen_fd, &amp;read_fds);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clients[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                FD_SET(clients[i], &amp;read_fds);</span><br><span class="line">                <span class="keyword">if</span> (clients[i] &gt; max_fd) &#123;</span><br><span class="line">                    max_fd = clients[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        select(max_fd + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(listen_fd, &amp;read_fds)) &#123;</span><br><span class="line">            <span class="type">int</span> client_fd = accept(listen_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (clients[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    clients[i] = client_fd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clients[i] &gt; <span class="number">0</span> &amp;&amp; FD_ISSET(clients[i], &amp;read_fds)) &#123;</span><br><span class="line">                <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">                <span class="type">int</span> len = read(clients[i], buffer, BUFFER_SIZE - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Received from client: %s\n&quot;</span>, buffer);</span><br><span class="line">                    write(clients[i], buffer, len);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    close(clients[i]);</span><br><span class="line">                    clients[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序首先创建一个监听套接字，然后进入一个无限循环，在循环中调用<code>select</code>函数等待新的连接或者已连接的客户端的请求。每次循环都会重新设置文件描述符集合，添加监听套接字以及所有已连接的客户端的套接字。</p>
<p>如果<code>select</code>函数返回并指示监听套接字已经准备好（有新的连接请求），程序就接受新的连接，并把新的客户端套接字添加到客户端数组中。</p>
<p>如果<code>select</code>函数返回并指示某个客户端套接字已经准备好（有新的数据到达），程序就</p>
<p>读取这个套接字上的数据，然后回显（即原样返回）这些数据。如果读取操作返回0或负值（表示连接已经关闭或出错），程序就关闭这个套接字，并把它从客户端数组中移除。</p>
<p>这个示例展示了如何使用<code>select</code>处理多个客户端的连接和请求。然而在实际的程序中，你需要处理更多的问题，例如<code>select</code>的最大文件描述符限制，以及文件描述符耗尽的问题。在处理大量连接时，你可能需要考虑使用其他的I&#x2F;O多路复用技术，例如<code>poll</code>或<code>epoll</code>。</p>
<h5 id="max-fd到底有啥作用呢？select函数第一个参数我为啥感觉没啥作用呢？"><a href="#max-fd到底有啥作用呢？select函数第一个参数我为啥感觉没啥作用呢？" class="headerlink" title="max_fd到底有啥作用呢？select函数第一个参数我为啥感觉没啥作用呢？"></a>max_fd到底有啥作用呢？select函数第一个参数我为啥感觉没啥作用呢？</h5><p><code>select</code>函数的第一个参数，即<code>nfds</code>，表示需要监视的文件描述符的范围，它的值应该是所有文件描述符中最大的那个加1。</p>
<p>为什么需要最大文件描述符呢？</p>
<p>原因是<code>select</code>函数在内部实现时会遍历所有的文件描述符，从0到<code>nfds - 1</code>。**<code>select</code>函数将检查这个范围内的每一个文件描述符，看看它是否在<code>readfds</code>、<code>writefds</code>或<code>exceptfds</code>集合中，并且它的状态是否发生了变化（即是否准备好进行读、写或者是否有异常）**。</p>
<p>实际上，<code>select</code>不关心文件描述符是否连续，它只是检查你指定的范围内的每一个文件描述符。因此，如果你的程序中最大的文件描述符是10，那么你就应该把<code>nfds</code>设为11，即使你的程序并没有使用文件描述符0到9。</p>
<p>在设置<code>nfds</code>时，使用最大文件描述符加1是一个优化的选择。如果你把<code>nfds</code>设得过大，<code>select</code>函数就会浪费时间去检查那些并不存在的文件描述符。反之，如果你把<code>nfds</code>设得过小，<code>select</code>函数就会忽略那些超出范围的文件描述符，即使它们在<code>readfds</code>、<code>writefds</code>或<code>exceptfds</code>集合中，并且状态发生了变化。</p>
<p>因此，<code>max_fd</code>在这里的作用就是帮助我们正确地设置<code>select</code>函数的<code>nfds</code>参数，以便让<code>select</code>函数高效地监视我们关心的所有文件描述符。</p>
<h5 id="代码里面貌似自始至终也没体现select函数的作用，因为连select函数的返回值都没用上，就好比现在select现在监听1-2-3-4-5-6这6个文件描述符，假设5准备就绪了，我怎么知道5准备就绪了呢，在你的代码貌似并没有体现出来"><a href="#代码里面貌似自始至终也没体现select函数的作用，因为连select函数的返回值都没用上，就好比现在select现在监听1-2-3-4-5-6这6个文件描述符，假设5准备就绪了，我怎么知道5准备就绪了呢，在你的代码貌似并没有体现出来" class="headerlink" title="代码里面貌似自始至终也没体现select函数的作用，因为连select函数的返回值都没用上，就好比现在select现在监听1 2 3 4 5 6这6个文件描述符，假设5准备就绪了，我怎么知道5准备就绪了呢，在你的代码貌似并没有体现出来"></a>代码里面貌似自始至终也没体现select函数的作用，因为连select函数的返回值都没用上，就好比现在select现在监听1 2 3 4 5 6这6个文件描述符，假设5准备就绪了，我怎么知道5准备就绪了呢，在你的代码貌似并没有体现出来</h5><p>实际上，当<code>select</code>函数返回后，我们可以通过检查<code>read_fds</code>集合来确定哪些文件描述符已经准备就绪。</p>
<p>具体来说，如果<code>FD_ISSET(fd, &amp;read_fds)</code>为真，那么就表示<code>fd</code>已经准备好进行读操作。在我的示例代码中，这个检查分别在处理监听套接字和客户端套接字时进行。</p>
<p>如果<code>select</code>函数指示监听套接字已经准备好（有新的连接请求），那么我们就接受新的连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (FD_ISSET(listen_fd, &amp;read_fds)) &#123;</span><br><span class="line">    <span class="type">int</span> client_fd = accept(listen_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 添加新的客户端到 clients 数组...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>select</code>函数指示某个客户端套接字已经准备好（有新的数据到达），那么我们就读取这个套接字上的数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (clients[i] &gt; <span class="number">0</span> &amp;&amp; FD_ISSET(clients[i], &amp;read_fds)) &#123;</span><br><span class="line">        <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">        <span class="type">int</span> len = read(clients[i], buffer, BUFFER_SIZE - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 处理读取到的数据...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例代码的目的是展示<code>select</code>函数如何用于处理多个连接和请求。在实际的应用中，你可能还需要处理更多的情况，例如写就绪和异常，以及<code>select</code>函数的返回值（表示已经准备就绪的文件描述符的数量）。</p>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>有了select的基础，理解poll起来就方便一点啦。<code>poll</code>函数是另一种I&#x2F;O多路复用的技术。与<code>select</code>相比，它的主要优点是没有文件描述符的数量限制，而且API使用起来可能更加直观。<code>poll</code>函数使用一个<code>pollfd</code>结构体数组，其中每个结构体都包含一个文件描述符和一些标志位，表示我们对哪些事件感兴趣（例如POLLIN表示我们对读事件感兴趣）。</p>
<p>下面是一个简单的使用<code>poll</code>的服务器代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_CLIENTS 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    servaddr.sin_port = htons(<span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line">    bind(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));</span><br><span class="line"></span><br><span class="line">    listen(listen_fd, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">clients</span>[<span class="title">MAX_CLIENTS</span>];</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">        clients[i].fd = <span class="number">-1</span>; <span class="comment">// -1表示该位置没有使用</span></span><br><span class="line">        clients[i].events = POLLIN; <span class="comment">// 对读事件感兴趣</span></span><br><span class="line">    &#125;</span><br><span class="line">    clients[<span class="number">0</span>].fd = listen_fd; <span class="comment">// 监听套接字始终在clients[0]的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> nready = poll(clients, MAX_CLIENTS, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clients[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">            <span class="comment">// 监听套接字准备好了，表示有新的连接请求</span></span><br><span class="line">            <span class="type">int</span> client_fd = accept(listen_fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 将新的连接添加到clients数组中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (clients[i].fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    clients[i].fd = client_fd;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAX_CLIENTS; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (clients[i].fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (clients[i].revents &amp; (POLLIN | POLLERR)) &#123;</span><br><span class="line">                <span class="comment">// 客户端套接字准备好了，表示有数据可以读取</span></span><br><span class="line">                <span class="type">char</span> buffer[BUFFER_SIZE];</span><br><span class="line">                <span class="type">int</span> len = read(clients[i].fd, buffer, BUFFER_SIZE - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 连接已经关闭或出错，将该客户端从数组中移除</span></span><br><span class="line">                    close(clients[i].fd);</span><br><span class="line">                    clients[i].fd = <span class="number">-1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 将接收到的数据回显给客户端</span></span><br><span class="line">                    write(clients[i].fd, buffer, len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，服务器使用<code>poll</code>函数同时监视所有连接的客户端套接字。每次当<code>poll</code>函数返回时，服务器会检查哪些套接字已经准备好进行I&#x2F;O操作，并相应地处理它们。</p>
<h5 id="clients-0-revents-amp-POLLIN这个代表啥意思"><a href="#clients-0-revents-amp-POLLIN这个代表啥意思" class="headerlink" title="clients[0].revents &amp; POLLIN这个代表啥意思"></a>clients[0].revents &amp; POLLIN这个代表啥意思</h5><p>这是在检查<code>poll</code>函数返回后哪些文件描述符发生了事件。</p>
<p><code>clients[0].revents &amp; POLLIN</code>这个表达式使用了位运算符<code>&amp;</code>来检查<code>revents</code>字段的某个特定位（在这个例子中是<code>POLLIN</code>位）是否被设置。如果结果非零，那么说明<code>POLLIN</code>事件发生了，也就是说对应的文件描述符已经准备好进行读操作。</p>
<p>这里的<code>POLLIN</code>是一个常量，表示可以从文件描述符中读取数据。<code>revents</code>字段则是<code>poll</code>函数返回后设置的，表示在调用<code>poll</code>函数期间，哪些事件发生了。</p>
<p>如果<code>clients[0].revents &amp; POLLIN</code>为真，那么就表示监听套接字已经准备好，我们可以从这个套接字上接受新的连接。</p>
<h5 id="这个能不能给出一个实例，不太理解"><a href="#这个能不能给出一个实例，不太理解" class="headerlink" title="这个能不能给出一个实例，不太理解"></a>这个能不能给出一个实例，不太理解</h5><p>当然可以，让我们试着用一个简单的例子来理解这个概念。</p>
<p>首先，我们要知道<code>POLLIN</code>和<code>revents</code>都是整型（int）变量，也就是说，它们都可以表示为二进制数。</p>
<p>假设<code>POLLIN</code>的值是4，也就是二进制的<code>100</code>，而<code>revents</code>的值是5，也就是二进制的<code>101</code>。</p>
<p>我们用<code>&amp;</code>（位运算符AND）来对这两个值进行操作，得到的结果是<code>100</code>，也就是4，非零值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  POLLIN:  100 (二进制)</span><br><span class="line">  revents: 101 (二进制)</span><br><span class="line">----------------------</span><br><span class="line">  结果:    100 (二进制) = 4 (十进制)</span><br></pre></td></tr></table></figure>

<p>这个结果是非零的，所以<code>if (clients[0].revents &amp; POLLIN)</code>的判断结果是真。这就表示<code>revents</code>的<code>POLLIN</code>位被设置了，也就是说，对应的文件描述符已经准备好进行读操作了。</p>
<p>如果<code>revents</code>的值是2（二进制<code>010</code>），那么结果就是零：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  POLLIN:  100 (二进制)</span><br><span class="line">  revents: 010 (二进制)</span><br><span class="line">----------------------</span><br><span class="line">  结果:    000 (二进制) = 0 (十进制)</span><br></pre></td></tr></table></figure>

<p>这个结果是零，所以<code>if (clients[0].revents &amp; POLLIN)</code>的判断结果是假。这就表示<code>revents</code>的<code>POLLIN</code>位没有被设置，也就是说，对应的文件描述符还没有准备好进行读操作。</p>
<p>所以，这个表达式就是在检查<code>revents</code>是否表示文件描述符已经准备好进行读操作。</p>
<h5 id="recv函数"><a href="#recv函数" class="headerlink" title="recv函数"></a><code>recv</code>函数</h5><p>在<code>socket</code>编程中，<code>recv</code>函数的返回值有以下三种情况：</p>
<ol>
<li><p>当<code>recv</code>函数返回0时，表示连接已经关闭，也就是说，另一端已经执行了<code>close</code>操作。</p>
</li>
<li><p>当<code>recv</code>函数返回-1时，表示接收数据时发生了错误，你可以通过检查全局变量<code>errno</code>来确定具体的错误类型。在非阻塞模式下，如果没有可读取的数据，<code>recv</code>函数也会返回-1，并且<code>errno</code>会被设置为<code>EAGAIN</code>或者<code>EWOULDBLOCK</code>。</p>
</li>
<li><p>如果返回值大于0，表示成功接收到了数据。</p>
</li>
</ol>
<p>在你给出的代码中，<code>if (ret &lt;= 0)</code>这个判断语句实际上就是在处理以上的前两种情况。也就是说，如果连接已经关闭，或者在接收数据时发生了错误，就关闭<code>socket</code>。</p>
<p>在你的例子中，<code>ret=0</code>实际上并不是代表LT模式下未响应此事件，而是表示对端关闭了连接。因此，关闭这个<code>socket</code>是合理的，因为这个连接已经没有用了。即使接收缓冲区里还有未读取的数据，这些数据也无法被发送到已经关闭的对端，所以就没有必要保持这个<code>socket</code>打开了。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/c/" rel="tag"># c++</a>
              <a href="/tags/Linux/" rel="tag"># Linux</a>
              <a href="/tags/webServer/" rel="tag"># webServer</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/04/22/%E7%AC%AC%E4%BA%8C%E7%AF%87%E5%8D%9A%E5%AE%A2/" rel="prev" title="构造函数">
                  <i class="fa fa-angle-left"></i> 构造函数
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/04/27/%E7%AC%AC%E4%B8%89%E7%AF%87%E5%8D%9A%E5%AE%A2/" rel="next" title="第三篇博客">
                  第三篇博客 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">GGBond</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"cdn":"https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML","tags":"none","src":"custom_mathjax_source","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>

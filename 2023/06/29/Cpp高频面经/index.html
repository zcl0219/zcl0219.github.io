<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar-16.png">
  <link rel="mask-icon" href="/images/emoji-smile.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zcl0219.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null,"show_result":true},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="new和malloc的区别 属性的区别 new&#x2F;delete：这两个是C++中的关键字； malloc&#x2F;free：这两个是库函数；  使用上的区别 malloc：申请空间需要显式填入申请内存的大小； new：无需显式填入申请内存的大小，new会根据new的类型分配内存；  返回类型的区别 new操作符内存分配成功，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，故">
<meta property="og:type" content="article">
<meta property="og:title" content="Cpp高频面经">
<meta property="og:url" content="http://zcl0219.github.io/2023/06/29/Cpp%E9%AB%98%E9%A2%91%E9%9D%A2%E7%BB%8F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="new和malloc的区别 属性的区别 new&#x2F;delete：这两个是C++中的关键字； malloc&#x2F;free：这两个是库函数；  使用上的区别 malloc：申请空间需要显式填入申请内存的大小； new：无需显式填入申请内存的大小，new会根据new的类型分配内存；  返回类型的区别 new操作符内存分配成功，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，故">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://zcl0219.github.io/2023/06/29/Cpp%E9%AB%98%E9%A2%91%E9%9D%A2%E7%BB%8F/png1.gif">
<meta property="article:published_time" content="2023-06-28T19:50:53.000Z">
<meta property="article:modified_time" content="2023-10-09T08:26:33.676Z">
<meta property="article:author" content="GGBond">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://zcl0219.github.io/2023/06/29/Cpp%E9%AB%98%E9%A2%91%E9%9D%A2%E7%BB%8F/png1.gif">


<link rel="canonical" href="http://zcl0219.github.io/2023/06/29/Cpp%E9%AB%98%E9%A2%91%E9%9D%A2%E7%BB%8F/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://zcl0219.github.io/2023/06/29/Cpp%E9%AB%98%E9%A2%91%E9%9D%A2%E7%BB%8F/","path":"2023/06/29/Cpp高频面经/","title":"Cpp高频面经"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Cpp高频面经 | Hexo</title>
  







<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap" rel="stylesheet">

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#new%E5%92%8Cmalloc%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">new和malloc的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">如何避免内存泄漏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%95%B0%E9%87%8F%E4%B8%80%E8%88%AC%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE"><span class="nav-number">3.</span> <span class="nav-text">线程池的数量一般怎么设置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9D%A5%E4%BA%86%E4%B8%80%E4%B8%AA%E6%96%B0%E4%BB%BB%E5%8A%A1%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%88%E6%9C%AC%E7%AD%94%E6%A1%88%E6%9C%89%E5%BE%85%E5%95%86%E6%A6%B7%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">来了一个新任务，线程池是怎么工作的（本答案有待商榷）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="nav-number">5.</span> <span class="nav-text">完美转发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8E%BB%E6%8E%89std-forward%E4%BC%9A%E5%92%8B%E6%A0%B7"><span class="nav-number">6.</span> <span class="nav-text">去掉std::forward会咋样</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8BC-%E4%B8%AD%E7%9A%84%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">7.</span> <span class="nav-text">讲一下C++中的虚继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">基类的析构函数为什么是虚函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#struct%E5%92%8Cunion%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%BB%98%E5%86%99%EF%BC%89"><span class="nav-number">9.</span> <span class="nav-text">struct和union的区别（默写）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80-x2F-%E7%A8%8B%E5%BA%8F%E5%88%86%E6%AE%B5%EF%BC%88%E9%BB%98%E5%86%99%EF%BC%89"><span class="nav-number">10.</span> <span class="nav-text">C++内存布局&#x2F;程序分段（默写）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3shared-ptr%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%AE%A9%E4%BD%A0%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAshared-ptr%EF%BC%8C%E4%BD%A0%E4%BC%9A%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1"><span class="nav-number">11.</span> <span class="nav-text">了解shared_ptr吗？如果让你手写一个shared_ptr，你会怎么设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BTCP%EF%BC%8CTCP%E7%B2%98%E5%8C%85%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">12.</span> <span class="nav-text">介绍一下TCP，TCP粘包如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">13.</span> <span class="nav-text">回调函数是什么，回调函数的本质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">14.</span> <span class="nav-text">进程和线程的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">15.</span> <span class="nav-text">GET和POST的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E5%92%8CHTTPS"><span class="nav-number">16.</span> <span class="nav-text">HTTP和HTTPS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">17.</span> <span class="nav-text">C++ 11新特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">18.</span> <span class="nav-text">lambda表达式的使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">19.</span> <span class="nav-text">vector迭代器失效的原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#map%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">20.</span> <span class="nav-text">map的底层数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unordered-map%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">21.</span> <span class="nav-text">unordered_map底层数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E6%8F%A1%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%A1%8C%E5%91%A2"><span class="nav-number">22.</span> <span class="nav-text">TCP握手为什么是三次握手，两次握手为什么不行呢</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">23.</span> <span class="nav-text">HTTP状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E4%BA%86%EF%BC%8C%E6%99%AE%E9%80%9A%E6%8C%87%E9%92%88%E8%BF%98%E8%83%BD%E7%94%A8%E5%90%97%EF%BC%9F"><span class="nav-number">24.</span> <span class="nav-text">使用智能指针了，普通指针还能用吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E6%99%AE%E9%80%9A%E6%8C%87%E9%92%88-%EF%BC%88CHATGPT%EF%BC%89"><span class="nav-number">25.</span> <span class="nav-text">什么时候使用智能指针，什么时候使用普通指针 （CHATGPT）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hash-map%E5%8E%9F%E7%90%86"><span class="nav-number">26.</span> <span class="nav-text">Hash_map原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%A4%9A%E6%80%81%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B"><span class="nav-number">27.</span> <span class="nav-text">C++多态介绍一下</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%8E%9F%E7%90%86%EF%BC%8C%E8%99%9A%E8%A1%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BB%BA%E7%AB%8B%E7%9A%84https-zhuanlan-zhihu-com-p-37331092"><span class="nav-number">28.</span> <span class="nav-text">虚函数、纯虚函数原理，虚表什么时候建立的	https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;37331092</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"><span class="nav-number">29.</span> <span class="nav-text">构造函数和析构函数可以是虚函数吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#map%E4%B8%BA%E5%95%A5%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8D%E7%94%A8avl%E6%A0%91%EF%BC%9F"><span class="nav-number">30.</span> <span class="nav-text">map为啥用红黑树不用avl树？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%ADmap%E9%87%8Ckey%E5%80%BC%E5%AD%98%E4%B8%8D%E5%AD%98%E5%9C%A8"><span class="nav-number">31.</span> <span class="nav-text">怎么判断map里key值存不存在</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">32.</span> <span class="nav-text">多进程通信方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">33.</span> <span class="nav-text">TCP和UDP的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-x2F-IP%E5%8D%8F%E8%AE%AE%E7%BB%84"><span class="nav-number">34.</span> <span class="nav-text">TCP&#x2F;IP协议组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#OSI%E4%B8%83%E5%B1%82"><span class="nav-number">35.</span> <span class="nav-text">OSI七层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#socket%E7%BC%96%E7%A8%8Brecv%E5%87%BD%E6%95%B0"><span class="nav-number">36.</span> <span class="nav-text">socket编程recv函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">37.</span> <span class="nav-text">排序算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81-1"><span class="nav-number">38.</span> <span class="nav-text">HTTP状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="nav-number">39.</span> <span class="nav-text">DNS解析过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%8C%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">40.</span> <span class="nav-text">TCP为什么需要四次挥手，三次挥手有什么问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E4%BC%A0%E8%BE%93%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%9D%A0%E7%9A%84"><span class="nav-number">41.</span> <span class="nav-text">TCP传输为什么是可靠的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">42.</span> <span class="nav-text">线程的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">43.</span> <span class="nav-text">死锁产生的条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">44.</span> <span class="nav-text">死锁解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91%E7%9A%84%E7%9F%A5%E8%AF%86"><span class="nav-number">45.</span> <span class="nav-text">树的知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux-API%E8%B0%83%E7%94%A8%E8%BF%94%E5%9B%9E%E5%80%BC%E6%B1%87%E6%80%BB"><span class="nav-number">46.</span> <span class="nav-text">Linux API调用返回值汇总</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DNS%E7%9A%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="nav-number">47.</span> <span class="nav-text">DNS的解析过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E4%BC%A0%E8%BE%93%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%9D%A0%E7%9A%84-1"><span class="nav-number">48.</span> <span class="nav-text">TCP传输为什么是可靠的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NAT%E5%8D%8F%E8%AE%AE%E5%92%8C%E8%B7%A8%E5%9F%9F%EF%BC%88%E4%B8%8D%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">49.</span> <span class="nav-text">NAT协议和跨域（不了解）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GET%E5%92%8CPOST%E5%8C%BA%E5%88%AB"><span class="nav-number">50.</span> <span class="nav-text">GET和POST区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E4%B8%80%E6%AE%B5%E6%AD%BB%E9%94%81%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="nav-number">51.</span> <span class="nav-text">写一段死锁的代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%B4%E5%B0%BE%E7%A9%BA%E6%A0%BC%E4%BB%A3%E7%A0%81"><span class="nav-number">52.</span> <span class="nav-text">删除字符串头尾空格代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#shared-ptr%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9Fhttps-cloud-tencent-com-developer-article-1654442"><span class="nav-number">53.</span> <span class="nav-text">shared_ptr是线程安全的吗？https:&#x2F;&#x2F;cloud.tencent.com&#x2F;developer&#x2F;article&#x2F;1654442</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mysql%E8%AF%BB%E5%86%99%E9%94%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0-mysql-%E8%AF%BB%E5%86%99%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%ABhttps-blog-51cto-com-u-16099299-7031260"><span class="nav-number">54.</span> <span class="nav-text">mysql读写锁怎么实现 mysql 读写锁和互斥锁的区别	https:&#x2F;&#x2F;blog.51cto.com&#x2F;u_16099299&#x2F;7031260</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#delete%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">55.</span> <span class="nav-text">delete关键字的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#define%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">56.</span> <span class="nav-text">define和const的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E6%97%B6%E6%8B%B7%E8%B4%9D%EF%BC%88COW%EF%BC%89https-www-cnblogs-com-biyeymyhjob-archive-2012-07-20-2601655-html"><span class="nav-number">57.</span> <span class="nav-text">写时拷贝（COW）	https:&#x2F;&#x2F;www.cnblogs.com&#x2F;biyeymyhjob&#x2F;archive&#x2F;2012&#x2F;07&#x2F;20&#x2F;2601655.html</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#coredump%EF%BC%8Cgdb%E6%80%8E%E4%B9%88%E5%AE%9A%E4%BD%8D"><span class="nav-number">58.</span> <span class="nav-text">coredump，gdb怎么定位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll"><span class="nav-number">59.</span> <span class="nav-text">epoll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">60.</span> <span class="nav-text">static的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E5%85%B3static%E7%9A%84%E5%BF%85%E8%A6%81%E8%A1%A5%E5%85%85"><span class="nav-number">61.</span> <span class="nav-text">有关static的必要补充</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">62.</span> <span class="nav-text">三种智能指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#STL%E5%86%85%E5%AD%98%E6%B1%A0%E6%9C%BA%E5%88%B6"><span class="nav-number">63.</span> <span class="nav-text">STL内存池机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E9%80%89B-%E6%A0%91%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">64.</span> <span class="nav-text">索引选B+树的原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AFTIME-WAIT%E8%BF%87%E5%A4%9A%E7%9A%84%E5%8D%B1%E5%AE%B3%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95"><span class="nav-number">65.</span> <span class="nav-text">服务端TIME_WAIT过多的危害及解决办法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#set%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">66.</span> <span class="nav-text">set底层数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mapreduce%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%8D%E6%87%82%EF%BC%8C%E9%A2%84%E7%95%99%EF%BC%89"><span class="nav-number">67.</span> <span class="nav-text">mapreduce原理（不懂，预留）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#socket%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E4%BA%A7%E7%94%9F%E9%98%BB%E5%A1%9E"><span class="nav-number">68.</span> <span class="nav-text">socket哪些操作会产生阻塞</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%B3%E8%AF%B7%E4%B8%80%E5%9D%97%E5%A4%A7%E5%86%85%E5%AD%98%E5%92%8C%E4%B8%80%E5%9D%97%E5%B0%8F%E5%86%85%E5%AD%98%E7%9A%84%E6%95%88%E7%8E%87%E6%98%AF%E4%B8%80%E6%A0%B7%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-number">69.</span> <span class="nav-text">申请一块大内存和一块小内存的效率是一样的吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E6%85%A2%E5%90%AF%E5%8A%A8%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">70.</span> <span class="nav-text">TCP慢启动和拥塞控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%91%E9%80%81%E7%AB%AF%E5%88%A4%E6%96%AD%E5%8F%91%E7%94%9F%E6%8B%A5%E5%A1%9E%E7%9A%84%E4%BE%9D%E6%8D%AE"><span class="nav-number">71.</span> <span class="nav-text">发送端判断发生拥塞的依据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Linux%E4%B8%8B%E7%9A%84POSIX%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">72.</span> <span class="nav-text">Linux下的POSIX互斥锁和条件变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E4%B8%80%E4%B8%AA%E7%94%9F%E4%BA%A7%E8%80%85-x2F-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%EF%BC%88%E9%87%87%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%89"><span class="nav-number">73.</span> <span class="nav-text">写一个生产者&#x2F;消费者模型（采用信号量）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">74.</span> <span class="nav-text">基类的析构函数为什么是虚函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E7%B1%BB%E4%B8%8D%E4%BD%BF%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8D%E8%B0%83%E7%94%A8%EF%BC%88%E9%99%A4%E4%BA%86%E5%86%99%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E6%9C%80%E5%A5%BD%E5%86%8D%E5%8A%A0%E4%B8%8A%E6%9C%89%E5%85%B3%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E3%80%81%E6%8C%87%E9%92%88%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%89"><span class="nav-number">75.</span> <span class="nav-text">为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%BC%95%E7%94%A8"><span class="nav-number">76.</span> <span class="nav-text">拷贝构造函数为什么要用引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B7%A6%E5%8F%B3%E5%80%BC%E7%9A%84%E5%B7%AE%E5%88%AB"><span class="nav-number">77.</span> <span class="nav-text">左右值的差别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E4%B8%AD%E7%9A%84%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">78.</span> <span class="nav-text">C++中的虚继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E4%B8%AD%E7%9A%84forward%E5%87%BD%E6%95%B0"><span class="nav-number">79.</span> <span class="nav-text">C++中的forward函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%ADTCP%E6%96%AD%E5%BC%80"><span class="nav-number">80.</span> <span class="nav-text">如何判断TCP断开</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BF%9B%E7%A8%8B%E6%95%B0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%95%B0"><span class="nav-number">81.</span> <span class="nav-text">如何查看系统的最大进程数和线程数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#git-rebase%E5%92%8Cgit-merge%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88https-joyohub-com-2020-04-06-git-rebase-%EF%BC%89"><span class="nav-number">82.</span> <span class="nav-text">git rebase和git merge的区别（https:&#x2F;&#x2F;joyohub.com&#x2F;2020&#x2F;04&#x2F;06&#x2F;git-rebase&#x2F;）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-calss-%E5%92%8C-struct%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">83.</span> <span class="nav-text">C++ calss 和 struct的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">84.</span> <span class="nav-text">指针和引用的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9E%E7%8E%B0%E4%B8%8D%E8%83%BD%E5%88%86%E5%88%AB%E5%86%99%E5%9C%A8-h%E6%96%87%E4%BB%B6%E5%92%8C-cpp%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="nav-number">85.</span> <span class="nav-text">为什么模板类的声明和实现不能分别写在.h文件和.cpp文件中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">86.</span> <span class="nav-text">动态链接与静态链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pragma-pack%E7%BC%96%E8%AF%91%E5%AE%8F"><span class="nav-number">87.</span> <span class="nav-text">pragma pack编译宏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#vector%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">88.</span> <span class="nav-text">vector底层实现原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="nav-number">89.</span> <span class="nav-text">常量指针和指针常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E4%B8%AD%E4%B8%80%E4%BA%9B%E7%89%B9%E5%88%AB%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88default%EF%BC%8Coverride%E3%80%81final%E3%80%81volatile%EF%BC%89"><span class="nav-number">90.</span> <span class="nav-text">C++中一些特别的关键字（default，override、final、volatile）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%9A%E5%B0%8F%E4%BA%8EN%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0"><span class="nav-number">91.</span> <span class="nav-text">字节算法题：小于N的最大数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%90%8C%E6%97%B6%E6%9C%89%E5%A4%A7%E9%87%8F%E5%AE%A2%E6%88%B7%E5%B9%B6%E5%8F%91%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%9C%89%E4%BB%80%E4%B9%88%E6%9C%BA%E5%88%B6%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86"><span class="nav-number">92.</span> <span class="nav-text">如果同时有大量客户并发建立连接，服务器端有什么机制进行处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E5%92%8CTCP%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">93.</span> <span class="nav-text">HTTP和TCP之间的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E4%BB%8E%E8%AF%B7%E6%B1%82%E5%88%B0%E5%BE%97%E5%88%B0%E7%BB%93%E6%9E%9C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">94.</span> <span class="nav-text">HTTP从请求到得到结果的过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#https%E5%92%8Chttp%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8Chttps%E5%85%B7%E4%BD%93%E6%98%AF%E6%80%8E%E4%B9%88%E5%81%9A%E7%9A%84"><span class="nav-number">95.</span> <span class="nav-text">https和http的区别是什么，https具体是怎么做的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#gdb%E4%B8%AD%EF%BC%8C%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E6%AF%8F%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="nav-number">96.</span> <span class="nav-text">gdb中，如何查看每个线程相关的信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%83%BD%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E5%86%99%E7%A8%8B%E5%BA%8F%E9%AA%8C%E8%AF%81%EF%BC%8C%E5%B9%B6%E4%BB%8E%E5%8E%9F%E7%90%86%E4%B8%8A%E5%88%86%E6%9E%90%E5%8E%9F%E5%9B%A0"><span class="nav-number">97.</span> <span class="nav-text">构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">98.</span> <span class="nav-text">迭代器的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">99.</span> <span class="nav-text">epoll红黑树的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E5%88%86%E5%88%AB%E4%BC%9A%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E5%88%87%E6%8D%A2%E7%9A%84"><span class="nav-number">100.</span> <span class="nav-text">用户态和内核态分别会做什么，怎么切换的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E9%9C%80%E8%A6%81%E7%B3%BB%E7%BB%9F%E5%88%86%E9%85%8D%E4%BB%80%E4%B9%88%E8%B5%84%E6%BA%90"><span class="nav-number">101.</span> <span class="nav-text">进程的创建需要系统分配什么资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTPS%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%EF%BC%9A%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E3%80%81%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="nav-number">102.</span> <span class="nav-text">HTTPS加密方式：对称加密、非对称加密</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">103.</span> <span class="nav-text">线程的三种状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E9%87%8C%E8%83%BD%E4%B8%8D%E8%83%BD%E6%8A%9B%E5%BC%82%E5%B8%B8-%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">104.</span> <span class="nav-text">析构函数里能不能抛异常?为什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%A4%E4%B8%AA%E7%B1%BB%E9%87%8C%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E6%88%90%E5%91%98%EF%BC%8C%E5%8C%BA%E5%88%AB%E5%9C%A8%E4%BA%8E%E4%B8%80%E4%B8%AA%E6%9C%89%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%B2%A1%E6%9C%89%EF%BC%8C%E5%93%AA%E4%B8%AA%E5%86%85%E5%AD%98%E5%A4%A7%EF%BC%9F"><span class="nav-number">105.</span> <span class="nav-text">两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%92%8C%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">106.</span> <span class="nav-text">数据报和数据流的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E5%AE%95%E6%9C%BA%E4%BA%86%E5%92%8B%E5%8A%9E%EF%BC%9F"><span class="nav-number">107.</span> <span class="nav-text">在分布式系统中，如果某个节点宕机了咋办？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">108.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">109.</span> <span class="nav-text">线程同步的方式有哪些</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="GGBond"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">GGBond</p>
  <div class="site-description" itemprop="description">Doing the tough things sets winners apart from losers</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zcl0219.github.io/2023/06/29/Cpp%E9%AB%98%E9%A2%91%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="GGBond">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="Doing the tough things sets winners apart from losers">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Cpp高频面经 | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Cpp高频面经
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-06-29 03:50:53" itemprop="dateCreated datePublished" datetime="2023-06-29T03:50:53+08:00">2023-06-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-10-09 16:26:33" itemprop="dateModified" datetime="2023-10-09T16:26:33+08:00">2023-10-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h4 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h4><ul>
<li><p>属性的区别</p>
<p>new&#x2F;delete：这两个是C++中的关键字；</p>
<p>malloc&#x2F;free：这两个是库函数；</p>
</li>
<li><p>使用上的区别</p>
<p>malloc：申请空间需要显式填入申请内存的大小；</p>
<p>new：无需显式填入申请内存的大小，new会根据new的类型分配内存；</p>
</li>
<li><p>返回类型的区别</p>
<p>new操作符内存分配成功，返回的是对象类型的指针，类型严格与对象匹配，无需进行类型转换，故new是符合类型安全性的操作符。</p>
<p>malloc内存分配成功返回的是void*指针，需要通过强制类型转换，转换成我们需要的类型。</p>
<p>所以C++中new比malloc安全可靠。</p>
</li>
<li><p>分配失败的区别</p>
<p>malloc分配失败会返回NULL，我们可以通过判断返回值是否是NULL得知是否分配成功。</p>
<p>new分配失败会抛出bad_alloc异常。</p>
</li>
<li><p>扩张内存的区别</p>
<p>malloc有内存扩张机制（通过realloc实现）。</p>
<p>new没有扩张内存机制。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/338489910">https://zhuanlan.zhihu.com/p/338489910</a></p>
<h4 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h4><ul>
<li>明确动态内存使用范围：在程序中使用动态内存时，需要明确该内存的使用范围，确保在不需要使用该内存时能够及时释放内存。</li>
<li>使用RAII技术：RAII（Resource Acquisition Is Initialization）是C++中一种常用的资源管理技术，它利用了C++对象的构造函数和析构函数自动调用的特性，在对象的构造函数中申请资源，在对象的析构函数中释放资源，从而避免资源泄漏问题。</li>
<li>使用智能指针：智能指针可以自动管理动态内存的分配和释放。</li>
</ul>
<h4 id="线程池的数量一般怎么设置"><a href="#线程池的数量一般怎么设置" class="headerlink" title="线程池的数量一般怎么设置"></a>线程池的数量一般怎么设置</h4><p>线程池中线程数量的设置主要考虑两个方面：</p>
<ul>
<li><p>I&#x2F;O密集型</p>
</li>
<li><p>如果说任务是耗时I&#x2F;O型，比如涉及数据库、文件的读写，网络通信等任务，这种任务的特点是不会特别消耗CPU资源，但是我们需要考虑到I&#x2F;O操作耗时较长。这种情况一般会将线程数设置的比较大，达到了CPU核心数的很多倍。因为如果线程数设置的比较少，会造成CPU计算资源的浪费。</p>
</li>
<li><p>CPU密集型</p>
</li>
<li><p>对于CPU密集型任务，线程数不宜设置的过多，因为过多的线程都会去抢占CPU资源，就会产生不必要的上下文切换，反而会造成整体性能的下降</p>
</li>
</ul>
<p>线程数通用计算公示：线程数 &#x3D; CPU核心数 * (1 + I&#x2F;O耗时 &#x2F; CPU耗时)</p>
<h4 id="来了一个新任务，线程池是怎么工作的（本答案有待商榷）"><a href="#来了一个新任务，线程池是怎么工作的（本答案有待商榷）" class="headerlink" title="来了一个新任务，线程池是怎么工作的（本答案有待商榷）"></a>来了一个新任务，线程池是怎么工作的（本答案有待商榷）</h4><p>当有一个新任务到来时，线程池会先判断是否有空闲线程，如果有，则将任务分配给空闲线程；</p>
<p>如果此时线程池里没有空线程，则先将任务放任务任务队列，待有空闲线程之后，再从任务队列中取出任务。</p>
<h4 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h4><p>在我的理解里，完美转发 &#x3D; std::forward + 万能引用 + 引用折叠。首先引用折叠机制为T&amp;&amp;类型的万能引用中的模板参数T赋予了一个恰到好处的值，而我们用T去指明std::forward的模板参数，从而使得std::forward返回的是正确的类型（这里关于返回的是正确的类型，应该去看std::forward实现的源码，知乎链接如下：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/369203981%EF%BC%89">https://zhuanlan.zhihu.com/p/369203981）</a></p>
<h4 id="去掉std-forward会咋样"><a href="#去掉std-forward会咋样" class="headerlink" title="去掉std::forward会咋样"></a>去掉std::forward会咋样</h4><p>可能会导致在传递参数的时候丢失类型信息，从而导致编译器无法正确推断模板类型或者在模板类型推断中发生错误。</p>
<h4 id="讲一下C-中的虚继承"><a href="#讲一下C-中的虚继承" class="headerlink" title="讲一下C++中的虚继承"></a>讲一下C++中的虚继承</h4><h4 id="基类的析构函数为什么是虚函数？"><a href="#基类的析构函数为什么是虚函数？" class="headerlink" title="基类的析构函数为什么是虚函数？"></a>基类的析构函数为什么是虚函数？</h4><p>如果基类的虚构函数不是虚函数，当我们定义一个父类指针指向子类对象时，最后子类的析构函数不会调用，导致内存泄漏。</p>
<h4 id="struct和union的区别（默写）"><a href="#struct和union的区别（默写）" class="headerlink" title="struct和union的区别（默写）"></a>struct和union的区别（默写）</h4><h4 id="C-内存布局-x2F-程序分段（默写）"><a href="#C-内存布局-x2F-程序分段（默写）" class="headerlink" title="C++内存布局&#x2F;程序分段（默写）"></a>C++内存布局&#x2F;程序分段（默写）</h4><h4 id="了解shared-ptr吗？如果让你手写一个shared-ptr，你会怎么设计"><a href="#了解shared-ptr吗？如果让你手写一个shared-ptr，你会怎么设计" class="headerlink" title="了解shared_ptr吗？如果让你手写一个shared_ptr，你会怎么设计"></a>了解shared_ptr吗？如果让你手写一个shared_ptr，你会怎么设计</h4><p>shared_ptr是智能指针里面的共享指针，即多个指针指向同一个内存。每多一个指针指向这片内存，引用计数加1。当对象的引用计数减少为0时，对象会自动析构，对应内存被自动释放。智能指针是模板类，而不是指针。</p>
<p>设计：将shared_ptr定义为一个模板类，包括两个成员：模板类指针和一个指向引用计数的指针。指向引用计数类型的指针应该包括这些成员函数：增加计数、减少计数、返回现有计数。一个私有成员就是用于计数的变量。共享指针模板类的构造函数接受一个模板类型指针，并且需要声明为explicit，表示必须直接初始化。另外就是拷贝构造函数和移动构造函数。拷贝构造需要注意拷贝的对象的指针是否为nullptr，如果不是nullptr，则需要增加引用计数。移动构造函数需要注意将传入的右值引用对象的指针置空，引用计数清零。析构函数有两个判断条件，第一个最后一个指向对象的指针需要为非nullptr并且此时引用计数减一后为0。然后就是重载*、-&gt;、bool，还有一个函数用于获得指针get()。动态转换（可考虑）。</p>
<h4 id="介绍一下TCP，TCP粘包如何解决"><a href="#介绍一下TCP，TCP粘包如何解决" class="headerlink" title="介绍一下TCP，TCP粘包如何解决"></a>介绍一下TCP，TCP粘包如何解决</h4><p>解决办法：</p>
<ul>
<li>发送端：使用TCP_NODELAY关闭Nagle算法，但是如果不是时延敏感的应用尽量不要关闭</li>
<li>接收端：没法解决，只能交给应用端解决</li>
<li>应用层：有三种解决办法<ul>
<li>只发送固定包长的数据包，但是这个方法基本不用，灵活性太差</li>
<li>指定标识结尾，比如\r\n之类的</li>
<li>包头加包体，包头一般是固定长度，并且里面有一个字段可以告知我们接下来的包体有多大</li>
</ul>
</li>
</ul>
<h4 id="回调函数是什么，回调函数的本质"><a href="#回调函数是什么，回调函数的本质" class="headerlink" title="回调函数是什么，回调函数的本质"></a>回调函数是什么，回调函数的本质</h4><p>回调函数允许我们将一个函数（或函数对象）作为参数传递给另一个函数，并在需要的时候由后者调用执行。回调函数定义了在特定事件或条件满足时应该执行的操作。主调函数是接受回调函数作为参数的函数。</p>
<h4 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h4><ol>
<li>进程<ul>
<li>进程拥有独立内存空间和系统资源</li>
<li>进程之间相互独立，一个进程的崩溃通常不会影响其他进程</li>
<li>创建、销毁和切换进程开销比较大</li>
</ul>
</li>
<li>线程<ul>
<li>一个进程可以包含多个线程，所有线程共享相同的地址空间和系统资源</li>
<li>线程之间可以直接读写进程内的共享数据，执行起来更高效</li>
<li>线程的创建、销毁和切换开销比较小</li>
</ul>
</li>
</ol>
<h4 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h4><p>GET用于获取资源，参数通过URL传递，不适合传输敏感信息，幂等，有缓存，传输数据的大小受限于URL的长度。POST用于提交数据，参数通过请求体传递，适合传输敏感信息，不幂等，无缓存，没有数据大小限制。</p>
<h4 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h4><ol>
<li>HTTP<ul>
<li>HTTP是一种应用层协议，用于在Web浏览器和Web服务器之间传输超文本和其他资源</li>
<li>HTTP是明文传输的协议，意味着数据在传输过程中是未加密的，容易被窃听和篡改</li>
<li>HTTP默认使用80端口号</li>
</ul>
</li>
<li>HTTPS<ul>
<li>HTTPS是HTTP协议的安全版本，加强了数据传输的安全性和保密性</li>
<li>HTTPS使用了SSL&#x2F;TLS协议进行数据加密和身份认证</li>
<li>HTTPS默认使用443端口通信</li>
</ul>
</li>
</ol>
<h4 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++ 11新特性"></a>C++ 11新特性</h4><ul>
<li><p>auto关键字</p>
</li>
<li><p>智能指针</p>
</li>
<li><p>lambda表达式	参考链接（<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15323899/5785594%EF%BC%89">https://blog.51cto.com/u_15323899/5785594）</a></p>
<p>Lambda表达式是C++11引入的一种新特性，它允许在代码中定义匿名函数。虽然在使用上非常简洁和方便，但lambda表达式背后的实现相对复杂。以下是lambda表达式在底层的工作原理：</p>
<ol>
<li><p><strong>转换为类</strong>:</p>
<ul>
<li>当你定义一个lambda表达式，编译器会为你生成一个匿名类（也称为闭包类型）。这个类将会覆盖函数调用操作符，使得该对象可以像函数一样被调用。</li>
<li>如果lambda表达式捕获了外部的局部变量（例如通过值或引用），这些变量将会被添加为该匿名类的成员。</li>
</ul>
</li>
<li><p><strong>成员变量</strong>:</p>
<ul>
<li>为了支持捕获，生成的闭包类型可能会包含成员变量。如果使用值捕获，那么这些成员变量将存储捕获的变量的副本；如果使用引用捕获，那么成员变量将存储相应变量的引用。</li>
</ul>
</li>
<li><p><strong>函数调用操作符重载</strong>:</p>
<ul>
<li>生成的类会覆盖函数调用操作符<code>operator()</code>. 这个操作符的实现就是lambda表达式的主体。</li>
</ul>
</li>
<li><p><strong>构造函数</strong>:</p>
<ul>
<li>该匿名类的构造函数会初始化所有捕获的变量。根据捕获方式（值或引用）来复制或绑定这些变量。</li>
</ul>
</li>
<li><p><strong>生成的类是只移动构造的</strong>:</p>
<ul>
<li>这意味着你不能按常规方式复制lambda表达式，但可以移动它。</li>
</ul>
</li>
</ol>
<p>下面是一个简单的lambda表达式的例子以及一个可能的简化版本的匿名类表示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lambda</span></span><br><span class="line"><span class="keyword">auto</span> lambda = [x](<span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Possible representation by the compiler</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__anonymous</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    __anonymous(<span class="type">int</span> _x) : <span class="built_in">x</span>(_x) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> y)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>要注意的是，这只是一个简化的表示。实际编译器生成的代码会比这更复杂，尤其是当涉及到更高级的特性（如泛型、<code>mutable</code>关键字或捕获列表）时。</p>
<p>最后，虽然从概念上讲，lambda表达式是转换为类的，但这并不意味着性能会受到影响。优化后的编译器通常会内联这些生成的类和函数调用操作符，从而消除由于间接调用导致的任何额外开销。</p>
</li>
<li><p>右值引用和移动语义</p>
</li>
</ul>
<h4 id="lambda表达式的使用场景"><a href="#lambda表达式的使用场景" class="headerlink" title="lambda表达式的使用场景"></a>lambda表达式的使用场景</h4><p>lambda表达式提供了一种简洁、方便的方式来创建匿名对象。在一些需要传递简单函数对象的场景下，使用lambda表达式可以避免额外的函数对象类。</p>
<h4 id="vector迭代器失效的原因"><a href="#vector迭代器失效的原因" class="headerlink" title="vector迭代器失效的原因"></a>vector迭代器失效的原因</h4><p>vector底层的实现是一个动态数组，vector里面存储的元素都是连续的，一旦比如删除一个元素，后面的所有元素都需要移动。我们可以考虑一种极端情况，删除最后一个元素，此时指向原vector数组的最后一个元素的迭代器就没指向任何元素了，如何此时我们访问这个迭代器所指向的元素，就会导致未定义行为，所以就会判定迭代器失效。其实所有改变vector大小的操作，都会导致vector迭代器失效。</p>
<h4 id="map的底层数据结构"><a href="#map的底层数据结构" class="headerlink" title="map的底层数据结构"></a>map的底层数据结构</h4><p>红黑树参考链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e136ec79235c">https://www.jianshu.com/p/e136ec79235c</a></p>
<p>map是有序容器，底层数据结构是红黑树，时间复杂度为log(n)。红黑树的前身可以说是二叉搜索树。但是二叉搜索树最坏的情况下树的高度为n，那么就导致时间复杂度为o(n), 所以便衍生出来了平衡二叉树。其实红黑树的五大特性就是为了保持二叉搜索树的平衡。保证时间复杂度稳定在o(logn)。</p>
<h4 id="unordered-map底层数据结构"><a href="#unordered-map底层数据结构" class="headerlink" title="unordered_map底层数据结构"></a>unordered_map底层数据结构</h4><p>unordered_map是无序容器，底层使用哈希表实现的。</p>
<h4 id="TCP握手为什么是三次握手，两次握手为什么不行呢"><a href="#TCP握手为什么是三次握手，两次握手为什么不行呢" class="headerlink" title="TCP握手为什么是三次握手，两次握手为什么不行呢"></a>TCP握手为什么是三次握手，两次握手为什么不行呢</h4><p>这里有两个大点，第一个字面意思很好理解，第二点举个例子就通透了，面试时最好全部答上来</p>
<ul>
<li><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤</p>
</li>
<li><p>防止已失效的连接请求又传送到服务器端，因而产生错误</p>
<p>只有采用三次握手可以减少服务端的资源浪费。解释如下：<br>例如，客户端向服务端发送请求同步报文A，因为网络阻塞等原因，服务端没有收到同步报文A，所以没有发送同步确认报文。过了一段时间，客户端没有收到服务端的确认报文，重新向服务端发送请求同步报文B，服务端接收到报文B后，向客户端发送同步确认报文，客户端接收到确认报文后，向服务端发送确认报文，建立连接。数据传输完毕后，连接断开。客户端进入close状态，此时服务端收到之前的报文A，向客户端返回同步确认报文。如果使用两次握手，服务端回应后不确认客户端的状态，连接建立成功。服务端会长时间等待客户端发送数据，连接长期保持，会造成资源浪费。当多个客户端产生这种情况，服务器就会等待多个客户端的响应，连接数量过多，之后的客户端请求，服务器无法响应。造成服务器处于瘫痪状态。<br>只有使用三次握手，当服务端收到确认报文后，保证当前时刻，客户端可以发送数据时，才能建立有意义的连接。当客户端一段时间不发送数据时，服务器应自动断开连接，来节省自身连接的客户端数量，减少资源的浪费。</p>
</li>
</ul>
<h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p>HTTP状态码是在HTTP协议中用于表示服务器对请求的处理结果的三位数字代码。HTTP状态码的分类如下：</p>
<ol>
<li><p>1xx（信息性状态码）：表示服务器已接收请求，需要客户端继续操作。</p>
</li>
<li><p>2xx（成功状态码）：表示服务器成功处理了请求。</p>
</li>
<li><p>3xx（重定向状态码）：表示请求需要进一步的操作，通常用于重定向。</p>
</li>
<li><p>4xx（客户端错误状态码）：表示客户端发出的请求有误。</p>
</li>
<li><p>5xx（服务器错误状态码）：表示服务器在处理请求时发生了错误。</p>
</li>
</ol>
<p>以下是一些常见的HTTP状态码示例：</p>
<ol>
<li><p>200 OK：请求成功，服务器成功处理了请求。</p>
</li>
<li><p>201 Created：请求成功，服务器已成功创建了资源。</p>
</li>
<li><p>204 No Content：请求成功，但服务器没有新的信息返回。</p>
</li>
<li><p>400 Bad Request：请求错误，服务器不理解或无法处理请求。</p>
</li>
<li><p>401 Unauthorized：请求需要用户认证，未提供有效的认证信息。</p>
</li>
<li><p>403 Forbidden：请求被服务器拒绝，没有访问权限。</p>
</li>
<li><p>404 Not Found：请求的资源不存在。</p>
</li>
<li><p>500 Internal Server Error：服务器内部错误，无法完成请求。</p>
</li>
<li><p>502 Bad Gateway：服务器作为网关或代理，从上游服务器收到无效的响应。</p>
</li>
<li><p>503 Service Unavailable：服务器暂时不可用，通常是由于过载或维护。</p>
</li>
</ol>
<p>这只是HTTP状态码中的一部分，实际中可能还会遇到其他状态码。状态码的具体含义可参考HTTP协议的官方文档或RFC文档。不同的状态码代表了服务器对请求的不同响应结果，客户端根据状态码可以做出相应的处理。</p>
<h4 id="使用智能指针了，普通指针还能用吗？"><a href="#使用智能指针了，普通指针还能用吗？" class="headerlink" title="使用智能指针了，普通指针还能用吗？"></a>使用智能指针了，普通指针还能用吗？</h4><p>个人觉得使用了智能指针后不推荐使用普通指针。因为使用了智能指针后，再使用普通指针指向相同对象，并不会增加引用计数，等智能指针引用计数变为0的时候，对象被销毁，此时普通指针就变为了野指针。</p>
<h4 id="什么时候使用智能指针，什么时候使用普通指针-（CHATGPT）"><a href="#什么时候使用智能指针，什么时候使用普通指针-（CHATGPT）" class="headerlink" title="什么时候使用智能指针，什么时候使用普通指针 （CHATGPT）"></a>什么时候使用智能指针，什么时候使用普通指针 （CHATGPT）</h4><p>使用智能指针还是普通指针取决于你的代码需求和内存管理需求。以下是一些指导原则：</p>
<p>使用智能指针的情况：</p>
<ol>
<li><p>动态分配内存：如果你需要动态分配内存，尤其是在使用<code>new</code>关键字时，最好使用智能指针来管理这些资源。智能指针会自动在不再需要时释放内存，避免了内存泄漏的问题。</p>
</li>
<li><p>所有权传递：当多个地方共享一个资源并且需要明确的所有权传递时，智能指针特别有用。例如，使用<code>std::shared_ptr</code>来共享资源，并在最后一个引用释放时自动删除资源。</p>
</li>
<li><p>异常安全：在使用普通指针的代码中，如果在动态分配资源后发生异常，可能会导致资源泄漏。使用智能指针可以更好地处理异常情况，确保资源在退出作用域时得到正确释放。</p>
</li>
<li><p>容器存储：如果要在STL容器中存储指针类型，建议使用智能指针。STL容器在元素添加或删除时可能会复制或移动元素，使用智能指针可以正确管理资源的所有权。</p>
</li>
</ol>
<p>使用普通指针的情况：</p>
<ol>
<li><p>接口和传统API：某些接口和传统的C API可能要求使用原始指针，此时你无法使用智能指针。在这种情况下，你应该小心管理内存，确保手动释放资源。</p>
</li>
<li><p>与C代码交互：当与C语言库或代码进行交互时，普通指针是常用的方式，因为C语言不支持智能指针。</p>
</li>
<li><p>临时指针：对于一些临时指针，其生命周期很短且不需要动态内存管理时，可以使用普通指针。</p>
</li>
<li><p>最低开销：在某些性能关键的场景，智能指针可能带来额外的开销，此时使用普通指针可能更合适。但请注意，在性能优化前确保使用智能指针没有影响到代码的正确性和可维护性。</p>
</li>
</ol>
<p>综上所述，智能指针在大多数情况下是推荐的内存管理方式，特别是在现代C++代码中。然而，有些特定的场景可能需要使用普通指针，但在这种情况下你需要格外小心以避免内存泄漏和悬挂指针问题。</p>
<h4 id="Hash-map原理"><a href="#Hash-map原理" class="headerlink" title="Hash_map原理"></a>Hash_map原理</h4><p>Hash_map基于Hash_map（哈希表）。</p>
<p>哈希表基本原理：使用一个下标范围较大的数组来储存元素。那我们怎么根据关键字知道它应该放在数组的哪个位置呢？这就通过哈希函数（散列函数）来解决。哈希函数使得每个元素的关键字都与一个函数值（即数组下标，hash值）相对应。但是，不能保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这就产生了哈希冲突。因此“直接定址”和“解决冲突”是哈希表的两大特点。</p>
<p>哈希冲突的解决主要有以下四种方法：开放地址法，再哈希法，链地址法和建立公共溢出区。关于这四种方法的解释见知乎链接 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/29520044">https://zhuanlan.zhihu.com/p/29520044</a></p>
<h4 id="C-多态介绍一下"><a href="#C-多态介绍一下" class="headerlink" title="C++多态介绍一下"></a>C++多态介绍一下</h4><p>C++多态主要包括重载、虚函数、模板。重载包括函数重载和运算符重载，编译期，即编译器在编译阶段就会根据函数调用的上下文来决定使用哪一个重载版本。虚函数是在运行期。重载和模板属于静态多态，虚函数属于动态多态。静态多态与动态多态靠编译期与运行期区分。</p>
<h4 id="虚函数、纯虚函数原理，虚表什么时候建立的https-zhuanlan-zhihu-com-p-37331092"><a href="#虚函数、纯虚函数原理，虚表什么时候建立的https-zhuanlan-zhihu-com-p-37331092" class="headerlink" title="虚函数、纯虚函数原理，虚表什么时候建立的	https://zhuanlan.zhihu.com/p/37331092"></a>虚函数、纯虚函数原理，虚表什么时候建立的	<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37331092">https://zhuanlan.zhihu.com/p/37331092</a></h4><ul>
<li>虚函数，在类成员方法的声明（不是定义）语句前加“virtual”，如virtual void func</li>
<li>纯虚函数，在虚函数后加“&#x3D;0”，如virtual void func &#x3D; 0</li>
<li>对于虚函数，子类可以（也可以不）重写基类的虚函数，该行为称之为override</li>
<li>对于纯虚函数，子类必须提供纯虚函数的个性化实现</li>
</ul>
<p>在派生子类中对虚函数和纯虚函数的个性化实现，都体现了多态特性，但区别在于：</p>
<ul>
<li>子类如果不提供虚函数的实现，将会自动调用基类的缺省虚函数实现</li>
<li>子类如果不提供纯虚函数的实现，将会编译失败</li>
</ul>
<p><strong>当使用类的指针调用成员函数时，普通函数由指针类型决定，而虚函数则由指针指向的实际类型决定</strong></p>
<p>实现虚函数表的关键就是虚函数表指针，这个指针指向一张名为虚函数表的表，为表中的数据则为函数指针，存储了虚函数具体实现所对应的位置。另外，当一个类有多个虚函数时，仍然只有一个虚函数指针，而此时的虚函数表里会有多个<strong>函数指针</strong>，因此，虚函数实现的过程是：<strong>通过对象内存中的虚函数指针vptr找到虚函数表vtbl，再通过vtbl中的函数指针找到对应虚函数的实现区域并进行调用。</strong>所以虚函数的调用时由指针所指向内存块的具体类型决定的。</p>
<h4 id="构造函数和析构函数可以是虚函数吗？"><a href="#构造函数和析构函数可以是虚函数吗？" class="headerlink" title="构造函数和析构函数可以是虚函数吗？"></a>构造函数和析构函数可以是虚函数吗？</h4><p>答案是：构造函数不能是虚函数，析构函数可以是虚函数且推荐最好设置为虚函数。</p>
<p>首先，我们已经知道虚函数的实现则是通过对象内存中的vptr来实现的。而构造函数是用来实例化一个对象的，通俗来讲就是为对象内存中的值做初始化操作。那么在构造函数完成之前，也即还没有进行初始化，此时vptr是没有值的，也就无法通过vptr找到作为构造函数和虚函数所在的代码区，所以构造函数只能以普通函数的形式存放在类所指定的代码区中。</p>
<p>而对于析构函数，当我们delete(a)的时候，如果析构函数不是虚函数，那么调用的将会是基类base的析构函数。而当继承的时候，通常派生类会在基类的基础上定义自己的成员，此时我们当然希望可以调用派生类的析构函数对新定义的成员也进行析构。</p>
<h4 id="map为啥用红黑树不用avl树？"><a href="#map为啥用红黑树不用avl树？" class="headerlink" title="map为啥用红黑树不用avl树？"></a>map为啥用红黑树不用avl树？</h4><ul>
<li>平衡调整次数更少</li>
<li>内存使用更少：AVL树需要存储额外的平衡因子信息</li>
<li>更适合于频繁的插入和删除操作</li>
</ul>
<h4 id="怎么判断map里key值存不存在"><a href="#怎么判断map里key值存不存在" class="headerlink" title="怎么判断map里key值存不存在"></a>怎么判断map里key值存不存在</h4><p>c.at(k)	访问关键字为k的元素，如果k不在c中，返回一个out_of_range异常</p>
<p>c.find(k)	如果存在，返回一个迭代器，指向关键字为k的元素；如果不存在，返回尾后迭代器</p>
<p>c.count(k)	不存在返回0，存在返回k关键字的数量</p>
<h4 id="多进程通信方式"><a href="#多进程通信方式" class="headerlink" title="多进程通信方式"></a>多进程通信方式</h4><p>管道、命名管道、消息队列、信号量、共享内存、套接字、RPC</p>
<p>管道：一种最简单的进程间通信方式，通常用于父子进程间通信。管道中数据只能朝一个方向流动，即一方读另一方写。管道通过系统调用pipe()创建。</p>
<p>命名管道：一种更通用的进程间通信方式，它可以在无关的进程之间进行通信。不同于管道，命名管道通过文件系统中的路径名来标识。命名管道可以通过系统调用 <code>mkfifo()</code> 创建。</p>
<p>信号量：讲好sem_init(), sem_wait(), sem_post()系统整体运作过程就好了</p>
<p>套接字：服务器监听一个ip+端口，客户端访问连接</p>
<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><table>
<thead>
<tr>
<th align="left"></th>
<th align="center">TCP</th>
<th align="center">UDP</th>
</tr>
</thead>
<tbody><tr>
<td align="left">可靠性</td>
<td align="center">可靠</td>
<td align="center">不可靠</td>
</tr>
<tr>
<td align="left">连接</td>
<td align="center">面向连接</td>
<td align="center">无连接</td>
</tr>
<tr>
<td align="left">数据传输方式</td>
<td align="center">字节流</td>
<td align="center">数据报</td>
</tr>
<tr>
<td align="left">双工性</td>
<td align="center">全双工</td>
<td align="center">一对一、一对多、多对一、多对多</td>
</tr>
<tr>
<td align="left">流量控制</td>
<td align="center">滑动窗口</td>
<td align="center">无</td>
</tr>
<tr>
<td align="left">拥塞控制</td>
<td align="center">慢启动、拥塞避免、快速重传、快速回复</td>
<td align="center">无</td>
</tr>
<tr>
<td align="left">效率</td>
<td align="center">低</td>
<td align="center">高</td>
</tr>
<tr>
<td align="left">传输速度</td>
<td align="center">慢</td>
<td align="center">快</td>
</tr>
</tbody></table>
<h4 id="TCP-x2F-IP协议组"><a href="#TCP-x2F-IP协议组" class="headerlink" title="TCP&#x2F;IP协议组"></a>TCP&#x2F;IP协议组</h4><p>IP协议、TCP协议、UDP协议、ICMP协议、ARP协议、RARP协议</p>
<h4 id="OSI七层"><a href="#OSI七层" class="headerlink" title="OSI七层"></a>OSI七层</h4><p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p>
<h4 id="socket编程recv函数"><a href="#socket编程recv函数" class="headerlink" title="socket编程recv函数"></a>socket编程recv函数</h4><p>返回0：对方关闭连接</p>
<p>返回相应的接收数据大小</p>
<p>返回错误码：传输出现错误</p>
<h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><p>快排思想：选定基准元素，小的放一边，大的放一边，最后分治</p>
<h4 id="HTTP状态码-1"><a href="#HTTP状态码-1" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><ol>
<li>1XX - 信息状态码：<ul>
<li>100 Continue：服务端已经收到了客户端请求，继续发送剩余部分</li>
</ul>
</li>
<li>2XX - 成功状态码：<ul>
<li>200 OK：请求成功，服务器成功处理了请求</li>
<li>201 Created：请求成功，并创建了资源</li>
<li>204 No Content：请求成功，但没有返回内容</li>
</ul>
</li>
<li>3XX - 重定向状态码：<ul>
<li>301 Moved Permanently：永久重定向，请求的资源被永久移到了新位置</li>
<li>302 Found：临时重定向，请求的资源被临时移到了新位置</li>
<li>304 Not Modified：客户端缓存资源仍然有效，未修改</li>
</ul>
</li>
<li>4XX - 客户端错误状态码：<ul>
<li>400 Bad Request：客户端请求错误，服务器无法理解</li>
<li>401 Unauthorized：请求要求身份验证，客户端未提供有效的身份信息</li>
<li>403 Forbidden：服务器拒绝请求，没有访问权限</li>
<li>404 Not Found：请求的资源不存在</li>
</ul>
</li>
<li>5XX - 服务器错误状态码：<ul>
<li>500 Internet Server Error：服务器内部错误，无法完成请求</li>
<li>502 Bad Gateway：作为网关或代理的服务器从上游服务器收到无效响应</li>
<li>503 Service Unavailable：服务器暂时过载或维护中，无法处理请求</li>
<li>504 Gateway Timeout：作为网关或代理服务器未及时从上游服务器接收响应</li>
</ul>
</li>
</ol>
<h4 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h4><p>DNS就是域名解析服务，查询过程依次递增。本地域名解析（操作系统首先会查询本地DNS缓存） —–》本地域名服务器查询 —–》根域名服务器查询 —–》顶级域名服务器查询 —–》权威域名服务器查询 —–》返回结果。DNS查询和应答报文具有相同格式，主要区别在于某些字段的标识。下面讲几个重要的字段。</p>
<ul>
<li>16位标识：用于标记一对DNS查询和应答，以此区分一个DNS应答是哪一个DNS查询的回应</li>
<li>16位标志<ul>
<li>QR：查询报文（0）&#x2F;	应答报文（1）</li>
<li>opcode：标准查询（0）&#x2F;    反向查询（1）就是是通过域名获取ip地址还是通过ip地址获取域名</li>
</ul>
</li>
</ul>
<h4 id="TCP为什么需要四次挥手，三次挥手有什么问题"><a href="#TCP为什么需要四次挥手，三次挥手有什么问题" class="headerlink" title="TCP为什么需要四次挥手，三次挥手有什么问题"></a>TCP为什么需要四次挥手，三次挥手有什么问题</h4><ol>
<li>客户端最后一个ACK可能会丢失，这样服务端就无法正常进入CLOSED状态。于是B会重传请求释放的报文，而此时如果A已经关闭了，那就收不到B的重传请求，就会导致B无法正常释放。而如果A还在等待时间内，就会收到B的重传，然后进行应答，这样B就可以进入CLOSED状态</li>
<li>如果三次挥手的话，服务端收到来自客户端的FIN请求后，需要同时回复ACK和发送FIN断开连接请求。但是在TCP连接中是有一个半关闭状态的，也就是服务端其实还是可以继续发送数据的，如果三次挥手，就无法做到服务器再发送数据了。</li>
</ol>
<h4 id="TCP传输为什么是可靠的"><a href="#TCP传输为什么是可靠的" class="headerlink" title="TCP传输为什么是可靠的"></a>TCP传输为什么是可靠的</h4><ul>
<li>确认与重传：如果一定时间内未收到ACK，则会重传</li>
<li>序列号与顺序性：TCP为每一个数据包分配一个序列号，接收端会进行数据包重组</li>
<li>流量控制</li>
<li>拥塞控制</li>
<li>连接管理：三次握手与四次挥手</li>
<li>超时与重试</li>
</ul>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p>新建、就绪、运行、阻塞、等待、终止</p>
<h4 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h4><p>死锁发生的必要条件，通常被称为死锁的四个条件，分别是：</p>
<ol>
<li><strong>互斥条件（Mutual Exclusion）：</strong> 指某个资源在一段时间内只能被一个线程或进程占用，其他线程或进程需要等待资源释放才能继续执行。</li>
<li><strong>请求与保持条件（Hold and Wait）：</strong> 指线程在保持至少一个资源的同时，还请求其他资源，而这些资源可能被其他线程占用，导致请求阻塞。</li>
<li><strong>不剥夺条件（No Preemption）：</strong> 指资源只能由占有它的线程显式释放，其他线程不能强行抢占资源。</li>
<li><strong>循环等待条件（Circular Wait）：</strong> 指多个线程形成一个循环，每个线程都在等待下一个线程所持有的资源，导致一个闭环的等待状态。</li>
</ol>
<h4 id="死锁解决方案"><a href="#死锁解决方案" class="headerlink" title="死锁解决方案"></a>死锁解决方案</h4><ul>
<li>系统重新启动</li>
<li>撤销进程、剥夺资源</li>
<li>进程回退策略，即让参与死锁的进程回退到没有发生死锁前某一点处。</li>
</ul>
<h4 id="树的知识"><a href="#树的知识" class="headerlink" title="树的知识"></a>树的知识</h4><p><a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/bplus-tree/">https://oi-wiki.org/ds/bplus-tree/</a></p>
<h4 id="Linux-API调用返回值汇总"><a href="#Linux-API调用返回值汇总" class="headerlink" title="Linux API调用返回值汇总"></a>Linux API调用返回值汇总</h4><p>int pthread_create：成功时返回0，失败时返回错误码</p>
<p>void pthread_exit：不会失败</p>
<p>int pthread_join ( pthread_t thread, void** retval)：成功时返回0，失败时返回错误码。错误码：EDEADLK：可能引起死锁，比如两个线程互相针对对方调用pthread_join，或者线程对自身调用pthread_join；EINVAL：目标线程是不可回收的，或者已经有其他线程在回收该目标线程；ESRCH：目标线程不存在。</p>
<p>int sem_init( sem_t* sem, int pshared, unsigned int value )</p>
<p>int sem_destroy( sem_t* sem )</p>
<p>int sem_wait( sem_t* sem)</p>
<p>int sem_trywait( sem_t* sem )</p>
<p>int sem_post( sem_t* sem )：以上五个成功时返回0， 失败时返回-1并设置errno</p>
<h4 id="DNS的解析过程"><a href="#DNS的解析过程" class="headerlink" title="DNS的解析过程"></a>DNS的解析过程</h4><p>DNS是实现域名和IP地址相互映射的一个分布式数据库。DNS解析过程主要包括以下步骤</p>
<ol>
<li>本地缓存查询：当用户通过浏览器访问某域名时，浏览器会首先在自己的缓存里查询是否有该域名对应的IP地址。</li>
<li>本地系统查询：查看本计算机系统Host文件DNS缓存是否有对应DNS缓存</li>
<li>查看路由器缓存</li>
<li>查询ISP DNS缓存：也称本地域名服务器查询，计算机会向你的ISP（互联网服务提供商）分配的本地域名服务器发出查询请求</li>
<li>根域名服务器</li>
<li>顶级域名服务器：根域名服务器并不会直接返回用户IP地址，而是会指向查询请求对应的顶级域名服务器</li>
<li>权威域名服务器：顶级域名服务器会指向域名的权威域名服务器，这些服务器管理特定的域名的DNS服务。</li>
</ol>
<h4 id="TCP传输为什么是可靠的-1"><a href="#TCP传输为什么是可靠的-1" class="headerlink" title="TCP传输为什么是可靠的"></a>TCP传输为什么是可靠的</h4><p>总结下来主要包括三个方面：</p>
<ul>
<li>检验和</li>
<li>确认应答（ACK和序列号一应一答）</li>
<li>超时重传</li>
</ul>
<h4 id="NAT协议和跨域（不了解）"><a href="#NAT协议和跨域（不了解）" class="headerlink" title="NAT协议和跨域（不了解）"></a>NAT协议和跨域（不了解）</h4><h4 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h4><p>最明显的一个区别就是GET请求会把参数放在URL（统一资源定位符）中，POST会把参数放在请求体中。</p>
<p>数据大小限制：GET请求把参数放在URL中，GET请求数据大小收到URL长度限制。POST请求则不会</p>
<p>幂等性：GET请求每次相同请求返回的结果都一样，多次重复请求不会对资源产生影响。POST请求则相反</p>
<p>安全性：POST更安全，参数没有暴露在URL上</p>
<p>缓存：GET请求可以被浏览器缓存，POST请求不会被浏览器缓存</p>
<h4 id="写一段死锁的代码"><a href="#写一段死锁的代码" class="headerlink" title="写一段死锁的代码"></a>写一段死锁的代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_a;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">another</span><span class="params">(<span class="type">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in child thread, get mutex a\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_b);</span><br><span class="line">    b += a;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_b);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_a, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_b, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;id, <span class="literal">NULL</span>, another, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in parent thread, get mutex b\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    ++b;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_a);</span><br><span class="line">    a += b;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(id, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_a);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pro is end\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="删除字符串头尾空格代码"><a href="#删除字符串头尾空格代码" class="headerlink" title="删除字符串头尾空格代码"></a>删除字符串头尾空格代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::string s;</span><br><span class="line">    std::string tmp;</span><br><span class="line">    <span class="built_in">getline</span>(std::cin, s);   <span class="comment">//这里很重要哦，如果用cin，“hello world”会被截断成hello</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = s.<span class="built_in">substr</span>(i, s.<span class="built_in">size</span>() - i);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = s.<span class="built_in">substr</span>(<span class="number">0</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="shared-ptr是线程安全的吗？https-cloud-tencent-com-developer-article-1654442"><a href="#shared-ptr是线程安全的吗？https-cloud-tencent-com-developer-article-1654442" class="headerlink" title="shared_ptr是线程安全的吗？https://cloud.tencent.com/developer/article/1654442"></a>shared_ptr是线程安全的吗？<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1654442">https://cloud.tencent.com/developer/article/1654442</a></h4><ul>
<li>多线程同时读一个shared_ptr对象是安全的</li>
<li>多线程同时对一个shared_ptr对象进行读和写是不安全的，需要加锁</li>
</ul>
<p>这里给出一个伪代码的简单例子</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Foo&gt; g(new Foo1);   // 线程之间共享的shared_ptr</span><br><span class="line">shared_ptr&lt;Foo&gt; x;   		  // 线程A的局部变量</span><br><span class="line">shared_ptr&lt;Foo&gt; n(new Foo2);   // 线程B的局部变量</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">线程A</span><br><span class="line">x = g;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">线程B</span><br><span class="line">g = n;</span><br><span class="line">---------------------------------------------------------</span><br><span class="line">测试场景：</span><br><span class="line"></span><br><span class="line">线程A </span><br><span class="line">  智能指针x 读取Foo1,然后还重置Foo1计数。</span><br><span class="line"></span><br><span class="line">线程 B:</span><br><span class="line"> 销毁了Foo1</span><br><span class="line">线程A</span><br><span class="line">重置计数时，foo1已经被销毁。</span><br></pre></td></tr></table></figure>



<h4 id="mysql读写锁怎么实现-mysql-读写锁和互斥锁的区别https-blog-51cto-com-u-16099299-7031260"><a href="#mysql读写锁怎么实现-mysql-读写锁和互斥锁的区别https-blog-51cto-com-u-16099299-7031260" class="headerlink" title="mysql读写锁怎么实现 mysql 读写锁和互斥锁的区别	https://blog.51cto.com/u_16099299/7031260"></a>mysql读写锁怎么实现 mysql 读写锁和互斥锁的区别	<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_16099299/7031260">https://blog.51cto.com/u_16099299/7031260</a></h4><ul>
<li>请你讲述一下互斥锁机制，以及互斥锁和读写锁的区别<ul>
<li>互斥锁（mutex），用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒。</li>
<li>读写锁（rwlock），分为读锁和写锁。处于读操作的时候，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其他获得写锁失败的线程将会进入睡眠状态，直到写锁释放时被唤醒。注意;写锁会阻塞其他读写锁。当有一个线程获得写锁在写时，读锁也不能被其他线程获取；写者优于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）。适用于读取数据的频率远远大于写数据的频率的场合。<br>读写锁：区分读者和写者，而互斥锁不区分，互斥锁只允许同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象。</li>
</ul>
</li>
<li>Linux中的四种锁机制<ul>
<li>互斥锁：在同一时间内只允许一个线程访问对象</li>
<li>读写锁：同一时间内允许多个读者同时读对象，同一时间内只允许一个写者访问对象，且当有一个线程获得写操作的时候，读锁也不能被其他的线程获取，写者优于读者，唤醒时先唤醒写者。</li>
<li>自旋锁：在任何时刻内自能有一个线程访问资源，但是当获取锁操作失败时，不会进入睡眠状态而是会原地自旋，直到锁被释放，这样减少了线程从睡眠状态到被唤醒状态的资源消耗，在加锁时间短暂的情况下使用会提高效率。但是加锁时间过长会非常浪费CPU</li>
<li>RCU（read-copy-update）：在修改数据时，首先需要读取数据，然后生成一个副本，对副本进行修改，然后在将老数据update成新数据。在RCU的时候读者几乎不需要同步开销，即不需要获取锁，也不适用原子指令，不会导致竞争因此不用考虑死锁问题了。但是对于写者的同步开销比较大，他需要复制被修改的数据，还必须使用锁机制同步并行其他写者的改操作，在有大量读操作，少量写操作的时候使用。</li>
</ul>
</li>
</ul>
<h4 id="delete关键字的作用"><a href="#delete关键字的作用" class="headerlink" title="delete关键字的作用"></a>delete关键字的作用</h4><ol>
<li><p>删除特殊的成员函数：在C++11中可以使用delete来显示的阻止编译器自动生成某些特殊的成员函数。通过在类的声明中将这些特殊函数标记为delete，可以防止这些函数隐式的生成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() = <span class="keyword">delete</span>; <span class="comment">// 阻止生成默认构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp;) = <span class="keyword">delete</span>; <span class="comment">// 阻止生成拷贝构造函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除特定的函数重载：在函数重载时，可以使用delete关键字来标记某个特定的函数重载，防止特定的重载函数被调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">(<span class="type">double</span> x)</span> </span>= <span class="keyword">delete</span>; <span class="comment">// 阻止调用带有 double 参数的函数</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="define和const的区别"><a href="#define和const的区别" class="headerlink" title="define和const的区别"></a>define和const的区别</h4><ul>
<li>就起作用的阶段而言：#define是在编译的预处理阶段起作用，而const是在编译、运行时起作用；</li>
<li>就起作用的方式而言：#define只是简单的字符串替换，没有类型检查，而const有类型检查，避免相应的错误；</li>
<li>就存储方式而言：#define只是进行展开，有多少地方使用，就有多少替换。const定义的只读变量在程序运行过程中只有一份备份；</li>
</ul>
<h4 id="写时拷贝（COW）https-www-cnblogs-com-biyeymyhjob-archive-2012-07-20-2601655-html"><a href="#写时拷贝（COW）https-www-cnblogs-com-biyeymyhjob-archive-2012-07-20-2601655-html" class="headerlink" title="写时拷贝（COW）	https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html"></a>写时拷贝（COW）	<a target="_blank" rel="noopener" href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html">https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html</a></h4><p>在linux里，fork（）会产生一个子进程，子进程与父进程用的是相同的物理空间，也就是说两者的虚拟空间不同，但对应的物理空间是一个。当父&#x2F;子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。这里的相应段你能理解不？其实就是一个程序一般分为哪些段，主要可以分为四大段：栈、堆、数据段、代码段；再细分的话可以加一个bss段，也就是用于存放程序中未初始化的全局变量的一块内存区域。</p>
<p>还有一个细节问题就是，fork之后内核会将子进程放在队列的前面，以让子进程先执行，以免父进程执行导致写时复制，造成不必要的复制，导致效率的下降。可以这么理解，可能子进程执行的代码并不需要写，完全可以使用原共享段，而父进程反而会改变（fork之后），如果父进程先执行，则子进程就要COW。</p>
<h4 id="coredump，gdb怎么定位"><a href="#coredump，gdb怎么定位" class="headerlink" title="coredump，gdb怎么定位"></a>coredump，gdb怎么定位</h4><p>整体流程如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g source.cpp -o <span class="built_in">source</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./source</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./source ./core</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where(在gdb下输入)</span><br></pre></td></tr></table></figure>



<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a><code>epoll</code></h4><p>关于<code>epoll</code>问题在这暂且不多写，只需记住内核事件表，<code>select</code>和<code>poll</code>都是轮询，事件复杂度：<code>epoll（o1）</code>，其他<code>（on）</code>。</p>
<p><code>select</code>和<code>poll</code>必须遍历内核事件表上所有已注册的文件描述符以找到其中的就绪者；<code>epoll</code>仅遍历就绪的文件描述符。</p>
<h4 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用"></a>static的作用</h4><ol>
<li><p>在函数体内，被声明为静态的变量在这一函数被调用过程中维持其值不变。</p>
<p>这句话其实是想说如果在函数内部声明了一个静态变量，那么这个变量在函数调用期间不会被重新初始化。它的生命周期是从程序开始到程序结束，但其作用域仍然限制在该函数内。这里给一段示例代码最好理解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    num++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;num is: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">count</span>();	<span class="comment">// num = 1</span></span><br><span class="line">    <span class="built_in">count</span>();	<span class="comment">// num = 2 正常情况下，如果是非static，num会被重新置0，但这里并没有体现出来。</span></span><br><span class="line">    <span class="built_in">count</span>();	<span class="comment">// num = 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在模块内（但在函数体外），一个被声明为静态的变量可以被模块内所用函数访问，但不能被模块外其他函数访问。它是一个本地的全局变量。</p>
<p>这句话就是表面意思，很好理解，这里给一个代码帮助理解</p>
<p><strong>moduleA.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> secretValue = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printSecretValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; secretValue &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifySecretValue</span><span class="params">(<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">    secretValue = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>moudleB.cpp</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">printSecretValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">modifySecretValue</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printSecretValue</span>();</span><br><span class="line">    <span class="built_in">modifySecretValue</span>(<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; secretValue &lt;&lt; std::endl; </span></span><br><span class="line">    <span class="comment">// 记住，这句话是会导致编译错误的，模块B不能直接访问模块A的变量。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在模块内，一个被声明为静态的函数只可被本模块内的其他函数调用。也就是，这个函数被限制在声明它的模块的本地范围内使用。</p>
<p>这里的意思其实就和第二点差不多了，也给一个简单示例代码吧</p>
<p><strong>moduleA.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是一个静态函数，只在moduleA.cpp中可见</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">secretFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside secret function of moduleA!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公开的函数，可以被其他模块调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">publicFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside public function of moduleA.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">secretFunction</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>moduleB.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">publicFunction</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">publicFunction</span>();  <span class="comment">// 可以调用这个函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能调用 secretFunction，因为它在moduleA.cpp中是静态的</span></span><br><span class="line">    <span class="comment">// secretFunction();  // 这一行会导致编译错误</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>moduleA.cpp</code>定义了一个静态函数<code>secretFunction</code>。在<code>moduleB.cpp</code>中，我们可以调用<code>publicFunction</code>，但当我们尝试调用<code>secretFunction</code>时，会导致编译错误，因为<code>secretFunction</code>只在<code>moduleA.cpp</code>中可见。</p>
</li>
</ol>
<h4 id="有关static的必要补充"><a href="#有关static的必要补充" class="headerlink" title="有关static的必要补充"></a>有关static的必要补充</h4><ul>
<li><p>修饰成员变量</p>
<p>用static修饰类的数据成员，使其成为类的全局变量，会被类的所有对象共享，包括派生类对象。<strong>所有对象只维持同一个实例。</strong>因此类的static成员必须进行类外初始化，而不能在构造函数内进行初始化，不过也可以用const修饰static数据成员在类内初始化。因为const修饰的变量无法修改。</p>
</li>
<li><p>修饰成员函数</p>
<p>用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针，因而只能访问static成员变量。<strong>注意</strong>：正是因为static修饰的成员函数不含this指针，而const修饰的成员函数会添加一个隐藏的参数const this*，所以这两种语义是矛盾的，所以在成员函数上不能同时用他们。</p>
</li>
<li><p>this指针理解</p>
<p>对象就是大房子，成员就是房子里的物件，this是一个指着房子的指针，如果要获取对象的成员也就是大房子内的物件，需要使用this指针加-&gt;这个符号。</p>
</li>
</ul>
<h4 id="三种智能指针"><a href="#三种智能指针" class="headerlink" title="三种智能指针"></a>三种智能指针</h4><p>智能指针是在栈中的一个类，用于管理堆上分配的内存。传统的C&#x2F;C++对于堆上内存的开辟释放，需要程序手动管理，而智能指针是一个类，有构造函数和析构函数，在超出作用范围后，程序会自动调用析构函数释放其管理的指针指向的内存，不需要手动释放。</p>
<ul>
<li>shared_ptr	共享智能指针，多个智能指针可以指向同一个对象，对象的资源在最后一个指针销毁时释放，通过引用计数来判断是否是最后一个智能指针。</li>
<li>unique_ptr	独占智能指针，同一时刻只有一个智能指针可以指向该对象，如果要安全重用该指针，标准库函数std::move()可以将unique_ptr赋值给另一个unique_ptr。</li>
<li>weak_ptr      弱智能指针，不会增加shared_ptr的引用计数，可以避免两个shared_ptr相互引用的死锁问题。weak_ptr只能用shared_ptr或者另一个weak_ptr构造，通过lock()方法weak_ptr可以转化为shared_ptr。</li>
</ul>
<p>下面给出代码示例</p>
<p><strong>unique_ptr</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string str;</span><br><span class="line">    ~<span class="built_in">test</span>()&#123; std::cout &lt;&lt; <span class="string">&quot;test::~test()&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;test&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> test())</span></span>;</span><br><span class="line">    p1-&gt;str = <span class="string">&quot;test string&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p1-&gt;str: &quot;</span> &lt;&lt; p1-&gt;str &lt;&lt; std::endl;</span><br><span class="line">    std::unique_ptr&lt;test&gt; p2;</span><br><span class="line">    p2 = std::<span class="built_in">move</span>(p1);</span><br><span class="line">    <span class="comment">// std::cout &lt;&lt; p1-&gt;str &lt;&lt; std::endl; p1此时已经访问不到资源了</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;p2-&gt;str: &quot;</span> &lt;&lt; p2-&gt;str &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// p1-&gt;str: test string</span></span><br><span class="line"><span class="comment">// p2-&gt;str: test string</span></span><br><span class="line"><span class="comment">// test::~test() 析构函数发生了调用，自动释放资源</span></span><br></pre></td></tr></table></figure>

<p><strong>shared_ptr</strong>造成的死锁问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; a;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;A&gt; b;</span><br><span class="line">    ~<span class="built_in">B</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::~B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*******前边两个类中相互引用，此时引入weak_ptr解决死锁问题*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    p1-&gt;a = p2;</span><br><span class="line">    p2-&gt;b = p1;<span class="comment">//这种情况发生死锁,两个shared_ptr计数都不会为0，资源不会被释放</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count():&quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count():&quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体解释一下死锁的产生主要原因是引用计数无法降为0。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">首先，来理解下为什么这种情况会导致资源不能被释放：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 当你创建`p1`和`p2`时，它们都有一个引用计数为1。</span></span><br><span class="line"><span class="comment">2. 当执行`p1-&gt;a = p2;`，`p2`的引用计数增加到2，因为现在有两个`shared_ptr`对象（`p1-&gt;a`和`p2`）指向同一个`B`对象。</span></span><br><span class="line"><span class="comment">3. 当执行`p2-&gt;b = p1;`，`p1`的引用计数增加到2，因为现在有两个`shared_ptr`对象（`p2-&gt;b`和`p1`）指向同一个`A`对象。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">到此，我们得到了一个环状结构：`p1`指向`A`对象，`A`对象内部的`shared_ptr`指向`B`对象，`B`对象内部的`shared_ptr`又指向`A`对象。这就形成了循环引用。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当`main`函数返回时，`p1`和`p2`的析构函数将被调用，但是它们的引用计数都不会降为0，因为循环引用。所以，`A`和`B`对象的析构函数永远不会被调用，这就导致了资源泄漏。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">要解决这个问题，可以使用`weak_ptr`来打破循环引用。你可以将其中一个类的`shared_ptr`成员变量替换为`weak_ptr`。这样，`weak_ptr`不会增加引用计数，从而避免了循环引用的问题。当你需要从`weak_ptr`获取一个`shared_ptr`时，可以使用`lock`方法。</span></span><br><span class="line"><span class="comment">*/</span> </span><br></pre></td></tr></table></figure>

<p><strong>weak_prt</strong>解决循环引用问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; a;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::~A()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    weak_ptr&lt;A&gt; b;  <span class="comment">// 将 shared_ptr 替换为 weak_ptr</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::~B()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line"></span><br><span class="line">    p1-&gt;a = p2;</span><br><span class="line">    p2-&gt;b = p1;  <span class="comment">// 这里不会增加 p1 的引用计数</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p1 use_count(): &quot;</span> &lt;&lt; p1.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 输出 1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p2 use_count(): &quot;</span> &lt;&lt; p2.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 当 main 返回时，p1 和 p2 都会被析构，它们所指向的对象也会被正确地销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="STL内存池机制"><a href="#STL内存池机制" class="headerlink" title="STL内存池机制"></a>STL内存池机制</h4><ul>
<li><p>第一级配置器</p>
<p>第一级配置器以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。</p>
</li>
<li><p>第二级配置器</p>
<p>在STL的第二级配置器中多了一些机制，避免太多小区造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。</p>
<p>如果要分配的区块大于128bytes，则移交给第一级配置器处理。<br>如果要分配的区块小于128bytes，则以 内存池管理（memory pool），又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。</p>
<p>参考连接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/a987073381/article/details/52245795">https://blog.csdn.net/a987073381/article/details/52245795</a></p>
</li>
</ul>
<h4 id="索引选B-树的原因"><a href="#索引选B-树的原因" class="headerlink" title="索引选B+树的原因"></a>索引选B+树的原因</h4><p>个人感觉主要就是探讨B+树和B树之间的区别。<br>参考链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/JCpeng/p/15231338.html">https://www.cnblogs.com/JCpeng/p/15231338.html</a></p>
<h4 id="服务端TIME-WAIT过多的危害及解决办法"><a href="#服务端TIME-WAIT过多的危害及解决办法" class="headerlink" title="服务端TIME_WAIT过多的危害及解决办法"></a>服务端TIME_WAIT过多的危害及解决办法</h4><p>危害</p>
<ul>
<li>导致大量socket连接端口被占用无法释放，导致系统停转</li>
<li>处理大量的TIME_WAIT状态的连接会占用更多的CPU时间，导致服务器响应时间增加</li>
</ul>
<p>解决办法</p>
<ul>
<li>调整系统内核参数</li>
<li>调整短连接为长连接</li>
</ul>
<h4 id="set底层数据结构"><a href="#set底层数据结构" class="headerlink" title="set底层数据结构"></a>set底层数据结构</h4><p>set底层数据结构是红黑树。关于map和set的一些问题列举如下：</p>
<p><strong>为何map和set的插入删除效率比用其他序列容器高？</strong><br>因为对于关联容器来说，不需要做内存拷贝和内存移动。因为map和set容器内部所有元素都是以节点的方式来存储，父节点和子节点。因此插入和删除的时候都是指针的指向换来换去，并没有内存移动。</p>
<p><strong>为何每次插入&#x2F;删除后以前保存的迭代器不会失效</strong><br>在这里，迭代器就相当于指向节点的指针，内存没有变，指向内存的指针当然不会失效。不同于map&#x2F;set，vector就会失效，比如需要扩容的时候，需要一块更大的内存，就必须把之前的内存释放，申请更大的内存，复制已有的数据元素到新的内存。</p>
<p><strong>为何map和set不能像vector一样有个reserve函数来预分配数据</strong><br>不懂！预留本问题</p>
<p><strong>当数据元素增多时（10000到20000个比较），map和set的插入和搜索速度变化如何？</strong><br>map和set使用的是二分查找，举例来说就是，16个元素查四次，32个元素查5次，10000个也就是14次，20000也就15次。</p>
<h4 id="mapreduce原理（不懂，预留）"><a href="#mapreduce原理（不懂，预留）" class="headerlink" title="mapreduce原理（不懂，预留）"></a>mapreduce原理（不懂，预留）</h4><h4 id="socket哪些操作会产生阻塞"><a href="#socket哪些操作会产生阻塞" class="headerlink" title="socket哪些操作会产生阻塞"></a>socket哪些操作会产生阻塞</h4><p>accept()：在等待客户端的连接请求时会阻塞。如果没有客户端尝试连接，调用这个函数的进程或者线程会被挂起。</p>
<p>connect()：当客户端尝试与远程主机建立连接时，此操作会阻塞，知道连接成功或失败</p>
<p>recv()：当数据从网络到达时，如果没有数据可读，函数调用就会被挂起，阻塞</p>
<p>send()：当发送缓冲区已满，并且无法接受更多数据发送到网络时，操作阻塞。</p>
<h4 id="申请一块大内存和一块小内存的效率是一样的吗？"><a href="#申请一块大内存和一块小内存的效率是一样的吗？" class="headerlink" title="申请一块大内存和一块小内存的效率是一样的吗？"></a>申请一块大内存和一块小内存的效率是一样的吗？</h4><p>不一样，申请一块小内存通常是不需要一级配置器，小块内存通常由内存分配器从预先分配的内存池中分配，这些池被称为<code>bins</code>，这种分配通常非常快，因为它只是涉及到从已存在的内存池中返回一个指针。大的内存通常要调用<code>mmap()</code>。</p>
<h4 id="TCP慢启动和拥塞控制"><a href="#TCP慢启动和拥塞控制" class="headerlink" title="TCP慢启动和拥塞控制"></a>TCP慢启动和拥塞控制</h4><p>TCP连接建立好之后，CWND（congestion window，拥塞窗口）被设置为初始值IW（initial window），其大小为2~4个SMSS（TCP报文段的最大长度，仅指数据部分），新的linux内核加大了这个值。此时发送端最多能发送IW字节的数据，此后发送端每收到一个确认，CWND就按照如下公式增长：<br>$$<br>CWND +&#x3D; min(N, SMSS)<br>$$<br>其中N是此次确认中包含的之前未被确认的字节数。<br>如果不施加其他手段，慢启动必然使得CWND增长的很快，所以TCP拥塞控制中有另外一个非常重要的变量：慢启动门限。当CWND超过慢启动门限值时，TCP将进入拥塞避免阶段。</p>
<h4 id="发送端判断发生拥塞的依据"><a href="#发送端判断发生拥塞的依据" class="headerlink" title="发送端判断发生拥塞的依据"></a>发送端判断发生拥塞的依据</h4><ul>
<li>传输超时</li>
<li>接收到重复的确认报文段</li>
</ul>
<h4 id="Linux下的POSIX互斥锁和条件变量"><a href="#Linux下的POSIX互斥锁和条件变量" class="headerlink" title="Linux下的POSIX互斥锁和条件变量"></a>Linux下的POSIX互斥锁和条件变量</h4><p>牢记这几个函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_init(&amp;mutex, NULL);</span><br><span class="line">pthread_mutex_destory(&amp;mutex);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">pthread_mutex_trylock(&amp;mutex);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_init(&amp;cond, NULL);</span><br><span class="line">pthread_cond_destory(&amp;cond);</span><br><span class="line">pthread_cond_broadcast(&amp;cond);</span><br><span class="line">pthread_cond_signal(&amp;cond);</span><br><span class="line">pthread_cond_wait(&amp;cond, &amp;mutex);</span><br></pre></td></tr></table></figure>

<p>条件变量要配合互斥锁使用。这里挂一个讲的比较清晰明了的博客链接（<a target="_blank" rel="noopener" href="https://punmy.cn/2018/06/07/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condition%20Variables%EF%BC%89.html%EF%BC%89%EF%BC%8C%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81%E5%8A%A0%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B">https://punmy.cn/2018/06/07/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%88Condition%20Variables%EF%BC%89.html），下面是使用互斥锁加条件变量实现的生产者-消费者模型</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_mutex_t</span> mutex_;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_cond_t</span> condition_;</span><br><span class="line"><span class="type">static</span> <span class="type">pthread_t</span> notifying_thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;condition_, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;condition_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">producer</span><span class="params">(<span class="type">void</span> *args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">    <span class="keyword">while</span>(value != <span class="number">10</span>)&#123;</span><br><span class="line">        value++;</span><br><span class="line">    &#125;</span><br><span class="line">    notifying_thread = <span class="built_in">pthread_self</span>();</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">    <span class="built_in">pthread_cond_signal</span>(&amp;condition_);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">    <span class="keyword">while</span>(value != <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;condition_, &amp;mutex_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;value is 10, the pthread is: %lu\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">long</span>)notifying_thread);</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">consumer</span><span class="params">(<span class="type">void</span> *args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">waitCondition</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> a1;</span><br><span class="line">    <span class="type">pthread_t</span> a2;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">setup</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;a1, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;a2, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(a1, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(a2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">destory</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="写一个生产者-x2F-消费者模型（采用信号量）"><a href="#写一个生产者-x2F-消费者模型（采用信号量）" class="headerlink" title="写一个生产者&#x2F;消费者模型（采用信号量）"></a>写一个生产者&#x2F;消费者模型（采用信号量）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_BUFFERS = <span class="number">10</span>;</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; buffer;</span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> empty;</span><br><span class="line"><span class="type">sem_t</span> full;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">producer</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        num = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;empty);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">        buffer.<span class="built_in">push</span>(num);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Produced&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;full);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">comsumer</span><span class="params">(<span class="type">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;full);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">        num = buffer.<span class="built_in">front</span>();</span><br><span class="line">        buffer.<span class="built_in">pop</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Comsumed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;empty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">pthread_t</span> proThread, comPthread;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;empty, <span class="number">0</span>, MAX_BUFFERS);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;full, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;proThread, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;comPthread, <span class="literal">NULL</span>, comsumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(proThread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(comPthread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;empty);</span><br><span class="line">    <span class="built_in">sem_destroy</span>(&amp;full);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="基类的析构函数为什么是虚函数"><a href="#基类的析构函数为什么是虚函数" class="headerlink" title="基类的析构函数为什么是虚函数"></a>基类的析构函数为什么是虚函数</h4><p>当基类的析构函数不是虚函数可能会导致派生类对象的析构函数不被调用。从而引发资源泄露或者其他未定义行为。下面给出示例代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base obj is constructed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">    <span class="comment">// ~Base() &#123; std::cout &lt;&lt; &quot;Base obj is deconstructed&quot; &lt;&lt; std::endl; &#125;</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;Base obj is deconstructed&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()&#123;</span><br><span class="line">        num_ = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived is constructed&quot;</span> &lt;&lt; std::endl; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Derived</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived is deconstructed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *num_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base *base = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）"><a href="#为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）" class="headerlink" title="为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）"></a>为什么基类不使用虚函数会导致派生类的析构函数不调用（除了写的内容，最好再加上有关虚函数表、指针的内容）</h4><p>当一个基类没有虚析构函数，并且通过基类指针删除一个派生类对象时，只有基类的析构函数会被调用。这是因为编译器在编译时期决定了调用哪个析构函数，而不是在运行时期，这种机制被称为“静态绑定”。</p>
<p>如果基类的析构函数是虚函数，那么编译器会在运行时决定要调用哪个析构函数，这种机制称为“动态绑定”或“多态”。</p>
<h4 id="拷贝构造函数为什么要用引用"><a href="#拷贝构造函数为什么要用引用" class="headerlink" title="拷贝构造函数为什么要用引用"></a>拷贝构造函数为什么要用引用</h4><p>避免拷贝构造函数无限递归下去！那传引用为什么行呢？回忆一下引用定义，传引用人家根本就不会涉及到构造函数这玩意，形参相当于实参的一个别名。</p>
<h4 id="左右值的差别"><a href="#左右值的差别" class="headerlink" title="左右值的差别"></a>左右值的差别</h4><h4 id="C-中的虚继承"><a href="#C-中的虚继承" class="headerlink" title="C++中的虚继承"></a>C++中的虚继承</h4><p>c++中的虚继承主要是为了解决多继承情况中存在的二义性问题。比如，现在类A为基类，类B和类C继承自类A，类D继承自类B和类C，假设此时A中有一个名为x的变量且B和C都定义了x，如果此时D直接访问x会产生二义性问题。因为不清楚是A-&gt;B-&gt;D还是A-&gt;C-&gt;D。此时如果让类B和类C虚继承自A，就使得在派生类中只保留有一份成员变量x，解决了二义性问题。<br>参考链接：<br><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/2280.html">http://c.biancheng.net/view/2280.html</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/41309205%EF%BC%88%E8%99%9A%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E9%83%BD%E8%AE%B2%E4%BA%86%EF%BC%8C%E5%8D%81%E5%88%86%E8%AF%A6%E7%BB%86%EF%BC%89">https://zhuanlan.zhihu.com/p/41309205（虚继承、虚函数都讲了，十分详细）</a></p>
<h4 id="C-中的forward函数"><a href="#C-中的forward函数" class="headerlink" title="C++中的forward函数"></a>C++中的forward函数</h4><p>左值引用和右值引用的结果都是左值，无法通过引用区分原本变量的左右值，forward可以保持变量的原本的左右值属性，帮助我们区分。</p>
<h4 id="如何判断TCP断开"><a href="#如何判断TCP断开" class="headerlink" title="如何判断TCP断开"></a>如何判断TCP断开</h4><ol>
<li>发送心跳消息</li>
<li>利用recv&#x2F;send函数的返回值<ul>
<li>recv返回0代表对方关闭了连接</li>
<li>recv返回-1并且errno&#x3D;&#x3D;EAGAIN或者EWOULDBLOCK时，表示没有数据可读，可以稍后再试。</li>
<li><strong>send返回非负值</strong>:<ul>
<li><code>send</code>返回的是实际发送的字节数，这可能会少于你请求发送的字节数（缓冲区已满）。</li>
<li>如果没有可用的缓冲区空间，那么在非阻塞模式下，<code>send</code>可能会返回<code>EAGAIN</code>或<code>EWOULDBLOCK</code>。</li>
</ul>
</li>
<li><strong>send返回-1</strong>:<ul>
<li>与<code>recv</code>类似，这表示出现了错误。</li>
<li>可以使用<code>perror</code>、<code>strerror</code>或检查<code>errno</code>来确定具体的错误原因。</li>
<li>常见的错误原因包括<code>EPIPE</code>（对端已关闭，本端仍尝试发送数据导致的”Broken pipe”错误）和<code>ECONNRESET</code>（连接被对端重置）。</li>
</ul>
</li>
</ul>
</li>
<li>利用tcp自带的keepalive机制</li>
</ol>
<h4 id="如何查看系统的最大进程数和线程数"><a href="#如何查看系统的最大进程数和线程数" class="headerlink" title="如何查看系统的最大进程数和线程数"></a>如何查看系统的最大进程数和线程数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/pid_max    # 最大进程数</span><br><span class="line">cat /proc/sys/kernel/threads-max	# 最大线程数</span><br></pre></td></tr></table></figure>



<h4 id="git-rebase和git-merge的区别（https-joyohub-com-2020-04-06-git-rebase-）"><a href="#git-rebase和git-merge的区别（https-joyohub-com-2020-04-06-git-rebase-）" class="headerlink" title="git rebase和git merge的区别（https://joyohub.com/2020/04/06/git-rebase/）"></a>git rebase和git merge的区别（<a target="_blank" rel="noopener" href="https://joyohub.com/2020/04/06/git-rebase/%EF%BC%89">https://joyohub.com/2020/04/06/git-rebase/）</a></h4><h4 id="C-calss-和-struct的区别"><a href="#C-calss-和-struct的区别" class="headerlink" title="C++ calss 和 struct的区别"></a>C++ calss 和 struct的区别</h4><p>class默认访问类型是private，struct默认访问类型是public</p>
<h4 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h4><ol>
<li>指针是一个变量，它保存了另一个变量的内存地址；引用是另一个变量的别名，与原变量共享内存地址。</li>
<li>指针可以被重新赋值，指向新的对象；引用绑定对象后不能更改。</li>
<li>指针可以为nullptr；引用必须初始化。</li>
</ol>
<h4 id="为什么模板类的声明和实现不能分别写在-h文件和-cpp文件中"><a href="#为什么模板类的声明和实现不能分别写在-h文件和-cpp文件中" class="headerlink" title="为什么模板类的声明和实现不能分别写在.h文件和.cpp文件中"></a>为什么模板类的声明和实现不能分别写在.h文件和.cpp文件中</h4><p>首先，模板不是传统意义上的代码。它更像是编译器的“代码生成工具”。当你使用一个特定的模板类型（例如<code>std::vector&lt;int&gt;</code>)，<strong>编译器会为你生成这种类型的实例代码</strong>。为了做到这一点，编译器需要能够看到模板的完整定义。注意：这就是模板和普通类的最大区别。普通类在编译阶段并没有（并不依赖于）编译时的类型特化，只需要在链接阶段将所有.cpp文件链接在一起就好了。而如果模板分开写，其他使用模板的.cpp文件在编译时找不到定义，导致链接错误。</p>
<h4 id="动态链接与静态链接"><a href="#动态链接与静态链接" class="headerlink" title="动态链接与静态链接"></a>动态链接与静态链接</h4><p>静态链接（.a&#x2F;.lib）：把要调用的函数或者过程链接到可执行文件中，成为可执行文件的一部分。如果多个程序使用相同的库，那么该库的代码在每个程序中都会被复制，这浪费了磁盘和内存空间。但是所有代码都在可执行文件中，没有运行时链接开销。</p>
<p>动态链接（.so&#x2F;.ddl）：动态链接所调用的函数代码并没有被拷贝到应用程序的可执行文件中去，而是仅仅在其中加入了所调用函数的描述信息（往往是一些重定位信息）。仅当应用程序被装入内存开始运行时，在Windows的管理下，才在应用程序与相应的DLL之间建立链接关系。当要执行所调用DLL中的函数时，根据链接产生的重定位信息，Windows才转去执行DLL中相应的函数代码。多份代码可以共享同一份库代码。</p>
<h4 id="pragma-pack编译宏"><a href="#pragma-pack编译宏" class="headerlink" title="pragma pack编译宏"></a>pragma pack编译宏</h4><p>pragma pack用于指定内存对齐值。</p>
<h4 id="vector底层实现原理"><a href="#vector底层实现原理" class="headerlink" title="vector底层实现原理"></a>vector底层实现原理</h4><p>理解vector的实现主要考虑四个东西就好了：三个指针加动态内存申请。</p>
<p>三个指针：</p>
<ul>
<li>first_：指向vector容器对象起始地址的位置</li>
<li>last_：指向vector容器对象中当前最后一个元素的末尾字节</li>
<li>end_：指向vector容器所占内存空间的最后一个字节</li>
</ul>
<p><img src="png1.gif"></p>
<p>动态内存申请：</p>
<p>当 vector 的大小和容量相等（size&#x3D;&#x3D;capacity）也就是满载时，如果再向其添加元素，那么 vector 就需要扩容。vector 容器扩容的过程需要经历以下 3 步：</p>
<ol>
<li>完全弃用现有的内存空间，重新申请更大的内存空间；</li>
<li>将旧内存空间中的数据，按原有顺序移动到新的内存空间中；</li>
<li>最后将旧的内存空间释放。</li>
</ol>
<h4 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h4><p>常量指针：记忆方法（常量的指针），指针指向的对象是一个常量，只能读取指针指向的内容，不能修改指针指向的内容。</p>
<p>指针常量：指针本身是一个常量，不能修改指针指向的地址，可以修改指针指向地址的内容。</p>
<h4 id="C-中一些特别的关键字（default，override、final、volatile）"><a href="#C-中一些特别的关键字（default，override、final、volatile）" class="headerlink" title="C++中一些特别的关键字（default，override、final、volatile）"></a>C++中一些特别的关键字（default，override、final、volatile）</h4><p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u011947630/article/details/103062773">https://blog.csdn.net/u011947630/article/details/103062773</a></p>
<h4 id="字节算法题：小于N的最大数"><a href="#字节算法题：小于N的最大数" class="headerlink" title="字节算法题：小于N的最大数"></a>字节算法题：小于N的最大数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> value = <span class="number">14132</span>;</span><br><span class="line">string valueStr = <span class="built_in">to_string</span>(value);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index, <span class="type">bool</span> judge, <span class="type">int</span> temp)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(index == valueStr.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ans = temp;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(judge) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">true</span>, temp * <span class="number">10</span> + (nums[nums.<span class="built_in">size</span>() - <span class="number">1</span>]));    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> val = valueStr[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val == nums[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">false</span>, temp * <span class="number">10</span> + nums[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; nums[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">true</span>, temp * <span class="number">10</span> + nums[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最终结果为空</span></span><br><span class="line">        <span class="keyword">if</span>(index != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//少了一位，显然小了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(index + <span class="number">1</span>, <span class="literal">true</span>, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="如果同时有大量客户并发建立连接，服务器端有什么机制进行处理"><a href="#如果同时有大量客户并发建立连接，服务器端有什么机制进行处理" class="headerlink" title="如果同时有大量客户并发建立连接，服务器端有什么机制进行处理"></a>如果同时有大量客户并发建立连接，服务器端有什么机制进行处理</h4><ol>
<li>多进程和多线程</li>
<li>连接池</li>
<li>异步I&#x2F;O</li>
<li>负载均衡</li>
<li>限流</li>
<li>短连接与长连接</li>
</ol>
<h4 id="HTTP和TCP之间的关系"><a href="#HTTP和TCP之间的关系" class="headerlink" title="HTTP和TCP之间的关系"></a>HTTP和TCP之间的关系</h4><ol>
<li><p>HTTP是一个应用层协议，TCP是一个传输层协议</p>
</li>
<li><p>HTTP依赖于TCP来进行数据的传输。比如，当你使用浏览器访问一个网页时，背后发生的是HTTP请求和响应的交换，而这些HTTP数据包是通过TCP连接发送的。</p>
</li>
<li><p>HTTP&#x2F;1.0对于每一个请求-响应都会新建一个TCP连接，使用完之后就关闭</p>
<p>HTPP&#x2F;1.1引入了keep-alive机制，允许在单个TCP连接上发送多个HTTP请求和响应</p>
<p>HTTP&#x2F;2进一步扩展了这种机制，允许在单个TCP连接上同时多路复用多个HTTP请求和响应</p>
</li>
</ol>
<h4 id="HTTP从请求到得到结果的过程"><a href="#HTTP从请求到得到结果的过程" class="headerlink" title="HTTP从请求到得到结果的过程"></a>HTTP从请求到得到结果的过程</h4><ol>
<li><p><strong>域名解析</strong>：</p>
<ul>
<li>客户端（通常是浏览器）首先检查URL是否包含域名（例如 <code>www.example.com</code>）。</li>
<li>如果包含，客户端首先会查找其DNS缓存是否已经有该域名的IP地址。</li>
<li>如果没有，客户端会发起一个DNS查询到配置的DNS服务器，以获取对应的IP地址。</li>
</ul>
</li>
<li><p><strong>建立TCP连接</strong>：</p>
<ul>
<li>使用从DNS查询得到的IP地址，客户端尝试与服务器的80端口（HTTP）或443端口（HTTPS）建立一个TCP连接。</li>
<li>这涉及到TCP三次握手过程。</li>
</ul>
</li>
<li><p><strong>（HTTPS的情况）SSL&#x2F;TLS握手</strong>：</p>
<ul>
<li>如果是HTTPS请求，一旦TCP连接建立，客户端和服务器会进行SSL&#x2F;TLS握手来建立加密的通信通道。</li>
</ul>
</li>
<li><p><strong>发送HTTP请求</strong>：</p>
<ul>
<li>连接建立后，客户端会发送HTTP请求报文。这包括请求行（例如 <code>GET /path HTTP/1.1</code>）、请求头和（对于某些请求如POST）请求体。</li>
</ul>
</li>
<li><p><strong>服务器处理请求</strong>：</p>
<ul>
<li>服务器接收到请求后，由其HTTP服务软件（如Apache、Nginx等）处理。</li>
<li>服务器可能会根据请求路径查询文件、与数据库交互或调用其他服务，以生成响应。</li>
</ul>
</li>
<li><p><strong>服务器发送响应</strong>：</p>
<ul>
<li>服务器生成响应后，它将响应报文发送回客户端。响应通常包括状态行（例如 <code>HTTP/1.1 200 OK</code>）、响应头和响应体。</li>
<li>对于动态内容，如由PHP、Python或Node.js等后端语言生成的页面，服务器可能会进行一些额外的处理来生成响应内容。</li>
</ul>
</li>
<li><p><strong>客户端处理响应</strong>：</p>
<ul>
<li>客户端（如浏览器）接收响应，并基于响应内容采取相应的行动。</li>
<li>如果响应是一个HTML页面，浏览器会开始解析HTML，并可能发起其他请求来获取页面上的资源，如图片、CSS、JavaScript文件等。</li>
</ul>
</li>
<li><p><strong>关闭连接</strong>：</p>
<ul>
<li>一旦数据交换完成，通常会关闭TCP连接。然而，在HTTP&#x2F;1.1中，默认使用<code>keep-alive</code>，意味着连接可以被复用，从而减少后续请求的延迟。</li>
</ul>
</li>
</ol>
<h4 id="https和http的区别是什么，https具体是怎么做的"><a href="#https和http的区别是什么，https具体是怎么做的" class="headerlink" title="https和http的区别是什么，https具体是怎么做的"></a>https和http的区别是什么，https具体是怎么做的</h4><p>HTTPS和HTTP唯一的区别就是HTTPS使用TLS&#x2F;SSL来加密普通的HTTP请求和响应。</p>
<p>关于https具体是如何做的，这里有一个参考博文链接，写的超好（参考链接：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/http-vs-https.html%EF%BC%89">https://www.runoob.com/w3cnote/http-vs-https.html）</a></p>
<h4 id="gdb中，如何查看每个线程相关的信息"><a href="#gdb中，如何查看每个线程相关的信息" class="headerlink" title="gdb中，如何查看每个线程相关的信息"></a>gdb中，如何查看每个线程相关的信息</h4><p>在 gdb 中，可以使用 <code>info threads</code> 命令查看当前进程中的所有线程信息。这个命令会列出每个线程的编号、状态（如运行、挂起等）以及当前所在的函数名称。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info threads</span><br><span class="line">  Id   Target Id         Frame </span><br><span class="line">  2    Thread 0x7ffff7fc8700 (LWP 13627) <span class="string">&quot;main&quot;</span> __libc_start_main (argc=1, argv=0x7fffffffe4c8, <span class="built_in">env</span>=0x7fffffffe4d8,</span><br><span class="line">      auxvec=0x7fffffffe4d8, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffe4c8) at ../csu/libc-start.c:310</span><br><span class="line">  3    Thread 0x7ffff77c7700 (LWP 13628) <span class="string">&quot;main&quot;</span> foo () at test.c:6</span><br><span class="line">  4    Thread 0x7ffff6fc6700 (LWP 13629) <span class="string">&quot;main&quot;</span> bar () at test.c:11</span><br></pre></td></tr></table></figure>

<p>你还可以使用 <code>thread &lt;thread-id&gt;</code> 命令来切换到指定的线程，然后使用其他 gdb 命令来查看线程的信息或调试线程。</p>
<p>例如，你可以输入 <code>thread 3</code> 命令切换到编号为 3 的线程，然后输入 <code>bt</code> 命令来查看线程的调用堆栈：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) thread 3</span><br><span class="line">[Switching to thread 3 (Thread 0x7ffff77c7700 (LWP 13628))]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  foo () at test.c:6</span></span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  foo () at test.c:6</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x00007ffff7bbb830 <span class="keyword">in</span> start_thread (arg=&lt;optimized out&gt;) at pthread_create.c:486</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  0x00007ffff78f95fd <span class="keyword">in</span> <span class="built_in">clone</span> () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95</span></span><br></pre></td></tr></table></figure>



<h4 id="构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因"><a href="#构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因" class="headerlink" title="构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因"></a>构造函数中能调用虚函数吗，如果调用虚函数，会出现什么问题，写程序验证，并从原理上分析原因</h4><p>构造函数从语法上调用虚函数没有任何问题，但这样做可能并不会达到预期的结果。因为在构造函数执行期间，对象的虚表仍在被设置，因此调用的虚函数版本可能并不是我们想要的版本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base construct\n&quot;</span>;</span><br><span class="line">        <span class="built_in">call</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base call\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived construct\n&quot;</span>;</span><br><span class="line">        <span class="built_in">call</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">call</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived call\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Derived</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这段程序，可能我们期望得到的结果是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Derived call</span><br><span class="line">Derived constructor</span><br><span class="line">Derived call</span><br></pre></td></tr></table></figure>

<p>但我们实际得到的结果是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Base constructor</span><br><span class="line">Base call</span><br><span class="line">Derived constructor</span><br><span class="line">Derived call</span><br></pre></td></tr></table></figure>

<p>原因是在Base构造函数执行时，Derived部分的对象还没有完全构造出来，因此，此时vtable仍然指向Base类的vtable。因此，当在Base构造函数中调用call虚函数时，他会调用Base版本，而不是Derived版本。</p>
<p><strong>这里延伸一下不要在析构函数中调用虚函数的原因</strong>：析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经“销毁”，这个时再调用子类的虚函数已经没有意义了。</p>
<h4 id="迭代器的实现"><a href="#迭代器的实现" class="headerlink" title="迭代器的实现"></a>迭代器的实现</h4><p>参考链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wengle520/p/12492708.html">https://www.cnblogs.com/wengle520/p/12492708.html</a></p>
<h4 id="epoll红黑树的作用"><a href="#epoll红黑树的作用" class="headerlink" title="epoll红黑树的作用"></a>epoll红黑树的作用</h4><p>简单点讲就是在内核事件表上快速注册&#x2F;删除所需连接文件描述符。下面两篇文章基本阐述了这个问题，好好看！</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1862671">https://cloud.tencent.com/developer/article/1862671</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/366955699">https://zhuanlan.zhihu.com/p/366955699</a></p>
<h4 id="用户态和内核态分别会做什么，怎么切换的"><a href="#用户态和内核态分别会做什么，怎么切换的" class="headerlink" title="用户态和内核态分别会做什么，怎么切换的"></a>用户态和内核态分别会做什么，怎么切换的</h4><p>内核空间主要负责操作系统内核线程以及用户程序系统调用。</p>
<p>用户空间主要负责用户程序的非系统调用。</p>
<p>从用户态切换到内核态主要有三种方式：</p>
<ol>
<li>系统调用：系统调用本身就是中断，但是<strong>软件中断</strong>，跟硬中断不同。系统调用机制是使用了操作系统为用户特别开放的一个中断来实现，如 Linux 的 int 80h 中断。</li>
<li>异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，会触发由当前运行进程切换到处理此异常的内核相关进程中</li>
<li>外围设备中断：外围设备完成用户请求的操作之后，会向CPU发出中断信号，这时CPU会转去处理对应的中断处理程序。</li>
</ol>
<p>有一个面试问题：I&#x2F;O频繁发生内核态和用户态切换，怎么解决？</p>
<p>答案：使用用户进程缓冲区。</p>
<p>用户进程缓冲区</p>
<p>你看一些程序在读取文件时，会先申请一块内存数组，称为buffer，然后每次调用read，读取设定字节长度的数据，写入buffer。之后的程序都是从buffer中获取数据，当buffer使用完后，在进行下一次调用，填充buffer。所以说：用户缓冲区的目的就是是为了减少系统调用次数，从而降低操作系统在用户态与核心态切换所耗费的时间。除了在进程中设计缓冲区，内核也有自己的缓冲区。</p>
<p>内核缓存区</p>
<p>当一个用户进程要从磁盘读取数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程缓冲区中。但若是内核缓冲区中没有数据，内核会把对数据块的请求，加入到请求队列，然后把进程挂起，为其它进程提供服务。等到数据已经读取到内核缓冲区时，把内核缓冲区中的数据读取到用户进程中，才会通知进程，当然不同的IO模型，在调度和使用内核缓冲区的方式上有所不同。</p>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42052956/article/details/111562280">https://blog.csdn.net/qq_42052956/article/details/111562280</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2131401">https://cloud.tencent.com/developer/article/2131401</a></p>
<h4 id="进程的创建需要系统分配什么资源"><a href="#进程的创建需要系统分配什么资源" class="headerlink" title="进程的创建需要系统分配什么资源"></a>进程的创建需要系统分配什么资源</h4><p>根据其他博客里写的底层源码来看，分配给一个进程的东西太多啦，我们挑几个记一下：内存、CPU处理时间、输入输出设备、存储空间。</p>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lvyibin890/article/details/82193900">https://blog.csdn.net/lvyibin890/article/details/82193900</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/s/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%99%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E4%BB%80%E4%B9%88%E8%B5%84%E6%BA%90">https://juejin.cn/s/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%99%E8%BF%9B%E7%A8%8B%E5%88%86%E9%85%8D%E4%BB%80%E4%B9%88%E8%B5%84%E6%BA%90</a></p>
<h4 id="HTTPS加密方式：对称加密、非对称加密"><a href="#HTTPS加密方式：对称加密、非对称加密" class="headerlink" title="HTTPS加密方式：对称加密、非对称加密"></a>HTTPS加密方式：对称加密、非对称加密</h4><p>对称加密：密钥只有一个，加密解密为同一个密码。利用这种加密方式时必须把密钥也发送给对方，密钥在传输过程中被窃取，也就失去了加密的意义。</p>
<p>非对称加密：密钥成对出现，公钥加密需要私钥解密，私钥加密需要公钥解密。</p>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/http-vs-https.html">https://www.runoob.com/w3cnote/http-vs-https.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.itwork.club/2022/05/27/why-did-https-use-mixed-encryption-algorithm/">https://www.itwork.club/2022/05/27/why-did-https-use-mixed-encryption-algorithm/</a></p>
<h4 id="线程的三种状态"><a href="#线程的三种状态" class="headerlink" title="线程的三种状态"></a>线程的三种状态</h4><p>就绪态、运行态、阻塞态</p>
<h4 id="析构函数里能不能抛异常-为什么？"><a href="#析构函数里能不能抛异常-为什么？" class="headerlink" title="析构函数里能不能抛异常?为什么？"></a>析构函数里能不能抛异常?为什么？</h4><p>析构函数从语法上是可以抛出异常的，但是这样做很危险，请尽量不要这要做。原因在《More Effective C++》中提到两个： </p>
<p>（1）如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。 </p>
<p>（2）通常异常发生时，c++的异常处理机制在异常的传播过程中会进行栈展开（stack-unwinding），因发生异常而逐步退出复合语句和函数定义的过程，被称为栈展开。在栈展开的过程中就会调用已经在栈构造好的对象的析构函数来释放资源，此时若其他析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃。</p>
<h4 id="两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？"><a href="#两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？" class="headerlink" title="两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？"></a>两个类里有相同的成员，区别在于一个有虚函数，一个没有，哪个内存大？</h4><p>有虚函数的大，因为有虚函数的类的会包含一个虚函数指针。注意不同操作系统指针大小不一样。</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/luolaihua2018/article/details/110736211">https://blog.csdn.net/luolaihua2018/article/details/110736211</a></p>
<h4 id="数据报和数据流的区别？"><a href="#数据报和数据流的区别？" class="headerlink" title="数据报和数据流的区别？"></a>数据报和数据流的区别？</h4><p>可以这么简单理解：</p>
<p>假设现在有100字节数据，面向数据流和面向数据报的连接可以分别怎么样处理呢？</p>
<ul>
<li>数据流是发送端可以调用10次write，每次10字节。接收端调用一次read。也可以是发送端调用一次write，接收端调用10次read。数据流是没有边界的</li>
<li>数据报则是一次write就需要一次read，是有边界的。</li>
</ul>
<h4 id="在分布式系统中，如果某个节点宕机了咋办？"><a href="#在分布式系统中，如果某个节点宕机了咋办？" class="headerlink" title="在分布式系统中，如果某个节点宕机了咋办？"></a>在分布式系统中，如果某个节点宕机了咋办？</h4><p>做一个数据副本策略，把每一台机器上的数据做几个副本的冗余，放在别的机器上。万一说某一台机器宕机，没事啊，因为其他机器上还有他的副本。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>所谓自旋锁就是通过while循环实现的，让拿到锁的线程进入临界区执行代码，让没有拿到锁的线程一直进行while死循环，这其实就是线程自己“旋”在while循环了，因而这种锁就叫做自旋锁。</p>
<p>自旋锁实现参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jeffasd/article/details/80661804">https://blog.csdn.net/jeffasd/article/details/80661804</a></p>
<h4 id="线程同步的方式有哪些"><a href="#线程同步的方式有哪些" class="headerlink" title="线程同步的方式有哪些"></a>线程同步的方式有哪些</h4><p>互斥锁、信号量、条件变量、自旋锁、读写锁、屏障</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/06/28/RPC/" rel="prev" title="RPC">
                  <i class="fa fa-angle-left"></i> RPC
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/07/26/shared-ptr/" rel="next" title="智能指针shared_ptr的实现">
                  智能指针shared_ptr的实现 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">GGBond</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"cdn":"https://cdn.jsdelivr.net/npm/mathjax@2.7.8/MathJax.js?config=TeX-AMS-MML_HTMLorMML","tags":"none","src":"custom_mathjax_source","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>

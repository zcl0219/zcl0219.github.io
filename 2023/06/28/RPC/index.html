<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar-16.png">
  <link rel="mask-icon" href="/images/emoji-smile.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zcl0219.github.io","root":"/","images":"/images","scheme":"Mist","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":true,"style":null,"show_result":true},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="开始补上MPRPC项目的代码实现，从头开始———-day1简介：项目基于muduo高性能网络库 + protobuf开发，所以命名为mprpc。 技术栈  集群和分布式概念及原理 RPC远程过程调用原理及实现 Protobuf数据序列化和反序列化协议 Zookeeper分布式一致性协调服务应用及编程（服务注册中心，方便寻找哪个服务在哪台服务器上） muduo网络库编程 conf配置文件读取 CMa">
<meta property="og:type" content="article">
<meta property="og:title" content="RPC">
<meta property="og:url" content="http://zcl0219.github.io/2023/06/28/RPC/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="开始补上MPRPC项目的代码实现，从头开始———-day1简介：项目基于muduo高性能网络库 + protobuf开发，所以命名为mprpc。 技术栈  集群和分布式概念及原理 RPC远程过程调用原理及实现 Protobuf数据序列化和反序列化协议 Zookeeper分布式一致性协调服务应用及编程（服务注册中心，方便寻找哪个服务在哪台服务器上） muduo网络库编程 conf配置文件读取 CMa">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://zcl0219.github.io/2023/06/28/RPC/png1.PNG">
<meta property="og:image" content="http://zcl0219.github.io/2023/06/28/RPC/png2.png">
<meta property="og:image" content="http://zcl0219.github.io/2023/06/28/RPC/png3.png">
<meta property="og:image" content="http://zcl0219.github.io/2023/06/28/RPC/png4.png">
<meta property="article:published_time" content="2023-06-28T14:08:50.000Z">
<meta property="article:modified_time" content="2023-09-18T06:18:48.048Z">
<meta property="article:author" content="GGBond">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://zcl0219.github.io/2023/06/28/RPC/png1.PNG">


<link rel="canonical" href="http://zcl0219.github.io/2023/06/28/RPC/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://zcl0219.github.io/2023/06/28/RPC/","path":"2023/06/28/RPC/","title":"RPC"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>RPC | Hexo</title>
  







<link href="https://fonts.googleapis.com/css?family=Noto+Serif+SC|Roboto&display=swap" rel="stylesheet">

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hexo</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B%E8%A1%A5%E4%B8%8AMPRPC%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%BB%8E%E5%A4%B4%E5%BC%80%E5%A7%8B%E2%80%94%E2%80%94%E2%80%94-day1"><span class="nav-number">1.</span> <span class="nav-text">开始补上MPRPC项目的代码实现，从头开始———-day1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%88%E6%90%9E%E6%87%82%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E5%B8%83%E5%BC%8F%EF%BC%89"><span class="nav-number">1.1.</span> <span class="nav-text">集群和分布式（搞懂为什么要分布式）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPC%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94%E2%80%94-day2"><span class="nav-number">2.</span> <span class="nav-text">RPC通信原理———-day2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-number">3.</span> <span class="nav-text">项目环境搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E6%88%90"><span class="nav-number">3.1.</span> <span class="nav-text">文件组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Ubuntu-protobuf%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="nav-number">3.2.</span> <span class="nav-text">Ubuntu protobuf环境搭建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#muduo%E5%BA%93%E5%AE%89%E8%A3%85"><span class="nav-number">3.3.</span> <span class="nav-text">muduo库安装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%EF%BC%88%E5%BE%AA%E5%BA%8F%E6%B8%90%E8%BF%9B%EF%BC%8C%E7%8E%B0%E5%9C%A8%E9%9C%80%E8%A6%81%E5%93%AA%E4%BA%9B%E6%96%87%E4%BB%B6%E5%A4%B9%E5%B0%B1%E5%88%9B%E5%BB%BA%E5%93%AA%E4%BA%9B%EF%BC%89"><span class="nav-number">3.4.</span> <span class="nav-text">创建文件（循序渐进，现在需要哪些文件夹就创建哪些）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#protobuf%E5%AE%9E%E8%B7%B5%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89"><span class="nav-number">3.5.</span> <span class="nav-text">protobuf实践讲解（一）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#protobuf%E5%AE%9E%E8%B7%B5%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="nav-number">3.6.</span> <span class="nav-text">protobuf实践讲解（二）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#protobuf%E5%AE%9E%E8%B7%B5%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89"><span class="nav-number">3.7.</span> <span class="nav-text">protobuf实践讲解（三）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E6%88%90RPC%E6%9C%8D%E5%8A%A1%EF%BC%88%E4%B8%80%EF%BC%89"><span class="nav-number">3.8.</span> <span class="nav-text">本地服务如何发布成RPC服务（一）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%A6%82%E4%BD%95%E5%8F%91%E5%B8%83%E6%88%90RPC%E6%9C%8D%E5%8A%A1%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="nav-number">3.9.</span> <span class="nav-text">本地服务如何发布成RPC服务（二）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mprpc%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E7%B1%BB%E8%AE%BE%E8%AE%A1"><span class="nav-number">3.10.</span> <span class="nav-text">Mprpc框架基础类设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mprpc%E6%A1%86%E6%9E%B6%E9%A1%B9%E7%9B%AE%E5%8A%A8%E6%80%81%E5%BA%93%E7%BC%96%E8%AF%91"><span class="nav-number">3.11.</span> <span class="nav-text">Mprpc框架项目动态库编译</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mprpc%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%88%E4%B8%80%EF%BC%89"><span class="nav-number">3.12.</span> <span class="nav-text">Mprpc配置文件的加载（一）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mprpc%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="nav-number">3.13.</span> <span class="nav-text">Mprpc配置文件的加载（二）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E5%8F%91RpcProvider%E7%9A%84%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1"><span class="nav-number">3.14.</span> <span class="nav-text">开发RpcProvider的网络服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RpcProvider%E5%8F%91%E5%B8%83%E6%9C%8D%E5%8A%A1%E6%96%B9%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89"><span class="nav-number">3.15.</span> <span class="nav-text">RpcProvider发布服务方法（一）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RpcProvider%E5%93%8D%E5%BA%94%E5%9B%9E%E8%B0%83%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.16.</span> <span class="nav-text">RpcProvider响应回调实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RpcController"><span class="nav-number">3.17.</span> <span class="nav-text">RpcController</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="GGBond"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">GGBond</p>
  <div class="site-description" itemprop="description">Doing the tough things sets winners apart from losers</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://zcl0219.github.io/2023/06/28/RPC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="GGBond">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="Doing the tough things sets winners apart from losers">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="RPC | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RPC
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-06-28 22:08:50" itemprop="dateCreated datePublished" datetime="2023-06-28T22:08:50+08:00">2023-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-09-18 14:18:48" itemprop="dateModified" datetime="2023-09-18T14:18:48+08:00">2023-09-18</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h3 id="开始补上MPRPC项目的代码实现，从头开始———-day1"><a href="#开始补上MPRPC项目的代码实现，从头开始———-day1" class="headerlink" title="开始补上MPRPC项目的代码实现，从头开始———-day1"></a><strong>开始补上<code>MPRPC</code>项目的代码实现，从头开始———-<code>day1</code></strong></h3><p>简介：项目基于muduo高性能网络库 + protobuf开发，所以命名为mprpc。</p>
<p>技术栈</p>
<ul>
<li>集群和分布式概念及原理</li>
<li>RPC远程过程调用原理及实现</li>
<li>Protobuf数据序列化和反序列化协议</li>
<li>Zookeeper分布式一致性协调服务应用及编程（服务注册中心，方便寻找哪个服务在哪台服务器上）</li>
<li>muduo网络库编程</li>
<li>conf配置文件读取</li>
<li>CMake构建项目集成编译环境</li>
</ul>
<h4 id="集群和分布式（搞懂为什么要分布式）"><a href="#集群和分布式（搞懂为什么要分布式）" class="headerlink" title="集群和分布式（搞懂为什么要分布式）"></a><strong>集群和分布式（搞懂为什么要分布式）</strong></h4><p><strong>集群</strong>：每一台服务器独立运行一个工程的所有模块</p>
<p><strong>分布式</strong>：一个工程拆分了很多模块，每一个模块独立部署运行在一个服务器主机上，所有服务器协同工作共同提供服务，每一台服务器称作分布式的一个节点，根据节点的并发要求，对一个节点可以再做节点模块集群部署。</p>
<p><img src="png1.PNG"></p>
<p>如图中<code>server</code>所示，一个聊天系统包括不同模块：用户管理、好友管理、群组管理、消息管理以及后台管理五个模块。每个模块有自己的特定业务，举个例子，用户管理模块包括用户注册、用户登录、用户注销等。</p>
<p>现在让你提出一些单机聊天服务器的缺陷，你能想到哪些？</p>
<ol>
<li>受限于硬件资源，聊天服务器所能承受的用户的并发量，比如端口用光了。</li>
<li>假设这个单机聊天服务器体系很庞大，项目编译需要两个小时！如果现在消息管理模块有一个小<code>bug</code>，需要改动几行，然后导致需要重新编译、部署整个项代码。</li>
<li>系统中，有些模块是属于<code>CPU</code>密集型，有些模块是<code>I/O</code>密集型的，造成各模块对于硬件资源的需求是不一样的。既然受限于硬件资源，我们就多部署几台服务器，横向增加服务器数量。但并未解决问题2和3。</li>
</ol>
<p>集群的优缺点如下，优点：用户的并发量提升了。缺点：项目代码还是需要整体重新编译，而且需要进行多次部署。</p>
<p><img src="png2.png"></p>
<p>现在我们看红色圈，我们把不同模块分类部署在不同服务器上。所有服务器共同构成一个聊天系统，这就是分布式。现在我们将不同服务器分别视为不同分布式节点。比如用户管理模块和消息管理模块对并发要求高，我们可以进行扩容，再部署几台服务器用于用户管理和消息管理（根据节点的并发要求，对一个节点可以再做节点模块集群部署）。分布式系统针对问题2，每个模块独立部署独立运行，哪个模块有<code>bug</code>，我只需要重新编译部署那个模块，其他模块还能正常运行。问题3就很明显了，视不同要求配置不同服务器。</p>
<p>那分布式就全是优点吗？下面我们说说关于分布式设计的难点。</p>
<ol>
<li>大系统的软件模块该怎么划分。</li>
<li>各模块之间怎么访问？集群服务器所有模块运行在一个进程里，不同模块之间访问简便。而分布式各模块都运行在不同的进程里，那服务器1的模块怎么调用服务器2上的模块的一个业务方法呢？我们这个项目所做的就是封装这种远程调用过程，方便用户调用，也就是程序员方便使用我们写的项目（<code>MPRPC</code>）。</li>
</ol>
<h3 id="RPC通信原理———-day2"><a href="#RPC通信原理———-day2" class="headerlink" title="RPC通信原理———-day2"></a><strong><code>RPC</code>通信原理———-<code>day2</code></strong></h3><p><img src="png3.png"></p>
<p>通过上图我们可以看到，我们设计的框架主要由以下部分和流程组成：</p>
<ul>
<li>发起调用端（caller）：调用方需要将调用的函数名、参数打包（序列化），并通过网络发送出去。这里打算采用muduo网络库。</li>
<li>接收端（callee）：接收方接收到包后，将包里的内容反序列化，就能知道调用哪一个函数、传入的参数是啥，然后返回值依旧是序列化之后通过网络发送回去，发送端接收到后反序列化，得到具体的返回值。</li>
<li>我们的框架主要是实现图中的黄绿部分。<ol>
<li>黄色部分是rpc方法参数的打包和解析，也就是数据的序列化与反序列化，通过protobuf完成。</li>
<li>在图中，有一些东西没画进去，比如我们将黄色块分别取名为client-stub和server-stub。这两个stub都是执行数据的序列化与反序列化。</li>
<li>如果远程调用过程中函数执行出错，我们可以返回一些错误码，防止接收端读取错误的返回值。</li>
<li>绿色部分：网络部分，包括寻找rpc服务主机，发起rpc调用请求和响应rpc调用结果，使用muduo网络库和Zookeeper服务配置中心（专门做服务发现）。</li>
</ol>
</li>
</ul>
<p>protobuf相对于json的好处：</p>
<p>1、protobuf是二进制存储；xml和json都是文本存储</p>
<p>2、protobuf不需要存储额外的信息；json通过key-value存储数据</p>
<ul>
<li><p>json：name: “zhang san”, pwd: “123456”</p>
</li>
<li><p>protobuf: “zhangsan” “123456”</p>
</li>
</ul>
<h3 id="项目环境搭建"><a href="#项目环境搭建" class="headerlink" title="项目环境搭建"></a><strong>项目环境搭建</strong></h3><h4 id="文件组成"><a href="#文件组成" class="headerlink" title="文件组成"></a>文件组成</h4><ul>
<li>bin：可执行文件</li>
<li>build：项目编译文件</li>
<li>lib：项目库文件</li>
<li>src：源文件</li>
<li>test：测试代码</li>
<li>example：框架代码使用范例</li>
<li>CMakeLists.txt：顶层的</li>
<li>cmake文件</li>
<li>README.md：项目自述文件</li>
<li>autonbuild.sh：一键编译脚本</li>
</ul>
<h4 id="Ubuntu-protobuf环境搭建"><a href="#Ubuntu-protobuf环境搭建" class="headerlink" title="Ubuntu protobuf环境搭建"></a>Ubuntu protobuf环境搭建</h4><p>首先在GitHub下载源代码，源码包中src&#x2F;README.md有详细的安装说明，也可以按照如下步骤安装：</p>
<ol>
<li>解压压缩包：unzip protobuf-master.zip</li>
<li>进入解压后的文件夹：cd protobuf-master</li>
<li>安装所需工具：sudo apt-get install autoconf automake libtool curl make g++ unzip</li>
<li>自动生成configure配置文件：.&#x2F;autogen.sh</li>
<li>配置环境：.&#x2F;configure</li>
<li>编译源代码（时间比较长）：make</li>
<li>安装：sudo make install</li>
<li>刷新动态库：sudo ldconfig</li>
<li>测试：看能否正常执行protoc命令（直接去终端执行）</li>
</ol>
<p>源码下载地址：<a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf">https://github.com/protocolbuffers/protobuf</a></p>
<h4 id="muduo库安装"><a href="#muduo库安装" class="headerlink" title="muduo库安装"></a>muduo库安装</h4><p>关于muduo库安装，强烈推荐按照施老师的步骤来（参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/QIANGWEIYUAN/article/details/89023980%EF%BC%89%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%B8%8D%E7%94%A8%E7%9C%8B%E6%88%91%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4%EF%BC%8C%E4%B8%8D%E5%AE%8C%E6%95%B4%EF%BC%81%EF%BC%81%EF%BC%81">https://blog.csdn.net/QIANGWEIYUAN/article/details/89023980），可以不用看我下面的安装步骤，不完整！！！</a></p>
<ol>
<li>安装依赖：sudo apt-get install libbost-dev libbost-test-dev sudo apt-get install libcurl4-openssl-dev libc-ares-dev</li>
<li>拉文件：git clone <a target="_blank" rel="noopener" href="https://github.com/chenshuo/muduo.git">https://github.com/chenshuo/muduo.git</a></li>
<li>.&#x2F;build.sh</li>
</ol>
<p>muduo库是否安装成功的测试：muduo_test.cpp实现了一个简单的echo server</p>
<p>编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++11 muduo_test.cpp -lmuduo_net -lmuduo_base -lpthread -o muduo_test</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<p>一个shell终端执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./muduo_test </span><br></pre></td></tr></table></figure>

<p>另一个shell终端执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 8032</span><br></pre></td></tr></table></figure>

<p>如下图所示则安装成功</p>
<p><img src="png4.png"></p>
<h4 id="创建文件（循序渐进，现在需要哪些文件夹就创建哪些）"><a href="#创建文件（循序渐进，现在需要哪些文件夹就创建哪些）" class="headerlink" title="创建文件（循序渐进，现在需要哪些文件夹就创建哪些）"></a>创建文件（循序渐进，现在需要哪些文件夹就创建哪些）</h4><p>首先，我们可以以自己的名字缩写作为后缀创建一个mprpc文件夹，比如我创建的</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir mprpc_zcl</span><br></pre></td></tr></table></figure>

<p>接下来我们需要在mprpc_zcl文件夹里创建以下这些文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cd mprpc_zcl</span><br><span class="line">mkdir bin</span><br><span class="line">mkdir build</span><br><span class="line">mkdir example</span><br><span class="line">mkdir lib</span><br><span class="line">mkdir src</span><br><span class="line">mkdir test</span><br><span class="line">touch autobuild.sh</span><br><span class="line">touch CMakeLists.txt</span><br></pre></td></tr></table></figure>

<p>好啦，第一件该做的事我们已经完成啦！</p>
<h4 id="protobuf实践讲解（一）"><a href="#protobuf实践讲解（一）" class="headerlink" title="protobuf实践讲解（一）"></a>protobuf实践讲解（一）</h4><p>首先我们写一个protobuf测试文件来了解一下protobuf的基本使用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在<span class="built_in">test</span>文件夹下创建protobuf文件夹，在protobuf文件夹里创建test.proto文件和main.cpp文件</span></span><br><span class="line">cd test/</span><br><span class="line">mkdir protobuf</span><br><span class="line">cd protobuf/</span><br><span class="line">touch main.cpp test.proto</span><br></pre></td></tr></table></figure>

<p>首先编写test.proto文件，必要的注释我会放在代码块里。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 声明protobuf版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug; <span class="comment">// 声明了代码所在的包（对于C++来说就是namespace）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">message就是消息类型，protobuf就是将我们封装好的数据类型进行序列化与反序列化。</span></span><br><span class="line"><span class="comment">定义登录消息类型：名字 + 密码</span></span><br><span class="line"><span class="comment">string name = 1; 1 代表第一个字段</span></span><br><span class="line"><span class="comment">注意，你的name等变量需要使用什么类型，string要指明。</span></span><br><span class="line"><span class="comment">这里的string是protobuf里的string类型，不是c++里的string类型</span></span><br><span class="line"><span class="comment">我们编译protobuf文件的时候需要使用这样的命令编译：protoc test.proto --cpp_out=./ （=后面是编译生成文件的输出路径）</span></span><br><span class="line"><span class="comment">编译后会生成一个LoginRequest类（这里仅拿LoginRequest举例），类有两个成员：string name 和 string pwd。</span></span><br><span class="line"><span class="comment">如果序列化成功，就把序列化的结果放在了send_str里面了，serializeToString是protobuf编译后人家已经帮我们写好的方法，我们直接用就好了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义登录请求消息类型 name pwd</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定于登录响应消息类型 错误码：errcode，错误消息：errmsg， 成功与否：success</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> errmsg = <span class="number">2</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，编写main.cpp进行测试</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// using namespace fixbug</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">protobuf是一个动态库，需要链接，所以整个编译命令为：g++ main.cpp test.pb.cc -lprotobuf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装了login请求对象的数据</span></span><br><span class="line">    fixbug::LoginRequest req;</span><br><span class="line">    req.<span class="built_in">set_name</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    req.<span class="built_in">set_pwd</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象数据序列化</span></span><br><span class="line">    std::string send_str;</span><br><span class="line">    <span class="keyword">if</span>(req.<span class="built_in">SerializeToString</span>(&amp;send_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; send_str.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从send_str反序列化一个login请求对象</span></span><br><span class="line">    fixbug::LoginRequest reqB;</span><br><span class="line">    <span class="keyword">if</span>(reqB.<span class="built_in">ParseFromString</span>(send_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; reqB.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; reqB.<span class="built_in">pwd</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="protobuf实践讲解（二）"><a href="#protobuf实践讲解（二）" class="headerlink" title="protobuf实践讲解（二）"></a>protobuf实践讲解（二）</h4><p>这一小节我们主要引入了两个新知识：</p>
<ul>
<li>在一个消息类型中定义另外一个消息类型</li>
<li>列表</li>
</ul>
<p>必要的注释我已经放在代码块里了，大家可以看看，有不对的地方请谅解并麻烦指出来。</p>
<p>首先是test.proto文件的更新版</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 声明protobuf版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug; <span class="comment">// 声明了代码所在的包（对于C++来说就是namespace）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">message就是消息类型，protobuf就是将我们封装好的数据类型进行序列化与反序列化。</span></span><br><span class="line"><span class="comment">定义登录消息类型：名字 + 密码</span></span><br><span class="line"><span class="comment">string name = 1; 1 代表第一个字段</span></span><br><span class="line"><span class="comment">注意，你的name等变量需要使用什么类型，string要指明。</span></span><br><span class="line"><span class="comment">这里的string是protobuf里的string类型，不是c++里的string类型</span></span><br><span class="line"><span class="comment">我们编译protobuf文件的时候需要使用这样的命令编译：protoc test.proto --cpp_out=./ （=后面是编译生成文件的输出路径）</span></span><br><span class="line"><span class="comment">编译后会生成一个LoginRequest类（这里仅拿LoginRequest举例），类有两个成员：string name 和 string pwd。</span></span><br><span class="line"><span class="comment">如果序列化成功，就把序列化的结果放在了send_str里面了，serializeToString是protobuf编译后人家已经帮我们写好的方法，我们直接用就好了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> errmsg = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义登录请求消息类型 name pwd</span></span><br><span class="line"><span class="comment">// 这里有一个点可以注意一下，一般把string定义成bytes，string也没错，但bytes效率更高</span></span><br><span class="line"><span class="comment">// 因为你定义成string，protobuf还是要转换成bytes</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定于登录响应消息类型 错误码：errcode，错误消息：errmsg， 成功与否：success</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：对于protobuf的消息类型里面定义的成员变量本身又是另外一个消息类型的话，</span></span><br><span class="line"><span class="comment">他都会提供一个mutable用于改变其成员</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在protobuf里还有一个常用的叫列表</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetFriendListsRequest</span>&#123;</span><br><span class="line">    <span class="type">uint32</span> userid = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32</span> age = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">enum </span><span class="title class_">Sex</span>&#123;</span><br><span class="line">        MAN = <span class="number">0</span>;</span><br><span class="line">        WOMAN = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Sex sex = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetFriendListsReponse</span>&#123;</span><br><span class="line">    <span class="comment">// 这里我们注意到，我们每次定义响应的时候好像都会定义errcode和errmsg字段</span></span><br><span class="line">    <span class="comment">// 所以我们决定将其封装起来（ResultCode），便于使用</span></span><br><span class="line">    <span class="comment">// int32 errcode = 1;</span></span><br><span class="line">    <span class="comment">// bytes errmsg = 2;</span></span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的肯定是一个列表，如何表示呢？</span></span><br><span class="line">    <span class="keyword">repeated</span> User friend_list = <span class="number">2</span>; <span class="comment">// 定义了一个列表类型</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>main.cpp更新版</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// using namespace fixbug</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">protobuf是一个动态库，需要链接，所以整个编译命令为：g++ main.cpp test.pb.cc -lprotobuf</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 封装了login请求对象的数据</span></span><br><span class="line">    fixbug::LoginRequest req;</span><br><span class="line">    req.<span class="built_in">set_name</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    req.<span class="built_in">set_pwd</span>(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象数据序列化</span></span><br><span class="line">    std::string send_str;</span><br><span class="line">    <span class="keyword">if</span>(req.<span class="built_in">SerializeToString</span>(&amp;send_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; send_str.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从send_str反序列化一个login请求对象</span></span><br><span class="line">    fixbug::LoginRequest reqB;</span><br><span class="line">    <span class="keyword">if</span>(reqB.<span class="built_in">ParseFromString</span>(send_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; reqB.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; reqB.<span class="built_in">pwd</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixbug::LoginResponse rsp;</span><br><span class="line">    fixbug::ResultCode *rc = rsp.<span class="built_in">mutable_result</span>();</span><br><span class="line">    rc-&gt;<span class="built_in">set_errcode</span>(<span class="number">1</span>);</span><br><span class="line">    rc-&gt;<span class="built_in">set_errmsg</span>(<span class="string">&quot;登陆处理失败了&quot;</span>);</span><br><span class="line"></span><br><span class="line">    std::string recv_str;</span><br><span class="line">    <span class="keyword">if</span>(rsp.<span class="built_in">SerializeToString</span>(&amp;recv_str))&#123;</span><br><span class="line">        <span class="comment">// 好像设置的errcode并没有输出，暂时不知道为啥</span></span><br><span class="line">        std::cout &lt;&lt; recv_str.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fixbug::GetFriendListsReponse rsp2;</span><br><span class="line">    fixbug::ResultCode *rc2 = rsp2.<span class="built_in">mutable_result</span>();</span><br><span class="line">    rc2-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    fixbug::User *user1 = rsp2.<span class="built_in">add_friend_list</span>();</span><br><span class="line">    user1-&gt;<span class="built_in">set_name</span>(<span class="string">&quot;zhang san&quot;</span>);</span><br><span class="line">    user1-&gt;<span class="built_in">set_age</span>(<span class="number">20</span>);</span><br><span class="line">    user1-&gt;<span class="built_in">set_sex</span>(fixbug::User::MAN);</span><br><span class="line"></span><br><span class="line">    fixbug::User *user2 = rsp2.<span class="built_in">add_friend_list</span>();</span><br><span class="line">    user2-&gt;<span class="built_in">set_name</span>(<span class="string">&quot;li si&quot;</span>);</span><br><span class="line">    user2-&gt;<span class="built_in">set_age</span>(<span class="number">18</span>);</span><br><span class="line">    user2-&gt;<span class="built_in">set_sex</span>(fixbug::User::MAN);</span><br><span class="line"></span><br><span class="line">    std::string recv_str2;</span><br><span class="line">    <span class="keyword">if</span>(rsp2.<span class="built_in">SerializeToString</span>(&amp;recv_str2))&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; recv_str2.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string user_str;</span><br><span class="line">    <span class="keyword">if</span>(user1-&gt;<span class="built_in">SerializeToString</span>(&amp;user_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; user_str.<span class="built_in">c_str</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; rsp2.<span class="built_in">friend_list_size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="protobuf实践讲解（三）"><a href="#protobuf实践讲解（三）" class="headerlink" title="protobuf实践讲解（三）"></a>protobuf实践讲解（三）</h4><p>这一节我们主要讲了如何引入函数名。因为我们只传输参数给远程rpc服务器是肯定不够的，远程rpc服务器还需要知道我们需要调用哪种方法，因此我们需要使用service在远程rpc服务器上注册函数？（不知道这个理解对不对）同时，方便之后函数调用方传输函数名，里面有一个ServiceDescriptor类型的指针，用于访问方法的各个属性。代码更新如下，主要更新了test.proto文件，main文件没有更新。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; <span class="comment">// 声明protobuf版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug; <span class="comment">// 声明了代码所在的包（对于C++来说就是namespace）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">message就是消息类型，protobuf就是将我们封装好的数据类型进行序列化与反序列化。</span></span><br><span class="line"><span class="comment">定义登录消息类型：名字 + 密码</span></span><br><span class="line"><span class="comment">string name = 1; 1 代表第一个字段</span></span><br><span class="line"><span class="comment">注意，你的name等变量需要使用什么类型，string要指明。</span></span><br><span class="line"><span class="comment">这里的string是protobuf里的string类型，不是c++里的string类型</span></span><br><span class="line"><span class="comment">我们编译protobuf文件的时候需要使用这样的命令编译：protoc test.proto --cpp_out=./ （=后面是编译生成文件的输出路径）</span></span><br><span class="line"><span class="comment">编译后会生成一个LoginRequest类（这里仅拿LoginRequest举例），类有两个成员：string name 和 string pwd。</span></span><br><span class="line"><span class="comment">如果序列化成功，就把序列化的结果放在了send_str里面了，serializeToString是protobuf编译后人家已经帮我们写好的方法，我们直接用就好了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> errmsg = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义登录请求消息类型 name pwd</span></span><br><span class="line"><span class="comment">// 这里有一个点可以注意一下，一般把string定义成bytes，string也没错，但bytes效率更高</span></span><br><span class="line"><span class="comment">// 因为你定义成string，protobuf还是要转换成bytes</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定于登录响应消息类型 错误码：errcode，错误消息：errmsg， 成功与否：success</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意：对于protobuf的消息类型里面定义的成员变量本身又是另外一个消息类型的话，</span></span><br><span class="line"><span class="comment">他都会提供一个mutable用于改变其成员</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在protobuf里还有一个常用的叫列表</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetFriendListsRequest</span>&#123;</span><br><span class="line">    <span class="type">uint32</span> userid = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32</span> age = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">enum </span><span class="title class_">Sex</span>&#123;</span><br><span class="line">        MAN = <span class="number">0</span>;</span><br><span class="line">        WOMAN = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Sex sex = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">GetFriendListsReponse</span>&#123;</span><br><span class="line">    <span class="comment">// 这里我们注意到，我们每次定义响应的时候好像都会定义errcode和errmsg字段</span></span><br><span class="line">    <span class="comment">// 所以我们决定将其封装起来（ResultCode），便于使用</span></span><br><span class="line">    <span class="comment">// int32 errcode = 1;</span></span><br><span class="line">    <span class="comment">// bytes errmsg = 2;</span></span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回的肯定是一个列表，如何表示呢？</span></span><br><span class="line">    <span class="keyword">repeated</span> User friend_list = <span class="number">2</span>; <span class="comment">// 定义了一个列表类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">我们在上面已经完成了参数和反回值传输，但我们仅将函数参数传过去，远程服务器并不知道我们要调用哪种方法啊！</span></span><br><span class="line"><span class="comment">protobuf没有rpc通信功能，只进行序列化与反序列化。但我们依旧要在protobuf里完成rpc方法类型的定义描述。</span></span><br><span class="line"><span class="comment">这就需要使用protobuf的service功能，注意此时需要加入option选项， option cc_generic_services = true; 表示生成service服务类和rpc方法描述</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 不管是message还是service，最后都会生成class类。注意message只生成一个，service会生成两个，一个class UserServiceRpc，一个class UserServiceRpc_stub</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserServiceRpc</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Login(LoginRequest) <span class="keyword">returns</span>(LoginResponse)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> GetFriendLists(GetFriendListsRequest) <span class="keyword">returns</span>(GetFriendListsReponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="本地服务如何发布成RPC服务（一）"><a href="#本地服务如何发布成RPC服务（一）" class="headerlink" title="本地服务如何发布成RPC服务（一）"></a>本地服务如何发布成RPC服务（一）</h4><p>这一块算是正式跨入项目第一步，我们通过业务出发，如果要实现我们所需要的具体需求应该怎么办，直接给出更新后的代码，必要的注释都在代码里</p>
<p>这里先给大家看一个本节之后的文件组成情况</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── autobuild.sh</span><br><span class="line">├── bin</span><br><span class="line">├── build</span><br><span class="line">├── example</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── callee</span><br><span class="line">│   │   ├── CMakeLists.txt</span><br><span class="line">│   │   └── userservice.cpp</span><br><span class="line">│   ├── caller</span><br><span class="line">│   ├── user.pb.cc</span><br><span class="line">│   ├── user.pb.h</span><br><span class="line">│   └── user.proto</span><br><span class="line">├── lib</span><br><span class="line">├── src</span><br><span class="line">└── test</span><br><span class="line">    └── protobuf</span><br><span class="line">        ├── a.out</span><br><span class="line">        ├── main.cpp</span><br><span class="line">        ├── test.pb.cc</span><br><span class="line">        ├── test.pb.h</span><br><span class="line">        └── test.proto</span><br><span class="line"></span><br><span class="line">9 directories, 13 files</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最上面的小点代表根目录：mprpc_zcl</span></span><br></pre></td></tr></table></figure>

<p>更新后的mprpc_zcl&#x2F;CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置cmake的最低版本和项目名称</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(mprpc_zcl)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目可执行文件输出的路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目库文件输出路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目编译头文件搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/example)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目库文件搜索路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># src里面放的是框架代码</span></span><br><span class="line"><span class="comment"># add_subdirectory(src)  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># example里面放的是rpc服务的使用者和消费者，业务代码</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(example)</span><br></pre></td></tr></table></figure>

<p>更新后的mprpc_zcl&#x2F;example&#x2F;user.proto</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> fixbug;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">ResultCode</span>&#123;</span><br><span class="line">    <span class="type">int32</span> errcode = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> errmsg = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginRequest</span>&#123;</span><br><span class="line">    <span class="type">bytes</span> name = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bytes</span> pwd = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">LoginResponse</span>&#123;</span><br><span class="line">    ResultCode result = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">UserServiceRpc</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> Login_rpc(LoginRequest) <span class="keyword">returns</span>(LoginResponse)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意，编写完之后直接使用protoc user.proto --cpp_out=./编译</span></span><br></pre></td></tr></table></figure>

<p>更新后的mprpc_zcl&#x2F;example&#x2F;CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(callee)</span><br></pre></td></tr></table></figure>

<p>更新后的mprpc_zcl&#x2F;example&#x2F;callee&#x2F;userservice.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我个人觉得这个项目应该从这里开始讲解，我们现在本地有一个用户登录Login_Local方法（隶属于UserService类）。</span></span><br><span class="line"><span class="comment">我们自己在本地调用那肯定很方便，创建一个UserService类对象，直接调用Login_Local方法即可</span></span><br><span class="line"><span class="comment">可是，如果现在有另外一个进程或者另外一台机器想调用我们这个方法怎么办呢？所以我们就要结合谷歌protobuf提供给我们的工具了</span></span><br><span class="line"><span class="comment">这个文件写的就是rpc服务提供者文件，我们在别人想要调用这个本地方法之前需要做哪些基础工作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1、proto文件经过protobuf编译后生成了UserServiceRpc类</span></span><br><span class="line"><span class="comment">2、我们需要在userservice.cpp文件里对这个类里的方法进行重写</span></span><br><span class="line"><span class="comment">3、注意：message会变为类的成员，service会生成一个类，service里的内容会生成方法</span></span><br><span class="line"><span class="comment">4、现在的问题就是：我们重写过后，远方是怎么调用的呢？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Userservice</span> : <span class="keyword">public</span> fixbug::UserServiceRpc   <span class="comment">// 使用在rpc服务发布端（rpc服务提供者）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Login_local</span><span class="params">(std::string name, std::string pwd)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doing local service: Login&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; pwd:&quot;</span> &lt;&lt; pwd;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，作用过程是这样的，当远端将请求发送过来，先会被我们的rpc框架接受，我们rpc框架根据接收到的参数，函数名等数据</span></span><br><span class="line">    <span class="comment">// 匹配到了我们重写的这个函数，然后调用了这个函数。</span></span><br><span class="line">    <span class="comment">// 所以这一块不属于框架的代码，是我们要使用这个框架必须自己写的代码，实现自己需要的功能。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Login_rpc</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> ::fixbug::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::fixbug::LoginResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::google::protobuf::Closure* done)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 暂时还没写完</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新后的mprpc_zcl&#x2F;example&#x2F;callee&#x2F;CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(SRC_LIST userservice.cpp ../user.pb.cc)</span><br><span class="line"><span class="keyword">add_executable</span>(provider <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="本地服务如何发布成RPC服务（二）"><a href="#本地服务如何发布成RPC服务（二）" class="headerlink" title="本地服务如何发布成RPC服务（二）"></a>本地服务如何发布成RPC服务（二）</h4><p>这一节必要的注释我都放在了代码里，以及思考的过程，这一节只对userservice.cpp进行了更新</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我个人觉得这个项目应该从这里开始讲解，我们现在本地有一个用户登录Login_Local方法（隶属于UserService类）。</span></span><br><span class="line"><span class="comment">我们自己在本地调用那肯定很方便，创建一个UserService类对象，直接调用Login_Local方法即可</span></span><br><span class="line"><span class="comment">可是，如果现在有另外一个进程或者另外一台机器想调用我们这个方法怎么办呢？所以我们就要结合谷歌protobuf提供给我们的工具了</span></span><br><span class="line"><span class="comment">这个文件写的就是rpc服务提供者文件，我们在别人想要调用这个本地方法之前需要做哪些基础工作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1、proto文件经过protobuf编译后生成了UserServiceRpc类</span></span><br><span class="line"><span class="comment">2、我们需要在userservice.cpp文件里对这个类里的方法进行重写</span></span><br><span class="line"><span class="comment">3、注意：message会变为类的成员，service会生成一个类，service里的内容会生成方法</span></span><br><span class="line"><span class="comment">4、现在的问题就是：我们重写过后，远方是怎么调用的呢？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Userservice</span> : <span class="keyword">public</span> fixbug::UserServiceRpc   <span class="comment">// 使用在rpc服务发布端（rpc服务提供者）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Login_local</span><span class="params">(std::string name, std::string pwd)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doing local service: Login&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; pwd:&quot;</span> &lt;&lt; pwd;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，作用过程是这样的，当远端将请求发送过来，先会被我们的rpc框架接受，我们rpc框架根据接收到的参数，函数名等数据</span></span><br><span class="line">    <span class="comment">// 匹配到了我们重写的这个函数，然后调用了这个函数。</span></span><br><span class="line">    <span class="comment">// 所以这一块不属于框架的代码，是我们要使用这个框架必须自己写的代码，实现自己需要的功能。</span></span><br><span class="line">    <span class="comment">// 现在的问题是，我callee端收到了参数和函数名，怎么匹配的呢？</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Login_rpc</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> ::fixbug::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::fixbug::LoginResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::google::protobuf::Closure* done)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 框架给业务上报了请求参数LoginRequest，应用获取相应数据做本地业务</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string pwd = request-&gt;<span class="built_in">pwd</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做本地业务</span></span><br><span class="line">        <span class="type">bool</span> login_result = <span class="built_in">Login_local</span>(name, pwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把响应写入，包括错误码、错误消息、返回值。我们不需要管序列化与反序列化，这个是框架来做的</span></span><br><span class="line">        fixbug::ResultCode *code = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        code-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        code-&gt;<span class="built_in">set_errmsg</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(login_result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，我们可以跳进::google::protobuf::Closure类去看看，里面的run是纯虚函数，需要我们进行重新写，那么run应该实现什么功能呢？</span></span><br><span class="line">        <span class="comment">// 其实就是执行响应对象数据的序列化与网络发送</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    总结一下，初始准备步骤：</span></span><br><span class="line"><span class="comment">    写proto文件 ------》继承生成的类，重写类里的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Mprpc框架基础类设计"><a href="#Mprpc框架基础类设计" class="headerlink" title="Mprpc框架基础类设计"></a>Mprpc框架基础类设计</h4><p>这一节我们从服务发布方的需求出发，比如我需要发布一个rpc服务，我需要做什么？我们考虑思路是这样的：假设现在框架写好了，当远端将请求发送过来，先会被我们的rpc框架接受，我们rpc框架根据接收到的参数，函数名等数据。匹配到了我们重写的这个函数，然后调用了这个函数。所以这一块不属于框架的代码，是我们要使用这个框架必须自己写的代码，实现自己需要的功能。<strong>现在的问题是，我callee端收到了参数和函数名，怎么匹配的呢？</strong></p>
<p>我们现在做好了服务发布方的基础工作，我们现在需要思考一个问题：我怎么能让别人想用我们写的rpc框架呢？答案只有一个，就是越简单越好。</p>
<ol>
<li>先进行框架初始化操作</li>
<li>框架里提供了用于发布服务的类</li>
</ol>
<p>这一节更新的文件如下</p>
<p>新加入src&#x2F;include&#x2F;mprpcapplication.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责框架的初始化操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MprpcApplication</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> MprpcApplication &amp;<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">MprpcApplication</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>(<span class="type">const</span> MprpcApplication&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>(MprpcApplication&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新加入src&#x2F;include&#x2F;mprpcprovider.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架提供的专门服务发布rpc服务的网络对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个是框架提供给外部使用的，可以发布rpc方法的函数接口 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新加入src&#x2F;mprpcapplication.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcApplication::Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MprpcApplication &amp;<span class="title">MprpcApplication::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> MprpcApplication app;</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新加入src&#x2F;mprpcprovider.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新了example&#x2F;callee&#x2F;userservice.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我个人觉得这个项目应该从这里开始讲解，我们现在本地有一个用户登录Login_Local方法（隶属于UserService类）。</span></span><br><span class="line"><span class="comment">我们自己在本地调用那肯定很方便，创建一个UserService类对象，直接调用Login_Local方法即可</span></span><br><span class="line"><span class="comment">可是，如果现在有另外一个进程或者另外一台机器想调用我们这个方法怎么办呢？所以我们就要结合谷歌protobuf提供给我们的工具了</span></span><br><span class="line"><span class="comment">这个文件写的就是rpc服务提供者文件，我们在别人想要调用这个本地方法之前需要做哪些基础工作</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1、proto文件经过protobuf编译后生成了UserServiceRpc类</span></span><br><span class="line"><span class="comment">2、我们需要在userservice.cpp文件里对这个类里的方法进行重写</span></span><br><span class="line"><span class="comment">3、注意：message会变为类的成员，service会生成一个类，service里的内容会生成方法</span></span><br><span class="line"><span class="comment">4、现在的问题就是：我们重写过后，远方是怎么调用的呢？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../user.pb.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;/home/zcl/mprpc_zcl/src/include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;/home/zcl/mprpc_zcl/src/include/mprpcprovider.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserService</span> : <span class="keyword">public</span> fixbug::UserServiceRpc   <span class="comment">// 使用在rpc服务发布端（rpc服务提供者）</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Login_local</span><span class="params">(std::string name, std::string pwd)</span></span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;doing local service: Login&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; pwd:&quot;</span> &lt;&lt; pwd;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，作用过程是这样的，当远端将请求发送过来，先会被我们的rpc框架接受，我们rpc框架根据接收到的参数，函数名等数据</span></span><br><span class="line">    <span class="comment">// 匹配到了我们重写的这个函数，然后调用了这个函数。</span></span><br><span class="line">    <span class="comment">// 所以这一块不属于框架的代码，是我们要使用这个框架必须自己写的代码，实现自己需要的功能。</span></span><br><span class="line">    <span class="comment">// 现在的问题是，我callee端收到了参数和函数名，怎么匹配的呢？</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Login_rpc</span><span class="params">(::google::protobuf::RpcController* controller,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> ::fixbug::LoginRequest* request,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::fixbug::LoginResponse* response,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ::google::protobuf::Closure* done)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 框架给业务上报了请求参数LoginRequest，应用获取相应数据做本地业务</span></span><br><span class="line">        std::string name = request-&gt;<span class="built_in">name</span>();</span><br><span class="line">        std::string pwd = request-&gt;<span class="built_in">pwd</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做本地业务</span></span><br><span class="line">        <span class="type">bool</span> login_result = <span class="built_in">Login_local</span>(name, pwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把响应写入，包括错误码、错误消息、返回值。我们不需要管序列化与反序列化，这个是框架来做的</span></span><br><span class="line">        fixbug::ResultCode *code = response-&gt;<span class="built_in">mutable_result</span>();</span><br><span class="line">        code-&gt;<span class="built_in">set_errcode</span>(<span class="number">0</span>);</span><br><span class="line">        code-&gt;<span class="built_in">set_errmsg</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        response-&gt;<span class="built_in">set_success</span>(login_result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行回调操作，我们可以跳进::google::protobuf::Closure类去看看，里面的run是纯虚函数，需要我们进行重新写，那么run应该实现什么功能呢？</span></span><br><span class="line">        <span class="comment">// 其实就是执行响应对象数据的序列化与网络发送</span></span><br><span class="line">        done-&gt;<span class="built_in">Run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    总结一下，初始准备步骤：</span></span><br><span class="line"><span class="comment">    写proto文件 ------》继承生成的类，重写类里的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">我们现在做好了服务发布方的基础工作，我们现在需要思考一个问题：我怎么能让别人想用我们写的rpc框架呢？答案只有一个，就是越简单越好。</span></span><br><span class="line"><span class="comment">1、先进行框架初始化操作</span></span><br><span class="line"><span class="comment">2、框架里提供了用于发布服务的类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="comment">// argc和argv是写ip地址和端口号配置文件这些的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用框架的初始化操作</span></span><br><span class="line">    MprpcApplication::<span class="built_in">Init</span>(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// provider是一个rpc网络服务对象。把UserService对象发布到rpc节点上</span></span><br><span class="line">    <span class="comment">// 可能会有很多用户同时使用Rpcprovider，所以这一块必须做到高并发，使用muduo网络库</span></span><br><span class="line">    RpcProvider provider;</span><br><span class="line">    provider.<span class="built_in">NotifyService</span>(<span class="keyword">new</span> <span class="built_in">UserService</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个rpc服务发布节点, Run以后，进程进入阻塞状态，等待远程的rpc调用请求</span></span><br><span class="line">    provider.<span class="built_in">Run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Mprpc框架项目动态库编译"><a href="#Mprpc框架项目动态库编译" class="headerlink" title="Mprpc框架项目动态库编译"></a>Mprpc框架项目动态库编译</h4><p>在init的时候，我们希望用户的输入是这样的：.&#x2F;provider -i config.conf（config.conf是配置文件，自动读取网络服务器和配置中心的ip地址和端口号）。</p>
<p>这节涉及到一个函数：int getopt(int argc, char * const argv[], const char *optstring); 我先给出这个函数的详细解释，方便解读下面的代码</p>
<p>首先，让我们看看<code>getopt</code>函数：</p>
<p><code>getopt</code>函数用于解析命令行参数。其原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getopt</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[], <span class="type">const</span> <span class="type">char</span> *optstring)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>argc</code>和<code>argv</code>是从<code>main</code>函数传递过来的命令行参数数量和参数值。</li>
<li><code>optstring</code>是一个字符串，表示我们期望的选项。例如，如果我们期望一个<code>-i</code>选项，那么<code>optstring</code>就会是<code>&quot;i:&quot;</code>。冒号表示<code>-i</code>后面必须跟一个参数值。</li>
</ul>
<p>函数每次调用都会返回一个字符，这个字符表示被解析到的选项。如果选项后面跟有参数值（如<code>-i value</code>），那么这个值可以通过<code>optarg</code>全局变量获得。当所有选项都被解析完毕后，<code>getopt</code>返回-1。</p>
<p>现在，让我们回到你的代码片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;i:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>while</code>循环的目的是持续解析命令行参数，直到所有选项都被解析完毕。</p>
<ul>
<li><p><code>c = getopt(argc, argv, &quot;i:&quot;)</code>：这里，<code>getopt</code>被调用，并返回值赋给<code>c</code>。如果有<code>-i</code>选项，<code>c</code>会等于字符<code>&#39;i&#39;</code>。</p>
</li>
<li><p><code>c != -1</code>：这个条件检查<code>c</code>是否不等于-1。如果<code>c</code>等于-1，那么说明所有选项都已经被解析完毕，<code>while</code>循环结束。</p>
</li>
</ul>
<p>在<code>while</code>循环的内部，你可能会基于<code>c</code>的值做一些操作，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">        <span class="comment">// do something with optarg, which contains the value after -i</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// possibly handle other options</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">        <span class="comment">// handle unknown option</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简而言之，这个代码片段用<code>getopt</code>函数在命令行参数中寻找<code>-i</code>选项，并将找到的值存储在<code>optarg</code>中。</p>
<p>在使用 <code>getopt</code> 函数来解析命令行参数时，你可能会遇到几种特定的返回值。当你在 <code>optstring</code> 中指定了一个选项后跟冒号（如 “i:”），这意味着该选项需要一个参数。</p>
<p>对于 <code>getopt</code> 的返回值：</p>
<ul>
<li>如果一个选项被发现，并且它有一个关联的参数（例如 <code>-i &lt;value&gt;</code>），那么 <code>getopt</code> 返回该选项字符。</li>
<li>如果一个选项被发现，但它缺少一个关联的参数（例如仅仅 <code>-i</code> 而没有后续值），并且在 <code>optstring</code> 中该选项后面有一个冒号，那么 <code>getopt</code> 返回 <code>&#39;:&#39;</code>。</li>
<li>如果找到一个不在 <code>optstring</code> 中的选项，或者找到一个不应有参数但却有参数的选项，那么 <code>getopt</code> 返回 <code>&#39;?&#39;</code>。</li>
</ul>
<p>所以，<code>case &#39;:&#39;</code> 在 <code>switch</code> 语句中处理的是缺少参数的选项情况。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = getopt(argc, argv, <span class="string">&quot;i:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (c) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">            <span class="comment">// handle the -i option with its argument in optarg</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:  <span class="comment">// Missing option argument</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Option -%c requires an argument.\n&quot;</span>, optopt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:  <span class="comment">// Unknown option</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Unknown option: -%c\n&quot;</span>, optopt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，如果用户只输入 <code>-i</code> 而没有提供参数，程序将输出 “Option -i requires an argument.”。</p>
<p>新加入src&#x2F;CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">aux_source_directory</span>(. SRC_LIST)</span><br><span class="line"><span class="keyword">add_library</span>(mprpc SHARED <span class="variable">$&#123;SRC_LIST&#125;</span>)  <span class="comment"># 创建一个动态库，方便用户调用</span></span><br></pre></td></tr></table></figure>

<p>更新example&#x2F;callee&#x2F;CMakeLists</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(SRC_LIST userservice.cpp ../user.pb.cc)</span><br><span class="line"><span class="keyword">add_executable</span>(provider <span class="variable">$&#123;SRC_LIST&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(provider mprpc protobuf)	<span class="comment"># 链接我们上面创建的mprpc动态库和protobuf库</span></span><br></pre></td></tr></table></figure>

<p>更新mprpcapplication.cpp文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showArgHelp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;format: command -i &lt;configfile&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcApplication::Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">showArgHelp</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    std::string config_file;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;i:&quot;</span>)) != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">                config_file = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;invalid args!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">showArgHelp</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);	<span class="comment">// 配置文件都没加载进来就不要break啦，直接退出运行吧</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;need config_file&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">showArgHelp</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始加载配置文件了 rpcserver_ip=  rpcserver_port=    zookeeper_ip=   zookeeper_port=</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MprpcApplication &amp;<span class="title">MprpcApplication::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> MprpcApplication app;</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Mprpc配置文件的加载（一）"><a href="#Mprpc配置文件的加载（一）" class="headerlink" title="Mprpc配置文件的加载（一）"></a>Mprpc配置文件的加载（一）</h4><p>这一节我们主要讲的是如何加载配置文件，换句话说就是解析配置文件。首先我们规定了配置文件的标准格式，如下所示：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpc节点的ip地址</span></span><br><span class="line">rpcserverip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># rpc节点的port端口号</span></span><br><span class="line">rpcserverport = <span class="number">8000</span></span><br><span class="line"><span class="comment"># zk的IP地址</span></span><br><span class="line">zookeeperip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># zk的port端口号</span></span><br><span class="line">zookeeperport = <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p>这一节引入了MprpcConfig类，我们考虑两部分：解析配置文件 + 查询配置信息。一个自然而然要思考的问题就是如何查询配置信息呢？我们这里考虑的是通过一个map映射即通过键找值。具体如何操作看代码就能了解了。</p>
<p>新加入配置文件&#x2F;bin&#x2F;test.conf</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rpc节点的ip地址</span></span><br><span class="line">rpcserverip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># rpc节点的port端口号</span></span><br><span class="line">rpcserverport = <span class="number">8000</span></span><br><span class="line"><span class="comment"># zk的IP地址</span></span><br><span class="line">zookeeperip = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="comment"># zk的port端口号</span></span><br><span class="line">zookeeperport = <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p>新加入&#x2F;src&#x2F;include&#x2F;mprpcconfig.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MprpcConfig</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 负责解析加载配置文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *config_file)</span></span>;</span><br><span class="line">    <span class="comment">// 查询配置项信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 每解析到一组ip---port，就insert进m_configMap</span></span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; m_configMap;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新加入&#x2F;src&#x2F;mprpcconfig.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcconfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责解析加载配置文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcConfig::loadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *config_file)</span></span>&#123;</span><br><span class="line">    FILE *pf = <span class="built_in">fopen</span>(config_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(pf == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; config_file &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、注释 2、正确的配置项通过=判断 3、去掉开头多余的空格</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">feof</span>(pf))&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">fgets</span>(buf, <span class="number">512</span>, pf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串前面的空格</span></span><br><span class="line">        <span class="comment">// 转换成字符串便于后续操作，因为字符串里有很多函数</span></span><br><span class="line">        <span class="function">std::string <span class="title">src_buf</span><span class="params">(buf)</span></span>;</span><br><span class="line">        <span class="type">int</span> idx = src_buf.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx != <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// 说明字符串前面有空格</span></span><br><span class="line">            src_buf = src_buf.<span class="built_in">substr</span>(idx, src_buf.<span class="built_in">size</span>() - idx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉字符串后面多余的空格</span></span><br><span class="line">        idx = src_buf.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx != <span class="number">-1</span>)&#123;</span><br><span class="line">            src_buf = src_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断#的注释</span></span><br><span class="line">        <span class="keyword">if</span>(src_buf[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || src_buf.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析配置项</span></span><br><span class="line">        idx = src_buf.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// 配置项不合法</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::string key;</span><br><span class="line">        std::string value;</span><br><span class="line">        key = src_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        value = src_buf.<span class="built_in">substr</span>(idx + <span class="number">1</span>, src_buf.<span class="built_in">size</span>() - idx);</span><br><span class="line">        m_configMap.<span class="built_in">insert</span>(&#123;key, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询配置项信息</span></span><br><span class="line"><span class="function">std::string <span class="title">MprpcConfig::load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_configMap.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(it == m_configMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新&#x2F;src&#x2F;include&#x2F;mprpcapplication.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责框架的初始化操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcconfig.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MprpcApplication</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> MprpcApplication &amp;<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> MprpcConfig m_config;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>(<span class="type">const</span> MprpcApplication&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">MprpcApplication</span>(MprpcApplication&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更新&#x2F;src&#x2F;mprpcapplication.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MprpcConfig MprpcApplication::m_config;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showArgHelp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;format: command -i &lt;configfile&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcApplication::Init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc &lt; <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">showArgHelp</span>();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    std::string config_file;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = <span class="built_in">getopt</span>(argc, argv, <span class="string">&quot;i:&quot;</span>)) != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">                config_file = optarg;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                <span class="built_in">showArgHelp</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">                <span class="built_in">showArgHelp</span>();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始加载配置文件了 rpcserver_ip=  rpcserver_port=    zookeeper_ip=   zookeeper_port=</span></span><br><span class="line">    <span class="comment">// 这是我们规定的配置文件的标准格式，因为我们后面解析的配置文件也是这个格式</span></span><br><span class="line">    m_config.<span class="built_in">loadConfigFile</span>(config_file.<span class="built_in">c_str</span>());</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rpcserverip:&quot;</span> &lt;&lt; m_config.<span class="built_in">load</span>(<span class="string">&quot;reserverip&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rpcserverport:&quot;</span> &lt;&lt; m_config.<span class="built_in">load</span>(<span class="string">&quot;reserverport&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;zookeeperip:&quot;</span> &lt;&lt; m_config.<span class="built_in">load</span>(<span class="string">&quot;zookeeperip&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;zookeeperport:&quot;</span> &lt;&lt; m_config.<span class="built_in">load</span>(<span class="string">&quot;zookeeperport&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">MprpcApplication &amp;<span class="title">MprpcApplication::GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> MprpcApplication app;</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Mprpc配置文件的加载（二）"><a href="#Mprpc配置文件的加载（二）" class="headerlink" title="Mprpc配置文件的加载（二）"></a>Mprpc配置文件的加载（二）</h4><p>在上一节中好像忘记告诉大家如何编译测试代码了。不知道大家还记不记得我们的可执行文件都是放在bin目录里的，所以我们需要先进入bin目录，即cd bin&#x2F;。</p>
<p>然后为了我们就可以在终端执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./provider -i test.conf</span><br></pre></td></tr></table></figure>

<p>从这个编译命令就可以看出来我们为什么要把test.conf文件和provider都放在bin目录下，这样方便我们编译。然后你们可以测试一下上一节的代码，是有bug的！然后我们需要进行gdb调试，进行gdb调试的话，我们需要在最外层的CMakeLists.txt文件加一行这个代码</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE <span class="string">&quot;Debug&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>bug出现在了mprpcconfig.cpp文件里，你们自己调试一下哈，我下面给出更新后的本节所有代码</p>
<p>更新后的CMakeLists.txt</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置cmake的最低版本和项目名称</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.0</span>)</span><br><span class="line"><span class="keyword">project</span>(mprpc_zcl)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb调试选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_BUILD_TYPE <span class="string">&quot;Debug&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目可执行文件输出的路径</span></span><br><span class="line"><span class="keyword">set</span>(EXECUTABLE_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目库文件输出路径</span></span><br><span class="line"><span class="keyword">set</span>(LIBRARY_OUTPUT_PATH <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目编译头文件搜索路径</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/src/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/example)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目库文件搜索路径</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/lib)</span><br><span class="line"></span><br><span class="line"><span class="comment"># src里面放的是框架代码</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># example里面放的是rpc服务的使用者和消费者，业务代码</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(example)</span><br></pre></td></tr></table></figure>

<p>更新后的&#x2F;src&#x2F;include&#x2F;mprpcconfig.h文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MprpcConfig</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 负责解析加载配置文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">loadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *config_file)</span></span>;</span><br><span class="line">    <span class="comment">// 查询配置项信息</span></span><br><span class="line">    <span class="function">std::string <span class="title">load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;std::string, std::string&gt; m_configMap;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 去掉字符串前后的空格</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Trim</span><span class="params">(std::string &amp;src_buf)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更新后的mprpcconfig.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcconfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 负责解析加载配置文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcConfig::loadConfigFile</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *config_file)</span></span>&#123;</span><br><span class="line">    FILE *pf = <span class="built_in">fopen</span>(config_file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(pf == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        std::cout &lt;&lt; config_file &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、注释 2、正确的配置项通过=判断 3、去掉开头多余的空格</span></span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">feof</span>(pf))&#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">fgets</span>(buf, <span class="number">512</span>, pf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去掉字符串前面的空格</span></span><br><span class="line">        <span class="comment">// 转换成字符串便于后续操作，因为字符串里有很多函数</span></span><br><span class="line">        <span class="function">std::string <span class="title">read_buf</span><span class="params">(buf)</span></span>;</span><br><span class="line">        <span class="built_in">Trim</span>(read_buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断#的注释</span></span><br><span class="line">        <span class="keyword">if</span>(read_buf[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> || read_buf.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析配置项</span></span><br><span class="line">        <span class="type">int</span> idx = read_buf.<span class="built_in">find</span>(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span>(idx == <span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// 配置项不合法</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::string key;</span><br><span class="line">        std::string value;</span><br><span class="line">        key = read_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx);</span><br><span class="line">        <span class="built_in">Trim</span>(key);</span><br><span class="line">        <span class="type">int</span> endidx = read_buf.<span class="built_in">find</span>(<span class="string">&#x27;\n&#x27;</span>, idx);</span><br><span class="line">        value = read_buf.<span class="built_in">substr</span>(idx + <span class="number">1</span>, endidx - idx - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">Trim</span>(value);</span><br><span class="line">        m_configMap.<span class="built_in">insert</span>(&#123;key, value&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询配置项信息</span></span><br><span class="line"><span class="function">std::string <span class="title">MprpcConfig::load</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = m_configMap.<span class="built_in">find</span>(key);</span><br><span class="line">    <span class="keyword">if</span>(it == m_configMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉字符串前后的空格</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MprpcConfig::Trim</span><span class="params">(std::string &amp;src_buf)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> idx = src_buf.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(idx != <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="comment">// 说明字符串前面有空格</span></span><br><span class="line">        src_buf = src_buf.<span class="built_in">substr</span>(idx, src_buf.<span class="built_in">size</span>() - idx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去掉字符串后面多余的空格</span></span><br><span class="line">    idx = src_buf.<span class="built_in">find_last_not_of</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(idx != <span class="number">-1</span>)&#123;</span><br><span class="line">        src_buf = src_buf.<span class="built_in">substr</span>(<span class="number">0</span>, idx + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="开发RpcProvider的网络服务"><a href="#开发RpcProvider的网络服务" class="headerlink" title="开发RpcProvider的网络服务"></a>开发RpcProvider的网络服务</h4><p>是这样的，我们现在已经能够读取到配置文件里的信息了，包括哪些信息呢？还记得吗？来一起回顾一下：rpc服务的ip地址和port端口号，zookeeper的ip地址和port端口号。我们现在回到这个配置文件这里，我们从这个角度出发，我们读取配置文件就是为了获取rpc服务发布节点的ip地址和port端口号，我们是为了什么读取呢？是为了让客户端能够接入，能够调用我们发布的这个rpc服务方法。我们之前在mprpcapplication里说过，为了简便用户的操作，我们提供了一个RpcProvoder类来发布服务节点。所以，这节我们要做的就是通过muduo网络库让配置文件里的rpc服务节点运行起来，可以接收客户端的连接请求。Let‘s go！</p>
<p>新加入mprpcprovider.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架提供的专门服务发布rpc服务的网络对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个是框架提供给外部使用的，可以发布rpc方法的函数接口 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 组合了EventLoop</span></span><br><span class="line">    muduo::net::EventLoop m_eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的socket连接回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已建立连接用户的读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新加入mprpcprovider.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 你启动一个rpc网络服务节点，总要获取ip地址和port端口号吧</span></span><br><span class="line">    <span class="comment">// 所以这里是获取ip地址和port端口号</span></span><br><span class="line">    std::string ip = MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;m_eventLoop, address, <span class="string">&quot;RpcProvider&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 绑定连接回调和消息读写回调方法 分离了网络代码和业务代码</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">// 设置muduo库线程数量，自动分配I/O线程和工作线程</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    m_eventLoop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="RpcProvider发布服务方法（一）"><a href="#RpcProvider发布服务方法（一）" class="headerlink" title="RpcProvider发布服务方法（一）"></a>RpcProvider发布服务方法（一）</h4><p>我们想一下，我们发布的rpc服务节点运行起来阻塞着等待客户的请求连接。假设现在有一个客户端将函数及其参数全部传递过来了，框架应该怎么做匹配呢？框架怎么就能做到这个函数名就匹配这个函数呢？对，有人应该想到了，使用map。我现在的想法也是map。我们将服务与函数对应起来（回忆一下：proto文件里服务生成类，函数就是类成员函数），所以要先限定服务，在限定函数。所以我们使用map将服务函数对应起来就好了。</p>
<p>更新mprpcprovider.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架提供的专门服务发布rpc服务的网络对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个是框架提供给外部使用的，可以发布rpc方法的函数接口 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 组合了EventLoop</span></span><br><span class="line">    muduo::net::EventLoop m_eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// service服务类型信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ServiceInfo</span>&#123;</span><br><span class="line">        google::protobuf::Service *m_service; <span class="comment">// 保存服务对象</span></span><br><span class="line">        std::unordered_map&lt;std::string, <span class="type">const</span> google::protobuf::MethodDescriptor*&gt; m_methodMap; <span class="comment">// 保存服务方法</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::unordered_map&lt;std::string, ServiceInfo&gt; m_serviceMap;  <span class="comment">// 可不止一个服务类型哦，所以也要建立一个映射到不同服务的表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的socket连接回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已建立连接用户的读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更新mprpcprovider.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是框架提供给外部使用的，可以发布rpc方法的函数接口</span></span><br><span class="line"><span class="comment">这里有一个很重要的指针（protobuf提供给我们获取服务及函数的）：google::protobuf::ServiceDescriptor *pserviceDesc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line">    ServiceInfo service_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务对象的描述信息</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::ServiceDescriptor *pserviceDesc = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line">    <span class="comment">// 获取服务的名字</span></span><br><span class="line">    std::string service_name = pserviceDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">    <span class="comment">// 获取服务对象service的方法的数量</span></span><br><span class="line">    <span class="type">int</span> methodCnt = pserviceDesc-&gt;<span class="built_in">method_count</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;service_name: &quot;</span> &lt;&lt; service_name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; methodCnt; ++i)&#123;</span><br><span class="line">        <span class="comment">// 获取了服务对象指定下标的服务方法的描述（抽象描述）</span></span><br><span class="line">        <span class="type">const</span> google::protobuf::MethodDescriptor *pmethodDesc = pserviceDesc-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        std::string method_name = pmethodDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">        service_info.m_methodMap.<span class="built_in">insert</span>(&#123;method_name, pmethodDesc&#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    service_info.m_service = service;</span><br><span class="line">    m_serviceMap.<span class="built_in">insert</span>(&#123;service_name, service_info&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 你启动一个rpc网络服务节点，总要获取ip地址和port端口号吧</span></span><br><span class="line">    <span class="comment">// 所以这里是获取ip地址和port端口号</span></span><br><span class="line">    std::string ip = MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;m_eventLoop, address, <span class="string">&quot;RpcProvider&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 绑定连接回调和消息读写回调方法 分离了网络代码和业务代码</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">// 设置muduo库线程数量，自动分配I/O线程和工作线程</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    m_eventLoop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是要处理当rpc服务节点接收到来自客户端的已经序列化的请求该如何处理。首先，我们框架内部RpcProvider和RpcConsumer协商好之间通信用的protobuf数据类型，这样才方便序列化与反序列化。我们考虑将服务名+方法名作为头部字段，同时，为了防止后面的参数与下一次请求产生粘包问题，我们需要在头部字段里声明参数的大小。另外还有一个问题就是，我们如何分离出头部字段和参数字段呢？一个方法就是指明头部字段有多长。所以，我们的代码更新如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcheader.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是框架提供给外部使用的，可以发布rpc方法的函数接口</span></span><br><span class="line"><span class="comment">这里有一个很重要的指针（protobuf提供给我们获取服务及函数的）：google::protobuf::ServiceDescriptor *pserviceDesc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line">    ServiceInfo service_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务对象的描述信息</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::ServiceDescriptor *pserviceDesc = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line">    <span class="comment">// 获取服务的名字</span></span><br><span class="line">    std::string service_name = pserviceDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">    <span class="comment">// 获取服务对象service的方法的数量</span></span><br><span class="line">    <span class="type">int</span> methodCnt = pserviceDesc-&gt;<span class="built_in">method_count</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;service_name: &quot;</span> &lt;&lt; service_name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; methodCnt; ++i)&#123;</span><br><span class="line">        <span class="comment">// 获取了服务对象指定下标的服务方法的描述（抽象描述）</span></span><br><span class="line">        <span class="comment">// 注意，这里建立map表都是依据proto文件建立的！！！思考一下哦！</span></span><br><span class="line">        <span class="type">const</span> google::protobuf::MethodDescriptor *pmethodDesc = pserviceDesc-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        std::string method_name = pmethodDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">        service_info.m_methodMap.<span class="built_in">insert</span>(&#123;method_name, pmethodDesc&#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    service_info.m_service = service;</span><br><span class="line">    m_serviceMap.<span class="built_in">insert</span>(&#123;service_name, service_info&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 你启动一个rpc网络服务节点，总要获取ip地址和port端口号吧</span></span><br><span class="line">    <span class="comment">// 所以这里是获取ip地址和port端口号</span></span><br><span class="line">    std::string ip = MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;m_eventLoop, address, <span class="string">&quot;RpcProvider&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 绑定连接回调和消息读写回调方法 分离了网络代码和业务代码</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">// 设置muduo库线程数量，自动分配I/O线程和工作线程</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    m_eventLoop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!conn-&gt;<span class="built_in">connected</span>())&#123;</span><br><span class="line">        <span class="comment">// 和rpc client的连接断开了</span></span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在框架内部，RpcProvider和RpcConsumer协商好之间通信用的protobuf数据类型</span></span><br><span class="line"><span class="comment">service_name method_name args   定义proto的message类型，进行数据头的序列化与反序列化</span></span><br><span class="line"><span class="comment">                                service_name method_name args_size（args_size是为了防止粘包问题，指定参数长度）</span></span><br><span class="line"><span class="comment">16UserServiceLogin_rpc16zhang san123456</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">header_size + header_str + args_size + args_str</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr &amp;conn, muduo::net::Buffer *buffer, muduo::Timestamp)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 接收到来自客户端的请求</span></span><br><span class="line">    std::string recv_buf = buffer-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字符流中读取前四个字节的内容</span></span><br><span class="line">    <span class="type">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    recv_buf.<span class="built_in">copy</span>((<span class="type">char</span>*)&amp;header_size, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据header_size读取数据头的原始字符流，反序列化数据，得到rpc请求的详细信息</span></span><br><span class="line">    std::string rpc_header_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span>, header_size);</span><br><span class="line">    mprpc::RpcHeader rpcHeader;</span><br><span class="line">    std::string servcie_name;</span><br><span class="line">    std::string method_name;</span><br><span class="line">    <span class="type">uint32_t</span> args_size;</span><br><span class="line">    <span class="keyword">if</span>(rpcHeader.<span class="built_in">ParseFromString</span>(rpc_header_str))&#123;</span><br><span class="line">        servcie_name = rpcHeader.<span class="built_in">service_name</span>();</span><br><span class="line">        method_name = rpcHeader.<span class="built_in">method_name</span>();</span><br><span class="line">        args_size = rpcHeader.<span class="built_in">args_size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;rpc_header_str:&quot;</span> &lt;&lt; rpc_header_str &lt;&lt; <span class="string">&quot; parse error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取rpc方法参数的字符流数据</span></span><br><span class="line">    std::string args_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span> + header_size, args_size);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;header_size: &quot;</span> &lt;&lt; header_size &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rpc_header_str: &quot;</span> &lt;&lt; rpc_header_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;servcie_name: &quot;</span> &lt;&lt; servcie_name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;args_str: &quot;</span> &lt;&lt; args_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="RpcProvider响应回调实现"><a href="#RpcProvider响应回调实现" class="headerlink" title="RpcProvider响应回调实现"></a>RpcProvider响应回调实现</h4><p>回忆一下provider应该做的事，调用方法并返回response。所以这一节做的就是这个事情。注意request和response都是继承自google::protobuf::Message。</p>
<p>更新mprpcprovider.h</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;google/protobuf/service.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpServer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/EventLoop.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/InetAddress.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;muduo/net/TcpConnection.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;google/protobuf/descriptor.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 框架提供的专门服务发布rpc服务的网络对象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RpcProvider</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 这个是框架提供给外部使用的，可以发布rpc方法的函数接口 </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 组合了EventLoop</span></span><br><span class="line">    muduo::net::EventLoop m_eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// service服务类型信息</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ServiceInfo</span>&#123;</span><br><span class="line">        google::protobuf::Service *m_service; <span class="comment">// 保存服务对象</span></span><br><span class="line">        std::unordered_map&lt;std::string, <span class="type">const</span> google::protobuf::MethodDescriptor*&gt; m_methodMap; <span class="comment">// 保存服务方法</span></span><br><span class="line">    &#125;;</span><br><span class="line">    std::unordered_map&lt;std::string, ServiceInfo&gt; m_serviceMap;  <span class="comment">// 可不止一个服务类型哦，所以也要建立一个映射到不同服务的表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的socket连接回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已建立连接用户的读写事件回调</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, muduo::net::Buffer*, muduo::Timestamp)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Closure的回调操作，用于序列化rpc的响应和网络发送</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SendRpcResponse</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp;, google::protobuf::Message*)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>更新mprpcprovider.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcprovider.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;include/mprpcapplication.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mprpcheader.pb.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是框架提供给外部使用的，可以发布rpc方法的函数接口</span></span><br><span class="line"><span class="comment">这里有一个很重要的指针（protobuf提供给我们获取服务及函数的）：google::protobuf::ServiceDescriptor *pserviceDesc</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::NotifyService</span><span class="params">(google::protobuf::Service *service)</span></span>&#123;</span><br><span class="line">    ServiceInfo service_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务对象的描述信息</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::ServiceDescriptor *pserviceDesc = service-&gt;<span class="built_in">GetDescriptor</span>();</span><br><span class="line">    <span class="comment">// 获取服务的名字</span></span><br><span class="line">    std::string service_name = pserviceDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">    <span class="comment">// 获取服务对象service的方法的数量</span></span><br><span class="line">    <span class="type">int</span> methodCnt = pserviceDesc-&gt;<span class="built_in">method_count</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;service_name: &quot;</span> &lt;&lt; service_name &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; methodCnt; ++i)&#123;</span><br><span class="line">        <span class="comment">// 获取了服务对象指定下标的服务方法的描述（抽象描述）</span></span><br><span class="line">        <span class="comment">// 注意，这里建立map表都是依据proto文件建立的！！！思考一下哦！</span></span><br><span class="line">        <span class="type">const</span> google::protobuf::MethodDescriptor *pmethodDesc = pserviceDesc-&gt;<span class="built_in">method</span>(i);</span><br><span class="line">        std::string method_name = pmethodDesc-&gt;<span class="built_in">name</span>();</span><br><span class="line">        service_info.m_methodMap.<span class="built_in">insert</span>(&#123;method_name, pmethodDesc&#125;);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    service_info.m_service = service;</span><br><span class="line">    m_serviceMap.<span class="built_in">insert</span>(&#123;service_name, service_info&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动rpc服务节点，开始提供rpc远程网络调用服务</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 你启动一个rpc网络服务节点，总要获取ip地址和port端口号吧</span></span><br><span class="line">    <span class="comment">// 所以这里是获取ip地址和port端口号</span></span><br><span class="line">    std::string ip = MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverip&quot;</span>);</span><br><span class="line">    <span class="type">uint16_t</span> port = <span class="built_in">atoi</span>(MprpcApplication::<span class="built_in">GetInstance</span>().<span class="built_in">getConfig</span>().<span class="built_in">load</span>(<span class="string">&quot;rpcserverport&quot;</span>).<span class="built_in">c_str</span>());</span><br><span class="line">    muduo::<span class="function">net::InetAddress <span class="title">address</span><span class="params">(ip, port)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TcpServer对象</span></span><br><span class="line">    muduo::<span class="function">net::TcpServer <span class="title">server</span><span class="params">(&amp;m_eventLoop, address, <span class="string">&quot;RpcProvider&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 绑定连接回调和消息读写回调方法 分离了网络代码和业务代码</span></span><br><span class="line">    server.<span class="built_in">setConnectionCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="keyword">this</span>, std::placeholders::_1));</span><br><span class="line">    server.<span class="built_in">setMessageCallback</span>(std::<span class="built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="keyword">this</span>, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));</span><br><span class="line">    <span class="comment">// 设置muduo库线程数量，自动分配I/O线程和工作线程</span></span><br><span class="line">    server.<span class="built_in">setThreadNum</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动网络服务</span></span><br><span class="line">    server.<span class="built_in">start</span>();</span><br><span class="line">    m_eventLoop.<span class="built_in">loop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnConnection</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr&amp; conn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!conn-&gt;<span class="built_in">connected</span>())&#123;</span><br><span class="line">        <span class="comment">// 和rpc client的连接断开了</span></span><br><span class="line">        conn-&gt;<span class="built_in">shutdown</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在框架内部，RpcProvider和RpcConsumer协商好之间通信用的protobuf数据类型</span></span><br><span class="line"><span class="comment">service_name method_name args   定义proto的message类型，进行数据头的序列化与反序列化</span></span><br><span class="line"><span class="comment">                                service_name method_name args_size（args_size是为了防止粘包问题，指定参数长度）</span></span><br><span class="line"><span class="comment">16UserServiceLogin_rpc16zhang san123456</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">header_size + header_str + args_size + args_str</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::OnMessage</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr &amp;conn, muduo::net::Buffer *buffer, muduo::Timestamp)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 接收到来自客户端的请求</span></span><br><span class="line">    std::string recv_buf = buffer-&gt;<span class="built_in">retrieveAllAsString</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从字符流中读取前四个字节的内容</span></span><br><span class="line">    <span class="type">uint32_t</span> header_size = <span class="number">0</span>;</span><br><span class="line">    recv_buf.<span class="built_in">copy</span>((<span class="type">char</span>*)&amp;header_size, <span class="number">4</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据header_size读取数据头的原始字符流，反序列化数据，得到rpc请求的详细信息</span></span><br><span class="line">    std::string rpc_header_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span>, header_size);</span><br><span class="line">    mprpc::RpcHeader rpcHeader;</span><br><span class="line">    std::string servcie_name;</span><br><span class="line">    std::string method_name;</span><br><span class="line">    <span class="type">uint32_t</span> args_size;</span><br><span class="line">    <span class="keyword">if</span>(rpcHeader.<span class="built_in">ParseFromString</span>(rpc_header_str))&#123;</span><br><span class="line">        servcie_name = rpcHeader.<span class="built_in">service_name</span>();</span><br><span class="line">        method_name = rpcHeader.<span class="built_in">method_name</span>();</span><br><span class="line">        args_size = rpcHeader.<span class="built_in">args_size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;rpc_header_str:&quot;</span> &lt;&lt; rpc_header_str &lt;&lt; <span class="string">&quot; parse error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取rpc方法参数的字符流数据</span></span><br><span class="line">    std::string args_str = recv_buf.<span class="built_in">substr</span>(<span class="number">4</span> + header_size, args_size);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;header_size: &quot;</span> &lt;&lt; header_size &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;rpc_header_str: &quot;</span> &lt;&lt; rpc_header_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;servcie_name: &quot;</span> &lt;&lt; servcie_name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;method_name: &quot;</span> &lt;&lt; method_name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;args_str: &quot;</span> &lt;&lt; args_str &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;---------------------------&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取servcie对象和method对象</span></span><br><span class="line">    <span class="keyword">auto</span> it = m_serviceMap.<span class="built_in">find</span>(servcie_name);</span><br><span class="line">    <span class="keyword">if</span>(it == m_serviceMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; servcie_name &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> mit = it-&gt;second.m_methodMap.<span class="built_in">find</span>(method_name);</span><br><span class="line">    <span class="keyword">if</span>(mit == it-&gt;second.m_methodMap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        std::cout &lt;&lt; servcie_name &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; method_name &lt;&lt; <span class="string">&quot; is not exist!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    google::protobuf::Service *service = it-&gt;second.m_service;  <span class="comment">// 获取seivice对象</span></span><br><span class="line">    <span class="type">const</span> google::protobuf::MethodDescriptor *method = mit-&gt;second; <span class="comment">// 获取method对像</span></span><br><span class="line"></span><br><span class="line">    google::protobuf::Message *request = service-&gt;<span class="built_in">GetRequestPrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line">    <span class="keyword">if</span>(!request-&gt;<span class="built_in">ParseFromString</span>(args_str))&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;request parse error, content:&quot;</span> &lt;&lt; args_str &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    google::protobuf::Message *response = service-&gt;<span class="built_in">GetResponsePrototype</span>(method).<span class="built_in">New</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给下面的method方法的调用，绑定一个Closure的回调函数</span></span><br><span class="line">    google::protobuf::Closure *done = google::protobuf::<span class="built_in">NewCallback</span>&lt;RpcProvider, <span class="type">const</span> muduo::net::TcpConnectionPtr &amp;, google::protobuf::Message *&gt;(<span class="keyword">this</span>, &amp;RpcProvider::SendRpcResponse, conn, response);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在框架上根据远端rpc请求，调用当前rpc节点上发布的方法</span></span><br><span class="line">    service-&gt;<span class="built_in">CallMethod</span>(method, <span class="literal">nullptr</span>, request, response, done);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Closure的回调操作，用于序列化rpc的响应和网络发送</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RpcProvider::SendRpcResponse</span><span class="params">(<span class="type">const</span> muduo::net::TcpConnectionPtr &amp;conn, google::protobuf::Message *response)</span></span>&#123;</span><br><span class="line">    std::string response_str;</span><br><span class="line">    <span class="keyword">if</span>(response-&gt;<span class="built_in">SerializeToString</span>(&amp;response_str))&#123; <span class="comment">// response进行序列化</span></span><br><span class="line">        <span class="comment">// 序列化成功后，通过网络把rpc方法执行的结果发送回rpc的调用方</span></span><br><span class="line">        conn-&gt;<span class="built_in">send</span>(response_str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;serialize response_str error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    conn-&gt;<span class="built_in">shutdown</span>(); <span class="comment">// 模拟http的短连接服务，由provider主动断开连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="RpcController"><a href="#RpcController" class="headerlink" title="RpcController"></a>RpcController</h4><p>为什么需要这个呢？这里我们需要注意到一个问题，举个例子，在我们的callfriendservice.cpp文件中，当我们使用完stub调用函数GetFriendlist之后，就直接开始读取response了。但你有没有想过，如果在序列化、网络发送、反序列化、函数执行等过程中产生错误了呢？那我们根本就拿不到response或者说拿到的response是错误的。RpcController可以帮助我们记录一些rpc调用过程中的状态信息。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/06/08/UNIX%E7%8E%AF%E5%A2%83%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/" rel="prev" title="UNIX环境高级编程第一章">
                  <i class="fa fa-angle-left"></i> UNIX环境高级编程第一章
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/06/29/Cpp%E9%AB%98%E9%A2%91%E9%9D%A2%E7%BB%8F/" rel="next" title="Cpp高频面经">
                  Cpp高频面经 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">GGBond</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  





</body>
</html>
